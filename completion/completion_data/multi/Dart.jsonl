{"task_id": "Dart/0-0-multi", "prompt": "/* Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n*/\nbool hasCloseElements(List<double> numbers, double threshold)", "canonical_solution": "{\n  for (int i = 0; i < numbers.length; i++) {\n    for (int j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        double distance = (numbers[i] - numbers[j]).abs();\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "test": "void main() {\n  check(hasCloseElements);\n}\n\nvoid check(bool Function(List<double>, double) hasCloseElements) {\n  assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n  assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n  assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true);\n  assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n  assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n  assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n  assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}", "entry_point": "hasCloseElements", "signature": ">>> hasCloseElements([1.0, 2.0, 3.0], 0.5)", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n\n* Incomplete Code:\n>>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n{\n[MASK]\n[MASK]\n      if (i != j) {\n        double distance = (numbers[i] - numbers[j]).abs();\n[MASK]\n[MASK]\n        }\n      }\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n[MASK]\n      if (i != j) {\n        double distance = (numbers[i] - numbers[j]).abs();\n[MASK]\n[MASK]\n        }\n      }\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/0-1-multi", "prompt": "/* Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n*/\nbool hasCloseElements(List<double> numbers, double threshold)", "canonical_solution": "{\n  for (int i = 0; i < numbers.length; i++) {\n    for (int j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        double distance = (numbers[i] - numbers[j]).abs();\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "test": "void main() {\n  check(hasCloseElements);\n}\n\nvoid check(bool Function(List<double>, double) hasCloseElements) {\n  assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n  assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n  assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true);\n  assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n  assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n  assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n  assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}", "entry_point": "hasCloseElements", "signature": ">>> hasCloseElements([1.0, 2.0, 3.0], 0.5)", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n\n* Incomplete Code:\n>>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n{\n  for (int i = 0; i < numbers.length; i++) {\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n          return true;\n        }\n      }\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  for (int i = 0; i < numbers.length; i++) {\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n          return true;\n        }\n      }\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/1-0-multi", "prompt": "int horseControl(int dx, int dy, int hx, int hy) \n/// The function horseControl takes four integer arguments: dx, dy, hx, and hy. \n/// The dx and dy parameters define the dimensions of a rectangular grid, while \n/// hx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid. \n/// The function calculates the number of ways to travel from the top-left corner of the grid \n/// to the bottom-right corner by only moving right or down, without passing through any of the \n/// cells that the horse controls.\n/// \n/// In chess, a knight can move in an L-shape: two cells in one direction and then one cell \n/// perpendicular to that direction. This function first marks all the cells within the grid that \n/// the horse controls, including the cell where the horse is located. Then, using dynamic programming, \n/// it calculates the total number of paths to each cell, accumulating the count from the top and \n/// left neighboring cells, but skipping any cells that are blocked by the horse's control.\n/// \n/// For example, let's assume we have a 6x6 grid (dx = 6, dy = 6) and a horse positioned at \n/// coordinates (3, 3). The horseControl function will return the number of paths to the bottom-right \n/// corner without passing through the cells the horse can reach. In this specific case, there are 6 \n/// such paths.", "canonical_solution": "{\n  List<List<int>> dp = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => 0));\n  List<List<bool>> horseBlock = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => false));\n\n  // Mark the positions that the horse controls\n  List<List<int>> moves = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n    [-2, -1], [-1, -2], [1, -2], [2, -1]\n  ];\n\n  horseBlock[hx][hy] = true; // Horse's current position\n  for (List<int> move in moves) {\n    int nx = hx + move[0];\n    int ny = hy + move[1];\n    if (nx >= 0 && nx <= dx && ny >= 0 && ny <= dy) {\n      horseBlock[nx][ny] = true; // Horse's control positions\n    }\n  }\n\n  // Initialize the dp table\n  dp[0][0] = 1;\n  for (int i = 0; i <= dx; i++) {\n    for (int j = 0; j <= dy; j++) {\n      if (horseBlock[i][j]) {\n        continue; // Skip the position if it's controlled by the horse\n      }\n      // Calculate the number of paths from the top and left cells\n      if (i > 0) dp[i][j] += dp[i - 1][j];\n      if (j > 0) dp[i][j] += dp[i][j - 1];\n    }\n  }\n  return dp[dx][dy];\n}", "test": "void main() {\n  // Test case 1: Start and horse positions are the same\n  assert(horseControl(1, 1, 0, 0) == 2, 'Test case 1 failed');\n\n  // Test case 2: Horse controls some of the paths\n  assert(horseControl(2, 2, 1, 1) == 2, 'Test case 2 failed');\n\n  // Test case 3: No horse control over the board\n  assert(horseControl(5, 5, 5, 5) == 0, 'Test case 3 failed');\n\n  // Additional test cases...\n\n  print('All test cases passed!');\n}", "entry_point": "horseControl", "signature": "int horseControl(int dx, int dy, int hx, int hy)", "docstring": "The function horseControl takes four integer arguments: dx, dy, hx, and hy.\nThe dx and dy parameters define the dimensions of a rectangular grid, while\nhx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid.\nThe function calculates the number of ways to travel from the top-left corner of the grid\nto the bottom-right corner by only moving right or down, without passing through any of the\ncells that the horse controls.\n\nIn chess, a knight can move in an L-shape: two cells in one direction and then one cell\nperpendicular to that direction. This function first marks all the cells within the grid that\nthe horse controls, including the cell where the horse is located. Then, using dynamic programming,\nit calculates the total number of paths to each cell, accumulating the count from the top and\nleft neighboring cells, but skipping any cells that are blocked by the horse's control.\n\nFor example, let's assume we have a 6x6 grid (dx = 6, dy = 6) and a horse positioned at\ncoordinates (3, 3). The horseControl function will return the number of paths to the bottom-right\ncorner without passing through the cells the horse can reach. In this specific case, there are 6\nsuch paths.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nThe function horseControl takes four integer arguments: dx, dy, hx, and hy.\nThe dx and dy parameters define the dimensions of a rectangular grid, while\nhx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid.\nThe function calculates the number of ways to travel from the top-left corner of the grid\nto the bottom-right corner by only moving right or down, without passing through any of the\ncells that the horse controls.\n\nIn chess, a knight can move in an L-shape: two cells in one direction and then one cell\nperpendicular to that direction. This function first marks all the cells within the grid that\nthe horse controls, including the cell where the horse is located. Then, using dynamic programming,\nit calculates the total number of paths to each cell, accumulating the count from the top and\nleft neighboring cells, but skipping any cells that are blocked by the horse's control.\n\nFor example, let's assume we have a 6x6 grid (dx = 6, dy = 6) and a horse positioned at\ncoordinates (3, 3). The horseControl function will return the number of paths to the bottom-right\ncorner without passing through the cells the horse can reach. In this specific case, there are 6\nsuch paths.\n\n* Incomplete Code:\nint horseControl(int dx, int dy, int hx, int hy)\n{\n[MASK]\n  List<List<bool>> horseBlock = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => false));\n\n  // Mark the positions that the horse controls\n  List<List<int>> moves = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n    [-2, -1], [-1, -2], [1, -2], [2, -1]\n  ];\n\n  horseBlock[hx][hy] = true; // Horse's current position\n[MASK]\n    int nx = hx + move[0];\n    int ny = hy + move[1];\n    if (nx >= 0 && nx <= dx && ny >= 0 && ny <= dy) {\n      horseBlock[nx][ny] = true; // Horse's control positions\n    }\n  }\n\n  // Initialize the dp table\n  dp[0][0] = 1;\n[MASK]\n    for (int j = 0; j <= dy; j++) {\n      if (horseBlock[i][j]) {\n        continue; // Skip the position if it's controlled by the horse\n      }\n      // Calculate the number of paths from the top and left cells\n[MASK]\n      if (j > 0) dp[i][j] += dp[i][j - 1];\n    }\n  }\n  return dp[dx][dy];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  List<List<bool>> horseBlock = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => false));\n\n  // Mark the positions that the horse controls\n  List<List<int>> moves = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n    [-2, -1], [-1, -2], [1, -2], [2, -1]\n  ];\n\n  horseBlock[hx][hy] = true; // Horse's current position\n[MASK]\n    int nx = hx + move[0];\n    int ny = hy + move[1];\n    if (nx >= 0 && nx <= dx && ny >= 0 && ny <= dy) {\n      horseBlock[nx][ny] = true; // Horse's control positions\n    }\n  }\n\n  // Initialize the dp table\n  dp[0][0] = 1;\n[MASK]\n    for (int j = 0; j <= dy; j++) {\n      if (horseBlock[i][j]) {\n        continue; // Skip the position if it's controlled by the horse\n      }\n      // Calculate the number of paths from the top and left cells\n[MASK]\n      if (j > 0) dp[i][j] += dp[i][j - 1];\n    }\n  }\n  return dp[dx][dy];\n}"}
{"task_id": "Dart/1-1-multi", "prompt": "int horseControl(int dx, int dy, int hx, int hy) \n/// The function horseControl takes four integer arguments: dx, dy, hx, and hy. \n/// The dx and dy parameters define the dimensions of a rectangular grid, while \n/// hx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid. \n/// The function calculates the number of ways to travel from the top-left corner of the grid \n/// to the bottom-right corner by only moving right or down, without passing through any of the \n/// cells that the horse controls.\n/// \n/// In chess, a knight can move in an L-shape: two cells in one direction and then one cell \n/// perpendicular to that direction. This function first marks all the cells within the grid that \n/// the horse controls, including the cell where the horse is located. Then, using dynamic programming, \n/// it calculates the total number of paths to each cell, accumulating the count from the top and \n/// left neighboring cells, but skipping any cells that are blocked by the horse's control.\n/// \n/// For example, let's assume we have a 6x6 grid (dx = 6, dy = 6) and a horse positioned at \n/// coordinates (3, 3). The horseControl function will return the number of paths to the bottom-right \n/// corner without passing through the cells the horse can reach. In this specific case, there are 6 \n/// such paths.", "canonical_solution": "{\n  List<List<int>> dp = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => 0));\n  List<List<bool>> horseBlock = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => false));\n\n  // Mark the positions that the horse controls\n  List<List<int>> moves = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n    [-2, -1], [-1, -2], [1, -2], [2, -1]\n  ];\n\n  horseBlock[hx][hy] = true; // Horse's current position\n  for (List<int> move in moves) {\n    int nx = hx + move[0];\n    int ny = hy + move[1];\n    if (nx >= 0 && nx <= dx && ny >= 0 && ny <= dy) {\n      horseBlock[nx][ny] = true; // Horse's control positions\n    }\n  }\n\n  // Initialize the dp table\n  dp[0][0] = 1;\n  for (int i = 0; i <= dx; i++) {\n    for (int j = 0; j <= dy; j++) {\n      if (horseBlock[i][j]) {\n        continue; // Skip the position if it's controlled by the horse\n      }\n      // Calculate the number of paths from the top and left cells\n      if (i > 0) dp[i][j] += dp[i - 1][j];\n      if (j > 0) dp[i][j] += dp[i][j - 1];\n    }\n  }\n  return dp[dx][dy];\n}", "test": "void main() {\n  // Test case 1: Start and horse positions are the same\n  assert(horseControl(1, 1, 0, 0) == 2, 'Test case 1 failed');\n\n  // Test case 2: Horse controls some of the paths\n  assert(horseControl(2, 2, 1, 1) == 2, 'Test case 2 failed');\n\n  // Test case 3: No horse control over the board\n  assert(horseControl(5, 5, 5, 5) == 0, 'Test case 3 failed');\n\n  // Additional test cases...\n\n  print('All test cases passed!');\n}", "entry_point": "horseControl", "signature": "int horseControl(int dx, int dy, int hx, int hy)", "docstring": "The function horseControl takes four integer arguments: dx, dy, hx, and hy.\nThe dx and dy parameters define the dimensions of a rectangular grid, while\nhx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid.\nThe function calculates the number of ways to travel from the top-left corner of the grid\nto the bottom-right corner by only moving right or down, without passing through any of the\ncells that the horse controls.\n\nIn chess, a knight can move in an L-shape: two cells in one direction and then one cell\nperpendicular to that direction. This function first marks all the cells within the grid that\nthe horse controls, including the cell where the horse is located. Then, using dynamic programming,\nit calculates the total number of paths to each cell, accumulating the count from the top and\nleft neighboring cells, but skipping any cells that are blocked by the horse's control.\n\nFor example, let's assume we have a 6x6 grid (dx = 6, dy = 6) and a horse positioned at\ncoordinates (3, 3). The horseControl function will return the number of paths to the bottom-right\ncorner without passing through the cells the horse can reach. In this specific case, there are 6\nsuch paths.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nThe function horseControl takes four integer arguments: dx, dy, hx, and hy.\nThe dx and dy parameters define the dimensions of a rectangular grid, while\nhx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid.\nThe function calculates the number of ways to travel from the top-left corner of the grid\nto the bottom-right corner by only moving right or down, without passing through any of the\ncells that the horse controls.\n\nIn chess, a knight can move in an L-shape: two cells in one direction and then one cell\nperpendicular to that direction. This function first marks all the cells within the grid that\nthe horse controls, including the cell where the horse is located. Then, using dynamic programming,\nit calculates the total number of paths to each cell, accumulating the count from the top and\nleft neighboring cells, but skipping any cells that are blocked by the horse's control.\n\nFor example, let's assume we have a 6x6 grid (dx = 6, dy = 6) and a horse positioned at\ncoordinates (3, 3). The horseControl function will return the number of paths to the bottom-right\ncorner without passing through the cells the horse can reach. In this specific case, there are 6\nsuch paths.\n\n* Incomplete Code:\nint horseControl(int dx, int dy, int hx, int hy)\n{\n  List<List<int>> dp = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => 0));\n  List<List<bool>> horseBlock = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => false));\n\n  // Mark the positions that the horse controls\n  List<List<int>> moves = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n[MASK]\n  ];\n\n  horseBlock[hx][hy] = true; // Horse's current position\n  for (List<int> move in moves) {\n    int nx = hx + move[0];\n    int ny = hy + move[1];\n    if (nx >= 0 && nx <= dx && ny >= 0 && ny <= dy) {\n      horseBlock[nx][ny] = true; // Horse's control positions\n    }\n  }\n\n  // Initialize the dp table\n  dp[0][0] = 1;\n  for (int i = 0; i <= dx; i++) {\n    for (int j = 0; j <= dy; j++) {\n      if (horseBlock[i][j]) {\n        continue; // Skip the position if it's controlled by the horse\n      }\n      // Calculate the number of paths from the top and left cells\n[MASK]\n      if (j > 0) dp[i][j] += dp[i][j - 1];\n    }\n  }\n  return dp[dx][dy];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<List<int>> dp = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => 0));\n  List<List<bool>> horseBlock = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => false));\n\n  // Mark the positions that the horse controls\n  List<List<int>> moves = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n[MASK]\n  ];\n\n  horseBlock[hx][hy] = true; // Horse's current position\n  for (List<int> move in moves) {\n    int nx = hx + move[0];\n    int ny = hy + move[1];\n    if (nx >= 0 && nx <= dx && ny >= 0 && ny <= dy) {\n      horseBlock[nx][ny] = true; // Horse's control positions\n    }\n  }\n\n  // Initialize the dp table\n  dp[0][0] = 1;\n  for (int i = 0; i <= dx; i++) {\n    for (int j = 0; j <= dy; j++) {\n      if (horseBlock[i][j]) {\n        continue; // Skip the position if it's controlled by the horse\n      }\n      // Calculate the number of paths from the top and left cells\n[MASK]\n      if (j > 0) dp[i][j] += dp[i][j - 1];\n    }\n  }\n  return dp[dx][dy];\n}"}
{"task_id": "Dart/2-0-multi", "prompt": "int findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)\n/// Finds the index of the topmost carpet that covers a given point.\n///\n/// Takes a list of carpets, where each carpet is represented by a list of four integers\n/// [a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\n/// and k (height). The function also takes a point represented by a list of two integers [x, y],\n/// which define the coordinates of the point.\n///\n/// The carpets are layered in the order they appear in the list, with the first carpet at the bottom.\n/// The function iterates through the carpets from the topmost to the bottommost. It returns the\n/// 1-based index of the first carpet that covers the point. If no carpet covers the point, the function\n/// returns -1.\n///\n/// Args:\n///   carpets (List<List<int>>): The list of carpets information.\n///   point (List<int>): The coordinates of the point to check.\n///\n/// Returns:\n///   int: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n///\n/// Example:\n///   // The point (2, 2) lies on the second carpet which is on top of the first one\n///   findTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n///\n///   // The point (6, 6) lies outside of any carpet\n///   findTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n///\n///   // The point (3, 3) lies on the only carpet\n///   findTopmostCarpetIndex([[0, 0, 5, 5]], [3, 3]); // Returns 1", "canonical_solution": " {\n  int x = point[0];\n  int y = point[1];\n  int result = -1;\n\n  // Iterate through the carpets from top to bottom.\n  for (int i = carpets.length - 1; i >= 0; i--) {\n    // Extract carpet's information.\n    List<int> carpet = carpets[i];\n    int a = carpet[0];\n    int b = carpet[1];\n    int g = carpet[2];\n    int k = carpet[3];\n\n    // Check if the point is within the current carpet.\n    if (x >= a && x <= a + g && y >= b && y <= b + k) {\n      result = i + 1; // Carpet numbers are 1-indexed.\n      break; // Stop searching as we found the topmost carpet.\n    }\n  }\n  return result;\n}", "test": "void testFindTopmostCarpetIndex() {\n  // TestCase 1: Point lies on the second carpet which is on top of the first one\n  List<List<int>> carpets1 = [\n    [0, 0, 4, 4], // Carpet 1 (bottom)\n    [1, 1, 3, 3], // Carpet 2 (top)\n  ];\n  List<int> point1 = [2, 2];\n  assert(findTopmostCarpetIndex(carpets1, point1) == 2, 'Test case 1 failed');\n\n  // TestCase 2: Point lies outside any carpet\n  List<List<int>> carpets2 = [\n    [0, 0, 4, 4],\n    [5, 5, 2, 2],\n  ];\n  List<int> point2 = [6, 6];\n  assert(findTopmostCarpetIndex(carpets2, point2) == 2, 'Test case 2 failed');\n\n  // TestCase 3: Point lies on the only carpet\n  List<List<int>> carpets3 = [\n    [0, 0, 5, 5], // Only one carpet\n  ];\n  List<int> point3 = [3, 3];\n  assert(findTopmostCarpetIndex(carpets3, point3) == 1, 'Test case 3 failed');\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  // Call the test function to run the test cases\n  testFindTopmostCarpetIndex();\n}", "entry_point": "findTopmostCarpetIndex", "signature": "int findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)", "docstring": "Finds the index of the topmost carpet that covers a given point.\n\nTakes a list of carpets, where each carpet is represented by a list of four integers\n[a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\nand k (height). The function also takes a point represented by a list of two integers [x, y],\nwhich define the coordinates of the point.\n\nThe carpets are layered in the order they appear in the list, with the first carpet at the bottom.\nThe function iterates through the carpets from the topmost to the bottommost. It returns the\n1-based index of the first carpet that covers the point. If no carpet covers the point, the function\nreturns -1.\n\nArgs:\ncarpets (List<List<int>>): The list of carpets information.\npoint (List<int>): The coordinates of the point to check.\n\nReturns:\nint: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n\nExample:\n// The point (2, 2) lies on the second carpet which is on top of the first one\nfindTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n\n// The point (6, 6) lies outside of any carpet\nfindTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n\n// The point (3, 3) lies on the only carpet\nfindTopmostCarpetIndex([[0, 0, 5, 5]], [3, 3]); // Returns 1", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds the index of the topmost carpet that covers a given point.\n\nTakes a list of carpets, where each carpet is represented by a list of four integers\n[a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\nand k (height). The function also takes a point represented by a list of two integers [x, y],\nwhich define the coordinates of the point.\n\nThe carpets are layered in the order they appear in the list, with the first carpet at the bottom.\nThe function iterates through the carpets from the topmost to the bottommost. It returns the\n1-based index of the first carpet that covers the point. If no carpet covers the point, the function\nreturns -1.\n\nArgs:\ncarpets (List<List<int>>): The list of carpets information.\npoint (List<int>): The coordinates of the point to check.\n\nReturns:\nint: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n\nExample:\n// The point (2, 2) lies on the second carpet which is on top of the first one\nfindTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n\n// The point (6, 6) lies outside of any carpet\nfindTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n\n// The point (3, 3) lies on the only carpet\nfindTopmostCarpetIndex([[0, 0, 5, 5]], [3, 3]); // Returns 1\n\n* Incomplete Code:\nint findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)\n {\n  int x = point[0];\n[MASK]\n  int result = -1;\n\n  // Iterate through the carpets from top to bottom.\n  for (int i = carpets.length - 1; i >= 0; i--) {\n    // Extract carpet's information.\n[MASK]\n[MASK]\n    int b = carpet[1];\n[MASK]\n    int k = carpet[3];\n\n    // Check if the point is within the current carpet.\n    if (x >= a && x <= a + g && y >= b && y <= b + k) {\n      result = i + 1; // Carpet numbers are 1-indexed.\n      break; // Stop searching as we found the topmost carpet.\n    }\n  }\n  return result;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  int x = point[0];\n[MASK]\n  int result = -1;\n\n  // Iterate through the carpets from top to bottom.\n  for (int i = carpets.length - 1; i >= 0; i--) {\n    // Extract carpet's information.\n[MASK]\n[MASK]\n    int b = carpet[1];\n[MASK]\n    int k = carpet[3];\n\n    // Check if the point is within the current carpet.\n    if (x >= a && x <= a + g && y >= b && y <= b + k) {\n      result = i + 1; // Carpet numbers are 1-indexed.\n      break; // Stop searching as we found the topmost carpet.\n    }\n  }\n  return result;\n}"}
{"task_id": "Dart/2-1-multi", "prompt": "int findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)\n/// Finds the index of the topmost carpet that covers a given point.\n///\n/// Takes a list of carpets, where each carpet is represented by a list of four integers\n/// [a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\n/// and k (height). The function also takes a point represented by a list of two integers [x, y],\n/// which define the coordinates of the point.\n///\n/// The carpets are layered in the order they appear in the list, with the first carpet at the bottom.\n/// The function iterates through the carpets from the topmost to the bottommost. It returns the\n/// 1-based index of the first carpet that covers the point. If no carpet covers the point, the function\n/// returns -1.\n///\n/// Args:\n///   carpets (List<List<int>>): The list of carpets information.\n///   point (List<int>): The coordinates of the point to check.\n///\n/// Returns:\n///   int: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n///\n/// Example:\n///   // The point (2, 2) lies on the second carpet which is on top of the first one\n///   findTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n///\n///   // The point (6, 6) lies outside of any carpet\n///   findTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n///\n///   // The point (3, 3) lies on the only carpet\n///   findTopmostCarpetIndex([[0, 0, 5, 5]], [3, 3]); // Returns 1", "canonical_solution": " {\n  int x = point[0];\n  int y = point[1];\n  int result = -1;\n\n  // Iterate through the carpets from top to bottom.\n  for (int i = carpets.length - 1; i >= 0; i--) {\n    // Extract carpet's information.\n    List<int> carpet = carpets[i];\n    int a = carpet[0];\n    int b = carpet[1];\n    int g = carpet[2];\n    int k = carpet[3];\n\n    // Check if the point is within the current carpet.\n    if (x >= a && x <= a + g && y >= b && y <= b + k) {\n      result = i + 1; // Carpet numbers are 1-indexed.\n      break; // Stop searching as we found the topmost carpet.\n    }\n  }\n  return result;\n}", "test": "void testFindTopmostCarpetIndex() {\n  // TestCase 1: Point lies on the second carpet which is on top of the first one\n  List<List<int>> carpets1 = [\n    [0, 0, 4, 4], // Carpet 1 (bottom)\n    [1, 1, 3, 3], // Carpet 2 (top)\n  ];\n  List<int> point1 = [2, 2];\n  assert(findTopmostCarpetIndex(carpets1, point1) == 2, 'Test case 1 failed');\n\n  // TestCase 2: Point lies outside any carpet\n  List<List<int>> carpets2 = [\n    [0, 0, 4, 4],\n    [5, 5, 2, 2],\n  ];\n  List<int> point2 = [6, 6];\n  assert(findTopmostCarpetIndex(carpets2, point2) == 2, 'Test case 2 failed');\n\n  // TestCase 3: Point lies on the only carpet\n  List<List<int>> carpets3 = [\n    [0, 0, 5, 5], // Only one carpet\n  ];\n  List<int> point3 = [3, 3];\n  assert(findTopmostCarpetIndex(carpets3, point3) == 1, 'Test case 3 failed');\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  // Call the test function to run the test cases\n  testFindTopmostCarpetIndex();\n}", "entry_point": "findTopmostCarpetIndex", "signature": "int findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)", "docstring": "Finds the index of the topmost carpet that covers a given point.\n\nTakes a list of carpets, where each carpet is represented by a list of four integers\n[a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\nand k (height). The function also takes a point represented by a list of two integers [x, y],\nwhich define the coordinates of the point.\n\nThe carpets are layered in the order they appear in the list, with the first carpet at the bottom.\nThe function iterates through the carpets from the topmost to the bottommost. It returns the\n1-based index of the first carpet that covers the point. If no carpet covers the point, the function\nreturns -1.\n\nArgs:\ncarpets (List<List<int>>): The list of carpets information.\npoint (List<int>): The coordinates of the point to check.\n\nReturns:\nint: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n\nExample:\n// The point (2, 2) lies on the second carpet which is on top of the first one\nfindTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n\n// The point (6, 6) lies outside of any carpet\nfindTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n\n// The point (3, 3) lies on the only carpet\nfindTopmostCarpetIndex([[0, 0, 5, 5]], [3, 3]); // Returns 1", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds the index of the topmost carpet that covers a given point.\n\nTakes a list of carpets, where each carpet is represented by a list of four integers\n[a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\nand k (height). The function also takes a point represented by a list of two integers [x, y],\nwhich define the coordinates of the point.\n\nThe carpets are layered in the order they appear in the list, with the first carpet at the bottom.\nThe function iterates through the carpets from the topmost to the bottommost. It returns the\n1-based index of the first carpet that covers the point. If no carpet covers the point, the function\nreturns -1.\n\nArgs:\ncarpets (List<List<int>>): The list of carpets information.\npoint (List<int>): The coordinates of the point to check.\n\nReturns:\nint: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n\nExample:\n// The point (2, 2) lies on the second carpet which is on top of the first one\nfindTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n\n// The point (6, 6) lies outside of any carpet\nfindTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n\n// The point (3, 3) lies on the only carpet\nfindTopmostCarpetIndex([[0, 0, 5, 5]], [3, 3]); // Returns 1\n\n* Incomplete Code:\nint findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)\n {\n[MASK]\n  int y = point[1];\n  int result = -1;\n\n  // Iterate through the carpets from top to bottom.\n[MASK]\n    // Extract carpet's information.\n    List<int> carpet = carpets[i];\n    int a = carpet[0];\n[MASK]\n[MASK]\n    int k = carpet[3];\n\n    // Check if the point is within the current carpet.\n    if (x >= a && x <= a + g && y >= b && y <= b + k) {\n      result = i + 1; // Carpet numbers are 1-indexed.\n      break; // Stop searching as we found the topmost carpet.\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n[MASK]\n  int y = point[1];\n  int result = -1;\n\n  // Iterate through the carpets from top to bottom.\n[MASK]\n    // Extract carpet's information.\n    List<int> carpet = carpets[i];\n    int a = carpet[0];\n[MASK]\n[MASK]\n    int k = carpet[3];\n\n    // Check if the point is within the current carpet.\n    if (x >= a && x <= a + g && y >= b && y <= b + k) {\n      result = i + 1; // Carpet numbers are 1-indexed.\n      break; // Stop searching as we found the topmost carpet.\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/3-0-multi", "prompt": "import 'dart:io';\nint maxSumInGrid(List<List<int>> grid, int N)\n/// Calculates the maximum sum of numbers that can be picked on a grid by two paths.\n///\n/// This function takes a square grid of integers and the size of the grid (N),\n/// and computes the maximum sum of numbers that can be collected by two paths\n/// starting from the top-left corner and ending at the bottom-right corner.\n/// Each path can only move right or down, and no two paths can overlap.\n///\n/// Args:\n///   grid (List<List<int>>): A 2D list of integers representing the grid.\n///   N (int): The size of the dimensions of the square grid.\n///\n/// Returns:\n///   int: The maximum sum of numbers picked by the two paths.\n///\n/// Example:\n///   Given a grid:\n///   [\n///     [0, 0, 0, 0],\n///     [0, 4, 0, 0],\n///     [0, 0, 2, 0],\n///     [1, 0, 0, 0]\n///   ]\n///   and N = 4\n///\n///   The maximum sum is obtained by one path moving right to pick 4, then moving\n///   down all the way to the bottom-right corner, and the other path moving down\n///   to pick 1, then moving right and down to pick 2, and finally moving right\n///   to the bottom-right corner. The total maximum sum would be 4 + 1 + 2 = 7.\n///\n///   The function call would look like this:\n///   int result = maxSumInGrid([\n///     [0, 0, 0, 0],\n///     [0, 4, 0, 0],\n///     [0, 0, 2, 0],\n///     [1, 0, 0, 0]\n///   ], 4);\n///   print(result); // Outputs: 7", "canonical_solution": " {\n  // Initialize a 3-dimensional array dp to store the maximum sum for each state (i, j, k).\n  List<List<List<int>>> dp = List.generate(\n    2 * N,\n    (i) => List.generate(N, (j) => List.generate(N, (k) => 0)),\n  );\n\n  // Populate the dp array with the input numbers\n  for (var i = 0; i < N; ++i) {\n    for (var j = 0; j < N; ++j) {\n      for (var k = 0; k < N; ++k) {\n        var l = i + j - k; // The position of P2 on the y-axis\n        if (l < 0 || l >= N) continue; // Skip invalid positions\n        var value = grid[i][j];\n        if (i != k) value += grid[k][l]; // If not on the same column, add P2's value\n        var maxPrev = 0;\n        if (i > 0) maxPrev = max(maxPrev, dp[i - 1][j][k]); // P1 left\n        if (j > 0) maxPrev = max(maxPrev, dp[i][j - 1][k]); // P1 up\n        if (k > 0) maxPrev = max(maxPrev, dp[i][j][k - 1]); // P2 left\n        if (l > 0) maxPrev = max(maxPrev, dp[i][j][k]); // P2 up\n        dp[i][j][k] = maxPrev + value;\n      }\n    }\n  }\n  // The answer is the value in dp[N-1][N-1][N-1]\n  return dp[N - 1][N - 1][N - 1];\n}\n\nint max(int a, int b) => a > b ? a : b;", "test": "void testMaxSumInGrid() {\n  // TestCase Structure\n  List<Map<String, dynamic>> testCases = [\n    {\n      'grid': [\n        [0, 0, 0, 0],\n        [0, 4, 0, 0],\n        [0, 0, 2, 0],\n        [1, 0, 0, 0]\n      ],\n      'N': 4,\n      'expected': 16\n    },\n    {\n      'grid': [\n        [0, 0, 13, 0],\n        [0, 0, 0, 6],\n        [0, 7, 0, 0],\n        [0, 0, 0, 0]\n      ],\n      'N': 4,\n      'expected': 58\n    },\n    // Add more test cases here\n  ];\n\n  for (var testCase in testCases) {\n    int result = maxSumInGrid(testCase['grid'], testCase['N']);\n    assert(result == testCase['expected'], \"Test case failed: Expected ${testCase['expected']}, got $result\");\n    print('Test case passed: Expected ${testCase['expected']}, got $result');\n  }\n}\n\nvoid main() {\n  testMaxSumInGrid();\n  // You can also handle the interactive part here, if necessary.\n}", "entry_point": "maxSumInGrid", "signature": "int maxSumInGrid(List<List<int>> grid, int N)", "docstring": "Calculates the maximum sum of numbers that can be picked on a grid by two paths.\n\nThis function takes a square grid of integers and the size of the grid (N),\nand computes the maximum sum of numbers that can be collected by two paths\nstarting from the top-left corner and ending at the bottom-right corner.\nEach path can only move right or down, and no two paths can overlap.\n\nArgs:\ngrid (List<List<int>>): A 2D list of integers representing the grid.\nN (int): The size of the dimensions of the square grid.\n\nReturns:\nint: The maximum sum of numbers picked by the two paths.\n\nExample:\nGiven a grid:\n[\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n]\nand N = 4\n\nThe maximum sum is obtained by one path moving right to pick 4, then moving\ndown all the way to the bottom-right corner, and the other path moving down\nto pick 1, then moving right and down to pick 2, and finally moving right\nto the bottom-right corner. The total maximum sum would be 4 + 1 + 2 = 7.\n\nThe function call would look like this:\nint result = maxSumInGrid([\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n], 4);\nprint(result); // Outputs: 7", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum sum of numbers that can be picked on a grid by two paths.\n\nThis function takes a square grid of integers and the size of the grid (N),\nand computes the maximum sum of numbers that can be collected by two paths\nstarting from the top-left corner and ending at the bottom-right corner.\nEach path can only move right or down, and no two paths can overlap.\n\nArgs:\ngrid (List<List<int>>): A 2D list of integers representing the grid.\nN (int): The size of the dimensions of the square grid.\n\nReturns:\nint: The maximum sum of numbers picked by the two paths.\n\nExample:\nGiven a grid:\n[\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n]\nand N = 4\n\nThe maximum sum is obtained by one path moving right to pick 4, then moving\ndown all the way to the bottom-right corner, and the other path moving down\nto pick 1, then moving right and down to pick 2, and finally moving right\nto the bottom-right corner. The total maximum sum would be 4 + 1 + 2 = 7.\n\nThe function call would look like this:\nint result = maxSumInGrid([\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n], 4);\nprint(result); // Outputs: 7\n\n* Incomplete Code:\nint maxSumInGrid(List<List<int>> grid, int N)\n {\n  // Initialize a 3-dimensional array dp to store the maximum sum for each state (i, j, k).\n  List<List<List<int>>> dp = List.generate(\n[MASK]\n    (i) => List.generate(N, (j) => List.generate(N, (k) => 0)),\n  );\n\n  // Populate the dp array with the input numbers\n  for (var i = 0; i < N; ++i) {\n    for (var j = 0; j < N; ++j) {\n      for (var k = 0; k < N; ++k) {\n        var l = i + j - k; // The position of P2 on the y-axis\n[MASK]\n        var value = grid[i][j];\n        if (i != k) value += grid[k][l]; // If not on the same column, add P2's value\n        var maxPrev = 0;\n        if (i > 0) maxPrev = max(maxPrev, dp[i - 1][j][k]); // P1 left\n        if (j > 0) maxPrev = max(maxPrev, dp[i][j - 1][k]); // P1 up\n        if (k > 0) maxPrev = max(maxPrev, dp[i][j][k - 1]); // P2 left\n        if (l > 0) maxPrev = max(maxPrev, dp[i][j][k]); // P2 up\n        dp[i][j][k] = maxPrev + value;\n      }\n    }\n  }\n  // The answer is the value in dp[N-1][N-1][N-1]\n  return dp[N - 1][N - 1][N - 1];\n}\n\nint max(int a, int b) => a > b ? a : b;\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  // Initialize a 3-dimensional array dp to store the maximum sum for each state (i, j, k).\n  List<List<List<int>>> dp = List.generate(\n[MASK]\n    (i) => List.generate(N, (j) => List.generate(N, (k) => 0)),\n  );\n\n  // Populate the dp array with the input numbers\n  for (var i = 0; i < N; ++i) {\n    for (var j = 0; j < N; ++j) {\n      for (var k = 0; k < N; ++k) {\n        var l = i + j - k; // The position of P2 on the y-axis\n[MASK]\n        var value = grid[i][j];\n        if (i != k) value += grid[k][l]; // If not on the same column, add P2's value\n        var maxPrev = 0;\n        if (i > 0) maxPrev = max(maxPrev, dp[i - 1][j][k]); // P1 left\n        if (j > 0) maxPrev = max(maxPrev, dp[i][j - 1][k]); // P1 up\n        if (k > 0) maxPrev = max(maxPrev, dp[i][j][k - 1]); // P2 left\n        if (l > 0) maxPrev = max(maxPrev, dp[i][j][k]); // P2 up\n        dp[i][j][k] = maxPrev + value;\n      }\n    }\n  }\n  // The answer is the value in dp[N-1][N-1][N-1]\n  return dp[N - 1][N - 1][N - 1];\n}\n\nint max(int a, int b) => a > b ? a : b;"}
{"task_id": "Dart/3-1-multi", "prompt": "import 'dart:io';\nint maxSumInGrid(List<List<int>> grid, int N)\n/// Calculates the maximum sum of numbers that can be picked on a grid by two paths.\n///\n/// This function takes a square grid of integers and the size of the grid (N),\n/// and computes the maximum sum of numbers that can be collected by two paths\n/// starting from the top-left corner and ending at the bottom-right corner.\n/// Each path can only move right or down, and no two paths can overlap.\n///\n/// Args:\n///   grid (List<List<int>>): A 2D list of integers representing the grid.\n///   N (int): The size of the dimensions of the square grid.\n///\n/// Returns:\n///   int: The maximum sum of numbers picked by the two paths.\n///\n/// Example:\n///   Given a grid:\n///   [\n///     [0, 0, 0, 0],\n///     [0, 4, 0, 0],\n///     [0, 0, 2, 0],\n///     [1, 0, 0, 0]\n///   ]\n///   and N = 4\n///\n///   The maximum sum is obtained by one path moving right to pick 4, then moving\n///   down all the way to the bottom-right corner, and the other path moving down\n///   to pick 1, then moving right and down to pick 2, and finally moving right\n///   to the bottom-right corner. The total maximum sum would be 4 + 1 + 2 = 7.\n///\n///   The function call would look like this:\n///   int result = maxSumInGrid([\n///     [0, 0, 0, 0],\n///     [0, 4, 0, 0],\n///     [0, 0, 2, 0],\n///     [1, 0, 0, 0]\n///   ], 4);\n///   print(result); // Outputs: 7", "canonical_solution": " {\n  // Initialize a 3-dimensional array dp to store the maximum sum for each state (i, j, k).\n  List<List<List<int>>> dp = List.generate(\n    2 * N,\n    (i) => List.generate(N, (j) => List.generate(N, (k) => 0)),\n  );\n\n  // Populate the dp array with the input numbers\n  for (var i = 0; i < N; ++i) {\n    for (var j = 0; j < N; ++j) {\n      for (var k = 0; k < N; ++k) {\n        var l = i + j - k; // The position of P2 on the y-axis\n        if (l < 0 || l >= N) continue; // Skip invalid positions\n        var value = grid[i][j];\n        if (i != k) value += grid[k][l]; // If not on the same column, add P2's value\n        var maxPrev = 0;\n        if (i > 0) maxPrev = max(maxPrev, dp[i - 1][j][k]); // P1 left\n        if (j > 0) maxPrev = max(maxPrev, dp[i][j - 1][k]); // P1 up\n        if (k > 0) maxPrev = max(maxPrev, dp[i][j][k - 1]); // P2 left\n        if (l > 0) maxPrev = max(maxPrev, dp[i][j][k]); // P2 up\n        dp[i][j][k] = maxPrev + value;\n      }\n    }\n  }\n  // The answer is the value in dp[N-1][N-1][N-1]\n  return dp[N - 1][N - 1][N - 1];\n}\n\nint max(int a, int b) => a > b ? a : b;", "test": "void testMaxSumInGrid() {\n  // TestCase Structure\n  List<Map<String, dynamic>> testCases = [\n    {\n      'grid': [\n        [0, 0, 0, 0],\n        [0, 4, 0, 0],\n        [0, 0, 2, 0],\n        [1, 0, 0, 0]\n      ],\n      'N': 4,\n      'expected': 16\n    },\n    {\n      'grid': [\n        [0, 0, 13, 0],\n        [0, 0, 0, 6],\n        [0, 7, 0, 0],\n        [0, 0, 0, 0]\n      ],\n      'N': 4,\n      'expected': 58\n    },\n    // Add more test cases here\n  ];\n\n  for (var testCase in testCases) {\n    int result = maxSumInGrid(testCase['grid'], testCase['N']);\n    assert(result == testCase['expected'], \"Test case failed: Expected ${testCase['expected']}, got $result\");\n    print('Test case passed: Expected ${testCase['expected']}, got $result');\n  }\n}\n\nvoid main() {\n  testMaxSumInGrid();\n  // You can also handle the interactive part here, if necessary.\n}", "entry_point": "maxSumInGrid", "signature": "int maxSumInGrid(List<List<int>> grid, int N)", "docstring": "Calculates the maximum sum of numbers that can be picked on a grid by two paths.\n\nThis function takes a square grid of integers and the size of the grid (N),\nand computes the maximum sum of numbers that can be collected by two paths\nstarting from the top-left corner and ending at the bottom-right corner.\nEach path can only move right or down, and no two paths can overlap.\n\nArgs:\ngrid (List<List<int>>): A 2D list of integers representing the grid.\nN (int): The size of the dimensions of the square grid.\n\nReturns:\nint: The maximum sum of numbers picked by the two paths.\n\nExample:\nGiven a grid:\n[\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n]\nand N = 4\n\nThe maximum sum is obtained by one path moving right to pick 4, then moving\ndown all the way to the bottom-right corner, and the other path moving down\nto pick 1, then moving right and down to pick 2, and finally moving right\nto the bottom-right corner. The total maximum sum would be 4 + 1 + 2 = 7.\n\nThe function call would look like this:\nint result = maxSumInGrid([\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n], 4);\nprint(result); // Outputs: 7", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum sum of numbers that can be picked on a grid by two paths.\n\nThis function takes a square grid of integers and the size of the grid (N),\nand computes the maximum sum of numbers that can be collected by two paths\nstarting from the top-left corner and ending at the bottom-right corner.\nEach path can only move right or down, and no two paths can overlap.\n\nArgs:\ngrid (List<List<int>>): A 2D list of integers representing the grid.\nN (int): The size of the dimensions of the square grid.\n\nReturns:\nint: The maximum sum of numbers picked by the two paths.\n\nExample:\nGiven a grid:\n[\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n]\nand N = 4\n\nThe maximum sum is obtained by one path moving right to pick 4, then moving\ndown all the way to the bottom-right corner, and the other path moving down\nto pick 1, then moving right and down to pick 2, and finally moving right\nto the bottom-right corner. The total maximum sum would be 4 + 1 + 2 = 7.\n\nThe function call would look like this:\nint result = maxSumInGrid([\n[0, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 2, 0],\n[1, 0, 0, 0]\n], 4);\nprint(result); // Outputs: 7\n\n* Incomplete Code:\nint maxSumInGrid(List<List<int>> grid, int N)\n {\n  // Initialize a 3-dimensional array dp to store the maximum sum for each state (i, j, k).\n  List<List<List<int>>> dp = List.generate(\n    2 * N,\n[MASK]\n  );\n\n  // Populate the dp array with the input numbers\n  for (var i = 0; i < N; ++i) {\n[MASK]\n      for (var k = 0; k < N; ++k) {\n        var l = i + j - k; // The position of P2 on the y-axis\n        if (l < 0 || l >= N) continue; // Skip invalid positions\n        var value = grid[i][j];\n        if (i != k) value += grid[k][l]; // If not on the same column, add P2's value\n        var maxPrev = 0;\n        if (i > 0) maxPrev = max(maxPrev, dp[i - 1][j][k]); // P1 left\n        if (j > 0) maxPrev = max(maxPrev, dp[i][j - 1][k]); // P1 up\n        if (k > 0) maxPrev = max(maxPrev, dp[i][j][k - 1]); // P2 left\n[MASK]\n        dp[i][j][k] = maxPrev + value;\n      }\n    }\n  }\n  // The answer is the value in dp[N-1][N-1][N-1]\n  return dp[N - 1][N - 1][N - 1];\n}\n\nint max(int a, int b) => a > b ? a : b;\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  // Initialize a 3-dimensional array dp to store the maximum sum for each state (i, j, k).\n  List<List<List<int>>> dp = List.generate(\n    2 * N,\n[MASK]\n  );\n\n  // Populate the dp array with the input numbers\n  for (var i = 0; i < N; ++i) {\n[MASK]\n      for (var k = 0; k < N; ++k) {\n        var l = i + j - k; // The position of P2 on the y-axis\n        if (l < 0 || l >= N) continue; // Skip invalid positions\n        var value = grid[i][j];\n        if (i != k) value += grid[k][l]; // If not on the same column, add P2's value\n        var maxPrev = 0;\n        if (i > 0) maxPrev = max(maxPrev, dp[i - 1][j][k]); // P1 left\n        if (j > 0) maxPrev = max(maxPrev, dp[i][j - 1][k]); // P1 up\n        if (k > 0) maxPrev = max(maxPrev, dp[i][j][k - 1]); // P2 left\n[MASK]\n        dp[i][j][k] = maxPrev + value;\n      }\n    }\n  }\n  // The answer is the value in dp[N-1][N-1][N-1]\n  return dp[N - 1][N - 1][N - 1];\n}\n\nint max(int a, int b) => a > b ? a : b;"}
{"task_id": "Dart/4-0-multi", "prompt": "// Recursive function to generate permutations\nList<List<int>> generatePermutations(List<int> list)\n/// Generates all possible permutations of a given list of integers.\n///\n/// This recursive function takes a list of integers as input and returns\n/// a list of lists, where each inner list represents a unique permutation\n/// of the input list. The function works by iterating over each element in\n/// the list, removing it, and generating all permutations of the remaining\n/// elements. Each of these permutations has the removed element prepended\n/// to it, thereby creating a new permutation that includes the removed element.\n/// The base case of the recursion is when the list contains only one element,\n/// in which case, the list itself is the only permutation.\n///\n/// Args:\n///   list (List<int>): The list of integers to permute.\n///\n/// Returns:\n///   List<List<int>>: A list containing all permutations of the input list.\n///\n/// Examples:\n///   generatePermutations([1]) returns [[1]]\n///   generatePermutations([1, 2]) returns [[1, 2], [2, 1]]\n///   generatePermutations([1, 2, 3])\n///     returns [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]", "canonical_solution": " {\n  if (list.length == 1) {\n    return [list];\n  }\n\n  List<List<int>> perms = [];\n  for (int i = 0; i < list.length; i++) {\n    int current = list[i];\n    List<int> remaining = List.from(list)..removeAt(i);\n    List<List<int>> remainingPerms = generatePermutations(remaining);\n\n    for (var perm in remainingPerms) {\n      perms.add([current] + perm);\n    }\n  }\n  return perms;\n}", "test": "void testGeneratePermutations() {\n  // Test case 1\n  List<int> list1 = [1];\n  List<List<int>> expectedPerms1 = [\n    [1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list1), expectedPerms1));\n\n  // Test case 2\n  List<int> list2 = [1, 2];\n  List<List<int>> expectedPerms2 = [\n    [1, 2],\n    [2, 1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list2), expectedPerms2));\n\n  // Test case 3\n  List<int> list3 = [1, 2, 3];\n  List<List<int>> expectedPerms3 = [\n    [1, 2, 3],\n    [1, 3, 2],\n    [2, 1, 3],\n    [2, 3, 1],\n    [3, 1, 2],\n    [3, 2, 1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list3), expectedPerms3));\n\n  print(\"All test cases passed!\");\n}\n\n// Equality for nested lists\nclass ListEquality {\n  bool equals(List<List<int>> list1, List<List<int>> list2) {\n    if (list1.length != list2.length) return false;\n    for (int i = 0; i < list1.length; i++) {\n      if (!_listEquals(list1[i], list2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  bool _listEquals(List<int> list1, List<int> list2) {\n    if (list1.length != list2.length) return false;\n    for (int i = 0; i < list1.length; i++) {\n      if (list1[i] != list2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nvoid main() {\n  testGeneratePermutations();\n}", "entry_point": "generatePermutations", "signature": "List<List<int>> generatePermutations(List<int> list)", "docstring": "Generates all possible permutations of a given list of integers.\n\nThis recursive function takes a list of integers as input and returns\na list of lists, where each inner list represents a unique permutation\nof the input list. The function works by iterating over each element in\nthe list, removing it, and generating all permutations of the remaining\nelements. Each of these permutations has the removed element prepended\nto it, thereby creating a new permutation that includes the removed element.\nThe base case of the recursion is when the list contains only one element,\nin which case, the list itself is the only permutation.\n\nArgs:\nlist (List<int>): The list of integers to permute.\n\nReturns:\nList<List<int>>: A list containing all permutations of the input list.\n\nExamples:\ngeneratePermutations([1]) returns [[1]]\ngeneratePermutations([1, 2]) returns [[1, 2], [2, 1]]\ngeneratePermutations([1, 2, 3])\nreturns [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nGenerates all possible permutations of a given list of integers.\n\nThis recursive function takes a list of integers as input and returns\na list of lists, where each inner list represents a unique permutation\nof the input list. The function works by iterating over each element in\nthe list, removing it, and generating all permutations of the remaining\nelements. Each of these permutations has the removed element prepended\nto it, thereby creating a new permutation that includes the removed element.\nThe base case of the recursion is when the list contains only one element,\nin which case, the list itself is the only permutation.\n\nArgs:\nlist (List<int>): The list of integers to permute.\n\nReturns:\nList<List<int>>: A list containing all permutations of the input list.\n\nExamples:\ngeneratePermutations([1]) returns [[1]]\ngeneratePermutations([1, 2]) returns [[1, 2], [2, 1]]\ngeneratePermutations([1, 2, 3])\nreturns [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n* Incomplete Code:\nList<List<int>> generatePermutations(List<int> list)\n {\n[MASK]\n    return [list];\n  }\n\n  List<List<int>> perms = [];\n  for (int i = 0; i < list.length; i++) {\n    int current = list[i];\n    List<int> remaining = List.from(list)..removeAt(i);\n    List<List<int>> remainingPerms = generatePermutations(remaining);\n\n    for (var perm in remainingPerms) {\n      perms.add([current] + perm);\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n[MASK]\n    return [list];\n  }\n\n  List<List<int>> perms = [];\n  for (int i = 0; i < list.length; i++) {\n    int current = list[i];\n    List<int> remaining = List.from(list)..removeAt(i);\n    List<List<int>> remainingPerms = generatePermutations(remaining);\n\n    for (var perm in remainingPerms) {\n      perms.add([current] + perm);\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/4-1-multi", "prompt": "// Recursive function to generate permutations\nList<List<int>> generatePermutations(List<int> list)\n/// Generates all possible permutations of a given list of integers.\n///\n/// This recursive function takes a list of integers as input and returns\n/// a list of lists, where each inner list represents a unique permutation\n/// of the input list. The function works by iterating over each element in\n/// the list, removing it, and generating all permutations of the remaining\n/// elements. Each of these permutations has the removed element prepended\n/// to it, thereby creating a new permutation that includes the removed element.\n/// The base case of the recursion is when the list contains only one element,\n/// in which case, the list itself is the only permutation.\n///\n/// Args:\n///   list (List<int>): The list of integers to permute.\n///\n/// Returns:\n///   List<List<int>>: A list containing all permutations of the input list.\n///\n/// Examples:\n///   generatePermutations([1]) returns [[1]]\n///   generatePermutations([1, 2]) returns [[1, 2], [2, 1]]\n///   generatePermutations([1, 2, 3])\n///     returns [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]", "canonical_solution": " {\n  if (list.length == 1) {\n    return [list];\n  }\n\n  List<List<int>> perms = [];\n  for (int i = 0; i < list.length; i++) {\n    int current = list[i];\n    List<int> remaining = List.from(list)..removeAt(i);\n    List<List<int>> remainingPerms = generatePermutations(remaining);\n\n    for (var perm in remainingPerms) {\n      perms.add([current] + perm);\n    }\n  }\n  return perms;\n}", "test": "void testGeneratePermutations() {\n  // Test case 1\n  List<int> list1 = [1];\n  List<List<int>> expectedPerms1 = [\n    [1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list1), expectedPerms1));\n\n  // Test case 2\n  List<int> list2 = [1, 2];\n  List<List<int>> expectedPerms2 = [\n    [1, 2],\n    [2, 1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list2), expectedPerms2));\n\n  // Test case 3\n  List<int> list3 = [1, 2, 3];\n  List<List<int>> expectedPerms3 = [\n    [1, 2, 3],\n    [1, 3, 2],\n    [2, 1, 3],\n    [2, 3, 1],\n    [3, 1, 2],\n    [3, 2, 1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list3), expectedPerms3));\n\n  print(\"All test cases passed!\");\n}\n\n// Equality for nested lists\nclass ListEquality {\n  bool equals(List<List<int>> list1, List<List<int>> list2) {\n    if (list1.length != list2.length) return false;\n    for (int i = 0; i < list1.length; i++) {\n      if (!_listEquals(list1[i], list2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  bool _listEquals(List<int> list1, List<int> list2) {\n    if (list1.length != list2.length) return false;\n    for (int i = 0; i < list1.length; i++) {\n      if (list1[i] != list2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nvoid main() {\n  testGeneratePermutations();\n}", "entry_point": "generatePermutations", "signature": "List<List<int>> generatePermutations(List<int> list)", "docstring": "Generates all possible permutations of a given list of integers.\n\nThis recursive function takes a list of integers as input and returns\na list of lists, where each inner list represents a unique permutation\nof the input list. The function works by iterating over each element in\nthe list, removing it, and generating all permutations of the remaining\nelements. Each of these permutations has the removed element prepended\nto it, thereby creating a new permutation that includes the removed element.\nThe base case of the recursion is when the list contains only one element,\nin which case, the list itself is the only permutation.\n\nArgs:\nlist (List<int>): The list of integers to permute.\n\nReturns:\nList<List<int>>: A list containing all permutations of the input list.\n\nExamples:\ngeneratePermutations([1]) returns [[1]]\ngeneratePermutations([1, 2]) returns [[1, 2], [2, 1]]\ngeneratePermutations([1, 2, 3])\nreturns [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nGenerates all possible permutations of a given list of integers.\n\nThis recursive function takes a list of integers as input and returns\na list of lists, where each inner list represents a unique permutation\nof the input list. The function works by iterating over each element in\nthe list, removing it, and generating all permutations of the remaining\nelements. Each of these permutations has the removed element prepended\nto it, thereby creating a new permutation that includes the removed element.\nThe base case of the recursion is when the list contains only one element,\nin which case, the list itself is the only permutation.\n\nArgs:\nlist (List<int>): The list of integers to permute.\n\nReturns:\nList<List<int>>: A list containing all permutations of the input list.\n\nExamples:\ngeneratePermutations([1]) returns [[1]]\ngeneratePermutations([1, 2]) returns [[1, 2], [2, 1]]\ngeneratePermutations([1, 2, 3])\nreturns [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n* Incomplete Code:\nList<List<int>> generatePermutations(List<int> list)\n {\n[MASK]\n    return [list];\n  }\n\n  List<List<int>> perms = [];\n  for (int i = 0; i < list.length; i++) {\n    int current = list[i];\n[MASK]\n    List<List<int>> remainingPerms = generatePermutations(remaining);\n\n[MASK]\n      perms.add([current] + perm);\n    }\n  }\n  return perms;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n[MASK]\n    return [list];\n  }\n\n  List<List<int>> perms = [];\n  for (int i = 0; i < list.length; i++) {\n    int current = list[i];\n[MASK]\n    List<List<int>> remainingPerms = generatePermutations(remaining);\n\n[MASK]\n      perms.add([current] + perm);\n    }\n  }\n  return perms;\n}"}
{"task_id": "Dart/5-0-multi", "prompt": "import 'dart:io';\nimport 'dart:math';\n\nBigInt sumOfFactorials(int n)\n/// Calculates the sum of factorials of all integers from 1 to n.\n///\n/// This function computes the factorial of each integer from 1 up to and\n/// including n using the `factorial` function, then sums these factorials to\n/// obtain the final result. The function uses `BigInt` to handle very large\n/// numbers that may arise from factorial calculations.\n///\n/// Args:\n///   n (int): The upper bound of the range for which to calculate the sum\n///            of factorials. The value of n should be a non-negative integer.\n///\n/// Returns:\n///   BigInt: The sum of factorials of all integers from 1 to n.\n///\n/// Examples:\n///   sumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\n///   sumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\n///   sumOfFactorials(4) returns BigInt.from(33) (since 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33)", "canonical_solution": "{\n  BigInt sum = BigInt.zero;\n  for (int i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\nBigInt factorial(int n) {\n  BigInt result = BigInt.one;\n  for (int i = 1; i <= n; i++) {\n    result *= BigInt.from(i);\n  }\n  return result;\n}", "test": "void testSumOfFactorials() {\n  // Test case 1: Sum of factorials up to 1\n  assert(sumOfFactorials(1) == BigInt.from(1), \"Sum of factorials up to 1 should be 1\");\n\n  // Test case 2: Sum of factorials up to 3\n  assert(sumOfFactorials(3) == BigInt.from(9), \"Sum of factorials up to 3 should be 9\");\n\n  // Test case 3: Sum of factorials up to 4\n  BigInt expectedSumOfFactorials4 = BigInt.from(1) + BigInt.from(2) + BigInt.from(6) + BigInt.from(24);\n  assert(sumOfFactorials(4) == expectedSumOfFactorials4, \"Sum of factorials up to 4 should be 33\");\n\n  print(\"All sum of factorials test cases passed!\");\n}\n\nvoid main() {\n  testSumOfFactorials();\n}", "entry_point": "sumOfFactorials", "signature": "BigInt sumOfFactorials(int n)", "docstring": "Calculates the sum of factorials of all integers from 1 to n.\n\nThis function computes the factorial of each integer from 1 up to and\nincluding n using the `factorial` function, then sums these factorials to\nobtain the final result. The function uses `BigInt` to handle very large\nnumbers that may arise from factorial calculations.\n\nArgs:\nn (int): The upper bound of the range for which to calculate the sum\nof factorials. The value of n should be a non-negative integer.\n\nReturns:\nBigInt: The sum of factorials of all integers from 1 to n.\n\nExamples:\nsumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\nsumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\nsumOfFactorials(4) returns BigInt.from(33) (since 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33)", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the sum of factorials of all integers from 1 to n.\n\nThis function computes the factorial of each integer from 1 up to and\nincluding n using the `factorial` function, then sums these factorials to\nobtain the final result. The function uses `BigInt` to handle very large\nnumbers that may arise from factorial calculations.\n\nArgs:\nn (int): The upper bound of the range for which to calculate the sum\nof factorials. The value of n should be a non-negative integer.\n\nReturns:\nBigInt: The sum of factorials of all integers from 1 to n.\n\nExamples:\nsumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\nsumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\nsumOfFactorials(4) returns BigInt.from(33) (since 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33)\n\n* Incomplete Code:\nBigInt sumOfFactorials(int n)\n{\n  BigInt sum = BigInt.zero;\n[MASK]\n    sum += factorial(i);\n  }\n  return sum;\n}\n\n[MASK]\n[MASK]\n[MASK]\n    result *= BigInt.from(i);\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  BigInt sum = BigInt.zero;\n[MASK]\n    sum += factorial(i);\n  }\n  return sum;\n}\n\n[MASK]\n[MASK]\n[MASK]\n    result *= BigInt.from(i);\n  }\n[MASK]\n}"}
{"task_id": "Dart/5-1-multi", "prompt": "import 'dart:io';\nimport 'dart:math';\n\nBigInt sumOfFactorials(int n)\n/// Calculates the sum of factorials of all integers from 1 to n.\n///\n/// This function computes the factorial of each integer from 1 up to and\n/// including n using the `factorial` function, then sums these factorials to\n/// obtain the final result. The function uses `BigInt` to handle very large\n/// numbers that may arise from factorial calculations.\n///\n/// Args:\n///   n (int): The upper bound of the range for which to calculate the sum\n///            of factorials. The value of n should be a non-negative integer.\n///\n/// Returns:\n///   BigInt: The sum of factorials of all integers from 1 to n.\n///\n/// Examples:\n///   sumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\n///   sumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\n///   sumOfFactorials(4) returns BigInt.from(33) (since 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33)", "canonical_solution": "{\n  BigInt sum = BigInt.zero;\n  for (int i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\nBigInt factorial(int n) {\n  BigInt result = BigInt.one;\n  for (int i = 1; i <= n; i++) {\n    result *= BigInt.from(i);\n  }\n  return result;\n}", "test": "void testSumOfFactorials() {\n  // Test case 1: Sum of factorials up to 1\n  assert(sumOfFactorials(1) == BigInt.from(1), \"Sum of factorials up to 1 should be 1\");\n\n  // Test case 2: Sum of factorials up to 3\n  assert(sumOfFactorials(3) == BigInt.from(9), \"Sum of factorials up to 3 should be 9\");\n\n  // Test case 3: Sum of factorials up to 4\n  BigInt expectedSumOfFactorials4 = BigInt.from(1) + BigInt.from(2) + BigInt.from(6) + BigInt.from(24);\n  assert(sumOfFactorials(4) == expectedSumOfFactorials4, \"Sum of factorials up to 4 should be 33\");\n\n  print(\"All sum of factorials test cases passed!\");\n}\n\nvoid main() {\n  testSumOfFactorials();\n}", "entry_point": "sumOfFactorials", "signature": "BigInt sumOfFactorials(int n)", "docstring": "Calculates the sum of factorials of all integers from 1 to n.\n\nThis function computes the factorial of each integer from 1 up to and\nincluding n using the `factorial` function, then sums these factorials to\nobtain the final result. The function uses `BigInt` to handle very large\nnumbers that may arise from factorial calculations.\n\nArgs:\nn (int): The upper bound of the range for which to calculate the sum\nof factorials. The value of n should be a non-negative integer.\n\nReturns:\nBigInt: The sum of factorials of all integers from 1 to n.\n\nExamples:\nsumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\nsumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\nsumOfFactorials(4) returns BigInt.from(33) (since 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33)", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the sum of factorials of all integers from 1 to n.\n\nThis function computes the factorial of each integer from 1 up to and\nincluding n using the `factorial` function, then sums these factorials to\nobtain the final result. The function uses `BigInt` to handle very large\nnumbers that may arise from factorial calculations.\n\nArgs:\nn (int): The upper bound of the range for which to calculate the sum\nof factorials. The value of n should be a non-negative integer.\n\nReturns:\nBigInt: The sum of factorials of all integers from 1 to n.\n\nExamples:\nsumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\nsumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\nsumOfFactorials(4) returns BigInt.from(33) (since 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33)\n\n* Incomplete Code:\nBigInt sumOfFactorials(int n)\n{\n  BigInt sum = BigInt.zero;\n  for (int i = 1; i <= n; i++) {\n[MASK]\n  }\n  return sum;\n}\n\nBigInt factorial(int n) {\n  BigInt result = BigInt.one;\n[MASK]\n[MASK]\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  BigInt sum = BigInt.zero;\n  for (int i = 1; i <= n; i++) {\n[MASK]\n  }\n  return sum;\n}\n\nBigInt factorial(int n) {\n  BigInt result = BigInt.one;\n[MASK]\n[MASK]\n  }\n[MASK]\n}"}
{"task_id": "Dart/6-0-multi", "prompt": "String concatenateLargestNumber(List<int> numbers)\n/// Creates the largest possible number by concatenating the given list of integers.\n///\n/// The function sorts the list of integers in such a way that when they are\n/// concatenated in this order, the resulting string represents the largest\n/// possible number. It uses a custom comparator for sorting that compares\n/// concatenated pairs of numbers in reverse order to ensure the correct\n/// placement for the largest concatenated result.\n///\n/// Args:\n///   numbers (List<int>): A list of non-negative integers to be concatenated.\n///\n/// Returns:\n///   String: A string representing the largest number formed by the\n///           concatenation of the provided integers.\n///\n/// Examples:\n///   concatenateLargestNumber([10, 2]) returns \"210\"\n///     Explanation: \"210\" is larger than \"102\" (the other concatenation).\n///\n///   concatenateLargestNumber([3, 30, 34, 5, 9]) returns \"9534330\"\n///     Explanation: By sorting the numbers as [9, 5, 34, 3, 30], the\n///     concatenation \"9534330\" forms the largest number.\n///\n///   concatenateLargestNumber([0, 0, 0, 1]) returns \"1000\"\n///     Explanation: \"1000\" is the largest number that can be formed, even\n///     though there are leading zeros in the sorted list.\n///\n///   concatenateLargestNumber([0, 0, 0, 0]) returns \"0\"\n///     Explanation: Regardless of how the zeros are concatenated, the result\n///     is the same: \"0\".\n///\n///   concatenateLargestNumber([42]) returns \"42\"\n///     Explanation: With a single number, the largest number is the number itself.", "canonical_solution": "{\n  // Custom comparator to decide which concatenation leads to a larger number\n  numbers.sort((a, b) {\n    String ab = '$a$b';\n    String ba = '$b$a';\n    return -ab.compareTo(ba); // Descending order\n  });\n  // Concatenate the numbers in the sorted order to form the largest number\n  return numbers.join('');\n}", "test": "void testConcatenateLargestNumber() {\n  // Test case 1: Simple case\n  assert(concatenateLargestNumber([10, 2]) == \"210\", \"Test Case 1 Failed: [10, 2] should concatenate to '210'\");\n\n  // Test case 2: Case with same starting digits\n  assert(concatenateLargestNumber([3, 30, 34, 5, 9]) == \"9534330\", \"Test Case 2 Failed: [3, 30, 34, 5, 9] should concatenate to '9534330'\");\n\n  // Test case 3: Case with zeros\n  assert(concatenateLargestNumber([0, 0, 0, 1]) == \"1000\", \"Test Case 3 Failed: [0, 0, 0, 1] should concatenate to '1000'\");\n\n  // Test case 4: All zeros\n  assert(concatenateLargestNumber([0, 0, 0, 0]) == \"0000\", \"Test Case 4 Failed: [0, 0, 0, 0] should concatenate to '0'\");\n\n  // Test case 5: Single number\n  assert(concatenateLargestNumber([42]) == \"42\", \"Test Case 5 Failed: [42] should concatenate to '42'\");\n\n  print(\"All concatenateLargestNumber test cases passed!\");\n}\n\nvoid main() {\n  testConcatenateLargestNumber();\n}", "entry_point": "concatenateLargestNumber", "signature": "String concatenateLargestNumber(List<int> numbers)", "docstring": "Creates the largest possible number by concatenating the given list of integers.\n\nThe function sorts the list of integers in such a way that when they are\nconcatenated in this order, the resulting string represents the largest\npossible number. It uses a custom comparator for sorting that compares\nconcatenated pairs of numbers in reverse order to ensure the correct\nplacement for the largest concatenated result.\n\nArgs:\nnumbers (List<int>): A list of non-negative integers to be concatenated.\n\nReturns:\nString: A string representing the largest number formed by the\nconcatenation of the provided integers.\n\nExamples:\nconcatenateLargestNumber([10, 2]) returns \"210\"\nExplanation: \"210\" is larger than \"102\" (the other concatenation).\n\nconcatenateLargestNumber([3, 30, 34, 5, 9]) returns \"9534330\"\nExplanation: By sorting the numbers as [9, 5, 34, 3, 30], the\nconcatenation \"9534330\" forms the largest number.\n\nconcatenateLargestNumber([0, 0, 0, 1]) returns \"1000\"\nExplanation: \"1000\" is the largest number that can be formed, even\nthough there are leading zeros in the sorted list.\n\nconcatenateLargestNumber([0, 0, 0, 0]) returns \"0\"\nExplanation: Regardless of how the zeros are concatenated, the result\nis the same: \"0\".\n\nconcatenateLargestNumber([42]) returns \"42\"\nExplanation: With a single number, the largest number is the number itself.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCreates the largest possible number by concatenating the given list of integers.\n\nThe function sorts the list of integers in such a way that when they are\nconcatenated in this order, the resulting string represents the largest\npossible number. It uses a custom comparator for sorting that compares\nconcatenated pairs of numbers in reverse order to ensure the correct\nplacement for the largest concatenated result.\n\nArgs:\nnumbers (List<int>): A list of non-negative integers to be concatenated.\n\nReturns:\nString: A string representing the largest number formed by the\nconcatenation of the provided integers.\n\nExamples:\nconcatenateLargestNumber([10, 2]) returns \"210\"\nExplanation: \"210\" is larger than \"102\" (the other concatenation).\n\nconcatenateLargestNumber([3, 30, 34, 5, 9]) returns \"9534330\"\nExplanation: By sorting the numbers as [9, 5, 34, 3, 30], the\nconcatenation \"9534330\" forms the largest number.\n\nconcatenateLargestNumber([0, 0, 0, 1]) returns \"1000\"\nExplanation: \"1000\" is the largest number that can be formed, even\nthough there are leading zeros in the sorted list.\n\nconcatenateLargestNumber([0, 0, 0, 0]) returns \"0\"\nExplanation: Regardless of how the zeros are concatenated, the result\nis the same: \"0\".\n\nconcatenateLargestNumber([42]) returns \"42\"\nExplanation: With a single number, the largest number is the number itself.\n\n* Incomplete Code:\nString concatenateLargestNumber(List<int> numbers)\n{\n  // Custom comparator to decide which concatenation leads to a larger number\n  numbers.sort((a, b) {\n[MASK]\n    String ba = '$b$a';\n[MASK]\n  });\n  // Concatenate the numbers in the sorted order to form the largest number\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Custom comparator to decide which concatenation leads to a larger number\n  numbers.sort((a, b) {\n[MASK]\n    String ba = '$b$a';\n[MASK]\n  });\n  // Concatenate the numbers in the sorted order to form the largest number\n[MASK]\n}"}
{"task_id": "Dart/6-1-multi", "prompt": "String concatenateLargestNumber(List<int> numbers)\n/// Creates the largest possible number by concatenating the given list of integers.\n///\n/// The function sorts the list of integers in such a way that when they are\n/// concatenated in this order, the resulting string represents the largest\n/// possible number. It uses a custom comparator for sorting that compares\n/// concatenated pairs of numbers in reverse order to ensure the correct\n/// placement for the largest concatenated result.\n///\n/// Args:\n///   numbers (List<int>): A list of non-negative integers to be concatenated.\n///\n/// Returns:\n///   String: A string representing the largest number formed by the\n///           concatenation of the provided integers.\n///\n/// Examples:\n///   concatenateLargestNumber([10, 2]) returns \"210\"\n///     Explanation: \"210\" is larger than \"102\" (the other concatenation).\n///\n///   concatenateLargestNumber([3, 30, 34, 5, 9]) returns \"9534330\"\n///     Explanation: By sorting the numbers as [9, 5, 34, 3, 30], the\n///     concatenation \"9534330\" forms the largest number.\n///\n///   concatenateLargestNumber([0, 0, 0, 1]) returns \"1000\"\n///     Explanation: \"1000\" is the largest number that can be formed, even\n///     though there are leading zeros in the sorted list.\n///\n///   concatenateLargestNumber([0, 0, 0, 0]) returns \"0\"\n///     Explanation: Regardless of how the zeros are concatenated, the result\n///     is the same: \"0\".\n///\n///   concatenateLargestNumber([42]) returns \"42\"\n///     Explanation: With a single number, the largest number is the number itself.", "canonical_solution": "{\n  // Custom comparator to decide which concatenation leads to a larger number\n  numbers.sort((a, b) {\n    String ab = '$a$b';\n    String ba = '$b$a';\n    return -ab.compareTo(ba); // Descending order\n  });\n  // Concatenate the numbers in the sorted order to form the largest number\n  return numbers.join('');\n}", "test": "void testConcatenateLargestNumber() {\n  // Test case 1: Simple case\n  assert(concatenateLargestNumber([10, 2]) == \"210\", \"Test Case 1 Failed: [10, 2] should concatenate to '210'\");\n\n  // Test case 2: Case with same starting digits\n  assert(concatenateLargestNumber([3, 30, 34, 5, 9]) == \"9534330\", \"Test Case 2 Failed: [3, 30, 34, 5, 9] should concatenate to '9534330'\");\n\n  // Test case 3: Case with zeros\n  assert(concatenateLargestNumber([0, 0, 0, 1]) == \"1000\", \"Test Case 3 Failed: [0, 0, 0, 1] should concatenate to '1000'\");\n\n  // Test case 4: All zeros\n  assert(concatenateLargestNumber([0, 0, 0, 0]) == \"0000\", \"Test Case 4 Failed: [0, 0, 0, 0] should concatenate to '0'\");\n\n  // Test case 5: Single number\n  assert(concatenateLargestNumber([42]) == \"42\", \"Test Case 5 Failed: [42] should concatenate to '42'\");\n\n  print(\"All concatenateLargestNumber test cases passed!\");\n}\n\nvoid main() {\n  testConcatenateLargestNumber();\n}", "entry_point": "concatenateLargestNumber", "signature": "String concatenateLargestNumber(List<int> numbers)", "docstring": "Creates the largest possible number by concatenating the given list of integers.\n\nThe function sorts the list of integers in such a way that when they are\nconcatenated in this order, the resulting string represents the largest\npossible number. It uses a custom comparator for sorting that compares\nconcatenated pairs of numbers in reverse order to ensure the correct\nplacement for the largest concatenated result.\n\nArgs:\nnumbers (List<int>): A list of non-negative integers to be concatenated.\n\nReturns:\nString: A string representing the largest number formed by the\nconcatenation of the provided integers.\n\nExamples:\nconcatenateLargestNumber([10, 2]) returns \"210\"\nExplanation: \"210\" is larger than \"102\" (the other concatenation).\n\nconcatenateLargestNumber([3, 30, 34, 5, 9]) returns \"9534330\"\nExplanation: By sorting the numbers as [9, 5, 34, 3, 30], the\nconcatenation \"9534330\" forms the largest number.\n\nconcatenateLargestNumber([0, 0, 0, 1]) returns \"1000\"\nExplanation: \"1000\" is the largest number that can be formed, even\nthough there are leading zeros in the sorted list.\n\nconcatenateLargestNumber([0, 0, 0, 0]) returns \"0\"\nExplanation: Regardless of how the zeros are concatenated, the result\nis the same: \"0\".\n\nconcatenateLargestNumber([42]) returns \"42\"\nExplanation: With a single number, the largest number is the number itself.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCreates the largest possible number by concatenating the given list of integers.\n\nThe function sorts the list of integers in such a way that when they are\nconcatenated in this order, the resulting string represents the largest\npossible number. It uses a custom comparator for sorting that compares\nconcatenated pairs of numbers in reverse order to ensure the correct\nplacement for the largest concatenated result.\n\nArgs:\nnumbers (List<int>): A list of non-negative integers to be concatenated.\n\nReturns:\nString: A string representing the largest number formed by the\nconcatenation of the provided integers.\n\nExamples:\nconcatenateLargestNumber([10, 2]) returns \"210\"\nExplanation: \"210\" is larger than \"102\" (the other concatenation).\n\nconcatenateLargestNumber([3, 30, 34, 5, 9]) returns \"9534330\"\nExplanation: By sorting the numbers as [9, 5, 34, 3, 30], the\nconcatenation \"9534330\" forms the largest number.\n\nconcatenateLargestNumber([0, 0, 0, 1]) returns \"1000\"\nExplanation: \"1000\" is the largest number that can be formed, even\nthough there are leading zeros in the sorted list.\n\nconcatenateLargestNumber([0, 0, 0, 0]) returns \"0\"\nExplanation: Regardless of how the zeros are concatenated, the result\nis the same: \"0\".\n\nconcatenateLargestNumber([42]) returns \"42\"\nExplanation: With a single number, the largest number is the number itself.\n\n* Incomplete Code:\nString concatenateLargestNumber(List<int> numbers)\n{\n  // Custom comparator to decide which concatenation leads to a larger number\n[MASK]\n[MASK]\n    String ba = '$b$a';\n[MASK]\n  });\n  // Concatenate the numbers in the sorted order to form the largest number\n  return numbers.join('');\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Custom comparator to decide which concatenation leads to a larger number\n[MASK]\n[MASK]\n    String ba = '$b$a';\n[MASK]\n  });\n  // Concatenate the numbers in the sorted order to form the largest number\n  return numbers.join('');\n}"}
{"task_id": "Dart/7-0-multi", "prompt": "String getCantorNumber(int n)\n/// Finds the N-th term in the Cantor enumeration of the rational numbers.\n///\n/// The Cantor enumeration is a sequence that lists all positive rational\n/// numbers (fractions) uniquely. The enumeration is based on traversing the\n/// infinite matrix of numerators/denominators diagonally. This function\n/// calculates the numerator and denominator of the N-th term in this sequence.\n///\n/// Args:\n///   n (int): The position in the sequence for which to calculate the\n///            numerator and denominator.\n///\n/// Returns:\n///   String: A string representation of the fraction at the N-th position\n///           in the form \"numerator/denominator\".\n///\n/// Examples:\n///   getCantorNumber(1) returns \"1/1\"\n///     Explanation: The first term in the Cantor enumeration is \"1/1\".\n///\n///   getCantorNumber(2) returns \"1/2\"\n///     Explanation: The second term moves to the next diagonal level, resulting\n///     in \"1/2\".\n///\n///   getCantorNumber(3) returns \"2/1\"\n///     Explanation: The third term is the first entry in the second diagonal,\n///     which inverts to \"2/1\".\n///\n///   getCantorNumber(4) returns \"3/1\"\n///     Explanation: The fourth term follows the diagonal up, increasing the\n///     numerator to \"3/1\".\n///\n///   getCantorNumber(6) returns \"1/3\"\n///     Explanation: The sixth term is \"1/3\", which follows the diagonal down\n///     from the previous term \"2/2\".", "canonical_solution": "{\n  // Determine the sum of the numerator and denominator for the N-th position\n  int sum = 0;\n  int count = 0;\n  while (count < n) {\n    sum++;\n    count += sum;\n  }\n\n  // Calculate the difference to backtrack to the start of the diagonal\n  int diff = count - n;\n\n  // Determine the numerator and denominator based on the diagonal's direction\n  int numerator, denominator;\n  if (sum % 2 == 0) {\n    // Even sum indicates a diagonal going down (numerator increases)\n    numerator = sum - diff;\n    denominator = 1 + diff;\n  } else {\n    // Odd sum indicates a diagonal going up (denominator increases)\n    numerator = 1 + diff;\n    denominator = sum - diff;\n  }\n  return \"$numerator/$denominator\";\n}", "test": "void testGetCantorNumber() {\n  // Test case 1: First term (N=1)\n  assert(getCantorNumber(1) == \"1/1\", \"Test Case 1 Failed: N=1 should result in '1/1'\");\n\n  // Test case 2: Fifth term (N=5)\n  assert(getCantorNumber(5) == \"2/2\", \"Test Case 2 Failed: N=5 should result in '2/2'\");\n\n  // Test case 3: Tenth term (N=10)\n  assert(getCantorNumber(10) == \"4/1\", \"Test Case 3 Failed: N=10 should result in '1/4'\");\n\n  print(\"All getCantorNumber test cases passed!\");\n}\n\nvoid main() {\n  testGetCantorNumber();\n}", "entry_point": "getCantorNumber", "signature": "String getCantorNumber(int n)", "docstring": "Finds the N-th term in the Cantor enumeration of the rational numbers.\n\nThe Cantor enumeration is a sequence that lists all positive rational\nnumbers (fractions) uniquely. The enumeration is based on traversing the\ninfinite matrix of numerators/denominators diagonally. This function\ncalculates the numerator and denominator of the N-th term in this sequence.\n\nArgs:\nn (int): The position in the sequence for which to calculate the\nnumerator and denominator.\n\nReturns:\nString: A string representation of the fraction at the N-th position\nin the form \"numerator/denominator\".\n\nExamples:\ngetCantorNumber(1) returns \"1/1\"\nExplanation: The first term in the Cantor enumeration is \"1/1\".\n\ngetCantorNumber(2) returns \"1/2\"\nExplanation: The second term moves to the next diagonal level, resulting\nin \"1/2\".\n\ngetCantorNumber(3) returns \"2/1\"\nExplanation: The third term is the first entry in the second diagonal,\nwhich inverts to \"2/1\".\n\ngetCantorNumber(4) returns \"3/1\"\nExplanation: The fourth term follows the diagonal up, increasing the\nnumerator to \"3/1\".\n\ngetCantorNumber(6) returns \"1/3\"\nExplanation: The sixth term is \"1/3\", which follows the diagonal down\nfrom the previous term \"2/2\".", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds the N-th term in the Cantor enumeration of the rational numbers.\n\nThe Cantor enumeration is a sequence that lists all positive rational\nnumbers (fractions) uniquely. The enumeration is based on traversing the\ninfinite matrix of numerators/denominators diagonally. This function\ncalculates the numerator and denominator of the N-th term in this sequence.\n\nArgs:\nn (int): The position in the sequence for which to calculate the\nnumerator and denominator.\n\nReturns:\nString: A string representation of the fraction at the N-th position\nin the form \"numerator/denominator\".\n\nExamples:\ngetCantorNumber(1) returns \"1/1\"\nExplanation: The first term in the Cantor enumeration is \"1/1\".\n\ngetCantorNumber(2) returns \"1/2\"\nExplanation: The second term moves to the next diagonal level, resulting\nin \"1/2\".\n\ngetCantorNumber(3) returns \"2/1\"\nExplanation: The third term is the first entry in the second diagonal,\nwhich inverts to \"2/1\".\n\ngetCantorNumber(4) returns \"3/1\"\nExplanation: The fourth term follows the diagonal up, increasing the\nnumerator to \"3/1\".\n\ngetCantorNumber(6) returns \"1/3\"\nExplanation: The sixth term is \"1/3\", which follows the diagonal down\nfrom the previous term \"2/2\".\n\n* Incomplete Code:\nString getCantorNumber(int n)\n{\n  // Determine the sum of the numerator and denominator for the N-th position\n  int sum = 0;\n  int count = 0;\n[MASK]\n    sum++;\n    count += sum;\n  }\n\n  // Calculate the difference to backtrack to the start of the diagonal\n  int diff = count - n;\n\n  // Determine the numerator and denominator based on the diagonal's direction\n[MASK]\n  if (sum % 2 == 0) {\n    // Even sum indicates a diagonal going down (numerator increases)\n[MASK]\n    denominator = 1 + diff;\n  } else {\n    // Odd sum indicates a diagonal going up (denominator increases)\n    numerator = 1 + diff;\n    denominator = sum - diff;\n  }\n  return \"$numerator/$denominator\";\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Determine the sum of the numerator and denominator for the N-th position\n  int sum = 0;\n  int count = 0;\n[MASK]\n    sum++;\n    count += sum;\n  }\n\n  // Calculate the difference to backtrack to the start of the diagonal\n  int diff = count - n;\n\n  // Determine the numerator and denominator based on the diagonal's direction\n[MASK]\n  if (sum % 2 == 0) {\n    // Even sum indicates a diagonal going down (numerator increases)\n[MASK]\n    denominator = 1 + diff;\n  } else {\n    // Odd sum indicates a diagonal going up (denominator increases)\n    numerator = 1 + diff;\n    denominator = sum - diff;\n  }\n  return \"$numerator/$denominator\";\n}"}
{"task_id": "Dart/7-1-multi", "prompt": "String getCantorNumber(int n)\n/// Finds the N-th term in the Cantor enumeration of the rational numbers.\n///\n/// The Cantor enumeration is a sequence that lists all positive rational\n/// numbers (fractions) uniquely. The enumeration is based on traversing the\n/// infinite matrix of numerators/denominators diagonally. This function\n/// calculates the numerator and denominator of the N-th term in this sequence.\n///\n/// Args:\n///   n (int): The position in the sequence for which to calculate the\n///            numerator and denominator.\n///\n/// Returns:\n///   String: A string representation of the fraction at the N-th position\n///           in the form \"numerator/denominator\".\n///\n/// Examples:\n///   getCantorNumber(1) returns \"1/1\"\n///     Explanation: The first term in the Cantor enumeration is \"1/1\".\n///\n///   getCantorNumber(2) returns \"1/2\"\n///     Explanation: The second term moves to the next diagonal level, resulting\n///     in \"1/2\".\n///\n///   getCantorNumber(3) returns \"2/1\"\n///     Explanation: The third term is the first entry in the second diagonal,\n///     which inverts to \"2/1\".\n///\n///   getCantorNumber(4) returns \"3/1\"\n///     Explanation: The fourth term follows the diagonal up, increasing the\n///     numerator to \"3/1\".\n///\n///   getCantorNumber(6) returns \"1/3\"\n///     Explanation: The sixth term is \"1/3\", which follows the diagonal down\n///     from the previous term \"2/2\".", "canonical_solution": "{\n  // Determine the sum of the numerator and denominator for the N-th position\n  int sum = 0;\n  int count = 0;\n  while (count < n) {\n    sum++;\n    count += sum;\n  }\n\n  // Calculate the difference to backtrack to the start of the diagonal\n  int diff = count - n;\n\n  // Determine the numerator and denominator based on the diagonal's direction\n  int numerator, denominator;\n  if (sum % 2 == 0) {\n    // Even sum indicates a diagonal going down (numerator increases)\n    numerator = sum - diff;\n    denominator = 1 + diff;\n  } else {\n    // Odd sum indicates a diagonal going up (denominator increases)\n    numerator = 1 + diff;\n    denominator = sum - diff;\n  }\n  return \"$numerator/$denominator\";\n}", "test": "void testGetCantorNumber() {\n  // Test case 1: First term (N=1)\n  assert(getCantorNumber(1) == \"1/1\", \"Test Case 1 Failed: N=1 should result in '1/1'\");\n\n  // Test case 2: Fifth term (N=5)\n  assert(getCantorNumber(5) == \"2/2\", \"Test Case 2 Failed: N=5 should result in '2/2'\");\n\n  // Test case 3: Tenth term (N=10)\n  assert(getCantorNumber(10) == \"4/1\", \"Test Case 3 Failed: N=10 should result in '1/4'\");\n\n  print(\"All getCantorNumber test cases passed!\");\n}\n\nvoid main() {\n  testGetCantorNumber();\n}", "entry_point": "getCantorNumber", "signature": "String getCantorNumber(int n)", "docstring": "Finds the N-th term in the Cantor enumeration of the rational numbers.\n\nThe Cantor enumeration is a sequence that lists all positive rational\nnumbers (fractions) uniquely. The enumeration is based on traversing the\ninfinite matrix of numerators/denominators diagonally. This function\ncalculates the numerator and denominator of the N-th term in this sequence.\n\nArgs:\nn (int): The position in the sequence for which to calculate the\nnumerator and denominator.\n\nReturns:\nString: A string representation of the fraction at the N-th position\nin the form \"numerator/denominator\".\n\nExamples:\ngetCantorNumber(1) returns \"1/1\"\nExplanation: The first term in the Cantor enumeration is \"1/1\".\n\ngetCantorNumber(2) returns \"1/2\"\nExplanation: The second term moves to the next diagonal level, resulting\nin \"1/2\".\n\ngetCantorNumber(3) returns \"2/1\"\nExplanation: The third term is the first entry in the second diagonal,\nwhich inverts to \"2/1\".\n\ngetCantorNumber(4) returns \"3/1\"\nExplanation: The fourth term follows the diagonal up, increasing the\nnumerator to \"3/1\".\n\ngetCantorNumber(6) returns \"1/3\"\nExplanation: The sixth term is \"1/3\", which follows the diagonal down\nfrom the previous term \"2/2\".", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds the N-th term in the Cantor enumeration of the rational numbers.\n\nThe Cantor enumeration is a sequence that lists all positive rational\nnumbers (fractions) uniquely. The enumeration is based on traversing the\ninfinite matrix of numerators/denominators diagonally. This function\ncalculates the numerator and denominator of the N-th term in this sequence.\n\nArgs:\nn (int): The position in the sequence for which to calculate the\nnumerator and denominator.\n\nReturns:\nString: A string representation of the fraction at the N-th position\nin the form \"numerator/denominator\".\n\nExamples:\ngetCantorNumber(1) returns \"1/1\"\nExplanation: The first term in the Cantor enumeration is \"1/1\".\n\ngetCantorNumber(2) returns \"1/2\"\nExplanation: The second term moves to the next diagonal level, resulting\nin \"1/2\".\n\ngetCantorNumber(3) returns \"2/1\"\nExplanation: The third term is the first entry in the second diagonal,\nwhich inverts to \"2/1\".\n\ngetCantorNumber(4) returns \"3/1\"\nExplanation: The fourth term follows the diagonal up, increasing the\nnumerator to \"3/1\".\n\ngetCantorNumber(6) returns \"1/3\"\nExplanation: The sixth term is \"1/3\", which follows the diagonal down\nfrom the previous term \"2/2\".\n\n* Incomplete Code:\nString getCantorNumber(int n)\n{\n  // Determine the sum of the numerator and denominator for the N-th position\n[MASK]\n  int count = 0;\n  while (count < n) {\n    sum++;\n    count += sum;\n  }\n\n  // Calculate the difference to backtrack to the start of the diagonal\n[MASK]\n\n  // Determine the numerator and denominator based on the diagonal's direction\n  int numerator, denominator;\n[MASK]\n    // Even sum indicates a diagonal going down (numerator increases)\n    numerator = sum - diff;\n    denominator = 1 + diff;\n  } else {\n    // Odd sum indicates a diagonal going up (denominator increases)\n    numerator = 1 + diff;\n    denominator = sum - diff;\n  }\n  return \"$numerator/$denominator\";\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Determine the sum of the numerator and denominator for the N-th position\n[MASK]\n  int count = 0;\n  while (count < n) {\n    sum++;\n    count += sum;\n  }\n\n  // Calculate the difference to backtrack to the start of the diagonal\n[MASK]\n\n  // Determine the numerator and denominator based on the diagonal's direction\n  int numerator, denominator;\n[MASK]\n    // Even sum indicates a diagonal going down (numerator increases)\n    numerator = sum - diff;\n    denominator = 1 + diff;\n  } else {\n    // Odd sum indicates a diagonal going up (denominator increases)\n    numerator = 1 + diff;\n    denominator = sum - diff;\n  }\n  return \"$numerator/$denominator\";\n}"}
{"task_id": "Dart/8-0-multi", "prompt": "String convertToNegativeBase(int n, int base) \n/// Converts an integer to its representation in a given negative base.\n///\n/// This function takes an integer `n` and a negative integer `base` and\n/// returns a string representing the number `n` in the specified negative\n/// base system. The conversion is done using the standard negative base\n/// conversion algorithm, which handles remainders and the division process\n/// differently than in positive base systems due to the nature of negative\n/// bases.\n///\n/// Args:\n///   n (int): The integer to be converted.\n///   base (int): The negative base to which the integer `n` will be converted.\n///               The base must be a negative integer (e.g., -2, -3, etc.).\n///\n/// Returns:\n///   String: A string representing the integer `n` in the negative base system.\n///\n/// Examples:\n///   convertToNegativeBase(10, -2) returns \"11010\"\n///     Explanation: In base -2, the number 10 is represented as \"11010\".\n///\n///   convertToNegativeBase(-15, -2) returns \"110001\"\n///     Explanation: In base -2, the number -15 is represented as \"110001\".\n///\n///   convertToNegativeBase(4, -3) returns \"102\"\n///     Explanation: In base -3, the number 4 is represented as \"102\".", "canonical_solution": "{\n  if (n == 0) return \"0\";\n\n  String result = \"\";\n  while (n != 0) {\n    int remainder = n % base;\n    n ~/= base;\n    if (remainder < 0) {\n      remainder += (-base);\n      n += 1;\n    }\n    result = _digitToChar(remainder) + result;\n  }\n  return result;\n}\n\nString _digitToChar(int digit) {\n  if (digit < 10) {\n    return digit.toString();\n  }\n  return String.fromCharCode('A'.codeUnitAt(0) + digit - 10);\n}", "test": "void testConvertToNegativeBase() {\n  // Test case 1: Conversion of 10 to base -2\n  assert(convertToNegativeBase(10, -2) == \"1010\", \"Test Case 1 Failed: 10 in base -2 should be '11010'\");\n\n  // Test case 2: Conversion of -15 to base -2\n  assert(convertToNegativeBase(-15, -2) == \"1111\", \"Test Case 2 Failed: -15 in base -2 should be '110001'\");\n\n  // Test case 3: Conversion of 4 to base -3\n  assert(convertToNegativeBase(4, -3) == \"21\", \"Test Case 3 Failed: 4 in base -3 should be '102'\");\n\n  print(\"All convertToNegativeBase test cases passed!\");\n}\n\nvoid main() {\n  testConvertToNegativeBase();\n}", "entry_point": "convertToNegativeBase", "signature": "String convertToNegativeBase(int n, int base)", "docstring": "Converts an integer to its representation in a given negative base.\n\nThis function takes an integer `n` and a negative integer `base` and\nreturns a string representing the number `n` in the specified negative\nbase system. The conversion is done using the standard negative base\nconversion algorithm, which handles remainders and the division process\ndifferently than in positive base systems due to the nature of negative\nbases.\n\nArgs:\nn (int): The integer to be converted.\nbase (int): The negative base to which the integer `n` will be converted.\nThe base must be a negative integer (e.g., -2, -3, etc.).\n\nReturns:\nString: A string representing the integer `n` in the negative base system.\n\nExamples:\nconvertToNegativeBase(10, -2) returns \"11010\"\nExplanation: In base -2, the number 10 is represented as \"11010\".\n\nconvertToNegativeBase(-15, -2) returns \"110001\"\nExplanation: In base -2, the number -15 is represented as \"110001\".\n\nconvertToNegativeBase(4, -3) returns \"102\"\nExplanation: In base -3, the number 4 is represented as \"102\".", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nConverts an integer to its representation in a given negative base.\n\nThis function takes an integer `n` and a negative integer `base` and\nreturns a string representing the number `n` in the specified negative\nbase system. The conversion is done using the standard negative base\nconversion algorithm, which handles remainders and the division process\ndifferently than in positive base systems due to the nature of negative\nbases.\n\nArgs:\nn (int): The integer to be converted.\nbase (int): The negative base to which the integer `n` will be converted.\nThe base must be a negative integer (e.g., -2, -3, etc.).\n\nReturns:\nString: A string representing the integer `n` in the negative base system.\n\nExamples:\nconvertToNegativeBase(10, -2) returns \"11010\"\nExplanation: In base -2, the number 10 is represented as \"11010\".\n\nconvertToNegativeBase(-15, -2) returns \"110001\"\nExplanation: In base -2, the number -15 is represented as \"110001\".\n\nconvertToNegativeBase(4, -3) returns \"102\"\nExplanation: In base -3, the number 4 is represented as \"102\".\n\n* Incomplete Code:\nString convertToNegativeBase(int n, int base)\n{\n  if (n == 0) return \"0\";\n\n[MASK]\n  while (n != 0) {\n    int remainder = n % base;\n[MASK]\n    if (remainder < 0) {\n      remainder += (-base);\n[MASK]\n    }\n    result = _digitToChar(remainder) + result;\n  }\n  return result;\n}\n\nString _digitToChar(int digit) {\n[MASK]\n    return digit.toString();\n  }\n  return String.fromCharCode('A'.codeUnitAt(0) + digit - 10);\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  if (n == 0) return \"0\";\n\n[MASK]\n  while (n != 0) {\n    int remainder = n % base;\n[MASK]\n    if (remainder < 0) {\n      remainder += (-base);\n[MASK]\n    }\n    result = _digitToChar(remainder) + result;\n  }\n  return result;\n}\n\nString _digitToChar(int digit) {\n[MASK]\n    return digit.toString();\n  }\n  return String.fromCharCode('A'.codeUnitAt(0) + digit - 10);\n}"}
{"task_id": "Dart/8-1-multi", "prompt": "String convertToNegativeBase(int n, int base) \n/// Converts an integer to its representation in a given negative base.\n///\n/// This function takes an integer `n` and a negative integer `base` and\n/// returns a string representing the number `n` in the specified negative\n/// base system. The conversion is done using the standard negative base\n/// conversion algorithm, which handles remainders and the division process\n/// differently than in positive base systems due to the nature of negative\n/// bases.\n///\n/// Args:\n///   n (int): The integer to be converted.\n///   base (int): The negative base to which the integer `n` will be converted.\n///               The base must be a negative integer (e.g., -2, -3, etc.).\n///\n/// Returns:\n///   String: A string representing the integer `n` in the negative base system.\n///\n/// Examples:\n///   convertToNegativeBase(10, -2) returns \"11010\"\n///     Explanation: In base -2, the number 10 is represented as \"11010\".\n///\n///   convertToNegativeBase(-15, -2) returns \"110001\"\n///     Explanation: In base -2, the number -15 is represented as \"110001\".\n///\n///   convertToNegativeBase(4, -3) returns \"102\"\n///     Explanation: In base -3, the number 4 is represented as \"102\".", "canonical_solution": "{\n  if (n == 0) return \"0\";\n\n  String result = \"\";\n  while (n != 0) {\n    int remainder = n % base;\n    n ~/= base;\n    if (remainder < 0) {\n      remainder += (-base);\n      n += 1;\n    }\n    result = _digitToChar(remainder) + result;\n  }\n  return result;\n}\n\nString _digitToChar(int digit) {\n  if (digit < 10) {\n    return digit.toString();\n  }\n  return String.fromCharCode('A'.codeUnitAt(0) + digit - 10);\n}", "test": "void testConvertToNegativeBase() {\n  // Test case 1: Conversion of 10 to base -2\n  assert(convertToNegativeBase(10, -2) == \"1010\", \"Test Case 1 Failed: 10 in base -2 should be '11010'\");\n\n  // Test case 2: Conversion of -15 to base -2\n  assert(convertToNegativeBase(-15, -2) == \"1111\", \"Test Case 2 Failed: -15 in base -2 should be '110001'\");\n\n  // Test case 3: Conversion of 4 to base -3\n  assert(convertToNegativeBase(4, -3) == \"21\", \"Test Case 3 Failed: 4 in base -3 should be '102'\");\n\n  print(\"All convertToNegativeBase test cases passed!\");\n}\n\nvoid main() {\n  testConvertToNegativeBase();\n}", "entry_point": "convertToNegativeBase", "signature": "String convertToNegativeBase(int n, int base)", "docstring": "Converts an integer to its representation in a given negative base.\n\nThis function takes an integer `n` and a negative integer `base` and\nreturns a string representing the number `n` in the specified negative\nbase system. The conversion is done using the standard negative base\nconversion algorithm, which handles remainders and the division process\ndifferently than in positive base systems due to the nature of negative\nbases.\n\nArgs:\nn (int): The integer to be converted.\nbase (int): The negative base to which the integer `n` will be converted.\nThe base must be a negative integer (e.g., -2, -3, etc.).\n\nReturns:\nString: A string representing the integer `n` in the negative base system.\n\nExamples:\nconvertToNegativeBase(10, -2) returns \"11010\"\nExplanation: In base -2, the number 10 is represented as \"11010\".\n\nconvertToNegativeBase(-15, -2) returns \"110001\"\nExplanation: In base -2, the number -15 is represented as \"110001\".\n\nconvertToNegativeBase(4, -3) returns \"102\"\nExplanation: In base -3, the number 4 is represented as \"102\".", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nConverts an integer to its representation in a given negative base.\n\nThis function takes an integer `n` and a negative integer `base` and\nreturns a string representing the number `n` in the specified negative\nbase system. The conversion is done using the standard negative base\nconversion algorithm, which handles remainders and the division process\ndifferently than in positive base systems due to the nature of negative\nbases.\n\nArgs:\nn (int): The integer to be converted.\nbase (int): The negative base to which the integer `n` will be converted.\nThe base must be a negative integer (e.g., -2, -3, etc.).\n\nReturns:\nString: A string representing the integer `n` in the negative base system.\n\nExamples:\nconvertToNegativeBase(10, -2) returns \"11010\"\nExplanation: In base -2, the number 10 is represented as \"11010\".\n\nconvertToNegativeBase(-15, -2) returns \"110001\"\nExplanation: In base -2, the number -15 is represented as \"110001\".\n\nconvertToNegativeBase(4, -3) returns \"102\"\nExplanation: In base -3, the number 4 is represented as \"102\".\n\n* Incomplete Code:\nString convertToNegativeBase(int n, int base)\n{\n[MASK]\n\n  String result = \"\";\n  while (n != 0) {\n    int remainder = n % base;\n[MASK]\n    if (remainder < 0) {\n[MASK]\n      n += 1;\n    }\n    result = _digitToChar(remainder) + result;\n  }\n  return result;\n}\n\nString _digitToChar(int digit) {\n  if (digit < 10) {\n[MASK]\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n\n  String result = \"\";\n  while (n != 0) {\n    int remainder = n % base;\n[MASK]\n    if (remainder < 0) {\n[MASK]\n      n += 1;\n    }\n    result = _digitToChar(remainder) + result;\n  }\n  return result;\n}\n\nString _digitToChar(int digit) {\n  if (digit < 10) {\n[MASK]\n  }\n[MASK]\n}"}
{"task_id": "Dart/9-0-multi", "prompt": "int maxProduct(String numbers, int n, int k)\n/// Calculates the maximum product by inserting `k` multiplication signs into\n/// the given string of digits `numbers`.\n///\n/// This function utilizes dynamic programming to find the maximum product that\n/// can be obtained by inserting `k` multiplication signs (`*`) into the string\n/// `numbers`, which is composed of `n` digits. The algorithm computes this by\n/// breaking down the problem into subproblems and storing intermediate results\n/// in a two-dimensional list `dp`, where dp[i][j] represents the maximum\n/// product obtainable from the first `i` digits with `j` multiplication signs.\n///\n/// Args:\n///   numbers (String): The string of digits to insert multiplication signs into.\n///   n (int): The number of digits in the `numbers` string.\n///   k (int): The number of multiplication signs to insert.\n///\n/// Returns:\n///   int: The maximum product that can be achieved by inserting `k`\n///        multiplication signs into the string `numbers`.\n///\n/// Examples:\n///   maxProduct(\"123\", 3, 1) returns 46\n///     Explanation: The maximum product is obtained by inserting one\n///                  multiplication sign between the first and second digits\n///                  (1 * 23 = 46).\n///\n///   maxProduct(\"1234\", 4, 1) returns 164\n///     Explanation: The maximum product is obtained by inserting one\n///                  multiplication sign between the second and third digits\n///                  (12 * 34 = 408).\n///\n///   maxProduct(\"1234\", 4, 2) returns 120\n///     Explanation: The maximum product is obtained by inserting multiplication\n///                  signs to get (1 * 2 * 34 = 68).", "canonical_solution": "{\n  List<List<int>> dp = List.generate(n + 1, (i) => List.generate(k + 1, (j) => 0));\n\n  // Convert the number string into an array of digits for easy access\n  List<int> digits = numbers.split('').map((c) => int.parse(c)).toList();\n\n  // Initialize the DP table for the case when we have 0 multiplication signs\n  for (int i = 1; i <= n; i++) {\n    dp[i][0] = dp[i - 1][0] * 10 + digits[i - 1];\n  }\n\n  // Fill the DP table\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= k && j < i; j++) {\n      for (int m = j; m < i; m++) {\n        int currentProduct = dp[m][j - 1] * (dp[i][0] ~/ dp[m][0]);\n        dp[i][j] = max(dp[i][j], currentProduct);\n      }\n    }\n  }\n  // The answer will be the maximum product when using k multiplication signs\n  return dp[n][k];\n}\n\nint max(int a, int b) => a > b ? a : b;", "test": "void testMaxProduct() {\n  // Test case 1\n  assert(maxProduct(\"123\", 3, 1) == 123, \"Test Case 1 Failed: The maximum product from '123' with 1 multiplication sign should be 23 (1 * 23).\");\n\n  // Test case 2\n  assert(maxProduct(\"1234\", 4, 1) == 1234, \"Test Case 2 Failed: The maximum product from '1234' with 1 multiplication sign should be 234 (1 * 234).\");\n\n  // Test case 3\n  assert(maxProduct(\"1234\", 4, 2) == 1230, \"Test Case 3 Failed: The maximum product from '1234' with 2 multiplication signs should be 48 (1 * 2 * 34).\");\n\n  print(\"All maxProduct test cases passed!\");\n}\n\nvoid main() {\n  testMaxProduct();\n}", "entry_point": "maxProduct", "signature": "int maxProduct(String numbers, int n, int k)", "docstring": "Calculates the maximum product by inserting `k` multiplication signs into\nthe given string of digits `numbers`.\n\nThis function utilizes dynamic programming to find the maximum product that\ncan be obtained by inserting `k` multiplication signs (`*`) into the string\n`numbers`, which is composed of `n` digits. The algorithm computes this by\nbreaking down the problem into subproblems and storing intermediate results\nin a two-dimensional list `dp`, where dp[i][j] represents the maximum\nproduct obtainable from the first `i` digits with `j` multiplication signs.\n\nArgs:\nnumbers (String): The string of digits to insert multiplication signs into.\nn (int): The number of digits in the `numbers` string.\nk (int): The number of multiplication signs to insert.\n\nReturns:\nint: The maximum product that can be achieved by inserting `k`\nmultiplication signs into the string `numbers`.\n\nExamples:\nmaxProduct(\"123\", 3, 1) returns 46\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the first and second digits\n(1 * 23 = 46).\n\nmaxProduct(\"1234\", 4, 1) returns 164\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the second and third digits\n(12 * 34 = 408).\n\nmaxProduct(\"1234\", 4, 2) returns 120\nExplanation: The maximum product is obtained by inserting multiplication\nsigns to get (1 * 2 * 34 = 68).", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum product by inserting `k` multiplication signs into\nthe given string of digits `numbers`.\n\nThis function utilizes dynamic programming to find the maximum product that\ncan be obtained by inserting `k` multiplication signs (`*`) into the string\n`numbers`, which is composed of `n` digits. The algorithm computes this by\nbreaking down the problem into subproblems and storing intermediate results\nin a two-dimensional list `dp`, where dp[i][j] represents the maximum\nproduct obtainable from the first `i` digits with `j` multiplication signs.\n\nArgs:\nnumbers (String): The string of digits to insert multiplication signs into.\nn (int): The number of digits in the `numbers` string.\nk (int): The number of multiplication signs to insert.\n\nReturns:\nint: The maximum product that can be achieved by inserting `k`\nmultiplication signs into the string `numbers`.\n\nExamples:\nmaxProduct(\"123\", 3, 1) returns 46\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the first and second digits\n(1 * 23 = 46).\n\nmaxProduct(\"1234\", 4, 1) returns 164\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the second and third digits\n(12 * 34 = 408).\n\nmaxProduct(\"1234\", 4, 2) returns 120\nExplanation: The maximum product is obtained by inserting multiplication\nsigns to get (1 * 2 * 34 = 68).\n\n* Incomplete Code:\nint maxProduct(String numbers, int n, int k)\n{\n  List<List<int>> dp = List.generate(n + 1, (i) => List.generate(k + 1, (j) => 0));\n\n  // Convert the number string into an array of digits for easy access\n[MASK]\n\n  // Initialize the DP table for the case when we have 0 multiplication signs\n[MASK]\n[MASK]\n  }\n\n  // Fill the DP table\n[MASK]\n    for (int j = 1; j <= k && j < i; j++) {\n      for (int m = j; m < i; m++) {\n[MASK]\n        dp[i][j] = max(dp[i][j], currentProduct);\n      }\n    }\n  }\n  // The answer will be the maximum product when using k multiplication signs\n  return dp[n][k];\n}\n\nint max(int a, int b) => a > b ? a : b;\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<List<int>> dp = List.generate(n + 1, (i) => List.generate(k + 1, (j) => 0));\n\n  // Convert the number string into an array of digits for easy access\n[MASK]\n\n  // Initialize the DP table for the case when we have 0 multiplication signs\n[MASK]\n[MASK]\n  }\n\n  // Fill the DP table\n[MASK]\n    for (int j = 1; j <= k && j < i; j++) {\n      for (int m = j; m < i; m++) {\n[MASK]\n        dp[i][j] = max(dp[i][j], currentProduct);\n      }\n    }\n  }\n  // The answer will be the maximum product when using k multiplication signs\n  return dp[n][k];\n}\n\nint max(int a, int b) => a > b ? a : b;"}
{"task_id": "Dart/9-1-multi", "prompt": "int maxProduct(String numbers, int n, int k)\n/// Calculates the maximum product by inserting `k` multiplication signs into\n/// the given string of digits `numbers`.\n///\n/// This function utilizes dynamic programming to find the maximum product that\n/// can be obtained by inserting `k` multiplication signs (`*`) into the string\n/// `numbers`, which is composed of `n` digits. The algorithm computes this by\n/// breaking down the problem into subproblems and storing intermediate results\n/// in a two-dimensional list `dp`, where dp[i][j] represents the maximum\n/// product obtainable from the first `i` digits with `j` multiplication signs.\n///\n/// Args:\n///   numbers (String): The string of digits to insert multiplication signs into.\n///   n (int): The number of digits in the `numbers` string.\n///   k (int): The number of multiplication signs to insert.\n///\n/// Returns:\n///   int: The maximum product that can be achieved by inserting `k`\n///        multiplication signs into the string `numbers`.\n///\n/// Examples:\n///   maxProduct(\"123\", 3, 1) returns 46\n///     Explanation: The maximum product is obtained by inserting one\n///                  multiplication sign between the first and second digits\n///                  (1 * 23 = 46).\n///\n///   maxProduct(\"1234\", 4, 1) returns 164\n///     Explanation: The maximum product is obtained by inserting one\n///                  multiplication sign between the second and third digits\n///                  (12 * 34 = 408).\n///\n///   maxProduct(\"1234\", 4, 2) returns 120\n///     Explanation: The maximum product is obtained by inserting multiplication\n///                  signs to get (1 * 2 * 34 = 68).", "canonical_solution": "{\n  List<List<int>> dp = List.generate(n + 1, (i) => List.generate(k + 1, (j) => 0));\n\n  // Convert the number string into an array of digits for easy access\n  List<int> digits = numbers.split('').map((c) => int.parse(c)).toList();\n\n  // Initialize the DP table for the case when we have 0 multiplication signs\n  for (int i = 1; i <= n; i++) {\n    dp[i][0] = dp[i - 1][0] * 10 + digits[i - 1];\n  }\n\n  // Fill the DP table\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= k && j < i; j++) {\n      for (int m = j; m < i; m++) {\n        int currentProduct = dp[m][j - 1] * (dp[i][0] ~/ dp[m][0]);\n        dp[i][j] = max(dp[i][j], currentProduct);\n      }\n    }\n  }\n  // The answer will be the maximum product when using k multiplication signs\n  return dp[n][k];\n}\n\nint max(int a, int b) => a > b ? a : b;", "test": "void testMaxProduct() {\n  // Test case 1\n  assert(maxProduct(\"123\", 3, 1) == 123, \"Test Case 1 Failed: The maximum product from '123' with 1 multiplication sign should be 23 (1 * 23).\");\n\n  // Test case 2\n  assert(maxProduct(\"1234\", 4, 1) == 1234, \"Test Case 2 Failed: The maximum product from '1234' with 1 multiplication sign should be 234 (1 * 234).\");\n\n  // Test case 3\n  assert(maxProduct(\"1234\", 4, 2) == 1230, \"Test Case 3 Failed: The maximum product from '1234' with 2 multiplication signs should be 48 (1 * 2 * 34).\");\n\n  print(\"All maxProduct test cases passed!\");\n}\n\nvoid main() {\n  testMaxProduct();\n}", "entry_point": "maxProduct", "signature": "int maxProduct(String numbers, int n, int k)", "docstring": "Calculates the maximum product by inserting `k` multiplication signs into\nthe given string of digits `numbers`.\n\nThis function utilizes dynamic programming to find the maximum product that\ncan be obtained by inserting `k` multiplication signs (`*`) into the string\n`numbers`, which is composed of `n` digits. The algorithm computes this by\nbreaking down the problem into subproblems and storing intermediate results\nin a two-dimensional list `dp`, where dp[i][j] represents the maximum\nproduct obtainable from the first `i` digits with `j` multiplication signs.\n\nArgs:\nnumbers (String): The string of digits to insert multiplication signs into.\nn (int): The number of digits in the `numbers` string.\nk (int): The number of multiplication signs to insert.\n\nReturns:\nint: The maximum product that can be achieved by inserting `k`\nmultiplication signs into the string `numbers`.\n\nExamples:\nmaxProduct(\"123\", 3, 1) returns 46\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the first and second digits\n(1 * 23 = 46).\n\nmaxProduct(\"1234\", 4, 1) returns 164\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the second and third digits\n(12 * 34 = 408).\n\nmaxProduct(\"1234\", 4, 2) returns 120\nExplanation: The maximum product is obtained by inserting multiplication\nsigns to get (1 * 2 * 34 = 68).", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum product by inserting `k` multiplication signs into\nthe given string of digits `numbers`.\n\nThis function utilizes dynamic programming to find the maximum product that\ncan be obtained by inserting `k` multiplication signs (`*`) into the string\n`numbers`, which is composed of `n` digits. The algorithm computes this by\nbreaking down the problem into subproblems and storing intermediate results\nin a two-dimensional list `dp`, where dp[i][j] represents the maximum\nproduct obtainable from the first `i` digits with `j` multiplication signs.\n\nArgs:\nnumbers (String): The string of digits to insert multiplication signs into.\nn (int): The number of digits in the `numbers` string.\nk (int): The number of multiplication signs to insert.\n\nReturns:\nint: The maximum product that can be achieved by inserting `k`\nmultiplication signs into the string `numbers`.\n\nExamples:\nmaxProduct(\"123\", 3, 1) returns 46\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the first and second digits\n(1 * 23 = 46).\n\nmaxProduct(\"1234\", 4, 1) returns 164\nExplanation: The maximum product is obtained by inserting one\nmultiplication sign between the second and third digits\n(12 * 34 = 408).\n\nmaxProduct(\"1234\", 4, 2) returns 120\nExplanation: The maximum product is obtained by inserting multiplication\nsigns to get (1 * 2 * 34 = 68).\n\n* Incomplete Code:\nint maxProduct(String numbers, int n, int k)\n{\n  List<List<int>> dp = List.generate(n + 1, (i) => List.generate(k + 1, (j) => 0));\n\n  // Convert the number string into an array of digits for easy access\n  List<int> digits = numbers.split('').map((c) => int.parse(c)).toList();\n\n  // Initialize the DP table for the case when we have 0 multiplication signs\n  for (int i = 1; i <= n; i++) {\n    dp[i][0] = dp[i - 1][0] * 10 + digits[i - 1];\n  }\n\n  // Fill the DP table\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= k && j < i; j++) {\n      for (int m = j; m < i; m++) {\n        int currentProduct = dp[m][j - 1] * (dp[i][0] ~/ dp[m][0]);\n[MASK]\n      }\n    }\n  }\n  // The answer will be the maximum product when using k multiplication signs\n  return dp[n][k];\n}\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<List<int>> dp = List.generate(n + 1, (i) => List.generate(k + 1, (j) => 0));\n\n  // Convert the number string into an array of digits for easy access\n  List<int> digits = numbers.split('').map((c) => int.parse(c)).toList();\n\n  // Initialize the DP table for the case when we have 0 multiplication signs\n  for (int i = 1; i <= n; i++) {\n    dp[i][0] = dp[i - 1][0] * 10 + digits[i - 1];\n  }\n\n  // Fill the DP table\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= k && j < i; j++) {\n      for (int m = j; m < i; m++) {\n        int currentProduct = dp[m][j - 1] * (dp[i][0] ~/ dp[m][0]);\n[MASK]\n      }\n    }\n  }\n  // The answer will be the maximum product when using k multiplication signs\n  return dp[n][k];\n}\n\n[MASK]"}
{"task_id": "Dart/10-0-multi", "prompt": "int calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)\n/// Calculates the scholarship amount a student is eligible to receive based on\n/// academic performance, leadership, geographic background, and research contributions.\n///\n/// The scholarship is calculated by considering the student's final exam score,\n/// class score, whether they are a student cadre (a leadership position),\n/// whether they come from a western region, and the number of papers they have\n/// published. Different conditions contribute varying amounts to the total scholarship.\n///\n/// Args:\n///   name (String): The name of the student (not used in the calculation).\n///   finalScore (int): The student's final exam score.\n///   classScore (int): The student's class score.\n///   isCadre (bool): Indicates if the student is a student cadre (true/false).\n///   isWestern (bool): Indicates if the student is from a western region (true/false).\n///   papers (int): The number of papers the student has published.\n///\n/// Returns:\n///   int: The total amount of scholarship money the student is eligible to receive.\n///\n/// Examples:\n///   calculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\n///     Explanation: Alice has a high final score and class score, plus has published papers,\n///                  so she receives 8000 + 4000 + 2000 = 14000 in total.\n///\n///   calculateScholarship(\"Bob\", 86, 82, true, true, 0) returns 5850\n///     Explanation: Bob is a student cadre with good scores and is from a western region,\n///                  so he receives 4000 + 1000 + 850 = 5850 in total.\n///\n///   calculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\n///     Explanation: Charlie does not meet any of the criteria for a scholarship,\n///                  so he receives 0 in total.", "canonical_solution": "{\n\n    int scholarship = 0;\n    if (finalScore > 80 && papers >= 1) scholarship += 8000;\n    if (finalScore > 85 && classScore > 80) scholarship += 4000;\n    if (finalScore > 90) scholarship += 2000;\n    if (isWestern && finalScore > 85) scholarship += 1000;\n    if (isCadre && classScore > 80) scholarship += 850;\n    return scholarship;\n}", "test": "void testCalculateScholarship() {\n  // Test case 1: Student with high final score, class score, and has papers, but is not a cadre or from the western region\n  assert(calculateScholarship(\"Alice\", 90, 85, false, false, 2) == 12000,\n    \"Test Case 1 Failed: Alice should receive a scholarship of 14000.\");\n\n  // Test case 2: Student with high final score, class score, is a cadre, and from the western region, but does not have papers\n  assert(calculateScholarship(\"Bob\", 86, 82, true, true, 0) == 5850,\n    \"Test Case 2 Failed: Bob should receive a scholarship of 5850.\");\n\n  // Test case 3: Student with average scores, not a cadre, not from the western region, and no papers\n  assert(calculateScholarship(\"Charlie\", 75, 75, false, false, 0) == 0,\n    \"Test Case 3 Failed: Charlie should not receive any scholarship.\");\n\n  print(\"All calculateScholarship test cases passed!\");\n}\n\nvoid main() {\n  testCalculateScholarship();\n}", "entry_point": "calculateScholarship", "signature": "int calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)", "docstring": "Calculates the scholarship amount a student is eligible to receive based on\nacademic performance, leadership, geographic background, and research contributions.\n\nThe scholarship is calculated by considering the student's final exam score,\nclass score, whether they are a student cadre (a leadership position),\nwhether they come from a western region, and the number of papers they have\npublished. Different conditions contribute varying amounts to the total scholarship.\n\nArgs:\nname (String): The name of the student (not used in the calculation).\nfinalScore (int): The student's final exam score.\nclassScore (int): The student's class score.\nisCadre (bool): Indicates if the student is a student cadre (true/false).\nisWestern (bool): Indicates if the student is from a western region (true/false).\npapers (int): The number of papers the student has published.\n\nReturns:\nint: The total amount of scholarship money the student is eligible to receive.\n\nExamples:\ncalculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\nExplanation: Alice has a high final score and class score, plus has published papers,\nso she receives 8000 + 4000 + 2000 = 14000 in total.\n\ncalculateScholarship(\"Bob\", 86, 82, true, true, 0) returns 5850\nExplanation: Bob is a student cadre with good scores and is from a western region,\nso he receives 4000 + 1000 + 850 = 5850 in total.\n\ncalculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\nExplanation: Charlie does not meet any of the criteria for a scholarship,\nso he receives 0 in total.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the scholarship amount a student is eligible to receive based on\nacademic performance, leadership, geographic background, and research contributions.\n\nThe scholarship is calculated by considering the student's final exam score,\nclass score, whether they are a student cadre (a leadership position),\nwhether they come from a western region, and the number of papers they have\npublished. Different conditions contribute varying amounts to the total scholarship.\n\nArgs:\nname (String): The name of the student (not used in the calculation).\nfinalScore (int): The student's final exam score.\nclassScore (int): The student's class score.\nisCadre (bool): Indicates if the student is a student cadre (true/false).\nisWestern (bool): Indicates if the student is from a western region (true/false).\npapers (int): The number of papers the student has published.\n\nReturns:\nint: The total amount of scholarship money the student is eligible to receive.\n\nExamples:\ncalculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\nExplanation: Alice has a high final score and class score, plus has published papers,\nso she receives 8000 + 4000 + 2000 = 14000 in total.\n\ncalculateScholarship(\"Bob\", 86, 82, true, true, 0) returns 5850\nExplanation: Bob is a student cadre with good scores and is from a western region,\nso he receives 4000 + 1000 + 850 = 5850 in total.\n\ncalculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\nExplanation: Charlie does not meet any of the criteria for a scholarship,\nso he receives 0 in total.\n\n* Incomplete Code:\nint calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)\n{\n\n    int scholarship = 0;\n    if (finalScore > 80 && papers >= 1) scholarship += 8000;\n    if (finalScore > 85 && classScore > 80) scholarship += 4000;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n\n    int scholarship = 0;\n    if (finalScore > 80 && papers >= 1) scholarship += 8000;\n    if (finalScore > 85 && classScore > 80) scholarship += 4000;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n}"}
{"task_id": "Dart/10-1-multi", "prompt": "int calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)\n/// Calculates the scholarship amount a student is eligible to receive based on\n/// academic performance, leadership, geographic background, and research contributions.\n///\n/// The scholarship is calculated by considering the student's final exam score,\n/// class score, whether they are a student cadre (a leadership position),\n/// whether they come from a western region, and the number of papers they have\n/// published. Different conditions contribute varying amounts to the total scholarship.\n///\n/// Args:\n///   name (String): The name of the student (not used in the calculation).\n///   finalScore (int): The student's final exam score.\n///   classScore (int): The student's class score.\n///   isCadre (bool): Indicates if the student is a student cadre (true/false).\n///   isWestern (bool): Indicates if the student is from a western region (true/false).\n///   papers (int): The number of papers the student has published.\n///\n/// Returns:\n///   int: The total amount of scholarship money the student is eligible to receive.\n///\n/// Examples:\n///   calculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\n///     Explanation: Alice has a high final score and class score, plus has published papers,\n///                  so she receives 8000 + 4000 + 2000 = 14000 in total.\n///\n///   calculateScholarship(\"Bob\", 86, 82, true, true, 0) returns 5850\n///     Explanation: Bob is a student cadre with good scores and is from a western region,\n///                  so he receives 4000 + 1000 + 850 = 5850 in total.\n///\n///   calculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\n///     Explanation: Charlie does not meet any of the criteria for a scholarship,\n///                  so he receives 0 in total.", "canonical_solution": "{\n\n    int scholarship = 0;\n    if (finalScore > 80 && papers >= 1) scholarship += 8000;\n    if (finalScore > 85 && classScore > 80) scholarship += 4000;\n    if (finalScore > 90) scholarship += 2000;\n    if (isWestern && finalScore > 85) scholarship += 1000;\n    if (isCadre && classScore > 80) scholarship += 850;\n    return scholarship;\n}", "test": "void testCalculateScholarship() {\n  // Test case 1: Student with high final score, class score, and has papers, but is not a cadre or from the western region\n  assert(calculateScholarship(\"Alice\", 90, 85, false, false, 2) == 12000,\n    \"Test Case 1 Failed: Alice should receive a scholarship of 14000.\");\n\n  // Test case 2: Student with high final score, class score, is a cadre, and from the western region, but does not have papers\n  assert(calculateScholarship(\"Bob\", 86, 82, true, true, 0) == 5850,\n    \"Test Case 2 Failed: Bob should receive a scholarship of 5850.\");\n\n  // Test case 3: Student with average scores, not a cadre, not from the western region, and no papers\n  assert(calculateScholarship(\"Charlie\", 75, 75, false, false, 0) == 0,\n    \"Test Case 3 Failed: Charlie should not receive any scholarship.\");\n\n  print(\"All calculateScholarship test cases passed!\");\n}\n\nvoid main() {\n  testCalculateScholarship();\n}", "entry_point": "calculateScholarship", "signature": "int calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)", "docstring": "Calculates the scholarship amount a student is eligible to receive based on\nacademic performance, leadership, geographic background, and research contributions.\n\nThe scholarship is calculated by considering the student's final exam score,\nclass score, whether they are a student cadre (a leadership position),\nwhether they come from a western region, and the number of papers they have\npublished. Different conditions contribute varying amounts to the total scholarship.\n\nArgs:\nname (String): The name of the student (not used in the calculation).\nfinalScore (int): The student's final exam score.\nclassScore (int): The student's class score.\nisCadre (bool): Indicates if the student is a student cadre (true/false).\nisWestern (bool): Indicates if the student is from a western region (true/false).\npapers (int): The number of papers the student has published.\n\nReturns:\nint: The total amount of scholarship money the student is eligible to receive.\n\nExamples:\ncalculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\nExplanation: Alice has a high final score and class score, plus has published papers,\nso she receives 8000 + 4000 + 2000 = 14000 in total.\n\ncalculateScholarship(\"Bob\", 86, 82, true, true, 0) returns 5850\nExplanation: Bob is a student cadre with good scores and is from a western region,\nso he receives 4000 + 1000 + 850 = 5850 in total.\n\ncalculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\nExplanation: Charlie does not meet any of the criteria for a scholarship,\nso he receives 0 in total.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the scholarship amount a student is eligible to receive based on\nacademic performance, leadership, geographic background, and research contributions.\n\nThe scholarship is calculated by considering the student's final exam score,\nclass score, whether they are a student cadre (a leadership position),\nwhether they come from a western region, and the number of papers they have\npublished. Different conditions contribute varying amounts to the total scholarship.\n\nArgs:\nname (String): The name of the student (not used in the calculation).\nfinalScore (int): The student's final exam score.\nclassScore (int): The student's class score.\nisCadre (bool): Indicates if the student is a student cadre (true/false).\nisWestern (bool): Indicates if the student is from a western region (true/false).\npapers (int): The number of papers the student has published.\n\nReturns:\nint: The total amount of scholarship money the student is eligible to receive.\n\nExamples:\ncalculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\nExplanation: Alice has a high final score and class score, plus has published papers,\nso she receives 8000 + 4000 + 2000 = 14000 in total.\n\ncalculateScholarship(\"Bob\", 86, 82, true, true, 0) returns 5850\nExplanation: Bob is a student cadre with good scores and is from a western region,\nso he receives 4000 + 1000 + 850 = 5850 in total.\n\ncalculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\nExplanation: Charlie does not meet any of the criteria for a scholarship,\nso he receives 0 in total.\n\n* Incomplete Code:\nint calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)\n{\n\n    int scholarship = 0;\n    if (finalScore > 80 && papers >= 1) scholarship += 8000;\n[MASK]\n    if (finalScore > 90) scholarship += 2000;\n    if (isWestern && finalScore > 85) scholarship += 1000;\n    if (isCadre && classScore > 80) scholarship += 850;\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n\n    int scholarship = 0;\n    if (finalScore > 80 && papers >= 1) scholarship += 8000;\n[MASK]\n    if (finalScore > 90) scholarship += 2000;\n    if (isWestern && finalScore > 85) scholarship += 1000;\n    if (isCadre && classScore > 80) scholarship += 850;\n[MASK]\n}"}
{"task_id": "Dart/11-0-multi", "prompt": "String validateISBN(String isbn)\n/// Validates an ISBN-10 number and returns either 'Right' if the ISBN is valid\n/// or the corrected ISBN with the proper check digit if it is not.\n///\n/// The function takes a String [isbn] which is an ISBN-10 number that may\n/// include hyphens. It removes any hyphens and then calculates the checksum \n/// based on the first 9 digits. The checksum is used to determine the correct\n/// check digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n///\n/// Arguments:\n///   isbn - A String containing the ISBN-10 number to be validated.\n///\n/// Returns:\n///   A String 'Right' if the ISBN is valid, or a String containing the\n///   corrected ISBN if the original ISBN has an incorrect check digit.\n///\n/// Examples:\n///   validateISBN(\"0-306-40615-2\") returns 'Right' because it is a valid ISBN.\n///   validateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\" because the last digit\n///   should be 2 instead of 0 to make the ISBN valid.\n///   validateISBN(\"1-85326-158-0\") returns 'Right' because it is already valid.", "canonical_solution": "{\n  // Remove the hyphens and keep only the digits and 'X' if present\n  String cleanISBN = isbn.replaceAll('-', '');\n\n  // Calculate the check sum\n  int checkSum = 0;\n  for (int i = 0; i < 9; i++) {\n    checkSum += int.parse(cleanISBN[i]) * (i + 1);\n  }\n\n  // Compute the check digit\n  String checkDigit = (checkSum % 11).toString();\n  checkDigit = checkDigit == '10' ? 'X' : checkDigit;\n\n  // Check if the last digit of the ISBN is equal to the calculated check digit\n  if (cleanISBN[9] == checkDigit) {\n    return 'Right';\n  } else {\n    // If the check digit is incorrect, replace it with the correct one and return the full ISBN\n    return isbn.substring(0, 12) + checkDigit;\n  }\n}", "test": "void testValidateISBN() {\n  // Test case 1: A valid ISBN-10\n  assert(validateISBN(\"0-306-40615-2\") == 'Right');\n\n  // Test case 2: An invalid ISBN-10 with an incorrect check digit\n  assert(validateISBN(\"0-306-40615-0\") == \"0-306-40615-2\");\n\n  // Test case 3: A valid ISBN-10 with 'X' as the check digit\n  assert(validateISBN(\"0-19-852663-6\") == 'Right');\n\n  // All tests passed if no assertion error is thrown\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testValidateISBN();\n}", "entry_point": "validateISBN", "signature": "String validateISBN(String isbn)", "docstring": "Validates an ISBN-10 number and returns either 'Right' if the ISBN is valid\nor the corrected ISBN with the proper check digit if it is not.\n\nThe function takes a String [isbn] which is an ISBN-10 number that may\ninclude hyphens. It removes any hyphens and then calculates the checksum\nbased on the first 9 digits. The checksum is used to determine the correct\ncheck digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n\nArguments:\nisbn - A String containing the ISBN-10 number to be validated.\n\nReturns:\nA String 'Right' if the ISBN is valid, or a String containing the\ncorrected ISBN if the original ISBN has an incorrect check digit.\n\nExamples:\nvalidateISBN(\"0-306-40615-2\") returns 'Right' because it is a valid ISBN.\nvalidateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\" because the last digit\nshould be 2 instead of 0 to make the ISBN valid.\nvalidateISBN(\"1-85326-158-0\") returns 'Right' because it is already valid.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nValidates an ISBN-10 number and returns either 'Right' if the ISBN is valid\nor the corrected ISBN with the proper check digit if it is not.\n\nThe function takes a String [isbn] which is an ISBN-10 number that may\ninclude hyphens. It removes any hyphens and then calculates the checksum\nbased on the first 9 digits. The checksum is used to determine the correct\ncheck digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n\nArguments:\nisbn - A String containing the ISBN-10 number to be validated.\n\nReturns:\nA String 'Right' if the ISBN is valid, or a String containing the\ncorrected ISBN if the original ISBN has an incorrect check digit.\n\nExamples:\nvalidateISBN(\"0-306-40615-2\") returns 'Right' because it is a valid ISBN.\nvalidateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\" because the last digit\nshould be 2 instead of 0 to make the ISBN valid.\nvalidateISBN(\"1-85326-158-0\") returns 'Right' because it is already valid.\n\n* Incomplete Code:\nString validateISBN(String isbn)\n{\n  // Remove the hyphens and keep only the digits and 'X' if present\n  String cleanISBN = isbn.replaceAll('-', '');\n\n  // Calculate the check sum\n  int checkSum = 0;\n[MASK]\n[MASK]\n  }\n\n  // Compute the check digit\n  String checkDigit = (checkSum % 11).toString();\n  checkDigit = checkDigit == '10' ? 'X' : checkDigit;\n\n  // Check if the last digit of the ISBN is equal to the calculated check digit\n  if (cleanISBN[9] == checkDigit) {\n    return 'Right';\n  } else {\n    // If the check digit is incorrect, replace it with the correct one and return the full ISBN\n    return isbn.substring(0, 12) + checkDigit;\n  }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Remove the hyphens and keep only the digits and 'X' if present\n  String cleanISBN = isbn.replaceAll('-', '');\n\n  // Calculate the check sum\n  int checkSum = 0;\n[MASK]\n[MASK]\n  }\n\n  // Compute the check digit\n  String checkDigit = (checkSum % 11).toString();\n  checkDigit = checkDigit == '10' ? 'X' : checkDigit;\n\n  // Check if the last digit of the ISBN is equal to the calculated check digit\n  if (cleanISBN[9] == checkDigit) {\n    return 'Right';\n  } else {\n    // If the check digit is incorrect, replace it with the correct one and return the full ISBN\n    return isbn.substring(0, 12) + checkDigit;\n  }\n}"}
{"task_id": "Dart/11-1-multi", "prompt": "String validateISBN(String isbn)\n/// Validates an ISBN-10 number and returns either 'Right' if the ISBN is valid\n/// or the corrected ISBN with the proper check digit if it is not.\n///\n/// The function takes a String [isbn] which is an ISBN-10 number that may\n/// include hyphens. It removes any hyphens and then calculates the checksum \n/// based on the first 9 digits. The checksum is used to determine the correct\n/// check digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n///\n/// Arguments:\n///   isbn - A String containing the ISBN-10 number to be validated.\n///\n/// Returns:\n///   A String 'Right' if the ISBN is valid, or a String containing the\n///   corrected ISBN if the original ISBN has an incorrect check digit.\n///\n/// Examples:\n///   validateISBN(\"0-306-40615-2\") returns 'Right' because it is a valid ISBN.\n///   validateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\" because the last digit\n///   should be 2 instead of 0 to make the ISBN valid.\n///   validateISBN(\"1-85326-158-0\") returns 'Right' because it is already valid.", "canonical_solution": "{\n  // Remove the hyphens and keep only the digits and 'X' if present\n  String cleanISBN = isbn.replaceAll('-', '');\n\n  // Calculate the check sum\n  int checkSum = 0;\n  for (int i = 0; i < 9; i++) {\n    checkSum += int.parse(cleanISBN[i]) * (i + 1);\n  }\n\n  // Compute the check digit\n  String checkDigit = (checkSum % 11).toString();\n  checkDigit = checkDigit == '10' ? 'X' : checkDigit;\n\n  // Check if the last digit of the ISBN is equal to the calculated check digit\n  if (cleanISBN[9] == checkDigit) {\n    return 'Right';\n  } else {\n    // If the check digit is incorrect, replace it with the correct one and return the full ISBN\n    return isbn.substring(0, 12) + checkDigit;\n  }\n}", "test": "void testValidateISBN() {\n  // Test case 1: A valid ISBN-10\n  assert(validateISBN(\"0-306-40615-2\") == 'Right');\n\n  // Test case 2: An invalid ISBN-10 with an incorrect check digit\n  assert(validateISBN(\"0-306-40615-0\") == \"0-306-40615-2\");\n\n  // Test case 3: A valid ISBN-10 with 'X' as the check digit\n  assert(validateISBN(\"0-19-852663-6\") == 'Right');\n\n  // All tests passed if no assertion error is thrown\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testValidateISBN();\n}", "entry_point": "validateISBN", "signature": "String validateISBN(String isbn)", "docstring": "Validates an ISBN-10 number and returns either 'Right' if the ISBN is valid\nor the corrected ISBN with the proper check digit if it is not.\n\nThe function takes a String [isbn] which is an ISBN-10 number that may\ninclude hyphens. It removes any hyphens and then calculates the checksum\nbased on the first 9 digits. The checksum is used to determine the correct\ncheck digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n\nArguments:\nisbn - A String containing the ISBN-10 number to be validated.\n\nReturns:\nA String 'Right' if the ISBN is valid, or a String containing the\ncorrected ISBN if the original ISBN has an incorrect check digit.\n\nExamples:\nvalidateISBN(\"0-306-40615-2\") returns 'Right' because it is a valid ISBN.\nvalidateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\" because the last digit\nshould be 2 instead of 0 to make the ISBN valid.\nvalidateISBN(\"1-85326-158-0\") returns 'Right' because it is already valid.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nValidates an ISBN-10 number and returns either 'Right' if the ISBN is valid\nor the corrected ISBN with the proper check digit if it is not.\n\nThe function takes a String [isbn] which is an ISBN-10 number that may\ninclude hyphens. It removes any hyphens and then calculates the checksum\nbased on the first 9 digits. The checksum is used to determine the correct\ncheck digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n\nArguments:\nisbn - A String containing the ISBN-10 number to be validated.\n\nReturns:\nA String 'Right' if the ISBN is valid, or a String containing the\ncorrected ISBN if the original ISBN has an incorrect check digit.\n\nExamples:\nvalidateISBN(\"0-306-40615-2\") returns 'Right' because it is a valid ISBN.\nvalidateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\" because the last digit\nshould be 2 instead of 0 to make the ISBN valid.\nvalidateISBN(\"1-85326-158-0\") returns 'Right' because it is already valid.\n\n* Incomplete Code:\nString validateISBN(String isbn)\n{\n  // Remove the hyphens and keep only the digits and 'X' if present\n  String cleanISBN = isbn.replaceAll('-', '');\n\n  // Calculate the check sum\n[MASK]\n  for (int i = 0; i < 9; i++) {\n    checkSum += int.parse(cleanISBN[i]) * (i + 1);\n  }\n\n  // Compute the check digit\n[MASK]\n  checkDigit = checkDigit == '10' ? 'X' : checkDigit;\n\n  // Check if the last digit of the ISBN is equal to the calculated check digit\n  if (cleanISBN[9] == checkDigit) {\n[MASK]\n  } else {\n    // If the check digit is incorrect, replace it with the correct one and return the full ISBN\n[MASK]\n  }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Remove the hyphens and keep only the digits and 'X' if present\n  String cleanISBN = isbn.replaceAll('-', '');\n\n  // Calculate the check sum\n[MASK]\n  for (int i = 0; i < 9; i++) {\n    checkSum += int.parse(cleanISBN[i]) * (i + 1);\n  }\n\n  // Compute the check digit\n[MASK]\n  checkDigit = checkDigit == '10' ? 'X' : checkDigit;\n\n  // Check if the last digit of the ISBN is equal to the calculated check digit\n  if (cleanISBN[9] == checkDigit) {\n[MASK]\n  } else {\n    // If the check digit is incorrect, replace it with the correct one and return the full ISBN\n[MASK]\n  }\n}"}
{"task_id": "Dart/12-0-multi", "prompt": "List<int> findCorridors(List<int> counts, int limit) \n/// Finds and returns a list of indices corresponding to the highest values in the\n/// `counts` list, up to the specified `limit`. The resulting list of indices is\n/// sorted in ascending order.\n///\n/// The function first generates a list of indices (1-based) up to the specified\n/// `limit`. Then it sorts these indices based on the corresponding values in the\n/// `counts` list, in descending order. After sorting, it takes the indices that\n/// correspond to the `limit` highest values and returns them sorted in ascending\n/// order. If the `limit` is greater than the number of elements in `counts`, the\n/// function will return indices up to the number of elements in `counts`.\n///\n/// Arguments:\n///   counts (List<int>): A list containing integer values to be ranked.\n///   limit (int): The maximum number of top values to return.\n///\n/// Returns:\n///   List<int>: A list containing the indices (1-based) of the top `limit` values\n///   from `counts`, sorted in ascending order.\n///\n/// Examples:\n///   1. findCorridors([10, 20, 30, 40, 50], 3)\n///      - This will return [3, 4, 5], the indices of the top 3 values (30, 40, 50).\n///\n///   2. findCorridors([50, 20, 50, 40, 10], 4)\n///      - This will return [1, 4, 2, 3], the indices of the top 4 values (50, 50, 40, 20),\n///        which are then sorted to [1, 2, 3, 4].\n///\n///   3. findCorridors([5, 15, 25], 5)\n///      - Since the `limit` exceeds the number of elements in `counts`, it will\n///        return [1, 2, 3], which are the indices of all the available values.", "canonical_solution": "{\n  List<int> corridors = [];\n  for (int i = 0; i < limit; i++) {\n    corridors.add(i + 1);\n  }\n\n  // Ensure we do not try to sort based on indices that don't exist in 'counts'\n  int countsLimit = counts.length < limit ? counts.length : limit;\n\n  corridors.sort((a, b) {\n    // Adjusting indices for zero-based indexing in the 'counts' list\n    int adjustedA = a - 1;\n    int adjustedB = b - 1;\n\n    // Prevent out-of-range access\n    if (adjustedA >= countsLimit) return 1;\n    if (adjustedB >= countsLimit) return -1;\n\n    return counts[adjustedB].compareTo(counts[adjustedA]);\n  });\n  // Take only the number of corridors that exists in the 'counts' list and sort them\n  return corridors.take(countsLimit).toList()..sort();\n}", "test": "void testFindCorridors() {\n  // Test case 1: General case with distinct counts\n  List<int> counts1 = [10, 20, 30, 40, 50];\n  int limit1 = 3;\n  List<int> expected1 = [1, 2, 3]; // Indices of the top 3 counts in ascending order\n  assert(findCorridors(counts1, limit1).toString() == expected1.toString());\n\n  // Test case 2: Case with some equal counts\n  List<int> counts2 = [50, 20, 50, 40, 10];\n  int limit2 = 4;\n  List<int> expected2 = [1, 2, 3, 4]; // Indices of the top 4 counts in ascending order\n  assert(findCorridors(counts2, limit2).toString() == expected2.toString());\n\n  // Test case 3: Case where limit exceeds the number of elements\n  List<int> counts3 = [5, 15, 25];\n  int limit3 = 5;\n  List<int> expected3 = [1, 2, 3]; // All indices in ascending order since limit exceeds the list size\n  assert(findCorridors(counts3, limit3).toString() == expected3.toString());\n\n  // All tests passed if no assertion error is thrown\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testFindCorridors();\n}", "entry_point": "findCorridors", "signature": "List<int> findCorridors(List<int> counts, int limit)", "docstring": "Finds and returns a list of indices corresponding to the highest values in the\n`counts` list, up to the specified `limit`. The resulting list of indices is\nsorted in ascending order.\n\nThe function first generates a list of indices (1-based) up to the specified\n`limit`. Then it sorts these indices based on the corresponding values in the\n`counts` list, in descending order. After sorting, it takes the indices that\ncorrespond to the `limit` highest values and returns them sorted in ascending\norder. If the `limit` is greater than the number of elements in `counts`, the\nfunction will return indices up to the number of elements in `counts`.\n\nArguments:\ncounts (List<int>): A list containing integer values to be ranked.\nlimit (int): The maximum number of top values to return.\n\nReturns:\nList<int>: A list containing the indices (1-based) of the top `limit` values\nfrom `counts`, sorted in ascending order.\n\nExamples:\n1. findCorridors([10, 20, 30, 40, 50], 3)\n- This will return [3, 4, 5], the indices of the top 3 values (30, 40, 50).\n\n2. findCorridors([50, 20, 50, 40, 10], 4)\n- This will return [1, 4, 2, 3], the indices of the top 4 values (50, 50, 40, 20),\nwhich are then sorted to [1, 2, 3, 4].\n\n3. findCorridors([5, 15, 25], 5)\n- Since the `limit` exceeds the number of elements in `counts`, it will\nreturn [1, 2, 3], which are the indices of all the available values.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds and returns a list of indices corresponding to the highest values in the\n`counts` list, up to the specified `limit`. The resulting list of indices is\nsorted in ascending order.\n\nThe function first generates a list of indices (1-based) up to the specified\n`limit`. Then it sorts these indices based on the corresponding values in the\n`counts` list, in descending order. After sorting, it takes the indices that\ncorrespond to the `limit` highest values and returns them sorted in ascending\norder. If the `limit` is greater than the number of elements in `counts`, the\nfunction will return indices up to the number of elements in `counts`.\n\nArguments:\ncounts (List<int>): A list containing integer values to be ranked.\nlimit (int): The maximum number of top values to return.\n\nReturns:\nList<int>: A list containing the indices (1-based) of the top `limit` values\nfrom `counts`, sorted in ascending order.\n\nExamples:\n1. findCorridors([10, 20, 30, 40, 50], 3)\n- This will return [3, 4, 5], the indices of the top 3 values (30, 40, 50).\n\n2. findCorridors([50, 20, 50, 40, 10], 4)\n- This will return [1, 4, 2, 3], the indices of the top 4 values (50, 50, 40, 20),\nwhich are then sorted to [1, 2, 3, 4].\n\n3. findCorridors([5, 15, 25], 5)\n- Since the `limit` exceeds the number of elements in `counts`, it will\nreturn [1, 2, 3], which are the indices of all the available values.\n\n* Incomplete Code:\nList<int> findCorridors(List<int> counts, int limit)\n{\n  List<int> corridors = [];\n  for (int i = 0; i < limit; i++) {\n[MASK]\n  }\n\n  // Ensure we do not try to sort based on indices that don't exist in 'counts'\n[MASK]\n\n  corridors.sort((a, b) {\n    // Adjusting indices for zero-based indexing in the 'counts' list\n[MASK]\n    int adjustedB = b - 1;\n\n    // Prevent out-of-range access\n    if (adjustedA >= countsLimit) return 1;\n    if (adjustedB >= countsLimit) return -1;\n\n[MASK]\n  });\n  // Take only the number of corridors that exists in the 'counts' list and sort them\n  return corridors.take(countsLimit).toList()..sort();\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> corridors = [];\n  for (int i = 0; i < limit; i++) {\n[MASK]\n  }\n\n  // Ensure we do not try to sort based on indices that don't exist in 'counts'\n[MASK]\n\n  corridors.sort((a, b) {\n    // Adjusting indices for zero-based indexing in the 'counts' list\n[MASK]\n    int adjustedB = b - 1;\n\n    // Prevent out-of-range access\n    if (adjustedA >= countsLimit) return 1;\n    if (adjustedB >= countsLimit) return -1;\n\n[MASK]\n  });\n  // Take only the number of corridors that exists in the 'counts' list and sort them\n  return corridors.take(countsLimit).toList()..sort();\n}"}
{"task_id": "Dart/12-1-multi", "prompt": "List<int> findCorridors(List<int> counts, int limit) \n/// Finds and returns a list of indices corresponding to the highest values in the\n/// `counts` list, up to the specified `limit`. The resulting list of indices is\n/// sorted in ascending order.\n///\n/// The function first generates a list of indices (1-based) up to the specified\n/// `limit`. Then it sorts these indices based on the corresponding values in the\n/// `counts` list, in descending order. After sorting, it takes the indices that\n/// correspond to the `limit` highest values and returns them sorted in ascending\n/// order. If the `limit` is greater than the number of elements in `counts`, the\n/// function will return indices up to the number of elements in `counts`.\n///\n/// Arguments:\n///   counts (List<int>): A list containing integer values to be ranked.\n///   limit (int): The maximum number of top values to return.\n///\n/// Returns:\n///   List<int>: A list containing the indices (1-based) of the top `limit` values\n///   from `counts`, sorted in ascending order.\n///\n/// Examples:\n///   1. findCorridors([10, 20, 30, 40, 50], 3)\n///      - This will return [3, 4, 5], the indices of the top 3 values (30, 40, 50).\n///\n///   2. findCorridors([50, 20, 50, 40, 10], 4)\n///      - This will return [1, 4, 2, 3], the indices of the top 4 values (50, 50, 40, 20),\n///        which are then sorted to [1, 2, 3, 4].\n///\n///   3. findCorridors([5, 15, 25], 5)\n///      - Since the `limit` exceeds the number of elements in `counts`, it will\n///        return [1, 2, 3], which are the indices of all the available values.", "canonical_solution": "{\n  List<int> corridors = [];\n  for (int i = 0; i < limit; i++) {\n    corridors.add(i + 1);\n  }\n\n  // Ensure we do not try to sort based on indices that don't exist in 'counts'\n  int countsLimit = counts.length < limit ? counts.length : limit;\n\n  corridors.sort((a, b) {\n    // Adjusting indices for zero-based indexing in the 'counts' list\n    int adjustedA = a - 1;\n    int adjustedB = b - 1;\n\n    // Prevent out-of-range access\n    if (adjustedA >= countsLimit) return 1;\n    if (adjustedB >= countsLimit) return -1;\n\n    return counts[adjustedB].compareTo(counts[adjustedA]);\n  });\n  // Take only the number of corridors that exists in the 'counts' list and sort them\n  return corridors.take(countsLimit).toList()..sort();\n}", "test": "void testFindCorridors() {\n  // Test case 1: General case with distinct counts\n  List<int> counts1 = [10, 20, 30, 40, 50];\n  int limit1 = 3;\n  List<int> expected1 = [1, 2, 3]; // Indices of the top 3 counts in ascending order\n  assert(findCorridors(counts1, limit1).toString() == expected1.toString());\n\n  // Test case 2: Case with some equal counts\n  List<int> counts2 = [50, 20, 50, 40, 10];\n  int limit2 = 4;\n  List<int> expected2 = [1, 2, 3, 4]; // Indices of the top 4 counts in ascending order\n  assert(findCorridors(counts2, limit2).toString() == expected2.toString());\n\n  // Test case 3: Case where limit exceeds the number of elements\n  List<int> counts3 = [5, 15, 25];\n  int limit3 = 5;\n  List<int> expected3 = [1, 2, 3]; // All indices in ascending order since limit exceeds the list size\n  assert(findCorridors(counts3, limit3).toString() == expected3.toString());\n\n  // All tests passed if no assertion error is thrown\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testFindCorridors();\n}", "entry_point": "findCorridors", "signature": "List<int> findCorridors(List<int> counts, int limit)", "docstring": "Finds and returns a list of indices corresponding to the highest values in the\n`counts` list, up to the specified `limit`. The resulting list of indices is\nsorted in ascending order.\n\nThe function first generates a list of indices (1-based) up to the specified\n`limit`. Then it sorts these indices based on the corresponding values in the\n`counts` list, in descending order. After sorting, it takes the indices that\ncorrespond to the `limit` highest values and returns them sorted in ascending\norder. If the `limit` is greater than the number of elements in `counts`, the\nfunction will return indices up to the number of elements in `counts`.\n\nArguments:\ncounts (List<int>): A list containing integer values to be ranked.\nlimit (int): The maximum number of top values to return.\n\nReturns:\nList<int>: A list containing the indices (1-based) of the top `limit` values\nfrom `counts`, sorted in ascending order.\n\nExamples:\n1. findCorridors([10, 20, 30, 40, 50], 3)\n- This will return [3, 4, 5], the indices of the top 3 values (30, 40, 50).\n\n2. findCorridors([50, 20, 50, 40, 10], 4)\n- This will return [1, 4, 2, 3], the indices of the top 4 values (50, 50, 40, 20),\nwhich are then sorted to [1, 2, 3, 4].\n\n3. findCorridors([5, 15, 25], 5)\n- Since the `limit` exceeds the number of elements in `counts`, it will\nreturn [1, 2, 3], which are the indices of all the available values.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds and returns a list of indices corresponding to the highest values in the\n`counts` list, up to the specified `limit`. The resulting list of indices is\nsorted in ascending order.\n\nThe function first generates a list of indices (1-based) up to the specified\n`limit`. Then it sorts these indices based on the corresponding values in the\n`counts` list, in descending order. After sorting, it takes the indices that\ncorrespond to the `limit` highest values and returns them sorted in ascending\norder. If the `limit` is greater than the number of elements in `counts`, the\nfunction will return indices up to the number of elements in `counts`.\n\nArguments:\ncounts (List<int>): A list containing integer values to be ranked.\nlimit (int): The maximum number of top values to return.\n\nReturns:\nList<int>: A list containing the indices (1-based) of the top `limit` values\nfrom `counts`, sorted in ascending order.\n\nExamples:\n1. findCorridors([10, 20, 30, 40, 50], 3)\n- This will return [3, 4, 5], the indices of the top 3 values (30, 40, 50).\n\n2. findCorridors([50, 20, 50, 40, 10], 4)\n- This will return [1, 4, 2, 3], the indices of the top 4 values (50, 50, 40, 20),\nwhich are then sorted to [1, 2, 3, 4].\n\n3. findCorridors([5, 15, 25], 5)\n- Since the `limit` exceeds the number of elements in `counts`, it will\nreturn [1, 2, 3], which are the indices of all the available values.\n\n* Incomplete Code:\nList<int> findCorridors(List<int> counts, int limit)\n{\n  List<int> corridors = [];\n  for (int i = 0; i < limit; i++) {\n[MASK]\n  }\n\n  // Ensure we do not try to sort based on indices that don't exist in 'counts'\n  int countsLimit = counts.length < limit ? counts.length : limit;\n\n[MASK]\n    // Adjusting indices for zero-based indexing in the 'counts' list\n    int adjustedA = a - 1;\n    int adjustedB = b - 1;\n\n    // Prevent out-of-range access\n    if (adjustedA >= countsLimit) return 1;\n    if (adjustedB >= countsLimit) return -1;\n\n    return counts[adjustedB].compareTo(counts[adjustedA]);\n  });\n  // Take only the number of corridors that exists in the 'counts' list and sort them\n  return corridors.take(countsLimit).toList()..sort();\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> corridors = [];\n  for (int i = 0; i < limit; i++) {\n[MASK]\n  }\n\n  // Ensure we do not try to sort based on indices that don't exist in 'counts'\n  int countsLimit = counts.length < limit ? counts.length : limit;\n\n[MASK]\n    // Adjusting indices for zero-based indexing in the 'counts' list\n    int adjustedA = a - 1;\n    int adjustedB = b - 1;\n\n    // Prevent out-of-range access\n    if (adjustedA >= countsLimit) return 1;\n    if (adjustedB >= countsLimit) return -1;\n\n    return counts[adjustedB].compareTo(counts[adjustedA]);\n  });\n  // Take only the number of corridors that exists in the 'counts' list and sort them\n  return corridors.take(countsLimit).toList()..sort();\n}"}
{"task_id": "Dart/13-0-multi", "prompt": "int passBallGame(int n, int m)\n/// Calculates the number of ways a ball can be passed among `n` students `m` times,\n/// such that the ball ends up with student 1 after the last pass.\n///\n/// This function uses dynamic programming to solve the problem, where `dp[i][j]`\n/// represents the number of ways to pass the ball `i` times and end up with student `j`.\n/// The function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\n/// intermediate results. The base case is set where no passes are made and the ball starts\n/// with student 1. The function then iterates over the number of passes and students to fill\n/// the `dp` table with the count of pass sequences for each scenario. The final result is the\n/// number of ways to pass the ball `m` times and return it to student 1.\n///\n/// Arguments:\n///   n (int): The total number of students among whom the ball is being passed.\n///   m (int): The total number of passes to be made.\n///\n/// Returns:\n///   int: The number of distinct ways to pass the ball `m` times such that it\n///   ends up with student 1.\n///\n/// Examples:\n///   1. passBallGame(3, 1)\n///      - With 3 students and 1 pass, there are 2 ways to pass the ball so it ends up with student 1.\n///\n///   2. passBallGame(5, 0)\n///      - With 5 students and 0 passes, there is only 1 way (no passing) for the ball to be with student 1.\n///\n///   3. passBallGame(4, 2)\n///      - With 4 students and 2 passes, there are 2 ways for the ball to end up with student 1 after the passes.", "canonical_solution": "{\n  List<List<int>> dp = List.generate(m + 1, (_) => List.filled(n + 1, 0));\n  dp[0][1] = 1; // Starting with student 1, 0 passes.\n\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n      dp[i][j] = dp[i - 1][(j - 2 + n) % n + 1] + dp[i - 1][j % n + 1];\n    }\n  }\n  return dp[m][1]; // Number of ways ball can be passed m times and end up with student 1.\n}", "test": "void testPassBallGame() {\n  // Test case 1: Small number of students and passes\n  assert(passBallGame(3, 1) == 0, 'Test Case 1 Failed'); // There are two ways to pass the ball once among 3 students and end with student 1.\n\n  // Test case 2: A scenario where no passes are made\n  assert(passBallGame(5, 0) == 1, 'Test Case 2 Failed'); // There is only one way (no passes) to end up with student 1 when no passes are made.\n\n  // Test case 3: A larger number of students and passes\n  assert(passBallGame(4, 2) == 2, 'Test Case 3 Failed'); // There are two ways to pass the ball twice among 4 students and end with student 1.\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testPassBallGame();\n}", "entry_point": "passBallGame", "signature": "int passBallGame(int n, int m)", "docstring": "Calculates the number of ways a ball can be passed among `n` students `m` times,\nsuch that the ball ends up with student 1 after the last pass.\n\nThis function uses dynamic programming to solve the problem, where `dp[i][j]`\nrepresents the number of ways to pass the ball `i` times and end up with student `j`.\nThe function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\nintermediate results. The base case is set where no passes are made and the ball starts\nwith student 1. The function then iterates over the number of passes and students to fill\nthe `dp` table with the count of pass sequences for each scenario. The final result is the\nnumber of ways to pass the ball `m` times and return it to student 1.\n\nArguments:\nn (int): The total number of students among whom the ball is being passed.\nm (int): The total number of passes to be made.\n\nReturns:\nint: The number of distinct ways to pass the ball `m` times such that it\nends up with student 1.\n\nExamples:\n1. passBallGame(3, 1)\n- With 3 students and 1 pass, there are 2 ways to pass the ball so it ends up with student 1.\n\n2. passBallGame(5, 0)\n- With 5 students and 0 passes, there is only 1 way (no passing) for the ball to be with student 1.\n\n3. passBallGame(4, 2)\n- With 4 students and 2 passes, there are 2 ways for the ball to end up with student 1 after the passes.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the number of ways a ball can be passed among `n` students `m` times,\nsuch that the ball ends up with student 1 after the last pass.\n\nThis function uses dynamic programming to solve the problem, where `dp[i][j]`\nrepresents the number of ways to pass the ball `i` times and end up with student `j`.\nThe function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\nintermediate results. The base case is set where no passes are made and the ball starts\nwith student 1. The function then iterates over the number of passes and students to fill\nthe `dp` table with the count of pass sequences for each scenario. The final result is the\nnumber of ways to pass the ball `m` times and return it to student 1.\n\nArguments:\nn (int): The total number of students among whom the ball is being passed.\nm (int): The total number of passes to be made.\n\nReturns:\nint: The number of distinct ways to pass the ball `m` times such that it\nends up with student 1.\n\nExamples:\n1. passBallGame(3, 1)\n- With 3 students and 1 pass, there are 2 ways to pass the ball so it ends up with student 1.\n\n2. passBallGame(5, 0)\n- With 5 students and 0 passes, there is only 1 way (no passing) for the ball to be with student 1.\n\n3. passBallGame(4, 2)\n- With 4 students and 2 passes, there are 2 ways for the ball to end up with student 1 after the passes.\n\n* Incomplete Code:\nint passBallGame(int n, int m)\n{\n[MASK]\n  dp[0][1] = 1; // Starting with student 1, 0 passes.\n\n  for (int i = 1; i <= m; i++) {\n[MASK]\n[MASK]\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  dp[0][1] = 1; // Starting with student 1, 0 passes.\n\n  for (int i = 1; i <= m; i++) {\n[MASK]\n[MASK]\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/13-1-multi", "prompt": "int passBallGame(int n, int m)\n/// Calculates the number of ways a ball can be passed among `n` students `m` times,\n/// such that the ball ends up with student 1 after the last pass.\n///\n/// This function uses dynamic programming to solve the problem, where `dp[i][j]`\n/// represents the number of ways to pass the ball `i` times and end up with student `j`.\n/// The function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\n/// intermediate results. The base case is set where no passes are made and the ball starts\n/// with student 1. The function then iterates over the number of passes and students to fill\n/// the `dp` table with the count of pass sequences for each scenario. The final result is the\n/// number of ways to pass the ball `m` times and return it to student 1.\n///\n/// Arguments:\n///   n (int): The total number of students among whom the ball is being passed.\n///   m (int): The total number of passes to be made.\n///\n/// Returns:\n///   int: The number of distinct ways to pass the ball `m` times such that it\n///   ends up with student 1.\n///\n/// Examples:\n///   1. passBallGame(3, 1)\n///      - With 3 students and 1 pass, there are 2 ways to pass the ball so it ends up with student 1.\n///\n///   2. passBallGame(5, 0)\n///      - With 5 students and 0 passes, there is only 1 way (no passing) for the ball to be with student 1.\n///\n///   3. passBallGame(4, 2)\n///      - With 4 students and 2 passes, there are 2 ways for the ball to end up with student 1 after the passes.", "canonical_solution": "{\n  List<List<int>> dp = List.generate(m + 1, (_) => List.filled(n + 1, 0));\n  dp[0][1] = 1; // Starting with student 1, 0 passes.\n\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n      dp[i][j] = dp[i - 1][(j - 2 + n) % n + 1] + dp[i - 1][j % n + 1];\n    }\n  }\n  return dp[m][1]; // Number of ways ball can be passed m times and end up with student 1.\n}", "test": "void testPassBallGame() {\n  // Test case 1: Small number of students and passes\n  assert(passBallGame(3, 1) == 0, 'Test Case 1 Failed'); // There are two ways to pass the ball once among 3 students and end with student 1.\n\n  // Test case 2: A scenario where no passes are made\n  assert(passBallGame(5, 0) == 1, 'Test Case 2 Failed'); // There is only one way (no passes) to end up with student 1 when no passes are made.\n\n  // Test case 3: A larger number of students and passes\n  assert(passBallGame(4, 2) == 2, 'Test Case 3 Failed'); // There are two ways to pass the ball twice among 4 students and end with student 1.\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testPassBallGame();\n}", "entry_point": "passBallGame", "signature": "int passBallGame(int n, int m)", "docstring": "Calculates the number of ways a ball can be passed among `n` students `m` times,\nsuch that the ball ends up with student 1 after the last pass.\n\nThis function uses dynamic programming to solve the problem, where `dp[i][j]`\nrepresents the number of ways to pass the ball `i` times and end up with student `j`.\nThe function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\nintermediate results. The base case is set where no passes are made and the ball starts\nwith student 1. The function then iterates over the number of passes and students to fill\nthe `dp` table with the count of pass sequences for each scenario. The final result is the\nnumber of ways to pass the ball `m` times and return it to student 1.\n\nArguments:\nn (int): The total number of students among whom the ball is being passed.\nm (int): The total number of passes to be made.\n\nReturns:\nint: The number of distinct ways to pass the ball `m` times such that it\nends up with student 1.\n\nExamples:\n1. passBallGame(3, 1)\n- With 3 students and 1 pass, there are 2 ways to pass the ball so it ends up with student 1.\n\n2. passBallGame(5, 0)\n- With 5 students and 0 passes, there is only 1 way (no passing) for the ball to be with student 1.\n\n3. passBallGame(4, 2)\n- With 4 students and 2 passes, there are 2 ways for the ball to end up with student 1 after the passes.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the number of ways a ball can be passed among `n` students `m` times,\nsuch that the ball ends up with student 1 after the last pass.\n\nThis function uses dynamic programming to solve the problem, where `dp[i][j]`\nrepresents the number of ways to pass the ball `i` times and end up with student `j`.\nThe function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\nintermediate results. The base case is set where no passes are made and the ball starts\nwith student 1. The function then iterates over the number of passes and students to fill\nthe `dp` table with the count of pass sequences for each scenario. The final result is the\nnumber of ways to pass the ball `m` times and return it to student 1.\n\nArguments:\nn (int): The total number of students among whom the ball is being passed.\nm (int): The total number of passes to be made.\n\nReturns:\nint: The number of distinct ways to pass the ball `m` times such that it\nends up with student 1.\n\nExamples:\n1. passBallGame(3, 1)\n- With 3 students and 1 pass, there are 2 ways to pass the ball so it ends up with student 1.\n\n2. passBallGame(5, 0)\n- With 5 students and 0 passes, there is only 1 way (no passing) for the ball to be with student 1.\n\n3. passBallGame(4, 2)\n- With 4 students and 2 passes, there are 2 ways for the ball to end up with student 1 after the passes.\n\n* Incomplete Code:\nint passBallGame(int n, int m)\n{\n  List<List<int>> dp = List.generate(m + 1, (_) => List.filled(n + 1, 0));\n[MASK]\n\n[MASK]\n    for (int j = 1; j <= n; j++) {\n[MASK]\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<List<int>> dp = List.generate(m + 1, (_) => List.filled(n + 1, 0));\n[MASK]\n\n[MASK]\n    for (int j = 1; j <= n; j++) {\n[MASK]\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/15-0-multi", "prompt": "import 'dart:math';\n\nint getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)\n\n/// Calculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n///\n/// This function uses a dynamic programming approach to determine the maximum value that can be achieved\n/// within the constraints of the total money available to spend. Each item's value is determined by its\n/// price multiplied by its importance. The function iterates over the list of items, updating the maximum\n/// value obtainable at each price point up to the total money available.\n///\n/// Arguments:\n///   totalMoney (int): The total amount of money available to spend on items.\n///   numItems (int): The number of different items available for purchase.\n///   prices (List<int>): A list containing the price of each item.\n///   importance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n///\n/// Returns:\n///   int: The maximum value obtainable with the given total money and items.\n///\n/// Examples:\n///   1. getMaxValue(50, 2, [20, 30], [5, 10])\n///      - With 50 money, buying items priced 20 with importance 5 and 30 with importance 10,\n///        the maximum value obtainable is 60 (20*5 + 30*10).\n///\n///   2. getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])\n///      - With only 10 money and items that cost more than 10, the best item to buy is the one\n///        priced at 5 with importance 3, yielding a maximum value of 6 (5*3).\n///\n///   3. getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])\n///      - With 100 money and various items to choose from, one can buy items priced 50, 25, and 20,\n///        with importances 1, 2, and 2, respectively, for a maximum value of 100 (50*1 + 25*2 + 20*2).", "canonical_solution": "{\n  List<int> dp = List.filled(totalMoney + 1, 0);\n\n  for (int i = 0; i < numItems; i++) {\n    for (int j = totalMoney; j >= prices[i]; j--) {\n      dp[j] = max(dp[j], dp[j - prices[i]] + prices[i] * importance[i]);\n    }\n  }\n\n  return dp[totalMoney];\n}", "test": "void testGetMaxValue() {\n  // Test case 1: Basic scenario with two items\n  assert(\n    getMaxValue(50, 2, [20, 30], [5, 10]) == 400,\n    'Test Case 1 Failed: Expected maximum value to be 60, got ${getMaxValue(50, 2, [20, 30], [5, 10])}'\n  );\n\n  // Test case 2: Scenario where the total money can't buy the most valuable item\n  assert(\n    getMaxValue(10, 3, [5, 10, 15], [3, 6, 9]) == 60,\n    'Test Case 2 Failed: Expected maximum value to be 6, got ${getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])}'\n  );\n\n  // Test case 3: Multiple items can be bought within the total money\n  assert(\n    getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2]) == 140,\n    'Test Case 3 Failed: Expected maximum value to be 100, got ${getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])}'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testGetMaxValue();\n}", "entry_point": "getMaxValue", "signature": "int getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)", "docstring": "Calculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n\nThis function uses a dynamic programming approach to determine the maximum value that can be achieved\nwithin the constraints of the total money available to spend. Each item's value is determined by its\nprice multiplied by its importance. The function iterates over the list of items, updating the maximum\nvalue obtainable at each price point up to the total money available.\n\nArguments:\ntotalMoney (int): The total amount of money available to spend on items.\nnumItems (int): The number of different items available for purchase.\nprices (List<int>): A list containing the price of each item.\nimportance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n\nReturns:\nint: The maximum value obtainable with the given total money and items.\n\nExamples:\n1. getMaxValue(50, 2, [20, 30], [5, 10])\n- With 50 money, buying items priced 20 with importance 5 and 30 with importance 10,\nthe maximum value obtainable is 60 (20*5 + 30*10).\n\n2. getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])\n- With only 10 money and items that cost more than 10, the best item to buy is the one\npriced at 5 with importance 3, yielding a maximum value of 6 (5*3).\n\n3. getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])\n- With 100 money and various items to choose from, one can buy items priced 50, 25, and 20,\nwith importances 1, 2, and 2, respectively, for a maximum value of 100 (50*1 + 25*2 + 20*2).", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n\nThis function uses a dynamic programming approach to determine the maximum value that can be achieved\nwithin the constraints of the total money available to spend. Each item's value is determined by its\nprice multiplied by its importance. The function iterates over the list of items, updating the maximum\nvalue obtainable at each price point up to the total money available.\n\nArguments:\ntotalMoney (int): The total amount of money available to spend on items.\nnumItems (int): The number of different items available for purchase.\nprices (List<int>): A list containing the price of each item.\nimportance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n\nReturns:\nint: The maximum value obtainable with the given total money and items.\n\nExamples:\n1. getMaxValue(50, 2, [20, 30], [5, 10])\n- With 50 money, buying items priced 20 with importance 5 and 30 with importance 10,\nthe maximum value obtainable is 60 (20*5 + 30*10).\n\n2. getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])\n- With only 10 money and items that cost more than 10, the best item to buy is the one\npriced at 5 with importance 3, yielding a maximum value of 6 (5*3).\n\n3. getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])\n- With 100 money and various items to choose from, one can buy items priced 50, 25, and 20,\nwith importances 1, 2, and 2, respectively, for a maximum value of 100 (50*1 + 25*2 + 20*2).\n\n* Incomplete Code:\nint getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)\n{\n[MASK]\n\n  for (int i = 0; i < numItems; i++) {\n    for (int j = totalMoney; j >= prices[i]; j--) {\n[MASK]\n    }\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n\n  for (int i = 0; i < numItems; i++) {\n    for (int j = totalMoney; j >= prices[i]; j--) {\n[MASK]\n    }\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/15-1-multi", "prompt": "import 'dart:math';\n\nint getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)\n\n/// Calculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n///\n/// This function uses a dynamic programming approach to determine the maximum value that can be achieved\n/// within the constraints of the total money available to spend. Each item's value is determined by its\n/// price multiplied by its importance. The function iterates over the list of items, updating the maximum\n/// value obtainable at each price point up to the total money available.\n///\n/// Arguments:\n///   totalMoney (int): The total amount of money available to spend on items.\n///   numItems (int): The number of different items available for purchase.\n///   prices (List<int>): A list containing the price of each item.\n///   importance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n///\n/// Returns:\n///   int: The maximum value obtainable with the given total money and items.\n///\n/// Examples:\n///   1. getMaxValue(50, 2, [20, 30], [5, 10])\n///      - With 50 money, buying items priced 20 with importance 5 and 30 with importance 10,\n///        the maximum value obtainable is 60 (20*5 + 30*10).\n///\n///   2. getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])\n///      - With only 10 money and items that cost more than 10, the best item to buy is the one\n///        priced at 5 with importance 3, yielding a maximum value of 6 (5*3).\n///\n///   3. getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])\n///      - With 100 money and various items to choose from, one can buy items priced 50, 25, and 20,\n///        with importances 1, 2, and 2, respectively, for a maximum value of 100 (50*1 + 25*2 + 20*2).", "canonical_solution": "{\n  List<int> dp = List.filled(totalMoney + 1, 0);\n\n  for (int i = 0; i < numItems; i++) {\n    for (int j = totalMoney; j >= prices[i]; j--) {\n      dp[j] = max(dp[j], dp[j - prices[i]] + prices[i] * importance[i]);\n    }\n  }\n\n  return dp[totalMoney];\n}", "test": "void testGetMaxValue() {\n  // Test case 1: Basic scenario with two items\n  assert(\n    getMaxValue(50, 2, [20, 30], [5, 10]) == 400,\n    'Test Case 1 Failed: Expected maximum value to be 60, got ${getMaxValue(50, 2, [20, 30], [5, 10])}'\n  );\n\n  // Test case 2: Scenario where the total money can't buy the most valuable item\n  assert(\n    getMaxValue(10, 3, [5, 10, 15], [3, 6, 9]) == 60,\n    'Test Case 2 Failed: Expected maximum value to be 6, got ${getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])}'\n  );\n\n  // Test case 3: Multiple items can be bought within the total money\n  assert(\n    getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2]) == 140,\n    'Test Case 3 Failed: Expected maximum value to be 100, got ${getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])}'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testGetMaxValue();\n}", "entry_point": "getMaxValue", "signature": "int getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)", "docstring": "Calculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n\nThis function uses a dynamic programming approach to determine the maximum value that can be achieved\nwithin the constraints of the total money available to spend. Each item's value is determined by its\nprice multiplied by its importance. The function iterates over the list of items, updating the maximum\nvalue obtainable at each price point up to the total money available.\n\nArguments:\ntotalMoney (int): The total amount of money available to spend on items.\nnumItems (int): The number of different items available for purchase.\nprices (List<int>): A list containing the price of each item.\nimportance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n\nReturns:\nint: The maximum value obtainable with the given total money and items.\n\nExamples:\n1. getMaxValue(50, 2, [20, 30], [5, 10])\n- With 50 money, buying items priced 20 with importance 5 and 30 with importance 10,\nthe maximum value obtainable is 60 (20*5 + 30*10).\n\n2. getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])\n- With only 10 money and items that cost more than 10, the best item to buy is the one\npriced at 5 with importance 3, yielding a maximum value of 6 (5*3).\n\n3. getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])\n- With 100 money and various items to choose from, one can buy items priced 50, 25, and 20,\nwith importances 1, 2, and 2, respectively, for a maximum value of 100 (50*1 + 25*2 + 20*2).", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n\nThis function uses a dynamic programming approach to determine the maximum value that can be achieved\nwithin the constraints of the total money available to spend. Each item's value is determined by its\nprice multiplied by its importance. The function iterates over the list of items, updating the maximum\nvalue obtainable at each price point up to the total money available.\n\nArguments:\ntotalMoney (int): The total amount of money available to spend on items.\nnumItems (int): The number of different items available for purchase.\nprices (List<int>): A list containing the price of each item.\nimportance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n\nReturns:\nint: The maximum value obtainable with the given total money and items.\n\nExamples:\n1. getMaxValue(50, 2, [20, 30], [5, 10])\n- With 50 money, buying items priced 20 with importance 5 and 30 with importance 10,\nthe maximum value obtainable is 60 (20*5 + 30*10).\n\n2. getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])\n- With only 10 money and items that cost more than 10, the best item to buy is the one\npriced at 5 with importance 3, yielding a maximum value of 6 (5*3).\n\n3. getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])\n- With 100 money and various items to choose from, one can buy items priced 50, 25, and 20,\nwith importances 1, 2, and 2, respectively, for a maximum value of 100 (50*1 + 25*2 + 20*2).\n\n* Incomplete Code:\nint getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)\n{\n[MASK]\n\n[MASK]\n[MASK]\n      dp[j] = max(dp[j], dp[j - prices[i]] + prices[i] * importance[i]);\n    }\n  }\n\n  return dp[totalMoney];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n\n[MASK]\n[MASK]\n      dp[j] = max(dp[j], dp[j - prices[i]] + prices[i] * importance[i]);\n    }\n  }\n\n  return dp[totalMoney];\n}"}
{"task_id": "Dart/16-0-multi", "prompt": "import 'dart:math';\n\nint maxEnergy(List<int> beads)\n\n/// Calculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n///\n/// This function simulates the energy released when breaking a circular necklace of beads into individual parts.\n/// The energy obtained from breaking the necklace at a certain point is the product of the values of the beads\n/// at the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\n/// that maximizes the total energy released.\n///\n/// Arguments:\n///   beads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n///\n/// Returns:\n///   int: The maximum energy obtainable by breaking the necklace.\n///\n/// Examples:\n///   1. maxEnergy([1, 2, 3])\n///      - Breaking the circular necklace of three beads with values [1, 2, 3], the maximum energy obtained\n///        is 12. Break between 1 and 3 first to get energy 1*2*3 = 6, then break between 2 and the combined\n///        bead to get additional energy 2*3 = 6, for a total of 12.\n///\n///   2. maxEnergy([4, 3, 2, 1])\n///      - For a necklace with four beads with values [4, 3, 2, 1], the maximum energy is 48. The optimal\n///        sequence of breaks could be first between 1 and 4 to get energy 4*3*1 = 12, then between 3 and 2\n///        to get energy 4*3*2 = 24, and finally between the combined bead and 2 to get additional energy\n///        4*2 = 12, for a total of 48.\n///\n///   3. maxEnergy([1, 3, 5, 8])\n///      - A necklace with beads [1, 3, 5, 8] yields a maximum energy of 152. The breaks that achieve this\n///        might first occur between 8 and 1 for energy 1*5*8 = 40, then between 5 and 3 for energy 1*5*3 = 15,\n///        and lastly between the combined bead and 3 for energy 1*3 = 3, totaling 152 after combining all breaks.", "canonical_solution": " {\n  int n = beads.length;\n  // Extend the beads list to simulate a circular necklace\n  List<int> extendedBeads = List.from(beads)..addAll(beads);\n  // Initialize a 2D array for dynamic programming\n  List<List<int>> dp = List.generate(2 * n, (i) => List.filled(2 * n, 0));\n\n  // Bottom-up dynamic programming approach\n  for (int len = 2; len <= n; ++len) { // length of the chain to multiply\n    for (int i = 0; i < 2 * n - len + 1; ++i) { // start of the chain\n      int j = i + len - 1; // end of the chain\n      for (int k = i + 1; k < j; ++k) { // split point of the chain\n        int energy = extendedBeads[i] * extendedBeads[k] * extendedBeads[j];\n        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + energy);\n      }\n    }\n  }\n\n  // Find the maximum energy that can be obtained\n  int maxEnergy = 0;\n  for (int i = 0; i < n; ++i) {\n    maxEnergy = max(maxEnergy, dp[i][i + n - 1]);\n  }\n\n  return maxEnergy;\n}", "test": "void testMaxEnergy() {\n  // Test case 1: Simple case with three beads\n  assert(\n    maxEnergy([1, 2, 3]) == 6,\n    'Test Case 1 Failed: Expected maximum energy to be 12, got ${maxEnergy([1, 2, 3])}'\n  );\n\n  // Test case 2: Another simple case with four beads\n  assert(\n    maxEnergy([4, 3, 2, 1]) == 32,\n    'Test Case 2 Failed: Expected maximum energy to be 48, got ${maxEnergy([4, 3, 2, 1])}'\n  );\n\n  // Test case 3: Case with more beads\n  assert(\n    maxEnergy([1, 3, 5, 8]) == 144,\n    'Test Case 3 Failed: Expected maximum energy to be 152, got ${maxEnergy([1, 3, 5, 8])}'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testMaxEnergy();\n}", "entry_point": "maxEnergy", "signature": "int maxEnergy(List<int> beads)", "docstring": "Calculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n\nThis function simulates the energy released when breaking a circular necklace of beads into individual parts.\nThe energy obtained from breaking the necklace at a certain point is the product of the values of the beads\nat the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\nthat maximizes the total energy released.\n\nArguments:\nbeads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n\nReturns:\nint: The maximum energy obtainable by breaking the necklace.\n\nExamples:\n1. maxEnergy([1, 2, 3])\n- Breaking the circular necklace of three beads with values [1, 2, 3], the maximum energy obtained\nis 12. Break between 1 and 3 first to get energy 1*2*3 = 6, then break between 2 and the combined\nbead to get additional energy 2*3 = 6, for a total of 12.\n\n2. maxEnergy([4, 3, 2, 1])\n- For a necklace with four beads with values [4, 3, 2, 1], the maximum energy is 48. The optimal\nsequence of breaks could be first between 1 and 4 to get energy 4*3*1 = 12, then between 3 and 2\nto get energy 4*3*2 = 24, and finally between the combined bead and 2 to get additional energy\n4*2 = 12, for a total of 48.\n\n3. maxEnergy([1, 3, 5, 8])\n- A necklace with beads [1, 3, 5, 8] yields a maximum energy of 152. The breaks that achieve this\nmight first occur between 8 and 1 for energy 1*5*8 = 40, then between 5 and 3 for energy 1*5*3 = 15,\nand lastly between the combined bead and 3 for energy 1*3 = 3, totaling 152 after combining all breaks.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n\nThis function simulates the energy released when breaking a circular necklace of beads into individual parts.\nThe energy obtained from breaking the necklace at a certain point is the product of the values of the beads\nat the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\nthat maximizes the total energy released.\n\nArguments:\nbeads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n\nReturns:\nint: The maximum energy obtainable by breaking the necklace.\n\nExamples:\n1. maxEnergy([1, 2, 3])\n- Breaking the circular necklace of three beads with values [1, 2, 3], the maximum energy obtained\nis 12. Break between 1 and 3 first to get energy 1*2*3 = 6, then break between 2 and the combined\nbead to get additional energy 2*3 = 6, for a total of 12.\n\n2. maxEnergy([4, 3, 2, 1])\n- For a necklace with four beads with values [4, 3, 2, 1], the maximum energy is 48. The optimal\nsequence of breaks could be first between 1 and 4 to get energy 4*3*1 = 12, then between 3 and 2\nto get energy 4*3*2 = 24, and finally between the combined bead and 2 to get additional energy\n4*2 = 12, for a total of 48.\n\n3. maxEnergy([1, 3, 5, 8])\n- A necklace with beads [1, 3, 5, 8] yields a maximum energy of 152. The breaks that achieve this\nmight first occur between 8 and 1 for energy 1*5*8 = 40, then between 5 and 3 for energy 1*5*3 = 15,\nand lastly between the combined bead and 3 for energy 1*3 = 3, totaling 152 after combining all breaks.\n\n* Incomplete Code:\nint maxEnergy(List<int> beads)\n {\n[MASK]\n  // Extend the beads list to simulate a circular necklace\n[MASK]\n  // Initialize a 2D array for dynamic programming\n  List<List<int>> dp = List.generate(2 * n, (i) => List.filled(2 * n, 0));\n\n  // Bottom-up dynamic programming approach\n  for (int len = 2; len <= n; ++len) { // length of the chain to multiply\n    for (int i = 0; i < 2 * n - len + 1; ++i) { // start of the chain\n[MASK]\n      for (int k = i + 1; k < j; ++k) { // split point of the chain\n[MASK]\n        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + energy);\n      }\n    }\n  }\n\n  // Find the maximum energy that can be obtained\n  int maxEnergy = 0;\n  for (int i = 0; i < n; ++i) {\n    maxEnergy = max(maxEnergy, dp[i][i + n - 1]);\n  }\n\n  return maxEnergy;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n[MASK]\n  // Extend the beads list to simulate a circular necklace\n[MASK]\n  // Initialize a 2D array for dynamic programming\n  List<List<int>> dp = List.generate(2 * n, (i) => List.filled(2 * n, 0));\n\n  // Bottom-up dynamic programming approach\n  for (int len = 2; len <= n; ++len) { // length of the chain to multiply\n    for (int i = 0; i < 2 * n - len + 1; ++i) { // start of the chain\n[MASK]\n      for (int k = i + 1; k < j; ++k) { // split point of the chain\n[MASK]\n        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + energy);\n      }\n    }\n  }\n\n  // Find the maximum energy that can be obtained\n  int maxEnergy = 0;\n  for (int i = 0; i < n; ++i) {\n    maxEnergy = max(maxEnergy, dp[i][i + n - 1]);\n  }\n\n  return maxEnergy;\n}"}
{"task_id": "Dart/16-1-multi", "prompt": "import 'dart:math';\n\nint maxEnergy(List<int> beads)\n\n/// Calculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n///\n/// This function simulates the energy released when breaking a circular necklace of beads into individual parts.\n/// The energy obtained from breaking the necklace at a certain point is the product of the values of the beads\n/// at the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\n/// that maximizes the total energy released.\n///\n/// Arguments:\n///   beads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n///\n/// Returns:\n///   int: The maximum energy obtainable by breaking the necklace.\n///\n/// Examples:\n///   1. maxEnergy([1, 2, 3])\n///      - Breaking the circular necklace of three beads with values [1, 2, 3], the maximum energy obtained\n///        is 12. Break between 1 and 3 first to get energy 1*2*3 = 6, then break between 2 and the combined\n///        bead to get additional energy 2*3 = 6, for a total of 12.\n///\n///   2. maxEnergy([4, 3, 2, 1])\n///      - For a necklace with four beads with values [4, 3, 2, 1], the maximum energy is 48. The optimal\n///        sequence of breaks could be first between 1 and 4 to get energy 4*3*1 = 12, then between 3 and 2\n///        to get energy 4*3*2 = 24, and finally between the combined bead and 2 to get additional energy\n///        4*2 = 12, for a total of 48.\n///\n///   3. maxEnergy([1, 3, 5, 8])\n///      - A necklace with beads [1, 3, 5, 8] yields a maximum energy of 152. The breaks that achieve this\n///        might first occur between 8 and 1 for energy 1*5*8 = 40, then between 5 and 3 for energy 1*5*3 = 15,\n///        and lastly between the combined bead and 3 for energy 1*3 = 3, totaling 152 after combining all breaks.", "canonical_solution": " {\n  int n = beads.length;\n  // Extend the beads list to simulate a circular necklace\n  List<int> extendedBeads = List.from(beads)..addAll(beads);\n  // Initialize a 2D array for dynamic programming\n  List<List<int>> dp = List.generate(2 * n, (i) => List.filled(2 * n, 0));\n\n  // Bottom-up dynamic programming approach\n  for (int len = 2; len <= n; ++len) { // length of the chain to multiply\n    for (int i = 0; i < 2 * n - len + 1; ++i) { // start of the chain\n      int j = i + len - 1; // end of the chain\n      for (int k = i + 1; k < j; ++k) { // split point of the chain\n        int energy = extendedBeads[i] * extendedBeads[k] * extendedBeads[j];\n        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + energy);\n      }\n    }\n  }\n\n  // Find the maximum energy that can be obtained\n  int maxEnergy = 0;\n  for (int i = 0; i < n; ++i) {\n    maxEnergy = max(maxEnergy, dp[i][i + n - 1]);\n  }\n\n  return maxEnergy;\n}", "test": "void testMaxEnergy() {\n  // Test case 1: Simple case with three beads\n  assert(\n    maxEnergy([1, 2, 3]) == 6,\n    'Test Case 1 Failed: Expected maximum energy to be 12, got ${maxEnergy([1, 2, 3])}'\n  );\n\n  // Test case 2: Another simple case with four beads\n  assert(\n    maxEnergy([4, 3, 2, 1]) == 32,\n    'Test Case 2 Failed: Expected maximum energy to be 48, got ${maxEnergy([4, 3, 2, 1])}'\n  );\n\n  // Test case 3: Case with more beads\n  assert(\n    maxEnergy([1, 3, 5, 8]) == 144,\n    'Test Case 3 Failed: Expected maximum energy to be 152, got ${maxEnergy([1, 3, 5, 8])}'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testMaxEnergy();\n}", "entry_point": "maxEnergy", "signature": "int maxEnergy(List<int> beads)", "docstring": "Calculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n\nThis function simulates the energy released when breaking a circular necklace of beads into individual parts.\nThe energy obtained from breaking the necklace at a certain point is the product of the values of the beads\nat the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\nthat maximizes the total energy released.\n\nArguments:\nbeads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n\nReturns:\nint: The maximum energy obtainable by breaking the necklace.\n\nExamples:\n1. maxEnergy([1, 2, 3])\n- Breaking the circular necklace of three beads with values [1, 2, 3], the maximum energy obtained\nis 12. Break between 1 and 3 first to get energy 1*2*3 = 6, then break between 2 and the combined\nbead to get additional energy 2*3 = 6, for a total of 12.\n\n2. maxEnergy([4, 3, 2, 1])\n- For a necklace with four beads with values [4, 3, 2, 1], the maximum energy is 48. The optimal\nsequence of breaks could be first between 1 and 4 to get energy 4*3*1 = 12, then between 3 and 2\nto get energy 4*3*2 = 24, and finally between the combined bead and 2 to get additional energy\n4*2 = 12, for a total of 48.\n\n3. maxEnergy([1, 3, 5, 8])\n- A necklace with beads [1, 3, 5, 8] yields a maximum energy of 152. The breaks that achieve this\nmight first occur between 8 and 1 for energy 1*5*8 = 40, then between 5 and 3 for energy 1*5*3 = 15,\nand lastly between the combined bead and 3 for energy 1*3 = 3, totaling 152 after combining all breaks.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n\nThis function simulates the energy released when breaking a circular necklace of beads into individual parts.\nThe energy obtained from breaking the necklace at a certain point is the product of the values of the beads\nat the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\nthat maximizes the total energy released.\n\nArguments:\nbeads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n\nReturns:\nint: The maximum energy obtainable by breaking the necklace.\n\nExamples:\n1. maxEnergy([1, 2, 3])\n- Breaking the circular necklace of three beads with values [1, 2, 3], the maximum energy obtained\nis 12. Break between 1 and 3 first to get energy 1*2*3 = 6, then break between 2 and the combined\nbead to get additional energy 2*3 = 6, for a total of 12.\n\n2. maxEnergy([4, 3, 2, 1])\n- For a necklace with four beads with values [4, 3, 2, 1], the maximum energy is 48. The optimal\nsequence of breaks could be first between 1 and 4 to get energy 4*3*1 = 12, then between 3 and 2\nto get energy 4*3*2 = 24, and finally between the combined bead and 2 to get additional energy\n4*2 = 12, for a total of 48.\n\n3. maxEnergy([1, 3, 5, 8])\n- A necklace with beads [1, 3, 5, 8] yields a maximum energy of 152. The breaks that achieve this\nmight first occur between 8 and 1 for energy 1*5*8 = 40, then between 5 and 3 for energy 1*5*3 = 15,\nand lastly between the combined bead and 3 for energy 1*3 = 3, totaling 152 after combining all breaks.\n\n* Incomplete Code:\nint maxEnergy(List<int> beads)\n {\n  int n = beads.length;\n  // Extend the beads list to simulate a circular necklace\n  List<int> extendedBeads = List.from(beads)..addAll(beads);\n  // Initialize a 2D array for dynamic programming\n[MASK]\n\n  // Bottom-up dynamic programming approach\n  for (int len = 2; len <= n; ++len) { // length of the chain to multiply\n[MASK]\n      int j = i + len - 1; // end of the chain\n      for (int k = i + 1; k < j; ++k) { // split point of the chain\n        int energy = extendedBeads[i] * extendedBeads[k] * extendedBeads[j];\n[MASK]\n      }\n    }\n  }\n\n  // Find the maximum energy that can be obtained\n[MASK]\n[MASK]\n    maxEnergy = max(maxEnergy, dp[i][i + n - 1]);\n  }\n\n  return maxEnergy;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  int n = beads.length;\n  // Extend the beads list to simulate a circular necklace\n  List<int> extendedBeads = List.from(beads)..addAll(beads);\n  // Initialize a 2D array for dynamic programming\n[MASK]\n\n  // Bottom-up dynamic programming approach\n  for (int len = 2; len <= n; ++len) { // length of the chain to multiply\n[MASK]\n      int j = i + len - 1; // end of the chain\n      for (int k = i + 1; k < j; ++k) { // split point of the chain\n        int energy = extendedBeads[i] * extendedBeads[k] * extendedBeads[j];\n[MASK]\n      }\n    }\n  }\n\n  // Find the maximum energy that can be obtained\n[MASK]\n[MASK]\n    maxEnergy = max(maxEnergy, dp[i][i + n - 1]);\n  }\n\n  return maxEnergy;\n}"}
{"task_id": "Dart/17-0-multi", "prompt": "String formatPolynomial(List<int> coefficients)\n\n/// Formats a list of coefficients into a string representation of a polynomial.\n///\n/// This function takes a list of integer coefficients and returns a string that represents\n/// the corresponding polynomial. Coefficients are listed in descending order of their degree.\n/// Zero coefficients are skipped, and the powers of 'x' are included only where necessary.\n/// The output polynomial does not contain unnecessary plus or minus signs and avoids using\n/// the coefficient '1' where it is implied, except for the constant term.\n///\n/// Arguments:\n///   coefficients (List<int>): A list of integer coefficients for the polynomial.\n///\n/// Returns:\n///   String: A string representation of the polynomial.\n///\n/// Examples:\n///   1. formatPolynomial([1, 0, -4, 3])\n///      - Given the coefficients for the polynomial x^3 - 4x + 3, the function will return\n///        the string \"x^3-4x+3\".\n///\n///   2. formatPolynomial([-3, 1])\n///      - For the polynomial -3x + 1, the function will return the string \"-3x+1\".\n///\n///   3. formatPolynomial([2, -1, 0, 0, 5])\n///      - For the polynomial 2x^4 - x^3 + 5, the output will be \"2x^4-x^3+5\", omitting\n///        the zero coefficients.\n///\n///   4. formatPolynomial([0, 0, 0, 1])\n///      - If only the constant term is non-zero, for example 1, the function returns \"1\",\n///        without any variables or powers.\n///\n///   5. formatPolynomial([0])\n///      - For a list with a single zero coefficient, the function will return an empty\n///        string, as the polynomial has no non-zero terms.", "canonical_solution": "{\n  StringBuffer polynomial = StringBuffer();\n  int degree = coefficients.length - 1;\n\n  for (int i = 0; i < coefficients.length; i++) {\n    int coeff = coefficients[i];\n    if (coeff == 0) continue; // Skip zero coefficients\n\n    int exp = degree - i; // Exponent for the current term\n    String term = \"\";\n\n    if (coeff > 0 && polynomial.isNotEmpty) {\n      term += \"+\"; // Add + sign for positive coefficients (except for the first term)\n    }\n\n    if (coeff < 0) {\n      term += \"-\"; // Add - sign for negative coefficients\n      coeff = -coeff; // Convert to positive for display\n    }\n\n    // Append the coefficient if it's not 1 or if it's the constant term (exp == 0)\n    if (coeff != 1 || exp == 0) {\n      term += coeff.toString();\n    }\n\n    if (exp > 0) {\n      term += \"x\"; // Append the variable x\n    }\n\n    if (exp > 1) {\n      term += \"^$exp\"; // Append the exponent if greater than 1\n    }\n\n    polynomial.write(term); // Add the term to the polynomial\n  }\n\n  return polynomial.toString();\n}", "test": "void testFormatPolynomial() {\n  // Test case 1: Polynomial with positive and negative coefficients, and zero coefficients\n  assert(\n    formatPolynomial([3, -2, 0, 1]) == \"3x^3-2x^2+1\",\n    'Test Case 1 Failed: Expected polynomial string to be \"3x^3-2x^2+x\", got \"${formatPolynomial([3, -2, 0, 1])}\"'\n  );\n\n  // Test case 2: Polynomial with all positive coefficients\n  assert(\n    formatPolynomial([1, 2, 3]) == \"x^2+2x+3\",\n    'Test Case 2 Failed: Expected polynomial string to be \"x^2+2x+3\", got \"${formatPolynomial([1, 2, 3])}\"'\n  );\n\n  // Test case 3: Polynomial with a single constant term\n  assert(\n    formatPolynomial([5]) == \"5\",\n    'Test Case 3 Failed: Expected polynomial string to be \"5\", got \"${formatPolynomial([5])}\"'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testFormatPolynomial();\n}", "entry_point": "formatPolynomial", "signature": "String formatPolynomial(List<int> coefficients)", "docstring": "Formats a list of coefficients into a string representation of a polynomial.\n\nThis function takes a list of integer coefficients and returns a string that represents\nthe corresponding polynomial. Coefficients are listed in descending order of their degree.\nZero coefficients are skipped, and the powers of 'x' are included only where necessary.\nThe output polynomial does not contain unnecessary plus or minus signs and avoids using\nthe coefficient '1' where it is implied, except for the constant term.\n\nArguments:\ncoefficients (List<int>): A list of integer coefficients for the polynomial.\n\nReturns:\nString: A string representation of the polynomial.\n\nExamples:\n1. formatPolynomial([1, 0, -4, 3])\n- Given the coefficients for the polynomial x^3 - 4x + 3, the function will return\nthe string \"x^3-4x+3\".\n\n2. formatPolynomial([-3, 1])\n- For the polynomial -3x + 1, the function will return the string \"-3x+1\".\n\n3. formatPolynomial([2, -1, 0, 0, 5])\n- For the polynomial 2x^4 - x^3 + 5, the output will be \"2x^4-x^3+5\", omitting\nthe zero coefficients.\n\n4. formatPolynomial([0, 0, 0, 1])\n- If only the constant term is non-zero, for example 1, the function returns \"1\",\nwithout any variables or powers.\n\n5. formatPolynomial([0])\n- For a list with a single zero coefficient, the function will return an empty\nstring, as the polynomial has no non-zero terms.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFormats a list of coefficients into a string representation of a polynomial.\n\nThis function takes a list of integer coefficients and returns a string that represents\nthe corresponding polynomial. Coefficients are listed in descending order of their degree.\nZero coefficients are skipped, and the powers of 'x' are included only where necessary.\nThe output polynomial does not contain unnecessary plus or minus signs and avoids using\nthe coefficient '1' where it is implied, except for the constant term.\n\nArguments:\ncoefficients (List<int>): A list of integer coefficients for the polynomial.\n\nReturns:\nString: A string representation of the polynomial.\n\nExamples:\n1. formatPolynomial([1, 0, -4, 3])\n- Given the coefficients for the polynomial x^3 - 4x + 3, the function will return\nthe string \"x^3-4x+3\".\n\n2. formatPolynomial([-3, 1])\n- For the polynomial -3x + 1, the function will return the string \"-3x+1\".\n\n3. formatPolynomial([2, -1, 0, 0, 5])\n- For the polynomial 2x^4 - x^3 + 5, the output will be \"2x^4-x^3+5\", omitting\nthe zero coefficients.\n\n4. formatPolynomial([0, 0, 0, 1])\n- If only the constant term is non-zero, for example 1, the function returns \"1\",\nwithout any variables or powers.\n\n5. formatPolynomial([0])\n- For a list with a single zero coefficient, the function will return an empty\nstring, as the polynomial has no non-zero terms.\n\n* Incomplete Code:\nString formatPolynomial(List<int> coefficients)\n{\n  StringBuffer polynomial = StringBuffer();\n  int degree = coefficients.length - 1;\n\n  for (int i = 0; i < coefficients.length; i++) {\n    int coeff = coefficients[i];\n[MASK]\n\n[MASK]\n    String term = \"\";\n\n    if (coeff > 0 && polynomial.isNotEmpty) {\n      term += \"+\"; // Add + sign for positive coefficients (except for the first term)\n    }\n\n    if (coeff < 0) {\n      term += \"-\"; // Add - sign for negative coefficients\n[MASK]\n    }\n\n    // Append the coefficient if it's not 1 or if it's the constant term (exp == 0)\n    if (coeff != 1 || exp == 0) {\n      term += coeff.toString();\n    }\n\n    if (exp > 0) {\n      term += \"x\"; // Append the variable x\n    }\n\n[MASK]\n[MASK]\n    }\n\n    polynomial.write(term); // Add the term to the polynomial\n  }\n\n  return polynomial.toString();\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  StringBuffer polynomial = StringBuffer();\n  int degree = coefficients.length - 1;\n\n  for (int i = 0; i < coefficients.length; i++) {\n    int coeff = coefficients[i];\n[MASK]\n\n[MASK]\n    String term = \"\";\n\n    if (coeff > 0 && polynomial.isNotEmpty) {\n      term += \"+\"; // Add + sign for positive coefficients (except for the first term)\n    }\n\n    if (coeff < 0) {\n      term += \"-\"; // Add - sign for negative coefficients\n[MASK]\n    }\n\n    // Append the coefficient if it's not 1 or if it's the constant term (exp == 0)\n    if (coeff != 1 || exp == 0) {\n      term += coeff.toString();\n    }\n\n    if (exp > 0) {\n      term += \"x\"; // Append the variable x\n    }\n\n[MASK]\n[MASK]\n    }\n\n    polynomial.write(term); // Add the term to the polynomial\n  }\n\n  return polynomial.toString();\n}"}
{"task_id": "Dart/17-1-multi", "prompt": "String formatPolynomial(List<int> coefficients)\n\n/// Formats a list of coefficients into a string representation of a polynomial.\n///\n/// This function takes a list of integer coefficients and returns a string that represents\n/// the corresponding polynomial. Coefficients are listed in descending order of their degree.\n/// Zero coefficients are skipped, and the powers of 'x' are included only where necessary.\n/// The output polynomial does not contain unnecessary plus or minus signs and avoids using\n/// the coefficient '1' where it is implied, except for the constant term.\n///\n/// Arguments:\n///   coefficients (List<int>): A list of integer coefficients for the polynomial.\n///\n/// Returns:\n///   String: A string representation of the polynomial.\n///\n/// Examples:\n///   1. formatPolynomial([1, 0, -4, 3])\n///      - Given the coefficients for the polynomial x^3 - 4x + 3, the function will return\n///        the string \"x^3-4x+3\".\n///\n///   2. formatPolynomial([-3, 1])\n///      - For the polynomial -3x + 1, the function will return the string \"-3x+1\".\n///\n///   3. formatPolynomial([2, -1, 0, 0, 5])\n///      - For the polynomial 2x^4 - x^3 + 5, the output will be \"2x^4-x^3+5\", omitting\n///        the zero coefficients.\n///\n///   4. formatPolynomial([0, 0, 0, 1])\n///      - If only the constant term is non-zero, for example 1, the function returns \"1\",\n///        without any variables or powers.\n///\n///   5. formatPolynomial([0])\n///      - For a list with a single zero coefficient, the function will return an empty\n///        string, as the polynomial has no non-zero terms.", "canonical_solution": "{\n  StringBuffer polynomial = StringBuffer();\n  int degree = coefficients.length - 1;\n\n  for (int i = 0; i < coefficients.length; i++) {\n    int coeff = coefficients[i];\n    if (coeff == 0) continue; // Skip zero coefficients\n\n    int exp = degree - i; // Exponent for the current term\n    String term = \"\";\n\n    if (coeff > 0 && polynomial.isNotEmpty) {\n      term += \"+\"; // Add + sign for positive coefficients (except for the first term)\n    }\n\n    if (coeff < 0) {\n      term += \"-\"; // Add - sign for negative coefficients\n      coeff = -coeff; // Convert to positive for display\n    }\n\n    // Append the coefficient if it's not 1 or if it's the constant term (exp == 0)\n    if (coeff != 1 || exp == 0) {\n      term += coeff.toString();\n    }\n\n    if (exp > 0) {\n      term += \"x\"; // Append the variable x\n    }\n\n    if (exp > 1) {\n      term += \"^$exp\"; // Append the exponent if greater than 1\n    }\n\n    polynomial.write(term); // Add the term to the polynomial\n  }\n\n  return polynomial.toString();\n}", "test": "void testFormatPolynomial() {\n  // Test case 1: Polynomial with positive and negative coefficients, and zero coefficients\n  assert(\n    formatPolynomial([3, -2, 0, 1]) == \"3x^3-2x^2+1\",\n    'Test Case 1 Failed: Expected polynomial string to be \"3x^3-2x^2+x\", got \"${formatPolynomial([3, -2, 0, 1])}\"'\n  );\n\n  // Test case 2: Polynomial with all positive coefficients\n  assert(\n    formatPolynomial([1, 2, 3]) == \"x^2+2x+3\",\n    'Test Case 2 Failed: Expected polynomial string to be \"x^2+2x+3\", got \"${formatPolynomial([1, 2, 3])}\"'\n  );\n\n  // Test case 3: Polynomial with a single constant term\n  assert(\n    formatPolynomial([5]) == \"5\",\n    'Test Case 3 Failed: Expected polynomial string to be \"5\", got \"${formatPolynomial([5])}\"'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testFormatPolynomial();\n}", "entry_point": "formatPolynomial", "signature": "String formatPolynomial(List<int> coefficients)", "docstring": "Formats a list of coefficients into a string representation of a polynomial.\n\nThis function takes a list of integer coefficients and returns a string that represents\nthe corresponding polynomial. Coefficients are listed in descending order of their degree.\nZero coefficients are skipped, and the powers of 'x' are included only where necessary.\nThe output polynomial does not contain unnecessary plus or minus signs and avoids using\nthe coefficient '1' where it is implied, except for the constant term.\n\nArguments:\ncoefficients (List<int>): A list of integer coefficients for the polynomial.\n\nReturns:\nString: A string representation of the polynomial.\n\nExamples:\n1. formatPolynomial([1, 0, -4, 3])\n- Given the coefficients for the polynomial x^3 - 4x + 3, the function will return\nthe string \"x^3-4x+3\".\n\n2. formatPolynomial([-3, 1])\n- For the polynomial -3x + 1, the function will return the string \"-3x+1\".\n\n3. formatPolynomial([2, -1, 0, 0, 5])\n- For the polynomial 2x^4 - x^3 + 5, the output will be \"2x^4-x^3+5\", omitting\nthe zero coefficients.\n\n4. formatPolynomial([0, 0, 0, 1])\n- If only the constant term is non-zero, for example 1, the function returns \"1\",\nwithout any variables or powers.\n\n5. formatPolynomial([0])\n- For a list with a single zero coefficient, the function will return an empty\nstring, as the polynomial has no non-zero terms.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFormats a list of coefficients into a string representation of a polynomial.\n\nThis function takes a list of integer coefficients and returns a string that represents\nthe corresponding polynomial. Coefficients are listed in descending order of their degree.\nZero coefficients are skipped, and the powers of 'x' are included only where necessary.\nThe output polynomial does not contain unnecessary plus or minus signs and avoids using\nthe coefficient '1' where it is implied, except for the constant term.\n\nArguments:\ncoefficients (List<int>): A list of integer coefficients for the polynomial.\n\nReturns:\nString: A string representation of the polynomial.\n\nExamples:\n1. formatPolynomial([1, 0, -4, 3])\n- Given the coefficients for the polynomial x^3 - 4x + 3, the function will return\nthe string \"x^3-4x+3\".\n\n2. formatPolynomial([-3, 1])\n- For the polynomial -3x + 1, the function will return the string \"-3x+1\".\n\n3. formatPolynomial([2, -1, 0, 0, 5])\n- For the polynomial 2x^4 - x^3 + 5, the output will be \"2x^4-x^3+5\", omitting\nthe zero coefficients.\n\n4. formatPolynomial([0, 0, 0, 1])\n- If only the constant term is non-zero, for example 1, the function returns \"1\",\nwithout any variables or powers.\n\n5. formatPolynomial([0])\n- For a list with a single zero coefficient, the function will return an empty\nstring, as the polynomial has no non-zero terms.\n\n* Incomplete Code:\nString formatPolynomial(List<int> coefficients)\n{\n  StringBuffer polynomial = StringBuffer();\n  int degree = coefficients.length - 1;\n\n  for (int i = 0; i < coefficients.length; i++) {\n    int coeff = coefficients[i];\n    if (coeff == 0) continue; // Skip zero coefficients\n\n    int exp = degree - i; // Exponent for the current term\n    String term = \"\";\n\n    if (coeff > 0 && polynomial.isNotEmpty) {\n[MASK]\n    }\n\n    if (coeff < 0) {\n      term += \"-\"; // Add - sign for negative coefficients\n      coeff = -coeff; // Convert to positive for display\n    }\n\n    // Append the coefficient if it's not 1 or if it's the constant term (exp == 0)\n    if (coeff != 1 || exp == 0) {\n      term += coeff.toString();\n    }\n\n    if (exp > 0) {\n[MASK]\n    }\n\n    if (exp > 1) {\n      term += \"^$exp\"; // Append the exponent if greater than 1\n    }\n\n    polynomial.write(term); // Add the term to the polynomial\n  }\n\n  return polynomial.toString();\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  StringBuffer polynomial = StringBuffer();\n  int degree = coefficients.length - 1;\n\n  for (int i = 0; i < coefficients.length; i++) {\n    int coeff = coefficients[i];\n    if (coeff == 0) continue; // Skip zero coefficients\n\n    int exp = degree - i; // Exponent for the current term\n    String term = \"\";\n\n    if (coeff > 0 && polynomial.isNotEmpty) {\n[MASK]\n    }\n\n    if (coeff < 0) {\n      term += \"-\"; // Add - sign for negative coefficients\n      coeff = -coeff; // Convert to positive for display\n    }\n\n    // Append the coefficient if it's not 1 or if it's the constant term (exp == 0)\n    if (coeff != 1 || exp == 0) {\n      term += coeff.toString();\n    }\n\n    if (exp > 0) {\n[MASK]\n    }\n\n    if (exp > 1) {\n      term += \"^$exp\"; // Append the exponent if greater than 1\n    }\n\n    polynomial.write(term); // Add the term to the polynomial\n  }\n\n  return polynomial.toString();\n}"}
{"task_id": "Dart/18-0-multi", "prompt": "List<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)\n/**\n * Sorts and filters a list of applicants based on their scores and an interview cutoff line.\n * \n * The function accepts a list of applicant records, where each record is a list containing\n * two integers: the applicant's number and their examination score. The function sorts the \n * applicants primarily by score in descending order and secondarily by applicant number in \n * ascending order. It then filters the applicants to include only those whose scores meet \n * or exceed the score of the applicant at the interview cutoff line, which is determined \n * as the score of the applicant ranked at position `m * 1.5` (floored). The final list\n * contains all applicants who have made it past the cutoff line.\n * \n * @param applicants A list of lists where each inner list contains two integers representing\n *                   an applicant's number and score, respectively.\n * @param m          An integer representing the number of positions available for interview.\n * \n * @return A list of applicants who have scores greater than or equal to the interview line score.\n * \n * Example cases:\n * \n * Case 1: No applicants are filtered out because all have scores above the cutoff.\n * Input: applicants = [[1, 90], [2, 85], [3, 80]], m = 2\n * Output: [[1, 90], [2, 85]]\n * \n * Case 2: One applicant is filtered out based on the cutoff score.\n * Input: applicants = [[3, 70], [1, 95], [2, 90]], m = 1\n * Output: [[1, 95], [2, 90]]\n * \n * Case 3: Applicants are sorted by score and then by applicant number, and some are filtered out.\n * Input: applicants = [[5, 85], [2, 85], [1, 90], [3, 80], [4, 85]], m = 2\n * Output: [[1, 90], [2, 85], [4, 85], [5, 85]]\n * \n * Note: The output lists only contain applicants who score at or above the cutoff line score,\n * and the ordering is from the highest score to the lowest score, and within the same score,\n * from the lowest applicant number to the highest.\n */", "canonical_solution": "{\n  // Sort the applicants based on score and then by applicant number\n  applicants.sort((a, b) => b[1] != a[1] ? b[1].compareTo(a[1]) : a[0].compareTo(b[0]));\n  int interviewLineIndex = (m * 1.5).floor() - 1;\n  int interviewLineScore = applicants[interviewLineIndex][1];\n  // Find all applicants who have a score >= interview line score\n  return applicants.where((applicant) => applicant[1] >= interviewLineScore).toList();\n}", "test": "void testSortAndFilterApplicants() {\n  // Test case 1: Basic test with already sorted applicants\n  List<List<int>> applicants1 = [\n    [1, 90],\n    [2, 85],\n    [3, 80],\n  ];\n  List<List<int>> expected1 = [[1, 90], [2, 85], [3, 80]];\n  assert(sortAndFilterApplicants(applicants1, 2).toString() == expected1.toString());\n\n  // Test case 2: Test with unsorted applicants and a cutoff that excludes some applicants\n  List<List<int>> applicants2 = [\n    [3, 70],\n    [1, 95],\n    [2, 90],\n  ];\n  List<List<int>> expected2 = [[1, 95]];\n  assert(sortAndFilterApplicants(applicants2, 1).toString() == expected2.toString());\n\n  // Test case 3: Test with a tie on scores\n  List<List<int>> applicants3 = [\n    [5, 85],\n    [2, 85],\n    [1, 90],\n    [3, 80],\n    [4, 85],\n  ];\n  List<List<int>> expected3 = [\n    [1, 90],\n    [2, 85],\n    [4, 85],\n    [5, 85],\n  ];\n  assert(sortAndFilterApplicants(applicants3, 2).toString() == expected3.toString());\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testSortAndFilterApplicants();\n}", "entry_point": "sortAndFilterApplicants", "signature": "List<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)", "docstring": "Sorts and filters a list of applicants based on their scores and an interview cutoff line.\n  \n  The function accepts a list of applicant records, where each record is a list containing\n  two integers: the applicant's number and their examination score. The function sorts the \n  applicants primarily by score in descending order and secondarily by applicant number in \n  ascending order. It then filters the applicants to include only those whose scores meet \n  or exceed the score of the applicant at the interview cutoff line, which is determined \n  as the score of the applicant ranked at position `m  1.5` (floored). The final list\n  contains all applicants who have made it past the cutoff line.\n  \n  @param applicants A list of lists where each inner list contains two integers representing\n                    an applicant's number and score, respectively.\n  @param m          An integer representing the number of positions available for interview.\n  \n  @return A list of applicants who have scores greater than or equal to the interview line score.\n  \n  Example cases:\n  \n  Case 1: No applicants are filtered out because all have scores above the cutoff.\n  Input: applicants = [[1, 90], [2, 85], [3, 80]], m = 2\n  Output: [[1, 90], [2, 85]]\n  \n  Case 2: One applicant is filtered out based on the cutoff score.\n  Input: applicants = [[3, 70], [1, 95], [2, 90]], m = 1\n  Output: [[1, 95], [2, 90]]\n  \n  Case 3: Applicants are sorted by score and then by applicant number, and some are filtered out.\n  Input: applicants = [[5, 85], [2, 85], [1, 90], [3, 80], [4, 85]], m = 2\n  Output: [[1, 90], [2, 85], [4, 85], [5, 85]]\n  \n  Note: The output lists only contain applicants who score at or above the cutoff line score,\n  and the ordering is from the highest score to the lowest score, and within the same score,\n  from the lowest applicant number to the highest.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nSorts and filters a list of applicants based on their scores and an interview cutoff line.\n  \n  The function accepts a list of applicant records, where each record is a list containing\n  two integers: the applicant's number and their examination score. The function sorts the \n  applicants primarily by score in descending order and secondarily by applicant number in \n  ascending order. It then filters the applicants to include only those whose scores meet \n  or exceed the score of the applicant at the interview cutoff line, which is determined \n  as the score of the applicant ranked at position `m  1.5` (floored). The final list\n  contains all applicants who have made it past the cutoff line.\n  \n  @param applicants A list of lists where each inner list contains two integers representing\n                    an applicant's number and score, respectively.\n  @param m          An integer representing the number of positions available for interview.\n  \n  @return A list of applicants who have scores greater than or equal to the interview line score.\n  \n  Example cases:\n  \n  Case 1: No applicants are filtered out because all have scores above the cutoff.\n  Input: applicants = [[1, 90], [2, 85], [3, 80]], m = 2\n  Output: [[1, 90], [2, 85]]\n  \n  Case 2: One applicant is filtered out based on the cutoff score.\n  Input: applicants = [[3, 70], [1, 95], [2, 90]], m = 1\n  Output: [[1, 95], [2, 90]]\n  \n  Case 3: Applicants are sorted by score and then by applicant number, and some are filtered out.\n  Input: applicants = [[5, 85], [2, 85], [1, 90], [3, 80], [4, 85]], m = 2\n  Output: [[1, 90], [2, 85], [4, 85], [5, 85]]\n  \n  Note: The output lists only contain applicants who score at or above the cutoff line score,\n  and the ordering is from the highest score to the lowest score, and within the same score,\n  from the lowest applicant number to the highest.\n\n* Incomplete Code:\nList<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)\n{\n  // Sort the applicants based on score and then by applicant number\n  applicants.sort((a, b) => b[1] != a[1] ? b[1].compareTo(a[1]) : a[0].compareTo(b[0]));\n  int interviewLineIndex = (m * 1.5).floor() - 1;\n[MASK]\n  // Find all applicants who have a score >= interview line score\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Sort the applicants based on score and then by applicant number\n  applicants.sort((a, b) => b[1] != a[1] ? b[1].compareTo(a[1]) : a[0].compareTo(b[0]));\n  int interviewLineIndex = (m * 1.5).floor() - 1;\n[MASK]\n  // Find all applicants who have a score >= interview line score\n[MASK]\n}"}
{"task_id": "Dart/18-1-multi", "prompt": "List<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)\n/**\n * Sorts and filters a list of applicants based on their scores and an interview cutoff line.\n * \n * The function accepts a list of applicant records, where each record is a list containing\n * two integers: the applicant's number and their examination score. The function sorts the \n * applicants primarily by score in descending order and secondarily by applicant number in \n * ascending order. It then filters the applicants to include only those whose scores meet \n * or exceed the score of the applicant at the interview cutoff line, which is determined \n * as the score of the applicant ranked at position `m * 1.5` (floored). The final list\n * contains all applicants who have made it past the cutoff line.\n * \n * @param applicants A list of lists where each inner list contains two integers representing\n *                   an applicant's number and score, respectively.\n * @param m          An integer representing the number of positions available for interview.\n * \n * @return A list of applicants who have scores greater than or equal to the interview line score.\n * \n * Example cases:\n * \n * Case 1: No applicants are filtered out because all have scores above the cutoff.\n * Input: applicants = [[1, 90], [2, 85], [3, 80]], m = 2\n * Output: [[1, 90], [2, 85]]\n * \n * Case 2: One applicant is filtered out based on the cutoff score.\n * Input: applicants = [[3, 70], [1, 95], [2, 90]], m = 1\n * Output: [[1, 95], [2, 90]]\n * \n * Case 3: Applicants are sorted by score and then by applicant number, and some are filtered out.\n * Input: applicants = [[5, 85], [2, 85], [1, 90], [3, 80], [4, 85]], m = 2\n * Output: [[1, 90], [2, 85], [4, 85], [5, 85]]\n * \n * Note: The output lists only contain applicants who score at or above the cutoff line score,\n * and the ordering is from the highest score to the lowest score, and within the same score,\n * from the lowest applicant number to the highest.\n */", "canonical_solution": "{\n  // Sort the applicants based on score and then by applicant number\n  applicants.sort((a, b) => b[1] != a[1] ? b[1].compareTo(a[1]) : a[0].compareTo(b[0]));\n  int interviewLineIndex = (m * 1.5).floor() - 1;\n  int interviewLineScore = applicants[interviewLineIndex][1];\n  // Find all applicants who have a score >= interview line score\n  return applicants.where((applicant) => applicant[1] >= interviewLineScore).toList();\n}", "test": "void testSortAndFilterApplicants() {\n  // Test case 1: Basic test with already sorted applicants\n  List<List<int>> applicants1 = [\n    [1, 90],\n    [2, 85],\n    [3, 80],\n  ];\n  List<List<int>> expected1 = [[1, 90], [2, 85], [3, 80]];\n  assert(sortAndFilterApplicants(applicants1, 2).toString() == expected1.toString());\n\n  // Test case 2: Test with unsorted applicants and a cutoff that excludes some applicants\n  List<List<int>> applicants2 = [\n    [3, 70],\n    [1, 95],\n    [2, 90],\n  ];\n  List<List<int>> expected2 = [[1, 95]];\n  assert(sortAndFilterApplicants(applicants2, 1).toString() == expected2.toString());\n\n  // Test case 3: Test with a tie on scores\n  List<List<int>> applicants3 = [\n    [5, 85],\n    [2, 85],\n    [1, 90],\n    [3, 80],\n    [4, 85],\n  ];\n  List<List<int>> expected3 = [\n    [1, 90],\n    [2, 85],\n    [4, 85],\n    [5, 85],\n  ];\n  assert(sortAndFilterApplicants(applicants3, 2).toString() == expected3.toString());\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testSortAndFilterApplicants();\n}", "entry_point": "sortAndFilterApplicants", "signature": "List<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)", "docstring": "Sorts and filters a list of applicants based on their scores and an interview cutoff line.\n  \n  The function accepts a list of applicant records, where each record is a list containing\n  two integers: the applicant's number and their examination score. The function sorts the \n  applicants primarily by score in descending order and secondarily by applicant number in \n  ascending order. It then filters the applicants to include only those whose scores meet \n  or exceed the score of the applicant at the interview cutoff line, which is determined \n  as the score of the applicant ranked at position `m  1.5` (floored). The final list\n  contains all applicants who have made it past the cutoff line.\n  \n  @param applicants A list of lists where each inner list contains two integers representing\n                    an applicant's number and score, respectively.\n  @param m          An integer representing the number of positions available for interview.\n  \n  @return A list of applicants who have scores greater than or equal to the interview line score.\n  \n  Example cases:\n  \n  Case 1: No applicants are filtered out because all have scores above the cutoff.\n  Input: applicants = [[1, 90], [2, 85], [3, 80]], m = 2\n  Output: [[1, 90], [2, 85]]\n  \n  Case 2: One applicant is filtered out based on the cutoff score.\n  Input: applicants = [[3, 70], [1, 95], [2, 90]], m = 1\n  Output: [[1, 95], [2, 90]]\n  \n  Case 3: Applicants are sorted by score and then by applicant number, and some are filtered out.\n  Input: applicants = [[5, 85], [2, 85], [1, 90], [3, 80], [4, 85]], m = 2\n  Output: [[1, 90], [2, 85], [4, 85], [5, 85]]\n  \n  Note: The output lists only contain applicants who score at or above the cutoff line score,\n  and the ordering is from the highest score to the lowest score, and within the same score,\n  from the lowest applicant number to the highest.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nSorts and filters a list of applicants based on their scores and an interview cutoff line.\n  \n  The function accepts a list of applicant records, where each record is a list containing\n  two integers: the applicant's number and their examination score. The function sorts the \n  applicants primarily by score in descending order and secondarily by applicant number in \n  ascending order. It then filters the applicants to include only those whose scores meet \n  or exceed the score of the applicant at the interview cutoff line, which is determined \n  as the score of the applicant ranked at position `m  1.5` (floored). The final list\n  contains all applicants who have made it past the cutoff line.\n  \n  @param applicants A list of lists where each inner list contains two integers representing\n                    an applicant's number and score, respectively.\n  @param m          An integer representing the number of positions available for interview.\n  \n  @return A list of applicants who have scores greater than or equal to the interview line score.\n  \n  Example cases:\n  \n  Case 1: No applicants are filtered out because all have scores above the cutoff.\n  Input: applicants = [[1, 90], [2, 85], [3, 80]], m = 2\n  Output: [[1, 90], [2, 85]]\n  \n  Case 2: One applicant is filtered out based on the cutoff score.\n  Input: applicants = [[3, 70], [1, 95], [2, 90]], m = 1\n  Output: [[1, 95], [2, 90]]\n  \n  Case 3: Applicants are sorted by score and then by applicant number, and some are filtered out.\n  Input: applicants = [[5, 85], [2, 85], [1, 90], [3, 80], [4, 85]], m = 2\n  Output: [[1, 90], [2, 85], [4, 85], [5, 85]]\n  \n  Note: The output lists only contain applicants who score at or above the cutoff line score,\n  and the ordering is from the highest score to the lowest score, and within the same score,\n  from the lowest applicant number to the highest.\n\n* Incomplete Code:\nList<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)\n{\n  // Sort the applicants based on score and then by applicant number\n[MASK]\n  int interviewLineIndex = (m * 1.5).floor() - 1;\n  int interviewLineScore = applicants[interviewLineIndex][1];\n  // Find all applicants who have a score >= interview line score\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Sort the applicants based on score and then by applicant number\n[MASK]\n  int interviewLineIndex = (m * 1.5).floor() - 1;\n  int interviewLineScore = applicants[interviewLineIndex][1];\n  // Find all applicants who have a score >= interview line score\n[MASK]\n}"}
{"task_id": "Dart/20-0-multi", "prompt": "import 'dart:math';\n\nint findLargerPrimeFactor(int n)\n\n/// Finds the larger prime factor of a given integer.\n///\n/// This function takes an integer `n` and returns its larger prime factor.\n/// It starts by checking from the smallest prime number, 2, and continues\n/// up to the square root of `n`. If a factor is found, it returns the\n/// complementary factor, which is guaranteed to be larger. If `n` is prime\n/// or 1, it returns `n` itself.\n///\n/// Args:\n///   int n: The integer to find the larger prime factor of.\n///\n/// Returns:\n///   The larger prime factor of `n` if it exists, otherwise `n` itself.\n///\n/// Examples:\n///   findLargerPrimeFactor(1) returns 1, as 1 is not considered prime and has no prime factors.\n///   findLargerPrimeFactor(15) returns 5, since 15 = 3 * 5 and 5 is the larger factor.\n///   findLargerPrimeFactor(29) returns 29, since 29 is prime and has no factors other than itself.\n///\n/// Note:\n///   The function assumes that `n` is a positive integer.\n///   The function may not correctly identify the larger prime factor if `n` is a product of more than two primes.", "canonical_solution": "{\n  // Handle the edge case if n is 1\n  if (n == 1) return 1;\n\n  // Start checking for factors from 2 upwards\n  for (int i = 2; i <= sqrt(n); i++) {\n    // If i is a factor of n, it means n / i is the other factor\n    if (n % i == 0) {\n      // Since n is a product of two primes, the larger factor is n / i\n      return n ~/ i;\n    }\n  }\n\n  // If no factors are found, n itself is a prime number\n  return n;\n}", "test": "void main() {\n  testFindLargerPrimeFactor();\n}\n\nvoid testFindLargerPrimeFactor() {\n  // Test case 1: Testing with a composite number which is a product of two primes\n  assert(findLargerPrimeFactor(14) == 7, 'Test case 1 failed');\n\n  // Test case 2: Testing with a prime number (should return the number itself)\n  assert(findLargerPrimeFactor(13) == 13, 'Test case 2 failed');\n\n  // Test case 3: Testing with a composite number with a non-prime factor\n  assert(findLargerPrimeFactor(49) == 7, 'Test case 3 failed');\n\n  // Add more cases if needed\n  // ...\n\n  print('All test cases passed!');\n}", "entry_point": "findLargerPrimeFactor", "signature": "int findLargerPrimeFactor(int n)", "docstring": "Finds the larger prime factor of a given integer.\n\nThis function takes an integer `n` and returns its larger prime factor.\nIt starts by checking from the smallest prime number, 2, and continues\nup to the square root of `n`. If a factor is found, it returns the\ncomplementary factor, which is guaranteed to be larger. If `n` is prime\nor 1, it returns `n` itself.\n\nArgs:\nint n: The integer to find the larger prime factor of.\n\nReturns:\nThe larger prime factor of `n` if it exists, otherwise `n` itself.\n\nExamples:\nfindLargerPrimeFactor(1) returns 1, as 1 is not considered prime and has no prime factors.\nfindLargerPrimeFactor(15) returns 5, since 15 = 3 * 5 and 5 is the larger factor.\nfindLargerPrimeFactor(29) returns 29, since 29 is prime and has no factors other than itself.\n\nNote:\nThe function assumes that `n` is a positive integer.\nThe function may not correctly identify the larger prime factor if `n` is a product of more than two primes.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds the larger prime factor of a given integer.\n\nThis function takes an integer `n` and returns its larger prime factor.\nIt starts by checking from the smallest prime number, 2, and continues\nup to the square root of `n`. If a factor is found, it returns the\ncomplementary factor, which is guaranteed to be larger. If `n` is prime\nor 1, it returns `n` itself.\n\nArgs:\nint n: The integer to find the larger prime factor of.\n\nReturns:\nThe larger prime factor of `n` if it exists, otherwise `n` itself.\n\nExamples:\nfindLargerPrimeFactor(1) returns 1, as 1 is not considered prime and has no prime factors.\nfindLargerPrimeFactor(15) returns 5, since 15 = 3 * 5 and 5 is the larger factor.\nfindLargerPrimeFactor(29) returns 29, since 29 is prime and has no factors other than itself.\n\nNote:\nThe function assumes that `n` is a positive integer.\nThe function may not correctly identify the larger prime factor if `n` is a product of more than two primes.\n\n* Incomplete Code:\nint findLargerPrimeFactor(int n)\n{\n  // Handle the edge case if n is 1\n[MASK]\n\n  // Start checking for factors from 2 upwards\n[MASK]\n    // If i is a factor of n, it means n / i is the other factor\n[MASK]\n      // Since n is a product of two primes, the larger factor is n / i\n      return n ~/ i;\n    }\n  }\n\n  // If no factors are found, n itself is a prime number\n  return n;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Handle the edge case if n is 1\n[MASK]\n\n  // Start checking for factors from 2 upwards\n[MASK]\n    // If i is a factor of n, it means n / i is the other factor\n[MASK]\n      // Since n is a product of two primes, the larger factor is n / i\n      return n ~/ i;\n    }\n  }\n\n  // If no factors are found, n itself is a prime number\n  return n;\n}"}
{"task_id": "Dart/20-1-multi", "prompt": "import 'dart:math';\n\nint findLargerPrimeFactor(int n)\n\n/// Finds the larger prime factor of a given integer.\n///\n/// This function takes an integer `n` and returns its larger prime factor.\n/// It starts by checking from the smallest prime number, 2, and continues\n/// up to the square root of `n`. If a factor is found, it returns the\n/// complementary factor, which is guaranteed to be larger. If `n` is prime\n/// or 1, it returns `n` itself.\n///\n/// Args:\n///   int n: The integer to find the larger prime factor of.\n///\n/// Returns:\n///   The larger prime factor of `n` if it exists, otherwise `n` itself.\n///\n/// Examples:\n///   findLargerPrimeFactor(1) returns 1, as 1 is not considered prime and has no prime factors.\n///   findLargerPrimeFactor(15) returns 5, since 15 = 3 * 5 and 5 is the larger factor.\n///   findLargerPrimeFactor(29) returns 29, since 29 is prime and has no factors other than itself.\n///\n/// Note:\n///   The function assumes that `n` is a positive integer.\n///   The function may not correctly identify the larger prime factor if `n` is a product of more than two primes.", "canonical_solution": "{\n  // Handle the edge case if n is 1\n  if (n == 1) return 1;\n\n  // Start checking for factors from 2 upwards\n  for (int i = 2; i <= sqrt(n); i++) {\n    // If i is a factor of n, it means n / i is the other factor\n    if (n % i == 0) {\n      // Since n is a product of two primes, the larger factor is n / i\n      return n ~/ i;\n    }\n  }\n\n  // If no factors are found, n itself is a prime number\n  return n;\n}", "test": "void main() {\n  testFindLargerPrimeFactor();\n}\n\nvoid testFindLargerPrimeFactor() {\n  // Test case 1: Testing with a composite number which is a product of two primes\n  assert(findLargerPrimeFactor(14) == 7, 'Test case 1 failed');\n\n  // Test case 2: Testing with a prime number (should return the number itself)\n  assert(findLargerPrimeFactor(13) == 13, 'Test case 2 failed');\n\n  // Test case 3: Testing with a composite number with a non-prime factor\n  assert(findLargerPrimeFactor(49) == 7, 'Test case 3 failed');\n\n  // Add more cases if needed\n  // ...\n\n  print('All test cases passed!');\n}", "entry_point": "findLargerPrimeFactor", "signature": "int findLargerPrimeFactor(int n)", "docstring": "Finds the larger prime factor of a given integer.\n\nThis function takes an integer `n` and returns its larger prime factor.\nIt starts by checking from the smallest prime number, 2, and continues\nup to the square root of `n`. If a factor is found, it returns the\ncomplementary factor, which is guaranteed to be larger. If `n` is prime\nor 1, it returns `n` itself.\n\nArgs:\nint n: The integer to find the larger prime factor of.\n\nReturns:\nThe larger prime factor of `n` if it exists, otherwise `n` itself.\n\nExamples:\nfindLargerPrimeFactor(1) returns 1, as 1 is not considered prime and has no prime factors.\nfindLargerPrimeFactor(15) returns 5, since 15 = 3 * 5 and 5 is the larger factor.\nfindLargerPrimeFactor(29) returns 29, since 29 is prime and has no factors other than itself.\n\nNote:\nThe function assumes that `n` is a positive integer.\nThe function may not correctly identify the larger prime factor if `n` is a product of more than two primes.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \nFinds the larger prime factor of a given integer.\n\nThis function takes an integer `n` and returns its larger prime factor.\nIt starts by checking from the smallest prime number, 2, and continues\nup to the square root of `n`. If a factor is found, it returns the\ncomplementary factor, which is guaranteed to be larger. If `n` is prime\nor 1, it returns `n` itself.\n\nArgs:\nint n: The integer to find the larger prime factor of.\n\nReturns:\nThe larger prime factor of `n` if it exists, otherwise `n` itself.\n\nExamples:\nfindLargerPrimeFactor(1) returns 1, as 1 is not considered prime and has no prime factors.\nfindLargerPrimeFactor(15) returns 5, since 15 = 3 * 5 and 5 is the larger factor.\nfindLargerPrimeFactor(29) returns 29, since 29 is prime and has no factors other than itself.\n\nNote:\nThe function assumes that `n` is a positive integer.\nThe function may not correctly identify the larger prime factor if `n` is a product of more than two primes.\n\n* Incomplete Code:\nint findLargerPrimeFactor(int n)\n{\n  // Handle the edge case if n is 1\n[MASK]\n\n  // Start checking for factors from 2 upwards\n  for (int i = 2; i <= sqrt(n); i++) {\n    // If i is a factor of n, it means n / i is the other factor\n[MASK]\n      // Since n is a product of two primes, the larger factor is n / i\n      return n ~/ i;\n    }\n  }\n\n  // If no factors are found, n itself is a prime number\n  return n;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Handle the edge case if n is 1\n[MASK]\n\n  // Start checking for factors from 2 upwards\n  for (int i = 2; i <= sqrt(n); i++) {\n    // If i is a factor of n, it means n / i is the other factor\n[MASK]\n      // Since n is a product of two primes, the larger factor is n / i\n      return n ~/ i;\n    }\n  }\n\n  // If no factors are found, n itself is a prime number\n  return n;\n}"}
{"task_id": "Dart/21-0-multi", "prompt": "\nimport 'package:collection/collection.dart';\nMap<dynamic, int> countOccurrences(List numbers)\n// ## Problem Description\n\n// Given that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\n\n// Now, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\n\n// ## Input Format\n\n// A single positive integer $k$.\n\n// ## Output Format\n\n// A single positive integer $n$.\n\n// ## Sample #1\n\n// ### Sample Input #1\n\n// ```\n// 1\n// ```\n\n// ### Sample Output #1\n\n// ```\n// 2\n// ```", "canonical_solution": "{\n  var countMap = <dynamic, int>{};\n  // 计算每个数字的出现次数\n  for (var num in numbers) {\n    if (!countMap.containsKey(num)) {\n      countMap[num] = 0;\n    }\n    countMap[num] = countMap[num]! + 1;\n  }\n\n  // 将Map转换为List，以便排序\n  var sortedNumbers = countMap.entries.toList()\n  // 对结果进行排序\n    ..sort((a, b) => a.key.compareTo(b.key));\n\n  // 将排序后的结果转换回期望的格式\n  return Map.fromEntries(sortedNumbers);\n}", "test": "void main() {\n\n  // 测试用例1：测试普通的数字列表\n  var testCase1 = [1, 2, 2, 3, 3, 3];\n  var expected1 = <dynamic, int>{1: 1, 2: 2, 3: 3}; // 明确指定类型\n  var result1 = countOccurrences(testCase1);\n  assert(DeepCollectionEquality().equals(result1, expected1), '测试用例1失败');\n\n  // 测试用例2：测试包含负数和零的列表\n  var testCase2 = [0, -1, -1, 2, 0, 2];\n  var expected2 = <dynamic, int>{-1: 2, 0: 2, 2: 2}; // 明确指定类型\n  var result2 = countOccurrences(testCase2);\n  assert(DeepCollectionEquality().equals(result2, expected2), '测试用例2失败');\n\n  // 测试用例3：测试空列表\n  var testCase3 = [];\n  var expected3 = <dynamic, int>{}; // 明确指定类型\n  var result3 = countOccurrences(testCase3);\n  assert(DeepCollectionEquality().equals(result3, expected3), '测试用例3失败');\n\n  print('所有测试用例通过！');\n}", "entry_point": "countOccurrences", "signature": "Map<dynamic, int> countOccurrences(List numbers)", "docstring": "## Problem Description\n\nGiven that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\n\nNow, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\n\n## Input Format\n\nA single positive integer $k$.\n\n## Output Format\n\nA single positive integer $n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n## Problem Description\n\nGiven that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\n\nNow, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\n\n## Input Format\n\nA single positive integer $k$.\n\n## Output Format\n\nA single positive integer $n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n* Incomplete Code:\nMap<dynamic, int> countOccurrences(List numbers)\n{\n[MASK]\n  // 计算每个数字的出现次数\n[MASK]\n    if (!countMap.containsKey(num)) {\n[MASK]\n    }\n    countMap[num] = countMap[num]! + 1;\n  }\n\n  // 将Map转换为List，以便排序\n[MASK]\n  // 对结果进行排序\n    ..sort((a, b) => a.key.compareTo(b.key));\n\n  // 将排序后的结果转换回期望的格式\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  // 计算每个数字的出现次数\n[MASK]\n    if (!countMap.containsKey(num)) {\n[MASK]\n    }\n    countMap[num] = countMap[num]! + 1;\n  }\n\n  // 将Map转换为List，以便排序\n[MASK]\n  // 对结果进行排序\n    ..sort((a, b) => a.key.compareTo(b.key));\n\n  // 将排序后的结果转换回期望的格式\n[MASK]\n}"}
{"task_id": "Dart/21-1-multi", "prompt": "\nimport 'package:collection/collection.dart';\nMap<dynamic, int> countOccurrences(List numbers)\n// ## Problem Description\n\n// Given that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\n\n// Now, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\n\n// ## Input Format\n\n// A single positive integer $k$.\n\n// ## Output Format\n\n// A single positive integer $n$.\n\n// ## Sample #1\n\n// ### Sample Input #1\n\n// ```\n// 1\n// ```\n\n// ### Sample Output #1\n\n// ```\n// 2\n// ```", "canonical_solution": "{\n  var countMap = <dynamic, int>{};\n  // 计算每个数字的出现次数\n  for (var num in numbers) {\n    if (!countMap.containsKey(num)) {\n      countMap[num] = 0;\n    }\n    countMap[num] = countMap[num]! + 1;\n  }\n\n  // 将Map转换为List，以便排序\n  var sortedNumbers = countMap.entries.toList()\n  // 对结果进行排序\n    ..sort((a, b) => a.key.compareTo(b.key));\n\n  // 将排序后的结果转换回期望的格式\n  return Map.fromEntries(sortedNumbers);\n}", "test": "void main() {\n\n  // 测试用例1：测试普通的数字列表\n  var testCase1 = [1, 2, 2, 3, 3, 3];\n  var expected1 = <dynamic, int>{1: 1, 2: 2, 3: 3}; // 明确指定类型\n  var result1 = countOccurrences(testCase1);\n  assert(DeepCollectionEquality().equals(result1, expected1), '测试用例1失败');\n\n  // 测试用例2：测试包含负数和零的列表\n  var testCase2 = [0, -1, -1, 2, 0, 2];\n  var expected2 = <dynamic, int>{-1: 2, 0: 2, 2: 2}; // 明确指定类型\n  var result2 = countOccurrences(testCase2);\n  assert(DeepCollectionEquality().equals(result2, expected2), '测试用例2失败');\n\n  // 测试用例3：测试空列表\n  var testCase3 = [];\n  var expected3 = <dynamic, int>{}; // 明确指定类型\n  var result3 = countOccurrences(testCase3);\n  assert(DeepCollectionEquality().equals(result3, expected3), '测试用例3失败');\n\n  print('所有测试用例通过！');\n}", "entry_point": "countOccurrences", "signature": "Map<dynamic, int> countOccurrences(List numbers)", "docstring": "## Problem Description\n\nGiven that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\n\nNow, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\n\n## Input Format\n\nA single positive integer $k$.\n\n## Output Format\n\nA single positive integer $n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n## Problem Description\n\nGiven that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\n\nNow, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\n\n## Input Format\n\nA single positive integer $k$.\n\n## Output Format\n\nA single positive integer $n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n* Incomplete Code:\nMap<dynamic, int> countOccurrences(List numbers)\n{\n  var countMap = <dynamic, int>{};\n  // 计算每个数字的出现次数\n  for (var num in numbers) {\n[MASK]\n      countMap[num] = 0;\n    }\n    countMap[num] = countMap[num]! + 1;\n  }\n\n  // 将Map转换为List，以便排序\n[MASK]\n  // 对结果进行排序\n    ..sort((a, b) => a.key.compareTo(b.key));\n\n  // 将排序后的结果转换回期望的格式\n  return Map.fromEntries(sortedNumbers);\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  var countMap = <dynamic, int>{};\n  // 计算每个数字的出现次数\n  for (var num in numbers) {\n[MASK]\n      countMap[num] = 0;\n    }\n    countMap[num] = countMap[num]! + 1;\n  }\n\n  // 将Map转换为List，以便排序\n[MASK]\n  // 对结果进行排序\n    ..sort((a, b) => a.key.compareTo(b.key));\n\n  // 将排序后的结果转换回期望的格式\n  return Map.fromEntries(sortedNumbers);\n}"}
{"task_id": "Dart/22-0-multi", "prompt": "int countPrimeSumCombinations(List<int> numbers, int n, int k)\n// ## Problem Description\n//\n// Given are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n//\n// $3+7+12=22$\n//\n// $3+7+19=29$\n//\n// $7+12+19=38$\n//\n// $3+12+19=34$\n//\n// The task is to compute the number of combinations for which the sum is a prime number.\n//\n// For the example given, there is only one combination where the sum is prime: $3+7+19=29$.\n//\n// ## Input Format\n//\n// The first line contains two integers separated by a space, $n,k$ ($1 \\le n \\le 20$, $k<n$).\n//\n// The second line contains $n$ integers, specifically $x_1,x_2,\\cdots,x_n$ ($1 \\le x_i \\le 5\\times 10^6$).\n//\n// ## Output Format\n//\n// Output a single integer representing the number of types.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 4 3\n// 3 7 12 19\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 1\n// ```", "canonical_solution": "{\n  int count = 0;\n  // 使用递归的方法生成所有可能的组合\n  void _combine(List<int> selected, int start) {\n    if (selected.length == k) {\n      // 如果选定的数达到k个，检查和是否为素数\n      int sum = selected.reduce((value, element) => value + element);\n      if (isPrime(sum)) {\n        count++;\n      }\n      return;\n    }\n    for (int i = start; i < numbers.length; i++) {\n      _combine([...selected, numbers[i]], i + 1);\n    }\n  }\n\n  _combine([], 0);\n  return count;\n}\n\n// 检查一个数是否是素数\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}", "test": "void main() {\n  // 测试用例1\n  {\n    List<int> numbers = [3, 7, 12, 19];\n    int n = 4;\n    int k = 3;\n    int expected = 1;\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例1失败: 预期$expected, 实际$result');\n  }\n\n  // 测试用例2\n  {\n    List<int> numbers = [2, 3, 5, 7];\n    int n = 4;\n    int k = 2;\n    int expected = 2; // 2+3=5, 5+7=12(不是素数)\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例2失败: 预期$expected, 实际$result');\n  }\n\n  // 测试用例3\n  {\n    List<int> numbers = [1, 3, 6, 8, 10];\n    int n = 5;\n    int k = 3;\n    int expected = 4; // 没有组合的和是素数\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例3失败: 预期$expected, 实际$result');\n  }\n\n  // 测试用例4\n  {\n    List<int> numbers = [11, 13, 17, 19, 23];\n    int n = 5;\n    int k = 4;\n    int expected = 0; // 所有可能的组合和都是素数\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例4失败: 预期$expected, 实际$result');\n  }\n\n  print('所有测试用例都通过了!');\n}", "entry_point": "countPrimeSumCombinations", "signature": "int countPrimeSumCombinations(List<int> numbers, int n, int k)", "docstring": "## Problem Description\n\nGiven are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n\n$3+7+12=22$\n\n$3+7+19=29$\n\n$7+12+19=38$\n\n$3+12+19=34$\n\nThe task is to compute the number of combinations for which the sum is a prime number.\n\nFor the example given, there is only one combination where the sum is prime: $3+7+19=29$.\n\n## Input Format\n\nThe first line contains two integers separated by a space, $n,k$ ($1 \\le n \\le 20$, $k<n$).\n\nThe second line contains $n$ integers, specifically $x_1,x_2,\\cdots,x_n$ ($1 \\le x_i \\le 5\\times 10^6$).\n\n## Output Format\n\nOutput a single integer representing the number of types.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 3\n3 7 12 19\n```\n\n### Sample Output #1\n\n```\n1\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n## Problem Description\n\nGiven are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n\n$3+7+12=22$\n\n$3+7+19=29$\n\n$7+12+19=38$\n\n$3+12+19=34$\n\nThe task is to compute the number of combinations for which the sum is a prime number.\n\nFor the example given, there is only one combination where the sum is prime: $3+7+19=29$.\n\n## Input Format\n\nThe first line contains two integers separated by a space, $n,k$ ($1 \\le n \\le 20$, $k<n$).\n\nThe second line contains $n$ integers, specifically $x_1,x_2,\\cdots,x_n$ ($1 \\le x_i \\le 5\\times 10^6$).\n\n## Output Format\n\nOutput a single integer representing the number of types.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 3\n3 7 12 19\n```\n\n### Sample Output #1\n\n```\n1\n```\n\n* Incomplete Code:\nint countPrimeSumCombinations(List<int> numbers, int n, int k)\n{\n  int count = 0;\n  // 使用递归的方法生成所有可能的组合\n  void _combine(List<int> selected, int start) {\n[MASK]\n      // 如果选定的数达到k个，检查和是否为素数\n      int sum = selected.reduce((value, element) => value + element);\n      if (isPrime(sum)) {\n        count++;\n      }\n      return;\n    }\n[MASK]\n      _combine([...selected, numbers[i]], i + 1);\n    }\n  }\n\n[MASK]\n  return count;\n}\n\n// 检查一个数是否是素数\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int count = 0;\n  // 使用递归的方法生成所有可能的组合\n  void _combine(List<int> selected, int start) {\n[MASK]\n      // 如果选定的数达到k个，检查和是否为素数\n      int sum = selected.reduce((value, element) => value + element);\n      if (isPrime(sum)) {\n        count++;\n      }\n      return;\n    }\n[MASK]\n      _combine([...selected, numbers[i]], i + 1);\n    }\n  }\n\n[MASK]\n  return count;\n}\n\n// 检查一个数是否是素数\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}"}
{"task_id": "Dart/22-1-multi", "prompt": "int countPrimeSumCombinations(List<int> numbers, int n, int k)\n// ## Problem Description\n//\n// Given are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n//\n// $3+7+12=22$\n//\n// $3+7+19=29$\n//\n// $7+12+19=38$\n//\n// $3+12+19=34$\n//\n// The task is to compute the number of combinations for which the sum is a prime number.\n//\n// For the example given, there is only one combination where the sum is prime: $3+7+19=29$.\n//\n// ## Input Format\n//\n// The first line contains two integers separated by a space, $n,k$ ($1 \\le n \\le 20$, $k<n$).\n//\n// The second line contains $n$ integers, specifically $x_1,x_2,\\cdots,x_n$ ($1 \\le x_i \\le 5\\times 10^6$).\n//\n// ## Output Format\n//\n// Output a single integer representing the number of types.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 4 3\n// 3 7 12 19\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 1\n// ```", "canonical_solution": "{\n  int count = 0;\n  // 使用递归的方法生成所有可能的组合\n  void _combine(List<int> selected, int start) {\n    if (selected.length == k) {\n      // 如果选定的数达到k个，检查和是否为素数\n      int sum = selected.reduce((value, element) => value + element);\n      if (isPrime(sum)) {\n        count++;\n      }\n      return;\n    }\n    for (int i = start; i < numbers.length; i++) {\n      _combine([...selected, numbers[i]], i + 1);\n    }\n  }\n\n  _combine([], 0);\n  return count;\n}\n\n// 检查一个数是否是素数\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}", "test": "void main() {\n  // 测试用例1\n  {\n    List<int> numbers = [3, 7, 12, 19];\n    int n = 4;\n    int k = 3;\n    int expected = 1;\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例1失败: 预期$expected, 实际$result');\n  }\n\n  // 测试用例2\n  {\n    List<int> numbers = [2, 3, 5, 7];\n    int n = 4;\n    int k = 2;\n    int expected = 2; // 2+3=5, 5+7=12(不是素数)\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例2失败: 预期$expected, 实际$result');\n  }\n\n  // 测试用例3\n  {\n    List<int> numbers = [1, 3, 6, 8, 10];\n    int n = 5;\n    int k = 3;\n    int expected = 4; // 没有组合的和是素数\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例3失败: 预期$expected, 实际$result');\n  }\n\n  // 测试用例4\n  {\n    List<int> numbers = [11, 13, 17, 19, 23];\n    int n = 5;\n    int k = 4;\n    int expected = 0; // 所有可能的组合和都是素数\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '测试用例4失败: 预期$expected, 实际$result');\n  }\n\n  print('所有测试用例都通过了!');\n}", "entry_point": "countPrimeSumCombinations", "signature": "int countPrimeSumCombinations(List<int> numbers, int n, int k)", "docstring": "## Problem Description\n\nGiven are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n\n$3+7+12=22$\n\n$3+7+19=29$\n\n$7+12+19=38$\n\n$3+12+19=34$\n\nThe task is to compute the number of combinations for which the sum is a prime number.\n\nFor the example given, there is only one combination where the sum is prime: $3+7+19=29$.\n\n## Input Format\n\nThe first line contains two integers separated by a space, $n,k$ ($1 \\le n \\le 20$, $k<n$).\n\nThe second line contains $n$ integers, specifically $x_1,x_2,\\cdots,x_n$ ($1 \\le x_i \\le 5\\times 10^6$).\n\n## Output Format\n\nOutput a single integer representing the number of types.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 3\n3 7 12 19\n```\n\n### Sample Output #1\n\n```\n1\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n## Problem Description\n\nGiven are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n\n$3+7+12=22$\n\n$3+7+19=29$\n\n$7+12+19=38$\n\n$3+12+19=34$\n\nThe task is to compute the number of combinations for which the sum is a prime number.\n\nFor the example given, there is only one combination where the sum is prime: $3+7+19=29$.\n\n## Input Format\n\nThe first line contains two integers separated by a space, $n,k$ ($1 \\le n \\le 20$, $k<n$).\n\nThe second line contains $n$ integers, specifically $x_1,x_2,\\cdots,x_n$ ($1 \\le x_i \\le 5\\times 10^6$).\n\n## Output Format\n\nOutput a single integer representing the number of types.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 3\n3 7 12 19\n```\n\n### Sample Output #1\n\n```\n1\n```\n\n* Incomplete Code:\nint countPrimeSumCombinations(List<int> numbers, int n, int k)\n{\n  int count = 0;\n  // 使用递归的方法生成所有可能的组合\n  void _combine(List<int> selected, int start) {\n[MASK]\n      // 如果选定的数达到k个，检查和是否为素数\n      int sum = selected.reduce((value, element) => value + element);\n      if (isPrime(sum)) {\n        count++;\n      }\n      return;\n    }\n    for (int i = start; i < numbers.length; i++) {\n[MASK]\n    }\n  }\n\n  _combine([], 0);\n  return count;\n}\n\n// 检查一个数是否是素数\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i * i <= n; i++) {\n[MASK]\n  }\n  return true;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int count = 0;\n  // 使用递归的方法生成所有可能的组合\n  void _combine(List<int> selected, int start) {\n[MASK]\n      // 如果选定的数达到k个，检查和是否为素数\n      int sum = selected.reduce((value, element) => value + element);\n      if (isPrime(sum)) {\n        count++;\n      }\n      return;\n    }\n    for (int i = start; i < numbers.length; i++) {\n[MASK]\n    }\n  }\n\n  _combine([], 0);\n  return count;\n}\n\n// 检查一个数是否是素数\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i * i <= n; i++) {\n[MASK]\n  }\n  return true;\n}"}
{"task_id": "Dart/23-0-multi", "prompt": "int countSequences(int n)\n// ## Background\n//\n// The stack is a classical data structure in computer science, simply described as a linear list where insertion and deletion operations are restricted to one end.\n//\n// There are two primary operations associated with stacks: pop (removing an element from the top of the stack) and push (adding an element to the stack).\n//\n// The significance of stacks is self-evident, as they are introduced in any data structures course. While reviewing the basic concepts of stacks, Ningning encountered a question not covered in textbooks and was unable to find the answer on his own, thus seeking your assistance.\n//\n// ## Problem Description\n//\n// Ningning contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n//\n// Currently, two operations can be performed:\n//\n// 1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n// 2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n//\n// Using these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n//\n// (The original state is depicted in the image above)\n//\n// Your program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n//\n// ## Input Format\n//\n// The input file contains a single integer $n$ ($1 \\leq n \\leq 18$).\n//\n// ## Output Format\n//\n// The output file consists of a single line, indicating the total number of possible output sequences.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 3\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 5\n// ```", "canonical_solution": "{\n  // Base case\n  if (n == 0 || n == 1) return 1;\n\n  int result = 0;\n\n  // Applying the formula for Catalan Numbers:\n  // C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n  for (int i = 0; i < n; i++) {\n    result += countSequences(i) * countSequences(n - 1 - i);\n  }\n\n  return result;\n}", "test": "void testCountSequences() {\n  // Test case 1: n = 3\n  assert(countSequences(3) == 5, 'Test case 1 failed');\n\n  // Test case 2: n = 4\n  assert(countSequences(4) == 14, 'Test case 2 failed');\n\n  // Test case 3: n = 5\n  assert(countSequences(5) == 42, 'Test case 3 failed');\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testCountSequences();\n}", "entry_point": "countSequences", "signature": "int countSequences(int n)", "docstring": "## Background\n\nThe stack is a classical data structure in computer science, simply described as a linear list where insertion and deletion operations are restricted to one end.\n\nThere are two primary operations associated with stacks: pop (removing an element from the top of the stack) and push (adding an element to the stack).\n\nThe significance of stacks is self-evident, as they are introduced in any data structures course. While reviewing the basic concepts of stacks, Ningning encountered a question not covered in textbooks and was unable to find the answer on his own, thus seeking your assistance.\n\n## Problem Description\n\nNingning contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n\nCurrently, two operations can be performed:\n\n1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n\nUsing these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n\n(The original state is depicted in the image above)\n\nYour program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n\n## Input Format\n\nThe input file contains a single integer $n$ ($1 \\leq n \\leq 18$).\n\n## Output Format\n\nThe output file consists of a single line, indicating the total number of possible output sequences.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n```\n\n### Sample Output #1\n\n```\n5\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n## Background\n\nThe stack is a classical data structure in computer science, simply described as a linear list where insertion and deletion operations are restricted to one end.\n\nThere are two primary operations associated with stacks: pop (removing an element from the top of the stack) and push (adding an element to the stack).\n\nThe significance of stacks is self-evident, as they are introduced in any data structures course. While reviewing the basic concepts of stacks, Ningning encountered a question not covered in textbooks and was unable to find the answer on his own, thus seeking your assistance.\n\n## Problem Description\n\nNingning contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n\nCurrently, two operations can be performed:\n\n1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n\nUsing these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n\n(The original state is depicted in the image above)\n\nYour program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n\n## Input Format\n\nThe input file contains a single integer $n$ ($1 \\leq n \\leq 18$).\n\n## Output Format\n\nThe output file consists of a single line, indicating the total number of possible output sequences.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n* Incomplete Code:\nint countSequences(int n)\n{\n  // Base case\n  if (n == 0 || n == 1) return 1;\n\n  int result = 0;\n\n  // Applying the formula for Catalan Numbers:\n  // C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n[MASK]\n[MASK]\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Base case\n  if (n == 0 || n == 1) return 1;\n\n  int result = 0;\n\n  // Applying the formula for Catalan Numbers:\n  // C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n[MASK]\n[MASK]\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/23-1-multi", "prompt": "int countSequences(int n)\n// ## Background\n//\n// The stack is a classical data structure in computer science, simply described as a linear list where insertion and deletion operations are restricted to one end.\n//\n// There are two primary operations associated with stacks: pop (removing an element from the top of the stack) and push (adding an element to the stack).\n//\n// The significance of stacks is self-evident, as they are introduced in any data structures course. While reviewing the basic concepts of stacks, Ningning encountered a question not covered in textbooks and was unable to find the answer on his own, thus seeking your assistance.\n//\n// ## Problem Description\n//\n// Ningning contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n//\n// Currently, two operations can be performed:\n//\n// 1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n// 2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n//\n// Using these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n//\n// (The original state is depicted in the image above)\n//\n// Your program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n//\n// ## Input Format\n//\n// The input file contains a single integer $n$ ($1 \\leq n \\leq 18$).\n//\n// ## Output Format\n//\n// The output file consists of a single line, indicating the total number of possible output sequences.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 3\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 5\n// ```", "canonical_solution": "{\n  // Base case\n  if (n == 0 || n == 1) return 1;\n\n  int result = 0;\n\n  // Applying the formula for Catalan Numbers:\n  // C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n  for (int i = 0; i < n; i++) {\n    result += countSequences(i) * countSequences(n - 1 - i);\n  }\n\n  return result;\n}", "test": "void testCountSequences() {\n  // Test case 1: n = 3\n  assert(countSequences(3) == 5, 'Test case 1 failed');\n\n  // Test case 2: n = 4\n  assert(countSequences(4) == 14, 'Test case 2 failed');\n\n  // Test case 3: n = 5\n  assert(countSequences(5) == 42, 'Test case 3 failed');\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testCountSequences();\n}", "entry_point": "countSequences", "signature": "int countSequences(int n)", "docstring": "## Background\n\nThe stack is a classical data structure in computer science, simply described as a linear list where insertion and deletion operations are restricted to one end.\n\nThere are two primary operations associated with stacks: pop (removing an element from the top of the stack) and push (adding an element to the stack).\n\nThe significance of stacks is self-evident, as they are introduced in any data structures course. While reviewing the basic concepts of stacks, Ningning encountered a question not covered in textbooks and was unable to find the answer on his own, thus seeking your assistance.\n\n## Problem Description\n\nNingning contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n\nCurrently, two operations can be performed:\n\n1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n\nUsing these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n\n(The original state is depicted in the image above)\n\nYour program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n\n## Input Format\n\nThe input file contains a single integer $n$ ($1 \\leq n \\leq 18$).\n\n## Output Format\n\nThe output file consists of a single line, indicating the total number of possible output sequences.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n```\n\n### Sample Output #1\n\n```\n5\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n## Background\n\nThe stack is a classical data structure in computer science, simply described as a linear list where insertion and deletion operations are restricted to one end.\n\nThere are two primary operations associated with stacks: pop (removing an element from the top of the stack) and push (adding an element to the stack).\n\nThe significance of stacks is self-evident, as they are introduced in any data structures course. While reviewing the basic concepts of stacks, Ningning encountered a question not covered in textbooks and was unable to find the answer on his own, thus seeking your assistance.\n\n## Problem Description\n\nNingning contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n\nCurrently, two operations can be performed:\n\n1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n\nUsing these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n\n(The original state is depicted in the image above)\n\nYour program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n\n## Input Format\n\nThe input file contains a single integer $n$ ($1 \\leq n \\leq 18$).\n\n## Output Format\n\nThe output file consists of a single line, indicating the total number of possible output sequences.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n* Incomplete Code:\nint countSequences(int n)\n{\n  // Base case\n  if (n == 0 || n == 1) return 1;\n\n[MASK]\n\n  // Applying the formula for Catalan Numbers:\n  // C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n[MASK]\n    result += countSequences(i) * countSequences(n - 1 - i);\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Base case\n  if (n == 0 || n == 1) return 1;\n\n[MASK]\n\n  // Applying the formula for Catalan Numbers:\n  // C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n[MASK]\n    result += countSequences(i) * countSequences(n - 1 - i);\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/24-0-multi", "prompt": "int countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)\n// # TaoTao Picking Apples\n//\n// ## Problem Description\n//\n// In the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n//\n// The task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n//\n// ## Input Format\n//\n// The input consists of two lines of data. The first line contains 10 integers, ranging from 100 to 200 centimeters (inclusive of both 100 and 200), representing the heights of the 10 apples from the ground, with a space separating each adjacent pair of integers. The second line contains a single integer between 100 and 120 centimeters (inclusive of both 100 and 120), representing the maximum height TaoTao can reach with her arm fully extended.\n//\n// ## Output Format\n//\n// The output should be a single line containing a single integer, indicating the number of apples TaoTao is able to pick.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 100 200 150 140 129 134 167 198 200 111\n// 110\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 5\n// ```|", "canonical_solution": "{\n  // TaoTao can use a 30 cm stool to reach higher\n  int stoolHeight = 30;\n\n  // Calculating the total height TaoTao can reach with the stool\n  int totalReachWithStool = maxReach + stoolHeight;\n\n  // Initializing a counter for the apples TaoTao can pick\n  int applesPicked = 0;\n\n  // Iterating through the list of apple heights\n  for (int height in appleHeights) {\n    // If TaoTao can reach the apple with or without the stool, increment the counter\n    if (height <= totalReachWithStool) {\n      applesPicked++;\n    }\n  }\n\n  // Returning the number of apples TaoTao can pick\n  return applesPicked;\n}", "test": "void testCountApplesTaoTaoCanPick() {\n  // Test case 1\n  List<int> appleHeights1 = [100, 200, 150, 140, 129, 134, 167, 198, 200, 111];\n  int maxReach1 = 110;\n  int expectedApples1 = 5;\n  assert(countApplesTaoTaoCanPick(appleHeights1, maxReach1) == expectedApples1);\n\n  // Test case 2\n  List<int> appleHeights2 = [120, 130, 140, 150, 160, 170, 180, 190, 200, 210];\n  int maxReach2 = 120;\n  int expectedApples2 = 4;\n  assert(countApplesTaoTaoCanPick(appleHeights2, maxReach2) == expectedApples2);\n\n  // Test case 3\n  List<int> appleHeights3 = [101, 102, 103, 104, 105, 106, 107, 108, 109, 110];\n  int maxReach3 = 100;\n  int expectedApples3 = 10;\n  assert(countApplesTaoTaoCanPick(appleHeights3, maxReach3) == expectedApples3);\n\n  // If the program reaches this point without any assertion error, print success message\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  // Running the test function\n  testCountApplesTaoTaoCanPick();\n}", "entry_point": "countApplesTaoTaoCanPick", "signature": "int countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)", "docstring": "# TaoTao Picking Apples\n\n## Problem Description\n\nIn the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n\nThe task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n\n## Input Format\n\nThe input consists of two lines of data. The first line contains 10 integers, ranging from 100 to 200 centimeters (inclusive of both 100 and 200), representing the heights of the 10 apples from the ground, with a space separating each adjacent pair of integers. The second line contains a single integer between 100 and 120 centimeters (inclusive of both 100 and 120), representing the maximum height TaoTao can reach with her arm fully extended.\n\n## Output Format\n\nThe output should be a single line containing a single integer, indicating the number of apples TaoTao is able to pick.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100 200 150 140 129 134 167 198 200 111\n110\n```\n\n### Sample Output #1\n\n```\n5\n```|", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# TaoTao Picking Apples\n\n## Problem Description\n\nIn the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n\nThe task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n\n## Input Format\n\nThe input consists of two lines of data. The first line contains 10 integers, ranging from 100 to 200 centimeters (inclusive of both 100 and 200), representing the heights of the 10 apples from the ground, with a space separating each adjacent pair of integers. The second line contains a single integer between 100 and 120 centimeters (inclusive of both 100 and 120), representing the maximum height TaoTao can reach with her arm fully extended.\n\n## Output Format\n\nThe output should be a single line containing a single integer, indicating the number of apples TaoTao is able to pick.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100 200 150 140 129 134 167 198 200 111\n110\n```\n\n### Sample Output #1\n\n```\n5\n```|\n\n* Incomplete Code:\nint countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)\n{\n  // TaoTao can use a 30 cm stool to reach higher\n[MASK]\n\n  // Calculating the total height TaoTao can reach with the stool\n  int totalReachWithStool = maxReach + stoolHeight;\n\n  // Initializing a counter for the apples TaoTao can pick\n[MASK]\n\n  // Iterating through the list of apple heights\n[MASK]\n    // If TaoTao can reach the apple with or without the stool, increment the counter\n    if (height <= totalReachWithStool) {\n[MASK]\n    }\n  }\n\n  // Returning the number of apples TaoTao can pick\n  return applesPicked;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // TaoTao can use a 30 cm stool to reach higher\n[MASK]\n\n  // Calculating the total height TaoTao can reach with the stool\n  int totalReachWithStool = maxReach + stoolHeight;\n\n  // Initializing a counter for the apples TaoTao can pick\n[MASK]\n\n  // Iterating through the list of apple heights\n[MASK]\n    // If TaoTao can reach the apple with or without the stool, increment the counter\n    if (height <= totalReachWithStool) {\n[MASK]\n    }\n  }\n\n  // Returning the number of apples TaoTao can pick\n  return applesPicked;\n}"}
{"task_id": "Dart/24-1-multi", "prompt": "int countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)\n// # TaoTao Picking Apples\n//\n// ## Problem Description\n//\n// In the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n//\n// The task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n//\n// ## Input Format\n//\n// The input consists of two lines of data. The first line contains 10 integers, ranging from 100 to 200 centimeters (inclusive of both 100 and 200), representing the heights of the 10 apples from the ground, with a space separating each adjacent pair of integers. The second line contains a single integer between 100 and 120 centimeters (inclusive of both 100 and 120), representing the maximum height TaoTao can reach with her arm fully extended.\n//\n// ## Output Format\n//\n// The output should be a single line containing a single integer, indicating the number of apples TaoTao is able to pick.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 100 200 150 140 129 134 167 198 200 111\n// 110\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 5\n// ```|", "canonical_solution": "{\n  // TaoTao can use a 30 cm stool to reach higher\n  int stoolHeight = 30;\n\n  // Calculating the total height TaoTao can reach with the stool\n  int totalReachWithStool = maxReach + stoolHeight;\n\n  // Initializing a counter for the apples TaoTao can pick\n  int applesPicked = 0;\n\n  // Iterating through the list of apple heights\n  for (int height in appleHeights) {\n    // If TaoTao can reach the apple with or without the stool, increment the counter\n    if (height <= totalReachWithStool) {\n      applesPicked++;\n    }\n  }\n\n  // Returning the number of apples TaoTao can pick\n  return applesPicked;\n}", "test": "void testCountApplesTaoTaoCanPick() {\n  // Test case 1\n  List<int> appleHeights1 = [100, 200, 150, 140, 129, 134, 167, 198, 200, 111];\n  int maxReach1 = 110;\n  int expectedApples1 = 5;\n  assert(countApplesTaoTaoCanPick(appleHeights1, maxReach1) == expectedApples1);\n\n  // Test case 2\n  List<int> appleHeights2 = [120, 130, 140, 150, 160, 170, 180, 190, 200, 210];\n  int maxReach2 = 120;\n  int expectedApples2 = 4;\n  assert(countApplesTaoTaoCanPick(appleHeights2, maxReach2) == expectedApples2);\n\n  // Test case 3\n  List<int> appleHeights3 = [101, 102, 103, 104, 105, 106, 107, 108, 109, 110];\n  int maxReach3 = 100;\n  int expectedApples3 = 10;\n  assert(countApplesTaoTaoCanPick(appleHeights3, maxReach3) == expectedApples3);\n\n  // If the program reaches this point without any assertion error, print success message\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  // Running the test function\n  testCountApplesTaoTaoCanPick();\n}", "entry_point": "countApplesTaoTaoCanPick", "signature": "int countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)", "docstring": "# TaoTao Picking Apples\n\n## Problem Description\n\nIn the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n\nThe task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n\n## Input Format\n\nThe input consists of two lines of data. The first line contains 10 integers, ranging from 100 to 200 centimeters (inclusive of both 100 and 200), representing the heights of the 10 apples from the ground, with a space separating each adjacent pair of integers. The second line contains a single integer between 100 and 120 centimeters (inclusive of both 100 and 120), representing the maximum height TaoTao can reach with her arm fully extended.\n\n## Output Format\n\nThe output should be a single line containing a single integer, indicating the number of apples TaoTao is able to pick.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100 200 150 140 129 134 167 198 200 111\n110\n```\n\n### Sample Output #1\n\n```\n5\n```|", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# TaoTao Picking Apples\n\n## Problem Description\n\nIn the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n\nThe task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n\n## Input Format\n\nThe input consists of two lines of data. The first line contains 10 integers, ranging from 100 to 200 centimeters (inclusive of both 100 and 200), representing the heights of the 10 apples from the ground, with a space separating each adjacent pair of integers. The second line contains a single integer between 100 and 120 centimeters (inclusive of both 100 and 120), representing the maximum height TaoTao can reach with her arm fully extended.\n\n## Output Format\n\nThe output should be a single line containing a single integer, indicating the number of apples TaoTao is able to pick.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100 200 150 140 129 134 167 198 200 111\n110\n```\n\n### Sample Output #1\n\n```\n5\n```|\n\n* Incomplete Code:\nint countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)\n{\n  // TaoTao can use a 30 cm stool to reach higher\n  int stoolHeight = 30;\n\n  // Calculating the total height TaoTao can reach with the stool\n[MASK]\n\n  // Initializing a counter for the apples TaoTao can pick\n  int applesPicked = 0;\n\n  // Iterating through the list of apple heights\n[MASK]\n    // If TaoTao can reach the apple with or without the stool, increment the counter\n    if (height <= totalReachWithStool) {\n      applesPicked++;\n    }\n  }\n\n  // Returning the number of apples TaoTao can pick\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // TaoTao can use a 30 cm stool to reach higher\n  int stoolHeight = 30;\n\n  // Calculating the total height TaoTao can reach with the stool\n[MASK]\n\n  // Initializing a counter for the apples TaoTao can pick\n  int applesPicked = 0;\n\n  // Iterating through the list of apple heights\n[MASK]\n    // If TaoTao can reach the apple with or without the stool, increment the counter\n    if (height <= totalReachWithStool) {\n      applesPicked++;\n    }\n  }\n\n  // Returning the number of apples TaoTao can pick\n[MASK]\n}"}
{"task_id": "Dart/25-0-multi", "prompt": "int countRemainingTrees(int roadLength, List<List<int>> regions)\n// #Trees Outside the School Gate\n//\n// ## Problem Description\n//\n// Adjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\n//\n// Some sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n//\n// ## Input Format\n//\n// The first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\n//\n// The following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n//\n// ## Output Format\n//\n// Output a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 500 3\n// 150 300\n// 100 200\n// 470 471\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 298\n// ```\n//\n// ## Notes\n//\n// **【Data Range】**\n//\n// - For $20\\%$ of the data, it is guaranteed that there are no overlaps between sections.\n// - For $100\\%$ of the data, it is guaranteed that $1 \\leq l \\leq 10^4$, $1 \\leq m \\leq 100$, $0 \\leq u \\leq v \\leq l$.", "canonical_solution": "{\n  // Initialize a list to keep track of the trees; true means the tree is still there\n  List<bool> trees = List.filled(roadLength + 1, true);\n\n  // Iterate through each region and mark the trees in that region as removed\n  for (var region in regions) {\n    for (int i = region[0]; i <= region[1]; i++) {\n      trees[i] = false; // Tree is removed\n    }\n  }\n\n  // Count the remaining trees\n  int remaining = trees.where((tree) => tree).length;\n  print(remaining);\n  return remaining;\n}", "test": "void testCountRemainingTrees() {\n  // Test case 1: Non-overlapping regions\n  int roadLength1 = 500;\n  List<List<int>> regions1 = [\n    [150, 300],\n    [301, 450]\n  ];\n  int expectedRemaining1 = 200; // Trees from 0-149, 451-500\n  assert(countRemainingTrees(roadLength1, regions1) == expectedRemaining1);\n\n  // Test case 2: Partially overlapping regions\n  int roadLength2 = 500;\n  List<List<int>> regions2 = [\n    [100, 200],\n    [150, 300],\n    [470, 471]\n  ];\n  int expectedRemaining2 = 298; // Trees from 0-99, 301-469, 472-500\n  assert(countRemainingTrees(roadLength2, regions2) == expectedRemaining2);\n\n  // Test case 3: All trees are removed\n  int roadLength3 = 10;\n  List<List<int>> regions3 = [\n    [0, 10]\n  ];\n  int expectedRemaining3 = 0; // All trees are removed\n  assert(countRemainingTrees(roadLength3, regions3) == expectedRemaining3);\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testCountRemainingTrees();\n}", "entry_point": "countRemainingTrees", "signature": "int countRemainingTrees(int roadLength, List<List<int>> regions)", "docstring": "#Trees Outside the School Gate\n\n## Problem Description\n\nAdjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\n\nSome sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n\n## Input Format\n\nThe first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\n\nThe following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n\n## Output Format\n\nOutput a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n500 3\n150 300\n100 200\n470 471\n```\n\n### Sample Output #1\n\n```\n298\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#Trees Outside the School Gate\n\n## Problem Description\n\nAdjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\n\nSome sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n\n## Input Format\n\nThe first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\n\nThe following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n\n## Output Format\n\nOutput a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n500 3\n150 300\n100 200\n470 471\n```\n\n### Sample Output #1\n\n```\n298\n```\n\n* Incomplete Code:\nint countRemainingTrees(int roadLength, List<List<int>> regions)\n{\n  // Initialize a list to keep track of the trees; true means the tree is still there\n[MASK]\n\n  // Iterate through each region and mark the trees in that region as removed\n[MASK]\n[MASK]\n[MASK]\n    }\n  }\n\n  // Count the remaining trees\n[MASK]\n  print(remaining);\n  return remaining;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Initialize a list to keep track of the trees; true means the tree is still there\n[MASK]\n\n  // Iterate through each region and mark the trees in that region as removed\n[MASK]\n[MASK]\n[MASK]\n    }\n  }\n\n  // Count the remaining trees\n[MASK]\n  print(remaining);\n  return remaining;\n}"}
{"task_id": "Dart/25-1-multi", "prompt": "int countRemainingTrees(int roadLength, List<List<int>> regions)\n// #Trees Outside the School Gate\n//\n// ## Problem Description\n//\n// Adjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\n//\n// Some sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n//\n// ## Input Format\n//\n// The first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\n//\n// The following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n//\n// ## Output Format\n//\n// Output a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 500 3\n// 150 300\n// 100 200\n// 470 471\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 298\n// ```\n//\n// ## Notes\n//\n// **【Data Range】**\n//\n// - For $20\\%$ of the data, it is guaranteed that there are no overlaps between sections.\n// - For $100\\%$ of the data, it is guaranteed that $1 \\leq l \\leq 10^4$, $1 \\leq m \\leq 100$, $0 \\leq u \\leq v \\leq l$.", "canonical_solution": "{\n  // Initialize a list to keep track of the trees; true means the tree is still there\n  List<bool> trees = List.filled(roadLength + 1, true);\n\n  // Iterate through each region and mark the trees in that region as removed\n  for (var region in regions) {\n    for (int i = region[0]; i <= region[1]; i++) {\n      trees[i] = false; // Tree is removed\n    }\n  }\n\n  // Count the remaining trees\n  int remaining = trees.where((tree) => tree).length;\n  print(remaining);\n  return remaining;\n}", "test": "void testCountRemainingTrees() {\n  // Test case 1: Non-overlapping regions\n  int roadLength1 = 500;\n  List<List<int>> regions1 = [\n    [150, 300],\n    [301, 450]\n  ];\n  int expectedRemaining1 = 200; // Trees from 0-149, 451-500\n  assert(countRemainingTrees(roadLength1, regions1) == expectedRemaining1);\n\n  // Test case 2: Partially overlapping regions\n  int roadLength2 = 500;\n  List<List<int>> regions2 = [\n    [100, 200],\n    [150, 300],\n    [470, 471]\n  ];\n  int expectedRemaining2 = 298; // Trees from 0-99, 301-469, 472-500\n  assert(countRemainingTrees(roadLength2, regions2) == expectedRemaining2);\n\n  // Test case 3: All trees are removed\n  int roadLength3 = 10;\n  List<List<int>> regions3 = [\n    [0, 10]\n  ];\n  int expectedRemaining3 = 0; // All trees are removed\n  assert(countRemainingTrees(roadLength3, regions3) == expectedRemaining3);\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testCountRemainingTrees();\n}", "entry_point": "countRemainingTrees", "signature": "int countRemainingTrees(int roadLength, List<List<int>> regions)", "docstring": "#Trees Outside the School Gate\n\n## Problem Description\n\nAdjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\n\nSome sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n\n## Input Format\n\nThe first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\n\nThe following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n\n## Output Format\n\nOutput a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n500 3\n150 300\n100 200\n470 471\n```\n\n### Sample Output #1\n\n```\n298\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#Trees Outside the School Gate\n\n## Problem Description\n\nAdjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\n\nSome sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n\n## Input Format\n\nThe first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\n\nThe following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n\n## Output Format\n\nOutput a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n500 3\n150 300\n100 200\n470 471\n```\n\n### Sample Output #1\n\n```\n298\n```\n\n* Incomplete Code:\nint countRemainingTrees(int roadLength, List<List<int>> regions)\n{\n  // Initialize a list to keep track of the trees; true means the tree is still there\n[MASK]\n\n  // Iterate through each region and mark the trees in that region as removed\n[MASK]\n[MASK]\n[MASK]\n    }\n  }\n\n  // Count the remaining trees\n  int remaining = trees.where((tree) => tree).length;\n  print(remaining);\n  return remaining;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Initialize a list to keep track of the trees; true means the tree is still there\n[MASK]\n\n  // Iterate through each region and mark the trees in that region as removed\n[MASK]\n[MASK]\n[MASK]\n    }\n  }\n\n  // Count the remaining trees\n  int remaining = trees.where((tree) => tree).length;\n  print(remaining);\n  return remaining;\n}"}
{"task_id": "Dart/26-0-multi", "prompt": "int getMaxValue(int T, int M, List<List<int>> herbs)\n// # Herb Collection\n//\n// ## Problem Description\n//\n// Chenchen is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes Chenchen to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\n//\n// If you were Chenchen, could you complete this task?\n//\n// ## Input Format\n//\n// The first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n//\n// The next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n//\n// ## Output Format\n//\n// Output the maximum total value of the herbs that can be collected within the allotted time.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 70 3\n// 71 100\n// 69 1\n// 1 2\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 3\n// ```\n//\n// ## Notes\n//\n// **【Data Range】**\n//\n// - For $30\\%$ of the data, $M \\le 10$;\n// - For the entire dataset, $M \\le 100$.", "canonical_solution": "{\n  List<int> dp = List.filled(T + 1, 0); // dp[i] represents the maximum value within time i\n\n  for (int i = 0; i < M; i++) {\n    int time = herbs[i][0];\n    int value = herbs[i][1];\n    for (int j = T; j >= time; j--) {\n      dp[j] = dp[j].compareTo(dp[j - time] + value) > 0 ? dp[j] : dp[j - time] + value;\n    }\n  }\n\n  return dp[T];\n}", "test": "void testGetMaxValue() {\n  // Test Case 1: Provided example\n  assert(getMaxValue(70, 3, [\n    [71, 100],\n    [69, 1],\n    [1, 2]\n  ]) == 3);\n\n  // Test Case 2: Multiple herbs can be collected, no single herb takes all time\n  assert(getMaxValue(10, 4, [\n    [1, 10],\n    [2, 15],\n    [3, 20],\n    [4, 30]\n  ]) == 75); // Best option: collect all herbs\n\n  // Test Case 3: Only one herb can be collected due to time constraint\n  assert(getMaxValue(5, 3, [\n    [5, 50],\n    [4, 40],\n    [3, 30]\n  ]) == 50); // Best option: collect the herb worth 50\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testGetMaxValue();\n}", "entry_point": "getMaxValue", "signature": "int getMaxValue(int T, int M, List<List<int>> herbs)", "docstring": "# Herb Collection\n\n## Problem Description\n\nChenchen is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes Chenchen to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\n\nIf you were Chenchen, could you complete this task?\n\n## Input Format\n\nThe first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n\nThe next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n\n## Output Format\n\nOutput the maximum total value of the herbs that can be collected within the allotted time.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n70 3\n71 100\n69 1\n1 2\n```\n\n### Sample Output #1\n\n```\n3\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Herb Collection\n\n## Problem Description\n\nChenchen is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes Chenchen to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\n\nIf you were Chenchen, could you complete this task?\n\n## Input Format\n\nThe first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n\nThe next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n\n## Output Format\n\nOutput the maximum total value of the herbs that can be collected within the allotted time.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n70 3\n71 100\n69 1\n1 2\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n* Incomplete Code:\nint getMaxValue(int T, int M, List<List<int>> herbs)\n{\n[MASK]\n\n[MASK]\n    int time = herbs[i][0];\n    int value = herbs[i][1];\n    for (int j = T; j >= time; j--) {\n      dp[j] = dp[j].compareTo(dp[j - time] + value) > 0 ? dp[j] : dp[j - time] + value;\n    }\n  }\n\n  return dp[T];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n\n[MASK]\n    int time = herbs[i][0];\n    int value = herbs[i][1];\n    for (int j = T; j >= time; j--) {\n      dp[j] = dp[j].compareTo(dp[j - time] + value) > 0 ? dp[j] : dp[j - time] + value;\n    }\n  }\n\n  return dp[T];\n}"}
{"task_id": "Dart/26-1-multi", "prompt": "int getMaxValue(int T, int M, List<List<int>> herbs)\n// # Herb Collection\n//\n// ## Problem Description\n//\n// Chenchen is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes Chenchen to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\n//\n// If you were Chenchen, could you complete this task?\n//\n// ## Input Format\n//\n// The first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n//\n// The next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n//\n// ## Output Format\n//\n// Output the maximum total value of the herbs that can be collected within the allotted time.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 70 3\n// 71 100\n// 69 1\n// 1 2\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 3\n// ```\n//\n// ## Notes\n//\n// **【Data Range】**\n//\n// - For $30\\%$ of the data, $M \\le 10$;\n// - For the entire dataset, $M \\le 100$.", "canonical_solution": "{\n  List<int> dp = List.filled(T + 1, 0); // dp[i] represents the maximum value within time i\n\n  for (int i = 0; i < M; i++) {\n    int time = herbs[i][0];\n    int value = herbs[i][1];\n    for (int j = T; j >= time; j--) {\n      dp[j] = dp[j].compareTo(dp[j - time] + value) > 0 ? dp[j] : dp[j - time] + value;\n    }\n  }\n\n  return dp[T];\n}", "test": "void testGetMaxValue() {\n  // Test Case 1: Provided example\n  assert(getMaxValue(70, 3, [\n    [71, 100],\n    [69, 1],\n    [1, 2]\n  ]) == 3);\n\n  // Test Case 2: Multiple herbs can be collected, no single herb takes all time\n  assert(getMaxValue(10, 4, [\n    [1, 10],\n    [2, 15],\n    [3, 20],\n    [4, 30]\n  ]) == 75); // Best option: collect all herbs\n\n  // Test Case 3: Only one herb can be collected due to time constraint\n  assert(getMaxValue(5, 3, [\n    [5, 50],\n    [4, 40],\n    [3, 30]\n  ]) == 50); // Best option: collect the herb worth 50\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testGetMaxValue();\n}", "entry_point": "getMaxValue", "signature": "int getMaxValue(int T, int M, List<List<int>> herbs)", "docstring": "# Herb Collection\n\n## Problem Description\n\nChenchen is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes Chenchen to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\n\nIf you were Chenchen, could you complete this task?\n\n## Input Format\n\nThe first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n\nThe next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n\n## Output Format\n\nOutput the maximum total value of the herbs that can be collected within the allotted time.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n70 3\n71 100\n69 1\n1 2\n```\n\n### Sample Output #1\n\n```\n3\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Herb Collection\n\n## Problem Description\n\nChenchen is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes Chenchen to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\n\nIf you were Chenchen, could you complete this task?\n\n## Input Format\n\nThe first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n\nThe next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n\n## Output Format\n\nOutput the maximum total value of the herbs that can be collected within the allotted time.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n70 3\n71 100\n69 1\n1 2\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n* Incomplete Code:\nint getMaxValue(int T, int M, List<List<int>> herbs)\n{\n  List<int> dp = List.filled(T + 1, 0); // dp[i] represents the maximum value within time i\n\n[MASK]\n    int time = herbs[i][0];\n    int value = herbs[i][1];\n    for (int j = T; j >= time; j--) {\n      dp[j] = dp[j].compareTo(dp[j - time] + value) > 0 ? dp[j] : dp[j - time] + value;\n    }\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> dp = List.filled(T + 1, 0); // dp[i] represents the maximum value within time i\n\n[MASK]\n    int time = herbs[i][0];\n    int value = herbs[i][1];\n    for (int j = T; j >= time; j--) {\n      dp[j] = dp[j].compareTo(dp[j - time] + value) > 0 ? dp[j] : dp[j - time] + value;\n    }\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/27-0-multi", "prompt": "int minRemainingSpace(int V, List<int> volumes)\n// # The Box Packing Problem\n//\n// ## Problem Description\n//\n// There is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n//\n// Now, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n//\n// ## Input Format\n//\n// The first line contains a single integer $V$, indicating the capacity of the box.\n//\n// The second line contains a single integer $n$, indicating the total number of items.\n//\n// The following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n//\n// ## Output Format\n//\n// - A single line containing one integer, indicating the minimum remaining space in the box.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 24\n// 6\n// 8\n// 3\n// 12\n// 7\n// 9\n// 7\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 0\n// ```\n//\n// ## Notes\n//\n// For $100\\%$ of the data, it satisfies $0<n \\le 30$, $1 \\le V \\le 20000$.", "canonical_solution": "{\n  List<int> dp = List.filled(V + 1, V);\n  dp[0] = 0;\n  for (int i = 0; i < volumes.length; i++) {\n    for (int j = V; j >= volumes[i]; j--) {\n      dp[j] = dp[j] < dp[j - volumes[i]] + volumes[i] ? dp[j] : dp[j - volumes[i]] + volumes[i];\n    }\n  }\n  print(V - dp[V]);\n  return V - dp[V];\n}", "test": "void testMinRemainingSpace() {\n  assert(minRemainingSpace(24, [8, 3, 12, 7, 9, 7]) == 0);\n  assert(minRemainingSpace(10, [5, 3, 2, 4]) == 0);\n  assert(minRemainingSpace(30, [10, 14, 20]) == 0);\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testMinRemainingSpace();\n}", "entry_point": "minRemainingSpace", "signature": "int minRemainingSpace(int V, List<int> volumes)", "docstring": "# The Box Packing Problem\n\n## Problem Description\n\nThere is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n\nNow, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n\n## Input Format\n\nThe first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n\n## Output Format\n\n- A single line containing one integer, indicating the minimum remaining space in the box.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n24\n6\n8\n3\n12\n7\n9\n7\n```\n\n### Sample Output #1\n\n```\n0\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# The Box Packing Problem\n\n## Problem Description\n\nThere is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n\nNow, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n\n## Input Format\n\nThe first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n\n## Output Format\n\n- A single line containing one integer, indicating the minimum remaining space in the box.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n24\n6\n8\n3\n12\n7\n9\n7\n```\n\n### Sample Output #1\n\n```\n0\n```\n\n* Incomplete Code:\nint minRemainingSpace(int V, List<int> volumes)\n{\n  List<int> dp = List.filled(V + 1, V);\n[MASK]\n[MASK]\n    for (int j = V; j >= volumes[i]; j--) {\n      dp[j] = dp[j] < dp[j - volumes[i]] + volumes[i] ? dp[j] : dp[j - volumes[i]] + volumes[i];\n    }\n  }\n  print(V - dp[V]);\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> dp = List.filled(V + 1, V);\n[MASK]\n[MASK]\n    for (int j = V; j >= volumes[i]; j--) {\n      dp[j] = dp[j] < dp[j - volumes[i]] + volumes[i] ? dp[j] : dp[j - volumes[i]] + volumes[i];\n    }\n  }\n  print(V - dp[V]);\n[MASK]\n}"}
{"task_id": "Dart/27-1-multi", "prompt": "int minRemainingSpace(int V, List<int> volumes)\n// # The Box Packing Problem\n//\n// ## Problem Description\n//\n// There is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n//\n// Now, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n//\n// ## Input Format\n//\n// The first line contains a single integer $V$, indicating the capacity of the box.\n//\n// The second line contains a single integer $n$, indicating the total number of items.\n//\n// The following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n//\n// ## Output Format\n//\n// - A single line containing one integer, indicating the minimum remaining space in the box.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// 24\n// 6\n// 8\n// 3\n// 12\n// 7\n// 9\n// 7\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 0\n// ```\n//\n// ## Notes\n//\n// For $100\\%$ of the data, it satisfies $0<n \\le 30$, $1 \\le V \\le 20000$.", "canonical_solution": "{\n  List<int> dp = List.filled(V + 1, V);\n  dp[0] = 0;\n  for (int i = 0; i < volumes.length; i++) {\n    for (int j = V; j >= volumes[i]; j--) {\n      dp[j] = dp[j] < dp[j - volumes[i]] + volumes[i] ? dp[j] : dp[j - volumes[i]] + volumes[i];\n    }\n  }\n  print(V - dp[V]);\n  return V - dp[V];\n}", "test": "void testMinRemainingSpace() {\n  assert(minRemainingSpace(24, [8, 3, 12, 7, 9, 7]) == 0);\n  assert(minRemainingSpace(10, [5, 3, 2, 4]) == 0);\n  assert(minRemainingSpace(30, [10, 14, 20]) == 0);\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testMinRemainingSpace();\n}", "entry_point": "minRemainingSpace", "signature": "int minRemainingSpace(int V, List<int> volumes)", "docstring": "# The Box Packing Problem\n\n## Problem Description\n\nThere is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n\nNow, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n\n## Input Format\n\nThe first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n\n## Output Format\n\n- A single line containing one integer, indicating the minimum remaining space in the box.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n24\n6\n8\n3\n12\n7\n9\n7\n```\n\n### Sample Output #1\n\n```\n0\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# The Box Packing Problem\n\n## Problem Description\n\nThere is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n\nNow, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n\n## Input Format\n\nThe first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n\n## Output Format\n\n- A single line containing one integer, indicating the minimum remaining space in the box.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n24\n6\n8\n3\n12\n7\n9\n7\n```\n\n### Sample Output #1\n\n```\n0\n```\n\n* Incomplete Code:\nint minRemainingSpace(int V, List<int> volumes)\n{\n[MASK]\n[MASK]\n[MASK]\n    for (int j = V; j >= volumes[i]; j--) {\n[MASK]\n    }\n  }\n  print(V - dp[V]);\n  return V - dp[V];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n[MASK]\n[MASK]\n    for (int j = V; j >= volumes[i]; j--) {\n[MASK]\n    }\n  }\n  print(V - dp[V]);\n  return V - dp[V];\n}"}
{"task_id": "Dart/28-0-multi", "prompt": "String decipher(String encryptedMessage, String originalMessage, String toTranslate)\n// #  Infiltrator\n//\n// ## Problem Description\n//\n// The countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n//\n// 1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n// 2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n// 3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n//\n// For instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n//\n// Now, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n//\n// 1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n// 2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n// 3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n//\n// Example:\n//\n// If a certain message $\\tt XYZ$ is translated to $\\tt ABA$, it violates the rule that \"different letters correspond to different cipher letters\".\n//\n// While C is overwhelmed with work, the command headquarters of R sends another telegram, requesting him to translate another encrypted message just intercepted from S. Now, you are asked to help C: using the information obtained through the inside source, attempt to decipher the cipher. Then, using the deciphered cipher, translate the encrypted message in the telegram.\n//\n// ## Input Format\n//\n// There are three lines in total, each being a string of length between $1$ and $100$.\n//\n// The first line is an encrypted message obtained by C;\n//\n// The second line is the original message corresponding to the encrypted message in the first line;\n//\n// The third line is the encrypted message that the command headquarters of R asks C to translate.\n//\n// The input data guarantees that all strings consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$, and the length of the first line is equal to that of the second line.\n//\n// ## Output Format\n//\n// A single line.\n//\n// If decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\n//\n// Otherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// AA\n// AB\n// EOWIE\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// Failed\n// ```\n//\n// ## Sample #2\n//\n// ### Sample Input #2\n//\n// ```\n// QWERTYUIOPLKJHGFDSAZXCVBN\n// ABCDEFGHIJKLMNOPQRSTUVWXY\n// DSLIEWO\n// ```\n//\n// ### Sample Output #2\n//\n// ```\n// Failed\n// ```\n//\n// ## Sample #3\n//\n// ### Sample Input #3\n//\n// ```\n// MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\n// YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\n// FLSO\n// ```\n//\n// ### Sample Output #3\n//\n// ```\n// NOIP\n// ```\n//\n// ## Notes\n//\n// **Explanation for Sample Input #1**\n//\n// The original message's letters $\\tt A$ and $\\tt B$ correspond to the same cipher letter, output $\\tt Failed$.\n//\n// **Explanation for Sample Input #2**\n//\n// The letter $\\tt Z$ did not appear in the original message, output $\\tt Failed$.", "canonical_solution": "{\n  Map<String, String> codeMap = {};\n  Set<String> used = Set();\n  for (int i = 0; i < encryptedMessage.length; i++) {\n    String encryptedChar = encryptedMessage[i];\n    String originalChar = originalMessage[i];\n    if (codeMap.containsKey(encryptedChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    if (used.contains(originalChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    codeMap[encryptedChar] = originalChar;\n    used.add(originalChar);\n  }\n  if (used.length < 26) {\n    return 'Failed';\n  }\n  String result = '';\n  for (int i = 0; i < toTranslate.length; i++) {\n    String charToTranslate = toTranslate[i];\n    if (!codeMap.containsKey(charToTranslate)) {\n      return 'Failed';\n    }\n    result += codeMap[charToTranslate]!;\n  }\n  print(result);\n  return result;\n}", "test": "void testDecipher() {\n    // Test case with all letters mapped to themselves except the given ones are translated\n  assert(decipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"QWERTY\") == \"ABCDEF\");\n  assert(decipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"HELLO\") == \"NCKKI\");\n  assert(decipher(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\");\n}\n\nvoid main() {\n  testDecipher();\n}", "entry_point": "decipher", "signature": "String decipher(String encryptedMessage, String originalMessage, String toTranslate)", "docstring": "#  Infiltrator\n\n## Problem Description\n\nThe countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n\n1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n\nFor instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n\nNow, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n\n1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n\nExample:\n\nIf a certain message $\\tt XYZ$ is translated to $\\tt ABA$, it violates the rule that \"different letters correspond to different cipher letters\".\n\nWhile C is overwhelmed with work, the command headquarters of R sends another telegram, requesting him to translate another encrypted message just intercepted from S. Now, you are asked to help C: using the information obtained through the inside source, attempt to decipher the cipher. Then, using the deciphered cipher, translate the encrypted message in the telegram.\n\n## Input Format\n\nThere are three lines in total, each being a string of length between $1$ and $100$.\n\nThe first line is an encrypted message obtained by C;\n\nThe second line is the original message corresponding to the encrypted message in the first line;\n\nThe third line is the encrypted message that the command headquarters of R asks C to translate.\n\nThe input data guarantees that all strings consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$, and the length of the first line is equal to that of the second line.\n\n## Output Format\n\nA single line.\n\nIf decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\n\nOtherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n\n## Sample #1\n\n### Sample Input #1\n\n```\nAA\nAB\nEOWIE\n```\n\n### Sample Output #1\n\n```\nFailed\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\nQWERTYUIOPLKJHGFDSAZXCVBN\nABCDEFGHIJKLMNOPQRSTUVWXY\nDSLIEWO\n```\n\n### Sample Output #2\n\n```\nFailed\n```\n\n## Sample #3\n\n### Sample Input #3\n\n```\nMSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\nYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\nFLSO\n```\n\n### Sample Output #3\n\n```\nNOIP\n```\n\n## Notes\n\n**Explanation for Sample Input #1**\n\nThe original message's letters $\\tt A$ and $\\tt B$ correspond to the same cipher letter, output $\\tt Failed$.\n\n**Explanation for Sample Input #2**\n\nThe letter $\\tt Z$ did not appear in the original message, output $\\tt Failed$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Infiltrator\n\n## Problem Description\n\nThe countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n\n1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n\nFor instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n\nNow, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n\n1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n\nExample:\n\nIf a certain message $\\tt XYZ$ is translated to $\\tt ABA$, it violates the rule that \"different letters correspond to different cipher letters\".\n\nWhile C is overwhelmed with work, the command headquarters of R sends another telegram, requesting him to translate another encrypted message just intercepted from S. Now, you are asked to help C: using the information obtained through the inside source, attempt to decipher the cipher. Then, using the deciphered cipher, translate the encrypted message in the telegram.\n\n## Input Format\n\nThere are three lines in total, each being a string of length between $1$ and $100$.\n\nThe first line is an encrypted message obtained by C;\n\nThe second line is the original message corresponding to the encrypted message in the first line;\n\nThe third line is the encrypted message that the command headquarters of R asks C to translate.\n\nThe input data guarantees that all strings consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$, and the length of the first line is equal to that of the second line.\n\n## Output Format\n\nA single line.\n\nIf decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\n\nOtherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n\n## Sample #1\n\n### Sample Input #1\n\n```\nAA\nAB\nEOWIE\n```\n\n### Sample Output #1\n\n```\nFailed\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\nQWERTYUIOPLKJHGFDSAZXCVBN\nABCDEFGHIJKLMNOPQRSTUVWXY\nDSLIEWO\n```\n\n### Sample Output #2\n\n```\nFailed\n```\n\n## Sample #3\n\n### Sample Input #3\n\n```\nMSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\nYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\nFLSO\n```\n\n### Sample Output #3\n\n```\nNOIP\n```\n\n## Notes\n\n**Explanation for Sample Input #1**\n\nThe original message's letters $\\tt A$ and $\\tt B$ correspond to the same cipher letter, output $\\tt Failed$.\n\n**Explanation for Sample Input #2**\n\nThe letter $\\tt Z$ did not appear in the original message, output $\\tt Failed$.\n\n* Incomplete Code:\nString decipher(String encryptedMessage, String originalMessage, String toTranslate)\n{\n[MASK]\n  Set<String> used = Set();\n[MASK]\n[MASK]\n    String originalChar = originalMessage[i];\n[MASK]\n      return 'Failed';\n    }\n    if (used.contains(originalChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    codeMap[encryptedChar] = originalChar;\n[MASK]\n  }\n  if (used.length < 26) {\n    return 'Failed';\n  }\n  String result = '';\n  for (int i = 0; i < toTranslate.length; i++) {\n    String charToTranslate = toTranslate[i];\n    if (!codeMap.containsKey(charToTranslate)) {\n      return 'Failed';\n    }\n    result += codeMap[charToTranslate]!;\n  }\n  print(result);\n  return result;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  Set<String> used = Set();\n[MASK]\n[MASK]\n    String originalChar = originalMessage[i];\n[MASK]\n      return 'Failed';\n    }\n    if (used.contains(originalChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    codeMap[encryptedChar] = originalChar;\n[MASK]\n  }\n  if (used.length < 26) {\n    return 'Failed';\n  }\n  String result = '';\n  for (int i = 0; i < toTranslate.length; i++) {\n    String charToTranslate = toTranslate[i];\n    if (!codeMap.containsKey(charToTranslate)) {\n      return 'Failed';\n    }\n    result += codeMap[charToTranslate]!;\n  }\n  print(result);\n  return result;\n}"}
{"task_id": "Dart/28-1-multi", "prompt": "String decipher(String encryptedMessage, String originalMessage, String toTranslate)\n// #  Infiltrator\n//\n// ## Problem Description\n//\n// The countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n//\n// 1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n// 2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n// 3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n//\n// For instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n//\n// Now, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n//\n// 1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n// 2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n// 3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n//\n// Example:\n//\n// If a certain message $\\tt XYZ$ is translated to $\\tt ABA$, it violates the rule that \"different letters correspond to different cipher letters\".\n//\n// While C is overwhelmed with work, the command headquarters of R sends another telegram, requesting him to translate another encrypted message just intercepted from S. Now, you are asked to help C: using the information obtained through the inside source, attempt to decipher the cipher. Then, using the deciphered cipher, translate the encrypted message in the telegram.\n//\n// ## Input Format\n//\n// There are three lines in total, each being a string of length between $1$ and $100$.\n//\n// The first line is an encrypted message obtained by C;\n//\n// The second line is the original message corresponding to the encrypted message in the first line;\n//\n// The third line is the encrypted message that the command headquarters of R asks C to translate.\n//\n// The input data guarantees that all strings consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$, and the length of the first line is equal to that of the second line.\n//\n// ## Output Format\n//\n// A single line.\n//\n// If decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\n//\n// Otherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n//\n// ## Sample #1\n//\n// ### Sample Input #1\n//\n// ```\n// AA\n// AB\n// EOWIE\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// Failed\n// ```\n//\n// ## Sample #2\n//\n// ### Sample Input #2\n//\n// ```\n// QWERTYUIOPLKJHGFDSAZXCVBN\n// ABCDEFGHIJKLMNOPQRSTUVWXY\n// DSLIEWO\n// ```\n//\n// ### Sample Output #2\n//\n// ```\n// Failed\n// ```\n//\n// ## Sample #3\n//\n// ### Sample Input #3\n//\n// ```\n// MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\n// YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\n// FLSO\n// ```\n//\n// ### Sample Output #3\n//\n// ```\n// NOIP\n// ```\n//\n// ## Notes\n//\n// **Explanation for Sample Input #1**\n//\n// The original message's letters $\\tt A$ and $\\tt B$ correspond to the same cipher letter, output $\\tt Failed$.\n//\n// **Explanation for Sample Input #2**\n//\n// The letter $\\tt Z$ did not appear in the original message, output $\\tt Failed$.", "canonical_solution": "{\n  Map<String, String> codeMap = {};\n  Set<String> used = Set();\n  for (int i = 0; i < encryptedMessage.length; i++) {\n    String encryptedChar = encryptedMessage[i];\n    String originalChar = originalMessage[i];\n    if (codeMap.containsKey(encryptedChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    if (used.contains(originalChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    codeMap[encryptedChar] = originalChar;\n    used.add(originalChar);\n  }\n  if (used.length < 26) {\n    return 'Failed';\n  }\n  String result = '';\n  for (int i = 0; i < toTranslate.length; i++) {\n    String charToTranslate = toTranslate[i];\n    if (!codeMap.containsKey(charToTranslate)) {\n      return 'Failed';\n    }\n    result += codeMap[charToTranslate]!;\n  }\n  print(result);\n  return result;\n}", "test": "void testDecipher() {\n    // Test case with all letters mapped to themselves except the given ones are translated\n  assert(decipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"QWERTY\") == \"ABCDEF\");\n  assert(decipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"HELLO\") == \"NCKKI\");\n  assert(decipher(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\");\n}\n\nvoid main() {\n  testDecipher();\n}", "entry_point": "decipher", "signature": "String decipher(String encryptedMessage, String originalMessage, String toTranslate)", "docstring": "#  Infiltrator\n\n## Problem Description\n\nThe countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n\n1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n\nFor instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n\nNow, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n\n1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n\nExample:\n\nIf a certain message $\\tt XYZ$ is translated to $\\tt ABA$, it violates the rule that \"different letters correspond to different cipher letters\".\n\nWhile C is overwhelmed with work, the command headquarters of R sends another telegram, requesting him to translate another encrypted message just intercepted from S. Now, you are asked to help C: using the information obtained through the inside source, attempt to decipher the cipher. Then, using the deciphered cipher, translate the encrypted message in the telegram.\n\n## Input Format\n\nThere are three lines in total, each being a string of length between $1$ and $100$.\n\nThe first line is an encrypted message obtained by C;\n\nThe second line is the original message corresponding to the encrypted message in the first line;\n\nThe third line is the encrypted message that the command headquarters of R asks C to translate.\n\nThe input data guarantees that all strings consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$, and the length of the first line is equal to that of the second line.\n\n## Output Format\n\nA single line.\n\nIf decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\n\nOtherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n\n## Sample #1\n\n### Sample Input #1\n\n```\nAA\nAB\nEOWIE\n```\n\n### Sample Output #1\n\n```\nFailed\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\nQWERTYUIOPLKJHGFDSAZXCVBN\nABCDEFGHIJKLMNOPQRSTUVWXY\nDSLIEWO\n```\n\n### Sample Output #2\n\n```\nFailed\n```\n\n## Sample #3\n\n### Sample Input #3\n\n```\nMSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\nYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\nFLSO\n```\n\n### Sample Output #3\n\n```\nNOIP\n```\n\n## Notes\n\n**Explanation for Sample Input #1**\n\nThe original message's letters $\\tt A$ and $\\tt B$ correspond to the same cipher letter, output $\\tt Failed$.\n\n**Explanation for Sample Input #2**\n\nThe letter $\\tt Z$ did not appear in the original message, output $\\tt Failed$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Infiltrator\n\n## Problem Description\n\nThe countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n\n1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n\nFor instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n\nNow, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n\n1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n\nExample:\n\nIf a certain message $\\tt XYZ$ is translated to $\\tt ABA$, it violates the rule that \"different letters correspond to different cipher letters\".\n\nWhile C is overwhelmed with work, the command headquarters of R sends another telegram, requesting him to translate another encrypted message just intercepted from S. Now, you are asked to help C: using the information obtained through the inside source, attempt to decipher the cipher. Then, using the deciphered cipher, translate the encrypted message in the telegram.\n\n## Input Format\n\nThere are three lines in total, each being a string of length between $1$ and $100$.\n\nThe first line is an encrypted message obtained by C;\n\nThe second line is the original message corresponding to the encrypted message in the first line;\n\nThe third line is the encrypted message that the command headquarters of R asks C to translate.\n\nThe input data guarantees that all strings consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$, and the length of the first line is equal to that of the second line.\n\n## Output Format\n\nA single line.\n\nIf decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\n\nOtherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n\n## Sample #1\n\n### Sample Input #1\n\n```\nAA\nAB\nEOWIE\n```\n\n### Sample Output #1\n\n```\nFailed\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\nQWERTYUIOPLKJHGFDSAZXCVBN\nABCDEFGHIJKLMNOPQRSTUVWXY\nDSLIEWO\n```\n\n### Sample Output #2\n\n```\nFailed\n```\n\n## Sample #3\n\n### Sample Input #3\n\n```\nMSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\nYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\nFLSO\n```\n\n### Sample Output #3\n\n```\nNOIP\n```\n\n## Notes\n\n**Explanation for Sample Input #1**\n\nThe original message's letters $\\tt A$ and $\\tt B$ correspond to the same cipher letter, output $\\tt Failed$.\n\n**Explanation for Sample Input #2**\n\nThe letter $\\tt Z$ did not appear in the original message, output $\\tt Failed$.\n\n* Incomplete Code:\nString decipher(String encryptedMessage, String originalMessage, String toTranslate)\n{\n  Map<String, String> codeMap = {};\n  Set<String> used = Set();\n  for (int i = 0; i < encryptedMessage.length; i++) {\n    String encryptedChar = encryptedMessage[i];\n[MASK]\n[MASK]\n      return 'Failed';\n    }\n[MASK]\n      return 'Failed';\n    }\n[MASK]\n    used.add(originalChar);\n  }\n  if (used.length < 26) {\n    return 'Failed';\n  }\n  String result = '';\n  for (int i = 0; i < toTranslate.length; i++) {\n[MASK]\n    if (!codeMap.containsKey(charToTranslate)) {\n      return 'Failed';\n    }\n    result += codeMap[charToTranslate]!;\n  }\n  print(result);\n  return result;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  Map<String, String> codeMap = {};\n  Set<String> used = Set();\n  for (int i = 0; i < encryptedMessage.length; i++) {\n    String encryptedChar = encryptedMessage[i];\n[MASK]\n[MASK]\n      return 'Failed';\n    }\n[MASK]\n      return 'Failed';\n    }\n[MASK]\n    used.add(originalChar);\n  }\n  if (used.length < 26) {\n    return 'Failed';\n  }\n  String result = '';\n  for (int i = 0; i < toTranslate.length; i++) {\n[MASK]\n    if (!codeMap.containsKey(charToTranslate)) {\n      return 'Failed';\n    }\n    result += codeMap[charToTranslate]!;\n  }\n  print(result);\n  return result;\n}"}
{"task_id": "Dart/29-0-multi", "prompt": "int countArrangements(int n, int m, List<int> a)\n// #Arranging Flowers\n//\n// ## Problem Description\n//\n// Upon the grand opening of Xiao Ming's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, Xiao Ming has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\n//\n// The task is to compute the total number of distinct flower arranging schemes.\n//\n// ## Input Format\n//\n// The first line contains two positive integers $n$ and $m$, separated by a space.\n//\n// The second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n//\n// ## Output Format\n//\n// Output a single integer, representing the number of schemes. Note: Since the number of schemes might be large, please output the number of schemes modulo $10^6+7$.\n//\n// ## Sample Case #1\n//\n// ### Sample Input #1\n//\n// ```\n// 2 4\n// 3 2\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 2\n// ```\n//\n// ## Note\n//\n// 【Data Range】\n//\n// For $20\\%$ of the data, $0<n \\le 8, 0<m \\le 8, 0 \\le a_i \\le 8$.\n//\n// For $50\\%$ of the data, $0<n \\le 20, 0<m \\le 20, 0 \\le a_i \\le 20$.\n//\n// For $100\\%$ of the data, $0<n \\le 100, 0<m \\le 100, 0 \\le a_i \\le 100$.", "canonical_solution": "{\n  const int mod = 1000007;\n  List<List<int>> dp = List.generate(n + 1, (_) => List.generate(m + 1, (_) => 0));\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      for (int k = 0; k <= a[i - 1] && k <= j; k++) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod;\n      }\n    }\n  }\n  return dp[n][m];\n}", "test": "void testCountWays() {\n  // Test case 1: Simple case\n  assert(countArrangements(1, 2, [2]) == 1);\n\n  // Test case 2: Two types, more combinations\n  assert(countArrangements(2, 2, [1, 1]) == 1);\n\n  // Test case 3: More complicated case\n  assert(countArrangements(3, 3, [1, 2, 3]) == 6);\n}\n\nvoid main() {\n  testCountWays();\n}", "entry_point": "countArrangements", "signature": "int countArrangements(int n, int m, List<int> a)", "docstring": "#Arranging Flowers\n\n## Problem Description\n\nUpon the grand opening of Xiao Ming's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, Xiao Ming has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\n\nThe task is to compute the total number of distinct flower arranging schemes.\n\n## Input Format\n\nThe first line contains two positive integers $n$ and $m$, separated by a space.\n\nThe second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n\n## Output Format\n\nOutput a single integer, representing the number of schemes. Note: Since the number of schemes might be large, please output the number of schemes modulo $10^6+7$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2 4\n3 2\n```\n\n### Sample Output #1\n\n```\n2\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#Arranging Flowers\n\n## Problem Description\n\nUpon the grand opening of Xiao Ming's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, Xiao Ming has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\n\nThe task is to compute the total number of distinct flower arranging schemes.\n\n## Input Format\n\nThe first line contains two positive integers $n$ and $m$, separated by a space.\n\nThe second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n\n## Output Format\n\nOutput a single integer, representing the number of schemes. Note: Since the number of schemes might be large, please output the number of schemes modulo $10^6+7$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2 4\n3 2\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n* Incomplete Code:\nint countArrangements(int n, int m, List<int> a)\n{\n[MASK]\n  List<List<int>> dp = List.generate(n + 1, (_) => List.generate(m + 1, (_) => 0));\n[MASK]\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      for (int k = 0; k <= a[i - 1] && k <= j; k++) {\n[MASK]\n      }\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  List<List<int>> dp = List.generate(n + 1, (_) => List.generate(m + 1, (_) => 0));\n[MASK]\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      for (int k = 0; k <= a[i - 1] && k <= j; k++) {\n[MASK]\n      }\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/29-1-multi", "prompt": "int countArrangements(int n, int m, List<int> a)\n// #Arranging Flowers\n//\n// ## Problem Description\n//\n// Upon the grand opening of Xiao Ming's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, Xiao Ming has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\n//\n// The task is to compute the total number of distinct flower arranging schemes.\n//\n// ## Input Format\n//\n// The first line contains two positive integers $n$ and $m$, separated by a space.\n//\n// The second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n//\n// ## Output Format\n//\n// Output a single integer, representing the number of schemes. Note: Since the number of schemes might be large, please output the number of schemes modulo $10^6+7$.\n//\n// ## Sample Case #1\n//\n// ### Sample Input #1\n//\n// ```\n// 2 4\n// 3 2\n// ```\n//\n// ### Sample Output #1\n//\n// ```\n// 2\n// ```\n//\n// ## Note\n//\n// 【Data Range】\n//\n// For $20\\%$ of the data, $0<n \\le 8, 0<m \\le 8, 0 \\le a_i \\le 8$.\n//\n// For $50\\%$ of the data, $0<n \\le 20, 0<m \\le 20, 0 \\le a_i \\le 20$.\n//\n// For $100\\%$ of the data, $0<n \\le 100, 0<m \\le 100, 0 \\le a_i \\le 100$.", "canonical_solution": "{\n  const int mod = 1000007;\n  List<List<int>> dp = List.generate(n + 1, (_) => List.generate(m + 1, (_) => 0));\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      for (int k = 0; k <= a[i - 1] && k <= j; k++) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod;\n      }\n    }\n  }\n  return dp[n][m];\n}", "test": "void testCountWays() {\n  // Test case 1: Simple case\n  assert(countArrangements(1, 2, [2]) == 1);\n\n  // Test case 2: Two types, more combinations\n  assert(countArrangements(2, 2, [1, 1]) == 1);\n\n  // Test case 3: More complicated case\n  assert(countArrangements(3, 3, [1, 2, 3]) == 6);\n}\n\nvoid main() {\n  testCountWays();\n}", "entry_point": "countArrangements", "signature": "int countArrangements(int n, int m, List<int> a)", "docstring": "#Arranging Flowers\n\n## Problem Description\n\nUpon the grand opening of Xiao Ming's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, Xiao Ming has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\n\nThe task is to compute the total number of distinct flower arranging schemes.\n\n## Input Format\n\nThe first line contains two positive integers $n$ and $m$, separated by a space.\n\nThe second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n\n## Output Format\n\nOutput a single integer, representing the number of schemes. Note: Since the number of schemes might be large, please output the number of schemes modulo $10^6+7$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2 4\n3 2\n```\n\n### Sample Output #1\n\n```\n2\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#Arranging Flowers\n\n## Problem Description\n\nUpon the grand opening of Xiao Ming's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, Xiao Ming has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\n\nThe task is to compute the total number of distinct flower arranging schemes.\n\n## Input Format\n\nThe first line contains two positive integers $n$ and $m$, separated by a space.\n\nThe second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n\n## Output Format\n\nOutput a single integer, representing the number of schemes. Note: Since the number of schemes might be large, please output the number of schemes modulo $10^6+7$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2 4\n3 2\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n* Incomplete Code:\nint countArrangements(int n, int m, List<int> a)\n{\n  const int mod = 1000007;\n[MASK]\n[MASK]\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      for (int k = 0; k <= a[i - 1] && k <= j; k++) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod;\n      }\n    }\n  }\n  return dp[n][m];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  const int mod = 1000007;\n[MASK]\n[MASK]\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      for (int k = 0; k <= a[i - 1] && k <= j; k++) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod;\n      }\n    }\n  }\n  return dp[n][m];\n}"}
{"task_id": "Dart/30-0-multi", "prompt": "int modInverse(int a, int b)\n\n/*\n#Congruence Equation\n\n## Problem Description\n\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\n## Input Format\n\nA single line containing two integers $a, b$, separated by a space.\n\n## Output Format\n\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n3 10\n```\n\n### Sample Output #1\n\n```\n7\n```\n\n## Notes\n\n### Data Specifications and Constraints\n\n- For $40\\%$ of the data, $2 \\leq b \\leq 1,000$;\n- For $60\\%$ of the data, $2 \\leq b \\leq 50,000,000$;\n- For $100\\%$ of the data, $2 \\leq a, b \\leq 2,000,000,000$._\n*/", "canonical_solution": "{\n  int b0 = b, t, q;\n  int x0 = 0, x1 = 1;\n  if (b == 1) return 1;\n  while (a > 1) {\n    q = a ~/ b;\n    t = b;\n    b = a % b;\n    a = t;\n    t = x0;\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n  if (x1 < 0) x1 += b0;\n  return x1;\n}", "test": "void testModInverse() {\n  assert(modInverse(3, 10) == 7);\n  assert(modInverse(25, 28) == 9);\n  assert(modInverse(4, 7) == 2);\n}\n\nvoid main() {\n  testModInverse();\n}", "entry_point": "modInverse", "signature": "int modInverse(int a, int b)", "docstring": "#Congruence Equation\n\n## Problem Description\n\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\n## Input Format\n\nA single line containing two integers $a, b$, separated by a space.\n\n## Output Format\n\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n3 10\n```\n\n### Sample Output #1\n\n```\n7\n```\n\n## Notes\n\n### Data Specifications and Constraints\n\n- For $40\\%$ of the data, $2 \\leq b \\leq 1,000$;\n- For $60\\%$ of the data, $2 \\leq b \\leq 50,000,000$;\n- For $100\\%$ of the data, $2 \\leq a, b \\leq 2,000,000,000$._", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#Congruence Equation\n\n## Problem Description\n\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\n## Input Format\n\nA single line containing two integers $a, b$, separated by a space.\n\n## Output Format\n\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n3 10\n```\n\n### Sample Output #1\n\n```\n7\n```\n\n## Notes\n\n### Data Specifications and Constraints\n\n- For $40\\%$ of the data, $2 \\leq b \\leq 1,000$;\n- For $60\\%$ of the data, $2 \\leq b \\leq 50,000,000$;\n- For $100\\%$ of the data, $2 \\leq a, b \\leq 2,000,000,000$._\n\n* Incomplete Code:\nint modInverse(int a, int b)\n{\n  int b0 = b, t, q;\n  int x0 = 0, x1 = 1;\n  if (b == 1) return 1;\n  while (a > 1) {\n[MASK]\n    t = b;\n    b = a % b;\n    a = t;\n    t = x0;\n[MASK]\n[MASK]\n  }\n  if (x1 < 0) x1 += b0;\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int b0 = b, t, q;\n  int x0 = 0, x1 = 1;\n  if (b == 1) return 1;\n  while (a > 1) {\n[MASK]\n    t = b;\n    b = a % b;\n    a = t;\n    t = x0;\n[MASK]\n[MASK]\n  }\n  if (x1 < 0) x1 += b0;\n[MASK]\n}"}
{"task_id": "Dart/30-1-multi", "prompt": "int modInverse(int a, int b)\n\n/*\n#Congruence Equation\n\n## Problem Description\n\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\n## Input Format\n\nA single line containing two integers $a, b$, separated by a space.\n\n## Output Format\n\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n3 10\n```\n\n### Sample Output #1\n\n```\n7\n```\n\n## Notes\n\n### Data Specifications and Constraints\n\n- For $40\\%$ of the data, $2 \\leq b \\leq 1,000$;\n- For $60\\%$ of the data, $2 \\leq b \\leq 50,000,000$;\n- For $100\\%$ of the data, $2 \\leq a, b \\leq 2,000,000,000$._\n*/", "canonical_solution": "{\n  int b0 = b, t, q;\n  int x0 = 0, x1 = 1;\n  if (b == 1) return 1;\n  while (a > 1) {\n    q = a ~/ b;\n    t = b;\n    b = a % b;\n    a = t;\n    t = x0;\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n  if (x1 < 0) x1 += b0;\n  return x1;\n}", "test": "void testModInverse() {\n  assert(modInverse(3, 10) == 7);\n  assert(modInverse(25, 28) == 9);\n  assert(modInverse(4, 7) == 2);\n}\n\nvoid main() {\n  testModInverse();\n}", "entry_point": "modInverse", "signature": "int modInverse(int a, int b)", "docstring": "#Congruence Equation\n\n## Problem Description\n\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\n## Input Format\n\nA single line containing two integers $a, b$, separated by a space.\n\n## Output Format\n\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n3 10\n```\n\n### Sample Output #1\n\n```\n7\n```\n\n## Notes\n\n### Data Specifications and Constraints\n\n- For $40\\%$ of the data, $2 \\leq b \\leq 1,000$;\n- For $60\\%$ of the data, $2 \\leq b \\leq 50,000,000$;\n- For $100\\%$ of the data, $2 \\leq a, b \\leq 2,000,000,000$._", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#Congruence Equation\n\n## Problem Description\n\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\n## Input Format\n\nA single line containing two integers $a, b$, separated by a space.\n\n## Output Format\n\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n3 10\n```\n\n### Sample Output #1\n\n```\n7\n```\n\n## Notes\n\n### Data Specifications and Constraints\n\n- For $40\\%$ of the data, $2 \\leq b \\leq 1,000$;\n- For $60\\%$ of the data, $2 \\leq b \\leq 50,000,000$;\n- For $100\\%$ of the data, $2 \\leq a, b \\leq 2,000,000,000$._\n\n* Incomplete Code:\nint modInverse(int a, int b)\n{\n  int b0 = b, t, q;\n  int x0 = 0, x1 = 1;\n  if (b == 1) return 1;\n[MASK]\n    q = a ~/ b;\n    t = b;\n[MASK]\n    a = t;\n[MASK]\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n  if (x1 < 0) x1 += b0;\n  return x1;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int b0 = b, t, q;\n  int x0 = 0, x1 = 1;\n  if (b == 1) return 1;\n[MASK]\n    q = a ~/ b;\n    t = b;\n[MASK]\n    a = t;\n[MASK]\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n  if (x1 < 0) x1 += b0;\n  return x1;\n}"}
{"task_id": "Dart/31-0-multi", "prompt": "int findMostUnhappyDay(List<List<int>> schedule)\n\n/**\n# [NOIP2004 Junior Division] The Discontent of Jinjin\n\n## Problem Description\n\nJinjin has entered junior high school. Her mother believes that Jinjin should be more dedicated to her studies; therefore, aside from attending school, Jinjin is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if Jinjin's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming Jinjin's discontent arises from no other cause and does not carry over to the next day, please help check Jinjin's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time Jinjin spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Notes\n\nNOIP2004 Junior Division Question 1\n\n- October 27, 2021: Added a set of hack data\n- June 5, 2022: Another set of hack data added\n*/", "canonical_solution": "{\n  int mostUnhappyDay = 0;\n  int maxUnhappiness = 0;\n  for (int i = 0; i < 7; i++) {\n    int schoolTime = schedule[i][0], extraClassTime = schedule[i][1];\n    int totalStudyTime = schoolTime + extraClassTime;\n    if (totalStudyTime > 8 && totalStudyTime > maxUnhappiness) {\n      maxUnhappiness = totalStudyTime;\n      mostUnhappyDay = i + 1; // Adjusting index to match days (1-7)\n    }\n  }\n  return mostUnhappyDay;\n}", "test": "void testFindMostUnhappyDay() {\n  // Test case 1\n  assert(findMostUnhappyDay([\n    [5, 3],\n    [6, 2],\n    [7, 2],\n    [5, 3],\n    [5, 4],\n    [0, 4],\n    [0, 6]\n  ]) == 3);\n\n  // Test case 2\n  assert(findMostUnhappyDay([\n    [2, 3],\n    [1, 2],\n    [2, 2],\n    [3, 5],\n    [6, 2],\n    [5, 3],\n    [4, 4]\n  ]) == 0);\n\n  // Test case 3\n  assert(findMostUnhappyDay([\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 7],\n    [8, 1]\n  ]) == 7);\n}\n\nvoid main() {\n  testFindMostUnhappyDay();\n}", "entry_point": "findMostUnhappyDay", "signature": "int findMostUnhappyDay(List<List<int>> schedule)", "docstring": "# [NOIP2004 Junior Division] The Discontent of Jinjin\n\n## Problem Description\n\nJinjin has entered junior high school. Her mother believes that Jinjin should be more dedicated to her studies; therefore, aside from attending school, Jinjin is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if Jinjin's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming Jinjin's discontent arises from no other cause and does not carry over to the next day, please help check Jinjin's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time Jinjin spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Notes\n\nNOIP2004 Junior Division Question 1\n\n- October 27, 2021: Added a set of hack data\n- June 5, 2022: Another set of hack data added", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# [NOIP2004 Junior Division] The Discontent of Jinjin\n\n## Problem Description\n\nJinjin has entered junior high school. Her mother believes that Jinjin should be more dedicated to her studies; therefore, aside from attending school, Jinjin is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if Jinjin's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming Jinjin's discontent arises from no other cause and does not carry over to the next day, please help check Jinjin's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time Jinjin spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Notes\n\nNOIP2004 Junior Division Question 1\n\n- October 27, 2021: Added a set of hack data\n- June 5, 2022: Another set of hack data added\n\n* Incomplete Code:\nint findMostUnhappyDay(List<List<int>> schedule)\n{\n  int mostUnhappyDay = 0;\n[MASK]\n  for (int i = 0; i < 7; i++) {\n    int schoolTime = schedule[i][0], extraClassTime = schedule[i][1];\n    int totalStudyTime = schoolTime + extraClassTime;\n    if (totalStudyTime > 8 && totalStudyTime > maxUnhappiness) {\n[MASK]\n      mostUnhappyDay = i + 1; // Adjusting index to match days (1-7)\n    }\n  }\n  return mostUnhappyDay;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int mostUnhappyDay = 0;\n[MASK]\n  for (int i = 0; i < 7; i++) {\n    int schoolTime = schedule[i][0], extraClassTime = schedule[i][1];\n    int totalStudyTime = schoolTime + extraClassTime;\n    if (totalStudyTime > 8 && totalStudyTime > maxUnhappiness) {\n[MASK]\n      mostUnhappyDay = i + 1; // Adjusting index to match days (1-7)\n    }\n  }\n  return mostUnhappyDay;\n}"}
{"task_id": "Dart/31-1-multi", "prompt": "int findMostUnhappyDay(List<List<int>> schedule)\n\n/**\n# [NOIP2004 Junior Division] The Discontent of Jinjin\n\n## Problem Description\n\nJinjin has entered junior high school. Her mother believes that Jinjin should be more dedicated to her studies; therefore, aside from attending school, Jinjin is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if Jinjin's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming Jinjin's discontent arises from no other cause and does not carry over to the next day, please help check Jinjin's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time Jinjin spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Notes\n\nNOIP2004 Junior Division Question 1\n\n- October 27, 2021: Added a set of hack data\n- June 5, 2022: Another set of hack data added\n*/", "canonical_solution": "{\n  int mostUnhappyDay = 0;\n  int maxUnhappiness = 0;\n  for (int i = 0; i < 7; i++) {\n    int schoolTime = schedule[i][0], extraClassTime = schedule[i][1];\n    int totalStudyTime = schoolTime + extraClassTime;\n    if (totalStudyTime > 8 && totalStudyTime > maxUnhappiness) {\n      maxUnhappiness = totalStudyTime;\n      mostUnhappyDay = i + 1; // Adjusting index to match days (1-7)\n    }\n  }\n  return mostUnhappyDay;\n}", "test": "void testFindMostUnhappyDay() {\n  // Test case 1\n  assert(findMostUnhappyDay([\n    [5, 3],\n    [6, 2],\n    [7, 2],\n    [5, 3],\n    [5, 4],\n    [0, 4],\n    [0, 6]\n  ]) == 3);\n\n  // Test case 2\n  assert(findMostUnhappyDay([\n    [2, 3],\n    [1, 2],\n    [2, 2],\n    [3, 5],\n    [6, 2],\n    [5, 3],\n    [4, 4]\n  ]) == 0);\n\n  // Test case 3\n  assert(findMostUnhappyDay([\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 7],\n    [8, 1]\n  ]) == 7);\n}\n\nvoid main() {\n  testFindMostUnhappyDay();\n}", "entry_point": "findMostUnhappyDay", "signature": "int findMostUnhappyDay(List<List<int>> schedule)", "docstring": "# [NOIP2004 Junior Division] The Discontent of Jinjin\n\n## Problem Description\n\nJinjin has entered junior high school. Her mother believes that Jinjin should be more dedicated to her studies; therefore, aside from attending school, Jinjin is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if Jinjin's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming Jinjin's discontent arises from no other cause and does not carry over to the next day, please help check Jinjin's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time Jinjin spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Notes\n\nNOIP2004 Junior Division Question 1\n\n- October 27, 2021: Added a set of hack data\n- June 5, 2022: Another set of hack data added", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# [NOIP2004 Junior Division] The Discontent of Jinjin\n\n## Problem Description\n\nJinjin has entered junior high school. Her mother believes that Jinjin should be more dedicated to her studies; therefore, aside from attending school, Jinjin is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if Jinjin's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming Jinjin's discontent arises from no other cause and does not carry over to the next day, please help check Jinjin's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time Jinjin spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Notes\n\nNOIP2004 Junior Division Question 1\n\n- October 27, 2021: Added a set of hack data\n- June 5, 2022: Another set of hack data added\n\n* Incomplete Code:\nint findMostUnhappyDay(List<List<int>> schedule)\n{\n  int mostUnhappyDay = 0;\n  int maxUnhappiness = 0;\n  for (int i = 0; i < 7; i++) {\n    int schoolTime = schedule[i][0], extraClassTime = schedule[i][1];\n    int totalStudyTime = schoolTime + extraClassTime;\n    if (totalStudyTime > 8 && totalStudyTime > maxUnhappiness) {\n[MASK]\n[MASK]\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int mostUnhappyDay = 0;\n  int maxUnhappiness = 0;\n  for (int i = 0; i < 7; i++) {\n    int schoolTime = schedule[i][0], extraClassTime = schedule[i][1];\n    int totalStudyTime = schoolTime + extraClassTime;\n    if (totalStudyTime > 8 && totalStudyTime > maxUnhappiness) {\n[MASK]\n[MASK]\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/32-0-multi", "prompt": "List<int> calculateNewDigits(int N, int M, List<int> digits)\n/**\n# Martians\n\n## Problem Description\n\nHumanity has finally set foot on Martian soil and encountered the enigmatic Martians. Neither humans nor Martians can comprehend each other's languages; however, our scientists have devised a method of communication using numbers. This method involves the Martian conveying an exceedingly large number to the human scientists, who, upon deciphering its meaning, add a relatively small number to the large one and relay the result back to the Martians as the human response.\n\nMartians represent numbers in a very simplistic manner—by bending fingers. Martians have only one hand, but it is equipped with thousands of fingers arranged in a row, numbered $1,2,3,\\cdots$. Martians can freely interchange the positions of any two fingers, and this is the method they use for counting.\n\nA Martian demonstrated their counting technique using a human hand. If the five fingers—thumb, index finger, middle finger, ring finger, and little finger—are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\nYou now have the privilege of being the first Earthling to communicate with Martians. A Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\n\nThere are three lines in total.  \nThe first line contains a positive integer $N$, indicating the number of Martian fingers ($1 \\le N \\le 10000$).  \nThe second line contains a positive integer $M$, representing the small integer to be added ($1  \\le  M  \\le  100$).  \nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5\n3\n1 2 3 4 5\n```\n\n### Sample Output #1\n\n```\n1 2 4 5 3\n```\n\n## Hints\n\nFor $30\\%$ of the data, $N \\le 15$.\n\nFor $60\\%$ of the data, $N \\le 50$.\n\nFor $100\\%$ of the data, $N \\le 10000$.\n\nNOIP2004 general group question 4\n*/", "canonical_solution": " {\n  int originalNumber = digits.reduce((a, b) => a * 10 + b);\n  int newNumber = originalNumber + M;\n  List<int> newDigits = [];\n\n  while (newNumber > 0) {\n    newDigits.insert(0, newNumber % 10);\n    newNumber ~/= 10;\n  }\n\n  return newDigits;\n}", "test": "void testCalculateNewDigits() {\n  assert(calculateNewDigits(3, 123, [1, 2, 3]).join() == '246');\n  assert(calculateNewDigits(4, 0, [1, 0, 0, 0]).join() == '1000');\n  assert(calculateNewDigits(2, 99, [3, 1]).join() == '130');\n\n  print('All tests passed!');\n}\n\n\nvoid main() {\n  testCalculateNewDigits();\n}", "entry_point": "calculateNewDigits", "signature": "List<int> calculateNewDigits(int N, int M, List<int> digits)", "docstring": "# Martians\n\n## Problem Description\n\nHumanity has finally set foot on Martian soil and encountered the enigmatic Martians. Neither humans nor Martians can comprehend each other's languages; however, our scientists have devised a method of communication using numbers. This method involves the Martian conveying an exceedingly large number to the human scientists, who, upon deciphering its meaning, add a relatively small number to the large one and relay the result back to the Martians as the human response.\n\nMartians represent numbers in a very simplistic manner—by bending fingers. Martians have only one hand, but it is equipped with thousands of fingers arranged in a row, numbered $1,2,3,\\cdots$. Martians can freely interchange the positions of any two fingers, and this is the method they use for counting.\n\nA Martian demonstrated their counting technique using a human hand. If the five fingers—thumb, index finger, middle finger, ring finger, and little finger—are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\nYou now have the privilege of being the first Earthling to communicate with Martians. A Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\n\nThere are three lines in total.\nThe first line contains a positive integer $N$, indicating the number of Martian fingers ($1 \\le N \\le 10000$).\nThe second line contains a positive integer $M$, representing the small integer to be added ($1  \\le  M  \\le  100$).\nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5\n3\n1 2 3 4 5\n```\n\n### Sample Output #1\n\n```\n1 2 4 5 3\n```\n\n## Hints\n\nFor $30\\%$ of the data, $N \\le 15$.\n\nFor $60\\%$ of the data, $N \\le 50$.\n\nFor $100\\%$ of the data, $N \\le 10000$.\n\nNOIP2004 general group question 4", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Martians\n\n## Problem Description\n\nHumanity has finally set foot on Martian soil and encountered the enigmatic Martians. Neither humans nor Martians can comprehend each other's languages; however, our scientists have devised a method of communication using numbers. This method involves the Martian conveying an exceedingly large number to the human scientists, who, upon deciphering its meaning, add a relatively small number to the large one and relay the result back to the Martians as the human response.\n\nMartians represent numbers in a very simplistic manner—by bending fingers. Martians have only one hand, but it is equipped with thousands of fingers arranged in a row, numbered $1,2,3,\\cdots$. Martians can freely interchange the positions of any two fingers, and this is the method they use for counting.\n\nA Martian demonstrated their counting technique using a human hand. If the five fingers—thumb, index finger, middle finger, ring finger, and little finger—are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\nYou now have the privilege of being the first Earthling to communicate with Martians. A Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\n\nThere are three lines in total.\nThe first line contains a positive integer $N$, indicating the number of Martian fingers ($1 \\le N \\le 10000$).\nThe second line contains a positive integer $M$, representing the small integer to be added ($1  \\le  M  \\le  100$).\nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5\n3\n1 2 3 4 5\n```\n\n### Sample Output #1\n\n```\n1 2 4 5 3\n```\n\n## Hints\n\nFor $30\\%$ of the data, $N \\le 15$.\n\nFor $60\\%$ of the data, $N \\le 50$.\n\nFor $100\\%$ of the data, $N \\le 10000$.\n\nNOIP2004 general group question 4\n\n* Incomplete Code:\nList<int> calculateNewDigits(int N, int M, List<int> digits)\n {\n  int originalNumber = digits.reduce((a, b) => a * 10 + b);\n  int newNumber = originalNumber + M;\n  List<int> newDigits = [];\n\n[MASK]\n[MASK]\n[MASK]\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  int originalNumber = digits.reduce((a, b) => a * 10 + b);\n  int newNumber = originalNumber + M;\n  List<int> newDigits = [];\n\n[MASK]\n[MASK]\n[MASK]\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/32-1-multi", "prompt": "List<int> calculateNewDigits(int N, int M, List<int> digits)\n/**\n# Martians\n\n## Problem Description\n\nHumanity has finally set foot on Martian soil and encountered the enigmatic Martians. Neither humans nor Martians can comprehend each other's languages; however, our scientists have devised a method of communication using numbers. This method involves the Martian conveying an exceedingly large number to the human scientists, who, upon deciphering its meaning, add a relatively small number to the large one and relay the result back to the Martians as the human response.\n\nMartians represent numbers in a very simplistic manner—by bending fingers. Martians have only one hand, but it is equipped with thousands of fingers arranged in a row, numbered $1,2,3,\\cdots$. Martians can freely interchange the positions of any two fingers, and this is the method they use for counting.\n\nA Martian demonstrated their counting technique using a human hand. If the five fingers—thumb, index finger, middle finger, ring finger, and little finger—are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\nYou now have the privilege of being the first Earthling to communicate with Martians. A Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\n\nThere are three lines in total.  \nThe first line contains a positive integer $N$, indicating the number of Martian fingers ($1 \\le N \\le 10000$).  \nThe second line contains a positive integer $M$, representing the small integer to be added ($1  \\le  M  \\le  100$).  \nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5\n3\n1 2 3 4 5\n```\n\n### Sample Output #1\n\n```\n1 2 4 5 3\n```\n\n## Hints\n\nFor $30\\%$ of the data, $N \\le 15$.\n\nFor $60\\%$ of the data, $N \\le 50$.\n\nFor $100\\%$ of the data, $N \\le 10000$.\n\nNOIP2004 general group question 4\n*/", "canonical_solution": " {\n  int originalNumber = digits.reduce((a, b) => a * 10 + b);\n  int newNumber = originalNumber + M;\n  List<int> newDigits = [];\n\n  while (newNumber > 0) {\n    newDigits.insert(0, newNumber % 10);\n    newNumber ~/= 10;\n  }\n\n  return newDigits;\n}", "test": "void testCalculateNewDigits() {\n  assert(calculateNewDigits(3, 123, [1, 2, 3]).join() == '246');\n  assert(calculateNewDigits(4, 0, [1, 0, 0, 0]).join() == '1000');\n  assert(calculateNewDigits(2, 99, [3, 1]).join() == '130');\n\n  print('All tests passed!');\n}\n\n\nvoid main() {\n  testCalculateNewDigits();\n}", "entry_point": "calculateNewDigits", "signature": "List<int> calculateNewDigits(int N, int M, List<int> digits)", "docstring": "# Martians\n\n## Problem Description\n\nHumanity has finally set foot on Martian soil and encountered the enigmatic Martians. Neither humans nor Martians can comprehend each other's languages; however, our scientists have devised a method of communication using numbers. This method involves the Martian conveying an exceedingly large number to the human scientists, who, upon deciphering its meaning, add a relatively small number to the large one and relay the result back to the Martians as the human response.\n\nMartians represent numbers in a very simplistic manner—by bending fingers. Martians have only one hand, but it is equipped with thousands of fingers arranged in a row, numbered $1,2,3,\\cdots$. Martians can freely interchange the positions of any two fingers, and this is the method they use for counting.\n\nA Martian demonstrated their counting technique using a human hand. If the five fingers—thumb, index finger, middle finger, ring finger, and little finger—are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\nYou now have the privilege of being the first Earthling to communicate with Martians. A Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\n\nThere are three lines in total.\nThe first line contains a positive integer $N$, indicating the number of Martian fingers ($1 \\le N \\le 10000$).\nThe second line contains a positive integer $M$, representing the small integer to be added ($1  \\le  M  \\le  100$).\nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5\n3\n1 2 3 4 5\n```\n\n### Sample Output #1\n\n```\n1 2 4 5 3\n```\n\n## Hints\n\nFor $30\\%$ of the data, $N \\le 15$.\n\nFor $60\\%$ of the data, $N \\le 50$.\n\nFor $100\\%$ of the data, $N \\le 10000$.\n\nNOIP2004 general group question 4", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Martians\n\n## Problem Description\n\nHumanity has finally set foot on Martian soil and encountered the enigmatic Martians. Neither humans nor Martians can comprehend each other's languages; however, our scientists have devised a method of communication using numbers. This method involves the Martian conveying an exceedingly large number to the human scientists, who, upon deciphering its meaning, add a relatively small number to the large one and relay the result back to the Martians as the human response.\n\nMartians represent numbers in a very simplistic manner—by bending fingers. Martians have only one hand, but it is equipped with thousands of fingers arranged in a row, numbered $1,2,3,\\cdots$. Martians can freely interchange the positions of any two fingers, and this is the method they use for counting.\n\nA Martian demonstrated their counting technique using a human hand. If the five fingers—thumb, index finger, middle finger, ring finger, and little finger—are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\nYou now have the privilege of being the first Earthling to communicate with Martians. A Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\n\nThere are three lines in total.\nThe first line contains a positive integer $N$, indicating the number of Martian fingers ($1 \\le N \\le 10000$).\nThe second line contains a positive integer $M$, representing the small integer to be added ($1  \\le  M  \\le  100$).\nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n5\n3\n1 2 3 4 5\n```\n\n### Sample Output #1\n\n```\n1 2 4 5 3\n```\n\n## Hints\n\nFor $30\\%$ of the data, $N \\le 15$.\n\nFor $60\\%$ of the data, $N \\le 50$.\n\nFor $100\\%$ of the data, $N \\le 10000$.\n\nNOIP2004 general group question 4\n\n* Incomplete Code:\nList<int> calculateNewDigits(int N, int M, List<int> digits)\n {\n  int originalNumber = digits.reduce((a, b) => a * 10 + b);\n[MASK]\n[MASK]\n\n[MASK]\n[MASK]\n[MASK]\n  }\n\n  return newDigits;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  int originalNumber = digits.reduce((a, b) => a * 10 + b);\n[MASK]\n[MASK]\n\n[MASK]\n[MASK]\n[MASK]\n  }\n\n  return newDigits;\n}"}
{"task_id": "Dart/33-0-multi", "prompt": "int calculateSavings(List<int> budgets)\n/**\n * # Jinjin's Savings Plan\n\n## Problem Description\n\nJinjin has always managed her pocket money by herself. At the beginning of each month, her mother gives Jinjin 300 yuan, from which Jinjin budgets her monthly expenses and consistently matches her actual expenses with her budget.\n\nTo teach Jinjin how to save money, her mother proposed that Jinjin could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to Jinjin with an additional 20% interest. Therefore, Jinjin devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\n\nFor instance, at the beginning of November, Jinjin has 83 yuan. Her mother gives her 300 yuan. Jinjin estimates her November expenses to be 180 yuan, so she would deposit 200 yuan with her mother and keep 183 yuan for herself. By the end of November, Jinjin would have 3 yuan left over.\n\nJinjin realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money Jinjin has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, Jinjin will have to economize and cut back on her budget for that month.\n\nNow, according to Jinjin's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money Jinjin will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, each line containing a non-negative integer less than 350, representing Jinjin's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money Jinjin will have at the end of 2004.\n\nNote that Luogu does not require file input/output but standard input/output.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n290\n230\n280\n200\n300\n170\n340\n50 \n90 \n80 \n200\n60\n```\n\n### Sample Output #1\n\n```\n-7\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n290 \n230 \n280 \n200 \n300 \n170 \n330 \n50 \n90 \n80 \n200 \n60\n```\n\n### Sample Output #2\n\n```\n1580\n```\n */", "canonical_solution": "{\n  int savings = 0;\n  int balance = 0;\n  for (int month = 1; month <= budgets.length; month++) {\n    int budget = budgets[month - 1];\n    balance += 300 - budget;\n    if (balance < 0) {\n      return -month;\n    }\n    savings += (balance ~/ 100) * 100;\n    balance %= 100;\n  }\n  return (savings * 1.2).toInt() + balance;\n}", "test": "void main() {\n  assert(calculateSavings([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]) == -7);\n  assert(calculateSavings([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]) == 1580);\n  assert(calculateSavings([300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]) == 0);\n}", "entry_point": "calculateSavings", "signature": "int calculateSavings(List<int> budgets)", "docstring": "# Jinjin's Savings Plan\n\n## Problem Description\n\nJinjin has always managed her pocket money by herself. At the beginning of each month, her mother gives Jinjin 300 yuan, from which Jinjin budgets her monthly expenses and consistently matches her actual expenses with her budget.\n\nTo teach Jinjin how to save money, her mother proposed that Jinjin could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to Jinjin with an additional 20% interest. Therefore, Jinjin devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\n\nFor instance, at the beginning of November, Jinjin has 83 yuan. Her mother gives her 300 yuan. Jinjin estimates her November expenses to be 180 yuan, so she would deposit 200 yuan with her mother and keep 183 yuan for herself. By the end of November, Jinjin would have 3 yuan left over.\n\nJinjin realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money Jinjin has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, Jinjin will have to economize and cut back on her budget for that month.\n\nNow, according to Jinjin's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money Jinjin will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, each line containing a non-negative integer less than 350, representing Jinjin's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money Jinjin will have at the end of 2004.\n\nNote that Luogu does not require file input/output but standard input/output.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n290\n230\n280\n200\n300\n170\n340\n50\n90\n80\n200\n60\n```\n\n### Sample Output #1\n\n```\n-7\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n290\n230\n280\n200\n300\n170\n330\n50\n90\n80\n200\n60\n```\n\n### Sample Output #2\n\n```\n1580\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Jinjin's Savings Plan\n\n## Problem Description\n\nJinjin has always managed her pocket money by herself. At the beginning of each month, her mother gives Jinjin 300 yuan, from which Jinjin budgets her monthly expenses and consistently matches her actual expenses with her budget.\n\nTo teach Jinjin how to save money, her mother proposed that Jinjin could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to Jinjin with an additional 20% interest. Therefore, Jinjin devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\n\nFor instance, at the beginning of November, Jinjin has 83 yuan. Her mother gives her 300 yuan. Jinjin estimates her November expenses to be 180 yuan, so she would deposit 200 yuan with her mother and keep 183 yuan for herself. By the end of November, Jinjin would have 3 yuan left over.\n\nJinjin realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money Jinjin has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, Jinjin will have to economize and cut back on her budget for that month.\n\nNow, according to Jinjin's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money Jinjin will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, each line containing a non-negative integer less than 350, representing Jinjin's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money Jinjin will have at the end of 2004.\n\nNote that Luogu does not require file input/output but standard input/output.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n290\n230\n280\n200\n300\n170\n340\n50\n90\n80\n200\n60\n```\n\n### Sample Output #1\n\n```\n-7\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n290\n230\n280\n200\n300\n170\n330\n50\n90\n80\n200\n60\n```\n\n### Sample Output #2\n\n```\n1580\n```\n\n* Incomplete Code:\nint calculateSavings(List<int> budgets)\n{\n  int savings = 0;\n[MASK]\n  for (int month = 1; month <= budgets.length; month++) {\n[MASK]\n    balance += 300 - budget;\n    if (balance < 0) {\n[MASK]\n    }\n    savings += (balance ~/ 100) * 100;\n[MASK]\n  }\n  return (savings * 1.2).toInt() + balance;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int savings = 0;\n[MASK]\n  for (int month = 1; month <= budgets.length; month++) {\n[MASK]\n    balance += 300 - budget;\n    if (balance < 0) {\n[MASK]\n    }\n    savings += (balance ~/ 100) * 100;\n[MASK]\n  }\n  return (savings * 1.2).toInt() + balance;\n}"}
{"task_id": "Dart/33-1-multi", "prompt": "int calculateSavings(List<int> budgets)\n/**\n * # Jinjin's Savings Plan\n\n## Problem Description\n\nJinjin has always managed her pocket money by herself. At the beginning of each month, her mother gives Jinjin 300 yuan, from which Jinjin budgets her monthly expenses and consistently matches her actual expenses with her budget.\n\nTo teach Jinjin how to save money, her mother proposed that Jinjin could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to Jinjin with an additional 20% interest. Therefore, Jinjin devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\n\nFor instance, at the beginning of November, Jinjin has 83 yuan. Her mother gives her 300 yuan. Jinjin estimates her November expenses to be 180 yuan, so she would deposit 200 yuan with her mother and keep 183 yuan for herself. By the end of November, Jinjin would have 3 yuan left over.\n\nJinjin realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money Jinjin has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, Jinjin will have to economize and cut back on her budget for that month.\n\nNow, according to Jinjin's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money Jinjin will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, each line containing a non-negative integer less than 350, representing Jinjin's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money Jinjin will have at the end of 2004.\n\nNote that Luogu does not require file input/output but standard input/output.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n290\n230\n280\n200\n300\n170\n340\n50 \n90 \n80 \n200\n60\n```\n\n### Sample Output #1\n\n```\n-7\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n290 \n230 \n280 \n200 \n300 \n170 \n330 \n50 \n90 \n80 \n200 \n60\n```\n\n### Sample Output #2\n\n```\n1580\n```\n */", "canonical_solution": "{\n  int savings = 0;\n  int balance = 0;\n  for (int month = 1; month <= budgets.length; month++) {\n    int budget = budgets[month - 1];\n    balance += 300 - budget;\n    if (balance < 0) {\n      return -month;\n    }\n    savings += (balance ~/ 100) * 100;\n    balance %= 100;\n  }\n  return (savings * 1.2).toInt() + balance;\n}", "test": "void main() {\n  assert(calculateSavings([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]) == -7);\n  assert(calculateSavings([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]) == 1580);\n  assert(calculateSavings([300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]) == 0);\n}", "entry_point": "calculateSavings", "signature": "int calculateSavings(List<int> budgets)", "docstring": "# Jinjin's Savings Plan\n\n## Problem Description\n\nJinjin has always managed her pocket money by herself. At the beginning of each month, her mother gives Jinjin 300 yuan, from which Jinjin budgets her monthly expenses and consistently matches her actual expenses with her budget.\n\nTo teach Jinjin how to save money, her mother proposed that Jinjin could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to Jinjin with an additional 20% interest. Therefore, Jinjin devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\n\nFor instance, at the beginning of November, Jinjin has 83 yuan. Her mother gives her 300 yuan. Jinjin estimates her November expenses to be 180 yuan, so she would deposit 200 yuan with her mother and keep 183 yuan for herself. By the end of November, Jinjin would have 3 yuan left over.\n\nJinjin realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money Jinjin has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, Jinjin will have to economize and cut back on her budget for that month.\n\nNow, according to Jinjin's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money Jinjin will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, each line containing a non-negative integer less than 350, representing Jinjin's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money Jinjin will have at the end of 2004.\n\nNote that Luogu does not require file input/output but standard input/output.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n290\n230\n280\n200\n300\n170\n340\n50\n90\n80\n200\n60\n```\n\n### Sample Output #1\n\n```\n-7\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n290\n230\n280\n200\n300\n170\n330\n50\n90\n80\n200\n60\n```\n\n### Sample Output #2\n\n```\n1580\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Jinjin's Savings Plan\n\n## Problem Description\n\nJinjin has always managed her pocket money by herself. At the beginning of each month, her mother gives Jinjin 300 yuan, from which Jinjin budgets her monthly expenses and consistently matches her actual expenses with her budget.\n\nTo teach Jinjin how to save money, her mother proposed that Jinjin could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to Jinjin with an additional 20% interest. Therefore, Jinjin devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\n\nFor instance, at the beginning of November, Jinjin has 83 yuan. Her mother gives her 300 yuan. Jinjin estimates her November expenses to be 180 yuan, so she would deposit 200 yuan with her mother and keep 183 yuan for herself. By the end of November, Jinjin would have 3 yuan left over.\n\nJinjin realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money Jinjin has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, Jinjin will have to economize and cut back on her budget for that month.\n\nNow, according to Jinjin's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money Jinjin will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, each line containing a non-negative integer less than 350, representing Jinjin's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money Jinjin will have at the end of 2004.\n\nNote that Luogu does not require file input/output but standard input/output.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n290\n230\n280\n200\n300\n170\n340\n50\n90\n80\n200\n60\n```\n\n### Sample Output #1\n\n```\n-7\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n290\n230\n280\n200\n300\n170\n330\n50\n90\n80\n200\n60\n```\n\n### Sample Output #2\n\n```\n1580\n```\n\n* Incomplete Code:\nint calculateSavings(List<int> budgets)\n{\n  int savings = 0;\n  int balance = 0;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n    }\n    savings += (balance ~/ 100) * 100;\n    balance %= 100;\n  }\n  return (savings * 1.2).toInt() + balance;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int savings = 0;\n  int balance = 0;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n    }\n    savings += (balance ~/ 100) * 100;\n    balance %= 100;\n  }\n  return (savings * 1.2).toInt() + balance;\n}"}
{"task_id": "Dart/34-0-multi", "prompt": "int minEnergy(List<int> weights)\n\n/**\n *#  Merging Fruits / [USACO06NOV] Fence Repair G\n\n## Problem Description\n\nWithin an orchard, DuoDuo has harvested all the fruits and sorted them into different piles according to their varieties. DuoDuo has decided to merge all the fruits into a single pile.\n\nEach merge allows DuoDuo to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by DuoDuo in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nSince substantial effort is still required to transport these fruits back home, DuoDuo aims to conserve as much energy as possible during the merging process. Assuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes DuoDuo's energy expenditure and output this minimum value.\n\nFor example, with $3$ varieties of fruits, with quantities of $1$, $2$, and $9$ respectively, one could first merge the piles of $1$ and $2$, resulting in a new pile of $3$ and an energy expenditure of $3$. Subsequently, this new pile can be merged with the original third pile, creating another new pile of $12$ and an energy expenditure of $12$. Thus, the total energy expenditure by DuoDuo is $3+12=15$. It can be demonstrated that $15$ is the minimum energy expenditure value.\n\n## Input Format\n\nThere are two lines in total.  \nThe first line contains an integer $n(1\\leq n\\leq 10000)$, representing the number of fruit varieties.\n\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i(1\\leq a_i\\leq 20000)$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n1 2 9\n```\n\n### Sample Output #1\n\n```\n15\n```\n\n## Note\n\nFor $30\\%$ of the data, it is assured that $n \\le 1000$;\n\nFor $50\\%$ of the data, it is assured that $n \\le 5000$;\n\nFor all the data, it is assured that $n \\le 10000$.\n */", "canonical_solution": "{\n  int energy = 0;\n  weights.sort();\n  while (weights.length > 1) {\n    int first = weights.removeAt(0);\n    int second = weights.removeAt(0);\n    int mergedWeight = first + second;\n    energy += mergedWeight;\n    weights.add(mergedWeight);\n    weights.sort();\n  }\n  return energy;\n}", "test": "void testMinEnergy() {\n  assert(minEnergy([1, 2, 9]) == 15);\n  assert(minEnergy([1, 2, 3, 4]) == 19);\n  assert(minEnergy([10]) == 0);\n}\n\nvoid main() {\n  testMinEnergy();\n}", "entry_point": "minEnergy", "signature": "int minEnergy(List<int> weights)", "docstring": "#  Merging Fruits / [USACO06NOV] Fence Repair G\n\n## Problem Description\n\nWithin an orchard, DuoDuo has harvested all the fruits and sorted them into different piles according to their varieties. DuoDuo has decided to merge all the fruits into a single pile.\n\nEach merge allows DuoDuo to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by DuoDuo in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nSince substantial effort is still required to transport these fruits back home, DuoDuo aims to conserve as much energy as possible during the merging process. Assuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes DuoDuo's energy expenditure and output this minimum value.\n\nFor example, with $3$ varieties of fruits, with quantities of $1$, $2$, and $9$ respectively, one could first merge the piles of $1$ and $2$, resulting in a new pile of $3$ and an energy expenditure of $3$. Subsequently, this new pile can be merged with the original third pile, creating another new pile of $12$ and an energy expenditure of $12$. Thus, the total energy expenditure by DuoDuo is $3+12=15$. It can be demonstrated that $15$ is the minimum energy expenditure value.\n\n## Input Format\n\nThere are two lines in total.\nThe first line contains an integer $n(1\\leq n\\leq 10000)$, representing the number of fruit varieties.\n\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i(1\\leq a_i\\leq 20000)$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n1 2 9\n```\n\n### Sample Output #1\n\n```\n15\n```\n\n## Note\n\nFor $30\\%$ of the data, it is assured that $n \\le 1000$;\n\nFor $50\\%$ of the data, it is assured that $n \\le 5000$;\n\nFor all the data, it is assured that $n \\le 10000$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Merging Fruits / [USACO06NOV] Fence Repair G\n\n## Problem Description\n\nWithin an orchard, DuoDuo has harvested all the fruits and sorted them into different piles according to their varieties. DuoDuo has decided to merge all the fruits into a single pile.\n\nEach merge allows DuoDuo to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by DuoDuo in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nSince substantial effort is still required to transport these fruits back home, DuoDuo aims to conserve as much energy as possible during the merging process. Assuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes DuoDuo's energy expenditure and output this minimum value.\n\nFor example, with $3$ varieties of fruits, with quantities of $1$, $2$, and $9$ respectively, one could first merge the piles of $1$ and $2$, resulting in a new pile of $3$ and an energy expenditure of $3$. Subsequently, this new pile can be merged with the original third pile, creating another new pile of $12$ and an energy expenditure of $12$. Thus, the total energy expenditure by DuoDuo is $3+12=15$. It can be demonstrated that $15$ is the minimum energy expenditure value.\n\n## Input Format\n\nThere are two lines in total.\nThe first line contains an integer $n(1\\leq n\\leq 10000)$, representing the number of fruit varieties.\n\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i(1\\leq a_i\\leq 20000)$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n1 2 9\n```\n\n### Sample Output #1\n\n```\n15\n```\n\n## Note\n\nFor $30\\%$ of the data, it is assured that $n \\le 1000$;\n\nFor $50\\%$ of the data, it is assured that $n \\le 5000$;\n\nFor all the data, it is assured that $n \\le 10000$.\n\n* Incomplete Code:\nint minEnergy(List<int> weights)\n{\n[MASK]\n  weights.sort();\n[MASK]\n[MASK]\n    int second = weights.removeAt(0);\n    int mergedWeight = first + second;\n    energy += mergedWeight;\n[MASK]\n[MASK]\n  }\n  return energy;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  weights.sort();\n[MASK]\n[MASK]\n    int second = weights.removeAt(0);\n    int mergedWeight = first + second;\n    energy += mergedWeight;\n[MASK]\n[MASK]\n  }\n  return energy;\n}"}
{"task_id": "Dart/34-1-multi", "prompt": "int minEnergy(List<int> weights)\n\n/**\n *#  Merging Fruits / [USACO06NOV] Fence Repair G\n\n## Problem Description\n\nWithin an orchard, DuoDuo has harvested all the fruits and sorted them into different piles according to their varieties. DuoDuo has decided to merge all the fruits into a single pile.\n\nEach merge allows DuoDuo to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by DuoDuo in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nSince substantial effort is still required to transport these fruits back home, DuoDuo aims to conserve as much energy as possible during the merging process. Assuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes DuoDuo's energy expenditure and output this minimum value.\n\nFor example, with $3$ varieties of fruits, with quantities of $1$, $2$, and $9$ respectively, one could first merge the piles of $1$ and $2$, resulting in a new pile of $3$ and an energy expenditure of $3$. Subsequently, this new pile can be merged with the original third pile, creating another new pile of $12$ and an energy expenditure of $12$. Thus, the total energy expenditure by DuoDuo is $3+12=15$. It can be demonstrated that $15$ is the minimum energy expenditure value.\n\n## Input Format\n\nThere are two lines in total.  \nThe first line contains an integer $n(1\\leq n\\leq 10000)$, representing the number of fruit varieties.\n\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i(1\\leq a_i\\leq 20000)$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n1 2 9\n```\n\n### Sample Output #1\n\n```\n15\n```\n\n## Note\n\nFor $30\\%$ of the data, it is assured that $n \\le 1000$;\n\nFor $50\\%$ of the data, it is assured that $n \\le 5000$;\n\nFor all the data, it is assured that $n \\le 10000$.\n */", "canonical_solution": "{\n  int energy = 0;\n  weights.sort();\n  while (weights.length > 1) {\n    int first = weights.removeAt(0);\n    int second = weights.removeAt(0);\n    int mergedWeight = first + second;\n    energy += mergedWeight;\n    weights.add(mergedWeight);\n    weights.sort();\n  }\n  return energy;\n}", "test": "void testMinEnergy() {\n  assert(minEnergy([1, 2, 9]) == 15);\n  assert(minEnergy([1, 2, 3, 4]) == 19);\n  assert(minEnergy([10]) == 0);\n}\n\nvoid main() {\n  testMinEnergy();\n}", "entry_point": "minEnergy", "signature": "int minEnergy(List<int> weights)", "docstring": "#  Merging Fruits / [USACO06NOV] Fence Repair G\n\n## Problem Description\n\nWithin an orchard, DuoDuo has harvested all the fruits and sorted them into different piles according to their varieties. DuoDuo has decided to merge all the fruits into a single pile.\n\nEach merge allows DuoDuo to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by DuoDuo in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nSince substantial effort is still required to transport these fruits back home, DuoDuo aims to conserve as much energy as possible during the merging process. Assuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes DuoDuo's energy expenditure and output this minimum value.\n\nFor example, with $3$ varieties of fruits, with quantities of $1$, $2$, and $9$ respectively, one could first merge the piles of $1$ and $2$, resulting in a new pile of $3$ and an energy expenditure of $3$. Subsequently, this new pile can be merged with the original third pile, creating another new pile of $12$ and an energy expenditure of $12$. Thus, the total energy expenditure by DuoDuo is $3+12=15$. It can be demonstrated that $15$ is the minimum energy expenditure value.\n\n## Input Format\n\nThere are two lines in total.\nThe first line contains an integer $n(1\\leq n\\leq 10000)$, representing the number of fruit varieties.\n\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i(1\\leq a_i\\leq 20000)$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n1 2 9\n```\n\n### Sample Output #1\n\n```\n15\n```\n\n## Note\n\nFor $30\\%$ of the data, it is assured that $n \\le 1000$;\n\nFor $50\\%$ of the data, it is assured that $n \\le 5000$;\n\nFor all the data, it is assured that $n \\le 10000$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Merging Fruits / [USACO06NOV] Fence Repair G\n\n## Problem Description\n\nWithin an orchard, DuoDuo has harvested all the fruits and sorted them into different piles according to their varieties. DuoDuo has decided to merge all the fruits into a single pile.\n\nEach merge allows DuoDuo to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by DuoDuo in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nSince substantial effort is still required to transport these fruits back home, DuoDuo aims to conserve as much energy as possible during the merging process. Assuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes DuoDuo's energy expenditure and output this minimum value.\n\nFor example, with $3$ varieties of fruits, with quantities of $1$, $2$, and $9$ respectively, one could first merge the piles of $1$ and $2$, resulting in a new pile of $3$ and an energy expenditure of $3$. Subsequently, this new pile can be merged with the original third pile, creating another new pile of $12$ and an energy expenditure of $12$. Thus, the total energy expenditure by DuoDuo is $3+12=15$. It can be demonstrated that $15$ is the minimum energy expenditure value.\n\n## Input Format\n\nThere are two lines in total.\nThe first line contains an integer $n(1\\leq n\\leq 10000)$, representing the number of fruit varieties.\n\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i(1\\leq a_i\\leq 20000)$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\n1 2 9\n```\n\n### Sample Output #1\n\n```\n15\n```\n\n## Note\n\nFor $30\\%$ of the data, it is assured that $n \\le 1000$;\n\nFor $50\\%$ of the data, it is assured that $n \\le 5000$;\n\nFor all the data, it is assured that $n \\le 10000$.\n\n* Incomplete Code:\nint minEnergy(List<int> weights)\n{\n  int energy = 0;\n[MASK]\n  while (weights.length > 1) {\n    int first = weights.removeAt(0);\n    int second = weights.removeAt(0);\n    int mergedWeight = first + second;\n    energy += mergedWeight;\n    weights.add(mergedWeight);\n[MASK]\n  }\n  return energy;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int energy = 0;\n[MASK]\n  while (weights.length > 1) {\n    int first = weights.removeAt(0);\n    int second = weights.removeAt(0);\n    int mergedWeight = first + second;\n    energy += mergedWeight;\n    weights.add(mergedWeight);\n[MASK]\n  }\n  return energy;\n}"}
{"task_id": "Dart/35-0-multi", "prompt": "import \"dart:math\";\nint choirFormation(List<int> heights) \n/**\n * # Scholarship Award\n\n\n## Problem Description\n\nA primary school recently received a donation and decided to use part of it to provide scholarships to the top $5$ students with excellent academic performance. At the end of the term, each student has grades for $3$ subjects: Chinese, Mathematics, and English. The students are first sorted by total score from highest to lowest. If two students have the same total score, they are then sorted by their Chinese grade from highest to lowest. If two students have the same total score and Chinese grade, the student with the smaller student number is ranked higher, ensuring that each student's ranking is uniquely determined.\n\nTask: First calculate the total score based on the input grades for the $3$ subjects, then sort according to the above rules, and finally output the student number and total score of the top five students in order of rank.\n\nNote that in the top $5$ students, each person's scholarship amount is different, so you must strictly follow the above rules for sorting. For example, in a correct answer, if the output data for the first two lines (each line outputs two numbers: student number, total score) is:\n\n```plain\n7 279  \n5 279\n```\n\nThe meaning of these two lines of data is that the student numbers of the two students with the highest total score are $7$ and $5$, respectively. Both students have a total score of $279$ (total score equals the sum of the grades for Chinese, Mathematics, and English), but the student with student number $7$ has a higher Chinese grade.\n\nIf your output data for the top two is:\n\n```plain\n5 279  \n7 279\n```\n\nThen it is treated as an incorrect output and you will not receive any points.\n\n## Input Format\n\nThere are $n+1$ lines in total.\n\nThe first line is a positive integer $n \\le 300$, indicating the number of students in the school participating in the selection.\n\nFrom the second to the $n+1$ lines, each line contains $3$ numbers separated by spaces, each number is between $0$ and $100$. The three numbers on line $j$ sequentially represent the Chinese, Mathematics, and English grades of the student with student number $j-1$. Each student's student number is numbered $1\\sim n$ according to the order of input (exactly the line number of the input data minus $1$).\n\nThe given data are all correct, no need to verify.\n\n## Output Format\n\nThere are $5$ lines in total, each line contains two positive integers separated by a space, successively indicating the student number and total score of the top $5$ students.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #1\n\n```\n6 265\n4 264\n3 258\n2 244\n1 237\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n8\n80 89 89\n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #2\n\n```\n8 265\n2 264\n6 264\n1 258\n5 258\n```\n */", "canonical_solution": "{\n  int n = heights.length;\n  List<int> dpLeft = List.filled(n, 1);\n  List<int> dpRight = List.filled(n, 1);\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < i; ++j) {\n      if (heights[i] > heights[j] && dpLeft[j] + 1 > dpLeft[i]) {\n        dpLeft[i] = dpLeft[j] + 1;\n      }\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = n - 1; j > i; --j) {\n      if (heights[i] > heights[j] && dpRight[j] + 1 > dpRight[i]) {\n        dpRight[i] = dpRight[j] + 1;\n      }\n    }\n  }\n\n  int maxLen = 0;\n  for (int i = 0; i < n; ++i) {\n    maxLen = max(maxLen, dpLeft[i] + dpRight[i] - 1);\n  }\n  return n - maxLen;\n}", "test": "void testChoirFormation() {\n  assert(choirFormation([186, 186, 150, 200, 160, 130, 197, 220]) == 4);\n  assert(choirFormation([130, 135, 148, 140, 145, 150, 153]) == 1);\n  assert(choirFormation([230, 220, 210, 200, 190, 180, 170]) == 0);\n}\nvoid main() {\n  testChoirFormation();\n}", "entry_point": "choirFormation", "signature": "int choirFormation(List<int> heights)", "docstring": "# Scholarship Award\n\n\n## Problem Description\n\nA primary school recently received a donation and decided to use part of it to provide scholarships to the top $5$ students with excellent academic performance. At the end of the term, each student has grades for $3$ subjects: Chinese, Mathematics, and English. The students are first sorted by total score from highest to lowest. If two students have the same total score, they are then sorted by their Chinese grade from highest to lowest. If two students have the same total score and Chinese grade, the student with the smaller student number is ranked higher, ensuring that each student's ranking is uniquely determined.\n\nTask: First calculate the total score based on the input grades for the $3$ subjects, then sort according to the above rules, and finally output the student number and total score of the top five students in order of rank.\n\nNote that in the top $5$ students, each person's scholarship amount is different, so you must strictly follow the above rules for sorting. For example, in a correct answer, if the output data for the first two lines (each line outputs two numbers: student number, total score) is:\n\n```plain\n7 279\n5 279\n```\n\nThe meaning of these two lines of data is that the student numbers of the two students with the highest total score are $7$ and $5$, respectively. Both students have a total score of $279$ (total score equals the sum of the grades for Chinese, Mathematics, and English), but the student with student number $7$ has a higher Chinese grade.\n\nIf your output data for the top two is:\n\n```plain\n5 279\n7 279\n```\n\nThen it is treated as an incorrect output and you will not receive any points.\n\n## Input Format\n\nThere are $n+1$ lines in total.\n\nThe first line is a positive integer $n \\le 300$, indicating the number of students in the school participating in the selection.\n\nFrom the second to the $n+1$ lines, each line contains $3$ numbers separated by spaces, each number is between $0$ and $100$. The three numbers on line $j$ sequentially represent the Chinese, Mathematics, and English grades of the student with student number $j-1$. Each student's student number is numbered $1\\sim n$ according to the order of input (exactly the line number of the input data minus $1$).\n\nThe given data are all correct, no need to verify.\n\n## Output Format\n\nThere are $5$ lines in total, each line contains two positive integers separated by a space, successively indicating the student number and total score of the top $5$ students.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #1\n\n```\n6 265\n4 264\n3 258\n2 244\n1 237\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n8\n80 89 89\n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #2\n\n```\n8 265\n2 264\n6 264\n1 258\n5 258\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Scholarship Award\n\n\n## Problem Description\n\nA primary school recently received a donation and decided to use part of it to provide scholarships to the top $5$ students with excellent academic performance. At the end of the term, each student has grades for $3$ subjects: Chinese, Mathematics, and English. The students are first sorted by total score from highest to lowest. If two students have the same total score, they are then sorted by their Chinese grade from highest to lowest. If two students have the same total score and Chinese grade, the student with the smaller student number is ranked higher, ensuring that each student's ranking is uniquely determined.\n\nTask: First calculate the total score based on the input grades for the $3$ subjects, then sort according to the above rules, and finally output the student number and total score of the top five students in order of rank.\n\nNote that in the top $5$ students, each person's scholarship amount is different, so you must strictly follow the above rules for sorting. For example, in a correct answer, if the output data for the first two lines (each line outputs two numbers: student number, total score) is:\n\n```plain\n7 279\n5 279\n```\n\nThe meaning of these two lines of data is that the student numbers of the two students with the highest total score are $7$ and $5$, respectively. Both students have a total score of $279$ (total score equals the sum of the grades for Chinese, Mathematics, and English), but the student with student number $7$ has a higher Chinese grade.\n\nIf your output data for the top two is:\n\n```plain\n5 279\n7 279\n```\n\nThen it is treated as an incorrect output and you will not receive any points.\n\n## Input Format\n\nThere are $n+1$ lines in total.\n\nThe first line is a positive integer $n \\le 300$, indicating the number of students in the school participating in the selection.\n\nFrom the second to the $n+1$ lines, each line contains $3$ numbers separated by spaces, each number is between $0$ and $100$. The three numbers on line $j$ sequentially represent the Chinese, Mathematics, and English grades of the student with student number $j-1$. Each student's student number is numbered $1\\sim n$ according to the order of input (exactly the line number of the input data minus $1$).\n\nThe given data are all correct, no need to verify.\n\n## Output Format\n\nThere are $5$ lines in total, each line contains two positive integers separated by a space, successively indicating the student number and total score of the top $5$ students.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #1\n\n```\n6 265\n4 264\n3 258\n2 244\n1 237\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n8\n80 89 89\n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #2\n\n```\n8 265\n2 264\n6 264\n1 258\n5 258\n```\n\n* Incomplete Code:\nint choirFormation(List<int> heights)\n{\n  int n = heights.length;\n  List<int> dpLeft = List.filled(n, 1);\n  List<int> dpRight = List.filled(n, 1);\n\n[MASK]\n    for (int j = 0; j < i; ++j) {\n      if (heights[i] > heights[j] && dpLeft[j] + 1 > dpLeft[i]) {\n        dpLeft[i] = dpLeft[j] + 1;\n      }\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = n - 1; j > i; --j) {\n      if (heights[i] > heights[j] && dpRight[j] + 1 > dpRight[i]) {\n        dpRight[i] = dpRight[j] + 1;\n      }\n    }\n  }\n\n[MASK]\n  for (int i = 0; i < n; ++i) {\n    maxLen = max(maxLen, dpLeft[i] + dpRight[i] - 1);\n  }\n  return n - maxLen;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int n = heights.length;\n  List<int> dpLeft = List.filled(n, 1);\n  List<int> dpRight = List.filled(n, 1);\n\n[MASK]\n    for (int j = 0; j < i; ++j) {\n      if (heights[i] > heights[j] && dpLeft[j] + 1 > dpLeft[i]) {\n        dpLeft[i] = dpLeft[j] + 1;\n      }\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = n - 1; j > i; --j) {\n      if (heights[i] > heights[j] && dpRight[j] + 1 > dpRight[i]) {\n        dpRight[i] = dpRight[j] + 1;\n      }\n    }\n  }\n\n[MASK]\n  for (int i = 0; i < n; ++i) {\n    maxLen = max(maxLen, dpLeft[i] + dpRight[i] - 1);\n  }\n  return n - maxLen;\n}"}
{"task_id": "Dart/35-1-multi", "prompt": "import \"dart:math\";\nint choirFormation(List<int> heights) \n/**\n * # Scholarship Award\n\n\n## Problem Description\n\nA primary school recently received a donation and decided to use part of it to provide scholarships to the top $5$ students with excellent academic performance. At the end of the term, each student has grades for $3$ subjects: Chinese, Mathematics, and English. The students are first sorted by total score from highest to lowest. If two students have the same total score, they are then sorted by their Chinese grade from highest to lowest. If two students have the same total score and Chinese grade, the student with the smaller student number is ranked higher, ensuring that each student's ranking is uniquely determined.\n\nTask: First calculate the total score based on the input grades for the $3$ subjects, then sort according to the above rules, and finally output the student number and total score of the top five students in order of rank.\n\nNote that in the top $5$ students, each person's scholarship amount is different, so you must strictly follow the above rules for sorting. For example, in a correct answer, if the output data for the first two lines (each line outputs two numbers: student number, total score) is:\n\n```plain\n7 279  \n5 279\n```\n\nThe meaning of these two lines of data is that the student numbers of the two students with the highest total score are $7$ and $5$, respectively. Both students have a total score of $279$ (total score equals the sum of the grades for Chinese, Mathematics, and English), but the student with student number $7$ has a higher Chinese grade.\n\nIf your output data for the top two is:\n\n```plain\n5 279  \n7 279\n```\n\nThen it is treated as an incorrect output and you will not receive any points.\n\n## Input Format\n\nThere are $n+1$ lines in total.\n\nThe first line is a positive integer $n \\le 300$, indicating the number of students in the school participating in the selection.\n\nFrom the second to the $n+1$ lines, each line contains $3$ numbers separated by spaces, each number is between $0$ and $100$. The three numbers on line $j$ sequentially represent the Chinese, Mathematics, and English grades of the student with student number $j-1$. Each student's student number is numbered $1\\sim n$ according to the order of input (exactly the line number of the input data minus $1$).\n\nThe given data are all correct, no need to verify.\n\n## Output Format\n\nThere are $5$ lines in total, each line contains two positive integers separated by a space, successively indicating the student number and total score of the top $5$ students.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #1\n\n```\n6 265\n4 264\n3 258\n2 244\n1 237\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n8\n80 89 89\n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #2\n\n```\n8 265\n2 264\n6 264\n1 258\n5 258\n```\n */", "canonical_solution": "{\n  int n = heights.length;\n  List<int> dpLeft = List.filled(n, 1);\n  List<int> dpRight = List.filled(n, 1);\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < i; ++j) {\n      if (heights[i] > heights[j] && dpLeft[j] + 1 > dpLeft[i]) {\n        dpLeft[i] = dpLeft[j] + 1;\n      }\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = n - 1; j > i; --j) {\n      if (heights[i] > heights[j] && dpRight[j] + 1 > dpRight[i]) {\n        dpRight[i] = dpRight[j] + 1;\n      }\n    }\n  }\n\n  int maxLen = 0;\n  for (int i = 0; i < n; ++i) {\n    maxLen = max(maxLen, dpLeft[i] + dpRight[i] - 1);\n  }\n  return n - maxLen;\n}", "test": "void testChoirFormation() {\n  assert(choirFormation([186, 186, 150, 200, 160, 130, 197, 220]) == 4);\n  assert(choirFormation([130, 135, 148, 140, 145, 150, 153]) == 1);\n  assert(choirFormation([230, 220, 210, 200, 190, 180, 170]) == 0);\n}\nvoid main() {\n  testChoirFormation();\n}", "entry_point": "choirFormation", "signature": "int choirFormation(List<int> heights)", "docstring": "# Scholarship Award\n\n\n## Problem Description\n\nA primary school recently received a donation and decided to use part of it to provide scholarships to the top $5$ students with excellent academic performance. At the end of the term, each student has grades for $3$ subjects: Chinese, Mathematics, and English. The students are first sorted by total score from highest to lowest. If two students have the same total score, they are then sorted by their Chinese grade from highest to lowest. If two students have the same total score and Chinese grade, the student with the smaller student number is ranked higher, ensuring that each student's ranking is uniquely determined.\n\nTask: First calculate the total score based on the input grades for the $3$ subjects, then sort according to the above rules, and finally output the student number and total score of the top five students in order of rank.\n\nNote that in the top $5$ students, each person's scholarship amount is different, so you must strictly follow the above rules for sorting. For example, in a correct answer, if the output data for the first two lines (each line outputs two numbers: student number, total score) is:\n\n```plain\n7 279\n5 279\n```\n\nThe meaning of these two lines of data is that the student numbers of the two students with the highest total score are $7$ and $5$, respectively. Both students have a total score of $279$ (total score equals the sum of the grades for Chinese, Mathematics, and English), but the student with student number $7$ has a higher Chinese grade.\n\nIf your output data for the top two is:\n\n```plain\n5 279\n7 279\n```\n\nThen it is treated as an incorrect output and you will not receive any points.\n\n## Input Format\n\nThere are $n+1$ lines in total.\n\nThe first line is a positive integer $n \\le 300$, indicating the number of students in the school participating in the selection.\n\nFrom the second to the $n+1$ lines, each line contains $3$ numbers separated by spaces, each number is between $0$ and $100$. The three numbers on line $j$ sequentially represent the Chinese, Mathematics, and English grades of the student with student number $j-1$. Each student's student number is numbered $1\\sim n$ according to the order of input (exactly the line number of the input data minus $1$).\n\nThe given data are all correct, no need to verify.\n\n## Output Format\n\nThere are $5$ lines in total, each line contains two positive integers separated by a space, successively indicating the student number and total score of the top $5$ students.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #1\n\n```\n6 265\n4 264\n3 258\n2 244\n1 237\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n8\n80 89 89\n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #2\n\n```\n8 265\n2 264\n6 264\n1 258\n5 258\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Scholarship Award\n\n\n## Problem Description\n\nA primary school recently received a donation and decided to use part of it to provide scholarships to the top $5$ students with excellent academic performance. At the end of the term, each student has grades for $3$ subjects: Chinese, Mathematics, and English. The students are first sorted by total score from highest to lowest. If two students have the same total score, they are then sorted by their Chinese grade from highest to lowest. If two students have the same total score and Chinese grade, the student with the smaller student number is ranked higher, ensuring that each student's ranking is uniquely determined.\n\nTask: First calculate the total score based on the input grades for the $3$ subjects, then sort according to the above rules, and finally output the student number and total score of the top five students in order of rank.\n\nNote that in the top $5$ students, each person's scholarship amount is different, so you must strictly follow the above rules for sorting. For example, in a correct answer, if the output data for the first two lines (each line outputs two numbers: student number, total score) is:\n\n```plain\n7 279\n5 279\n```\n\nThe meaning of these two lines of data is that the student numbers of the two students with the highest total score are $7$ and $5$, respectively. Both students have a total score of $279$ (total score equals the sum of the grades for Chinese, Mathematics, and English), but the student with student number $7$ has a higher Chinese grade.\n\nIf your output data for the top two is:\n\n```plain\n5 279\n7 279\n```\n\nThen it is treated as an incorrect output and you will not receive any points.\n\n## Input Format\n\nThere are $n+1$ lines in total.\n\nThe first line is a positive integer $n \\le 300$, indicating the number of students in the school participating in the selection.\n\nFrom the second to the $n+1$ lines, each line contains $3$ numbers separated by spaces, each number is between $0$ and $100$. The three numbers on line $j$ sequentially represent the Chinese, Mathematics, and English grades of the student with student number $j-1$. Each student's student number is numbered $1\\sim n$ according to the order of input (exactly the line number of the input data minus $1$).\n\nThe given data are all correct, no need to verify.\n\n## Output Format\n\nThere are $5$ lines in total, each line contains two positive integers separated by a space, successively indicating the student number and total score of the top $5$ students.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #1\n\n```\n6 265\n4 264\n3 258\n2 244\n1 237\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n8\n80 89 89\n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n```\n\n### Sample Output #2\n\n```\n8 265\n2 264\n6 264\n1 258\n5 258\n```\n\n* Incomplete Code:\nint choirFormation(List<int> heights)\n{\n  int n = heights.length;\n  List<int> dpLeft = List.filled(n, 1);\n[MASK]\n\n  for (int i = 0; i < n; ++i) {\n[MASK]\n      if (heights[i] > heights[j] && dpLeft[j] + 1 > dpLeft[i]) {\n[MASK]\n      }\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = n - 1; j > i; --j) {\n[MASK]\n        dpRight[i] = dpRight[j] + 1;\n      }\n    }\n  }\n\n  int maxLen = 0;\n  for (int i = 0; i < n; ++i) {\n    maxLen = max(maxLen, dpLeft[i] + dpRight[i] - 1);\n  }\n  return n - maxLen;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int n = heights.length;\n  List<int> dpLeft = List.filled(n, 1);\n[MASK]\n\n  for (int i = 0; i < n; ++i) {\n[MASK]\n      if (heights[i] > heights[j] && dpLeft[j] + 1 > dpLeft[i]) {\n[MASK]\n      }\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    for (int j = n - 1; j > i; --j) {\n[MASK]\n        dpRight[i] = dpRight[j] + 1;\n      }\n    }\n  }\n\n  int maxLen = 0;\n  for (int i = 0; i < n; ++i) {\n    maxLen = max(maxLen, dpLeft[i] + dpRight[i] - 1);\n  }\n  return n - maxLen;\n}"}
{"task_id": "Dart/36-0-multi", "prompt": "int minimumGroups(List<int> gifts, int limit)\n/**\n * #  Souvenir Grouping\n\n## Problem Background\n\nNOIP2007 Junior Division Task 2\n\n## Problem Description\n\nWith the New Year's Day approaching, the school's student council has assigned Lele the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, Lele must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, Lele hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+2$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nThe second line is an integer $n$, indicating the total number of purchased souvenirs $G$.\n\nLines $3$ to $n+2$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100 \n9 \n90 \n20 \n20 \n30 \n50 \n60 \n70 \n80 \n90\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hint\n\n$50\\%$ of the data satisfies: $1\\le n\\le15$.\n\n$100\\%$ of the data satisfies: $1\\le n\\le3\\times10^4$, $80\\le w\\le200$, $5 \\le  P_i  \\le  w$.\n */", "canonical_solution": " {\n  gifts.sort();\n  int i = 0, j = gifts.length - 1, groups = 0;\n  while (i <= j) {\n    if (gifts[i] + gifts[j] <= limit) i++;\n    j--;\n    groups++;\n  }\n  return groups;\n}", "test": "void testMinimumGroups() {\n  assert(minimumGroups([90, 20, 20, 30, 50, 60, 70, 80, 90], 100) == 6);\n  assert(minimumGroups([10, 20, 30, 40, 50, 60, 70, 80, 90], 150) == 5);\n  assert(minimumGroups([30, 30, 50, 60, 70], 100) == 3);\n}\n\nvoid main() {\n  testMinimumGroups();\n}", "entry_point": "minimumGroups", "signature": "int minimumGroups(List<int> gifts, int limit)", "docstring": "#  Souvenir Grouping\n\n## Problem Background\n\nNOIP2007 Junior Division Task 2\n\n## Problem Description\n\nWith the New Year's Day approaching, the school's student council has assigned Lele the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, Lele must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, Lele hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+2$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nThe second line is an integer $n$, indicating the total number of purchased souvenirs $G$.\n\nLines $3$ to $n+2$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100\n9\n90\n20\n20\n30\n50\n60\n70\n80\n90\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hint\n\n$50\\%$ of the data satisfies: $1\\le n\\le15$.\n\n$100\\%$ of the data satisfies: $1\\le n\\le3\\times10^4$, $80\\le w\\le200$, $5 \\le  P_i  \\le  w$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Souvenir Grouping\n\n## Problem Background\n\nNOIP2007 Junior Division Task 2\n\n## Problem Description\n\nWith the New Year's Day approaching, the school's student council has assigned Lele the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, Lele must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, Lele hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+2$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nThe second line is an integer $n$, indicating the total number of purchased souvenirs $G$.\n\nLines $3$ to $n+2$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100\n9\n90\n20\n20\n30\n50\n60\n70\n80\n90\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hint\n\n$50\\%$ of the data satisfies: $1\\le n\\le15$.\n\n$100\\%$ of the data satisfies: $1\\le n\\le3\\times10^4$, $80\\le w\\le200$, $5 \\le  P_i  \\le  w$.\n\n* Incomplete Code:\nint minimumGroups(List<int> gifts, int limit)\n {\n[MASK]\n  int i = 0, j = gifts.length - 1, groups = 0;\n[MASK]\n    if (gifts[i] + gifts[j] <= limit) i++;\n    j--;\n[MASK]\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n[MASK]\n  int i = 0, j = gifts.length - 1, groups = 0;\n[MASK]\n    if (gifts[i] + gifts[j] <= limit) i++;\n    j--;\n[MASK]\n  }\n[MASK]\n}"}
{"task_id": "Dart/36-1-multi", "prompt": "int minimumGroups(List<int> gifts, int limit)\n/**\n * #  Souvenir Grouping\n\n## Problem Background\n\nNOIP2007 Junior Division Task 2\n\n## Problem Description\n\nWith the New Year's Day approaching, the school's student council has assigned Lele the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, Lele must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, Lele hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+2$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nThe second line is an integer $n$, indicating the total number of purchased souvenirs $G$.\n\nLines $3$ to $n+2$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100 \n9 \n90 \n20 \n20 \n30 \n50 \n60 \n70 \n80 \n90\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hint\n\n$50\\%$ of the data satisfies: $1\\le n\\le15$.\n\n$100\\%$ of the data satisfies: $1\\le n\\le3\\times10^4$, $80\\le w\\le200$, $5 \\le  P_i  \\le  w$.\n */", "canonical_solution": " {\n  gifts.sort();\n  int i = 0, j = gifts.length - 1, groups = 0;\n  while (i <= j) {\n    if (gifts[i] + gifts[j] <= limit) i++;\n    j--;\n    groups++;\n  }\n  return groups;\n}", "test": "void testMinimumGroups() {\n  assert(minimumGroups([90, 20, 20, 30, 50, 60, 70, 80, 90], 100) == 6);\n  assert(minimumGroups([10, 20, 30, 40, 50, 60, 70, 80, 90], 150) == 5);\n  assert(minimumGroups([30, 30, 50, 60, 70], 100) == 3);\n}\n\nvoid main() {\n  testMinimumGroups();\n}", "entry_point": "minimumGroups", "signature": "int minimumGroups(List<int> gifts, int limit)", "docstring": "#  Souvenir Grouping\n\n## Problem Background\n\nNOIP2007 Junior Division Task 2\n\n## Problem Description\n\nWith the New Year's Day approaching, the school's student council has assigned Lele the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, Lele must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, Lele hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+2$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nThe second line is an integer $n$, indicating the total number of purchased souvenirs $G$.\n\nLines $3$ to $n+2$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100\n9\n90\n20\n20\n30\n50\n60\n70\n80\n90\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hint\n\n$50\\%$ of the data satisfies: $1\\le n\\le15$.\n\n$100\\%$ of the data satisfies: $1\\le n\\le3\\times10^4$, $80\\le w\\le200$, $5 \\le  P_i  \\le  w$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Souvenir Grouping\n\n## Problem Background\n\nNOIP2007 Junior Division Task 2\n\n## Problem Description\n\nWith the New Year's Day approaching, the school's student council has assigned Lele the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, Lele must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, Lele hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+2$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nThe second line is an integer $n$, indicating the total number of purchased souvenirs $G$.\n\nLines $3$ to $n+2$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n100\n9\n90\n20\n20\n30\n50\n60\n70\n80\n90\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hint\n\n$50\\%$ of the data satisfies: $1\\le n\\le15$.\n\n$100\\%$ of the data satisfies: $1\\le n\\le3\\times10^4$, $80\\le w\\le200$, $5 \\le  P_i  \\le  w$.\n\n* Incomplete Code:\nint minimumGroups(List<int> gifts, int limit)\n {\n  gifts.sort();\n[MASK]\n  while (i <= j) {\n[MASK]\n    j--;\n    groups++;\n  }\n  return groups;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  gifts.sort();\n[MASK]\n  while (i <= j) {\n[MASK]\n    j--;\n    groups++;\n  }\n  return groups;\n}"}
{"task_id": "Dart/37-0-multi", "prompt": "int hanoiTwinTowers(int n)\n/**\n * # Hanoi Twin Towers Problem\n\n## Problem Description\n\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other (the figure below illustrates the case when $n=3$).\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2\n```\n\n### Sample Output #2\n\n```\n6\n```\n\n## Hints\n\n**Constraints**\n\n- For $50\\%$ of the data, $1  \\le  n  \\le  25$;\n- For $100\\%$ of the data, $1  \\le  n  \\le  200$.\n\n**Hint**\n\nTry to establish a recursive relationship between $A_n$ and $A_{n-1}$.\n */", "canonical_solution": "{\n  List<int> dp = List<int>.filled(n + 1, 0);\n  dp[1] = 2;\n  for (int i = 2; i <= n; i++) {\n    dp[i] = 3 * dp[i - 1] + 2;\n  }\n  return dp[n];\n}", "test": "void testHanoiTwinTowers() {\n  assert(hanoiTwinTowers(1) == 2);\n  assert(hanoiTwinTowers(2) == 8);\n  assert(hanoiTwinTowers(3) == 26);\n}\n\nvoid main() {\n  testHanoiTwinTowers();\n}", "entry_point": "hanoiTwinTowers", "signature": "int hanoiTwinTowers(int n)", "docstring": "# Hanoi Twin Towers Problem\n\n## Problem Description\n\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other (the figure below illustrates the case when $n=3$).\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2\n```\n\n### Sample Output #2\n\n```\n6\n```\n\n## Hints\n\nConstraints\n\n- For $50\\%$ of the data, $1  \\le  n  \\le  25$;\n- For $100\\%$ of the data, $1  \\le  n  \\le  200$.\n\nHint\n\nTry to establish a recursive relationship between $A_n$ and $A_{n-1}$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Hanoi Twin Towers Problem\n\n## Problem Description\n\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other (the figure below illustrates the case when $n=3$).\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2\n```\n\n### Sample Output #2\n\n```\n6\n```\n\n## Hints\n\nConstraints\n\n- For $50\\%$ of the data, $1  \\le  n  \\le  25$;\n- For $100\\%$ of the data, $1  \\le  n  \\le  200$.\n\nHint\n\nTry to establish a recursive relationship between $A_n$ and $A_{n-1}$.\n\n* Incomplete Code:\nint hanoiTwinTowers(int n)\n{\n  List<int> dp = List<int>.filled(n + 1, 0);\n  dp[1] = 2;\n[MASK]\n[MASK]\n  }\n  return dp[n];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> dp = List<int>.filled(n + 1, 0);\n  dp[1] = 2;\n[MASK]\n[MASK]\n  }\n  return dp[n];\n}"}
{"task_id": "Dart/37-1-multi", "prompt": "int hanoiTwinTowers(int n)\n/**\n * # Hanoi Twin Towers Problem\n\n## Problem Description\n\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other (the figure below illustrates the case when $n=3$).\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2\n```\n\n### Sample Output #2\n\n```\n6\n```\n\n## Hints\n\n**Constraints**\n\n- For $50\\%$ of the data, $1  \\le  n  \\le  25$;\n- For $100\\%$ of the data, $1  \\le  n  \\le  200$.\n\n**Hint**\n\nTry to establish a recursive relationship between $A_n$ and $A_{n-1}$.\n */", "canonical_solution": "{\n  List<int> dp = List<int>.filled(n + 1, 0);\n  dp[1] = 2;\n  for (int i = 2; i <= n; i++) {\n    dp[i] = 3 * dp[i - 1] + 2;\n  }\n  return dp[n];\n}", "test": "void testHanoiTwinTowers() {\n  assert(hanoiTwinTowers(1) == 2);\n  assert(hanoiTwinTowers(2) == 8);\n  assert(hanoiTwinTowers(3) == 26);\n}\n\nvoid main() {\n  testHanoiTwinTowers();\n}", "entry_point": "hanoiTwinTowers", "signature": "int hanoiTwinTowers(int n)", "docstring": "# Hanoi Twin Towers Problem\n\n## Problem Description\n\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other (the figure below illustrates the case when $n=3$).\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2\n```\n\n### Sample Output #2\n\n```\n6\n```\n\n## Hints\n\nConstraints\n\n- For $50\\%$ of the data, $1  \\le  n  \\le  25$;\n- For $100\\%$ of the data, $1  \\le  n  \\le  200$.\n\nHint\n\nTry to establish a recursive relationship between $A_n$ and $A_{n-1}$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Hanoi Twin Towers Problem\n\n## Problem Description\n\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other (the figure below illustrates the case when $n=3$).\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1\n```\n\n### Sample Output #1\n\n```\n2\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2\n```\n\n### Sample Output #2\n\n```\n6\n```\n\n## Hints\n\nConstraints\n\n- For $50\\%$ of the data, $1  \\le  n  \\le  25$;\n- For $100\\%$ of the data, $1  \\le  n  \\le  200$.\n\nHint\n\nTry to establish a recursive relationship between $A_n$ and $A_{n-1}$.\n\n* Incomplete Code:\nint hanoiTwinTowers(int n)\n{\n  List<int> dp = List<int>.filled(n + 1, 0);\n[MASK]\n[MASK]\n[MASK]\n  }\n  return dp[n];\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> dp = List<int>.filled(n + 1, 0);\n[MASK]\n[MASK]\n[MASK]\n  }\n  return dp[n];\n}"}
{"task_id": "Dart/38-0-multi", "prompt": "String expandString(String input, int p1, int p2, int p3)\n/**\n * #  String Expansion\n\n## Problem Description\n\nIn the preliminary general group's \"Read the Program and Write the Result\" problem, we provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1 2 1\nabcs-w1234-9s-4zz\n```\n\n### Sample Output #1\n\n```\nabcsttuuvvw1234556677889s-4zz\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2 3 2\na-d-d\n```\n\n### Sample Output #2\n\n```\naCCCBBBd-d\n```\n*/", "canonical_solution": "{\n  // Helper function to expand a given range.\n  String expandRange(String start, String end, int p1, int p2, int p3) {\n    if (start.codeUnitAt(0) + 1 == end.codeUnitAt(0)) {\n      return \"$start$end\"; // Directly return if end is successor of start.\n    }\n\n    List<int> range = [];\n    for (int i = start.codeUnitAt(0) + 1; i < end.codeUnitAt(0); i++) {\n      for (int j = 0; j < p2; j++) { // Repeat according to p2.\n        range.add(i);\n      }\n    }\n\n    if (p3 == 2) {\n      range = range.reversed.toList(); // Reverse if p3 is 2.\n    }\n\n    return String.fromCharCodes(range.map((i) {\n      if (p1 == 3) return 42; // Return '*' for p1 = 3.\n      if (p1 == 2 && i >= 97 && i <= 122) return i - 32; // Uppercase for letters if p1 = 2.\n      return i; // Default behavior.\n    }));\n  }\n\n  RegExp exp = RegExp(r'([a-z0-9])-([a-z0-9])');\n  return input.replaceAllMapped(exp, (Match m) {\n    String start = m.group(1)!;\n    String end = m.group(2)!;\n\n    // Check if the end character is strictly greater than the start character.\n    if (start.codeUnitAt(0) < end.codeUnitAt(0)) {\n      return start + expandRange(start, end, p1, p2, p3) + end;\n    } else {\n      return m.group(0)!; // Return original if not in correct order.\n    }\n  });\n}", "test": "void main() {\n  // Test case 1: Normal case\n  assert(expandString('abcs-w1234-9s-4zz', 1, 2, 1) == 'abcsttuuvvw1234556677889s-4zz');\n\n  // Test case 2: With numbers, order preserved\n  assert(expandString('3-6', 1, 1, 1) == '3456');\n\n  // Test case 3: Mixed characters, inverse order with stars\n  assert(expandString('a-d-d', 2, 3, 2) == 'aCCCBBBd-d');\n}", "entry_point": "expandString", "signature": "String expandString(String input, int p1, int p2, int p3)", "docstring": "#  String Expansion\n\n## Problem Description\n\nIn the preliminary general group's \"Read the Program and Write the Result\" problem, we provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1 2 1\nabcs-w1234-9s-4zz\n```\n\n### Sample Output #1\n\n```\nabcsttuuvvw1234556677889s-4zz\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2 3 2\na-d-d\n```\n\n### Sample Output #2\n\n```\naCCCBBBd-d\n```\n\n## Hints\n\n$40\\%$ of the data satisfies: the length of the string does not exceed $5$.\n\n$100\\%$ of the data satisfies: $1 \\le p_1 \\le 3,1 \\le p_2 \\le 8,1 \\le p_3 \\le 2$. The length of the string does not exceed $100$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  String Expansion\n\n## Problem Description\n\nIn the preliminary general group's \"Read the Program and Write the Result\" problem, we provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1 2 1\nabcs-w1234-9s-4zz\n```\n\n### Sample Output #1\n\n```\nabcsttuuvvw1234556677889s-4zz\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2 3 2\na-d-d\n```\n\n### Sample Output #2\n\n```\naCCCBBBd-d\n```\n\n## Hints\n\n$40\\%$ of the data satisfies: the length of the string does not exceed $5$.\n\n$100\\%$ of the data satisfies: $1 \\le p_1 \\le 3,1 \\le p_2 \\le 8,1 \\le p_3 \\le 2$. The length of the string does not exceed $100$.\n\n* Incomplete Code:\nString expandString(String input, int p1, int p2, int p3)\n{\n  // Helper function to expand a given range.\n  String expandRange(String start, String end, int p1, int p2, int p3) {\n    if (start.codeUnitAt(0) + 1 == end.codeUnitAt(0)) {\n[MASK]\n    }\n\n[MASK]\n    for (int i = start.codeUnitAt(0) + 1; i < end.codeUnitAt(0); i++) {\n      for (int j = 0; j < p2; j++) { // Repeat according to p2.\n        range.add(i);\n      }\n    }\n\n    if (p3 == 2) {\n      range = range.reversed.toList(); // Reverse if p3 is 2.\n    }\n\n    return String.fromCharCodes(range.map((i) {\n      if (p1 == 3) return 42; // Return '*' for p1 = 3.\n      if (p1 == 2 && i >= 97 && i <= 122) return i - 32; // Uppercase for letters if p1 = 2.\n      return i; // Default behavior.\n    }));\n  }\n\n  RegExp exp = RegExp(r'([a-z0-9])-([a-z0-9])');\n  return input.replaceAllMapped(exp, (Match m) {\n    String start = m.group(1)!;\n    String end = m.group(2)!;\n\n    // Check if the end character is strictly greater than the start character.\n    if (start.codeUnitAt(0) < end.codeUnitAt(0)) {\n      return start + expandRange(start, end, p1, p2, p3) + end;\n    } else {\n      return m.group(0)!; // Return original if not in correct order.\n    }\n  });\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Helper function to expand a given range.\n  String expandRange(String start, String end, int p1, int p2, int p3) {\n    if (start.codeUnitAt(0) + 1 == end.codeUnitAt(0)) {\n[MASK]\n    }\n\n[MASK]\n    for (int i = start.codeUnitAt(0) + 1; i < end.codeUnitAt(0); i++) {\n      for (int j = 0; j < p2; j++) { // Repeat according to p2.\n        range.add(i);\n      }\n    }\n\n    if (p3 == 2) {\n      range = range.reversed.toList(); // Reverse if p3 is 2.\n    }\n\n    return String.fromCharCodes(range.map((i) {\n      if (p1 == 3) return 42; // Return '*' for p1 = 3.\n      if (p1 == 2 && i >= 97 && i <= 122) return i - 32; // Uppercase for letters if p1 = 2.\n      return i; // Default behavior.\n    }));\n  }\n\n  RegExp exp = RegExp(r'([a-z0-9])-([a-z0-9])');\n  return input.replaceAllMapped(exp, (Match m) {\n    String start = m.group(1)!;\n    String end = m.group(2)!;\n\n    // Check if the end character is strictly greater than the start character.\n    if (start.codeUnitAt(0) < end.codeUnitAt(0)) {\n      return start + expandRange(start, end, p1, p2, p3) + end;\n    } else {\n      return m.group(0)!; // Return original if not in correct order.\n    }\n  });\n}"}
{"task_id": "Dart/38-1-multi", "prompt": "String expandString(String input, int p1, int p2, int p3)\n/**\n * #  String Expansion\n\n## Problem Description\n\nIn the preliminary general group's \"Read the Program and Write the Result\" problem, we provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1 2 1\nabcs-w1234-9s-4zz\n```\n\n### Sample Output #1\n\n```\nabcsttuuvvw1234556677889s-4zz\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2 3 2\na-d-d\n```\n\n### Sample Output #2\n\n```\naCCCBBBd-d\n```\n*/", "canonical_solution": "{\n  // Helper function to expand a given range.\n  String expandRange(String start, String end, int p1, int p2, int p3) {\n    if (start.codeUnitAt(0) + 1 == end.codeUnitAt(0)) {\n      return \"$start$end\"; // Directly return if end is successor of start.\n    }\n\n    List<int> range = [];\n    for (int i = start.codeUnitAt(0) + 1; i < end.codeUnitAt(0); i++) {\n      for (int j = 0; j < p2; j++) { // Repeat according to p2.\n        range.add(i);\n      }\n    }\n\n    if (p3 == 2) {\n      range = range.reversed.toList(); // Reverse if p3 is 2.\n    }\n\n    return String.fromCharCodes(range.map((i) {\n      if (p1 == 3) return 42; // Return '*' for p1 = 3.\n      if (p1 == 2 && i >= 97 && i <= 122) return i - 32; // Uppercase for letters if p1 = 2.\n      return i; // Default behavior.\n    }));\n  }\n\n  RegExp exp = RegExp(r'([a-z0-9])-([a-z0-9])');\n  return input.replaceAllMapped(exp, (Match m) {\n    String start = m.group(1)!;\n    String end = m.group(2)!;\n\n    // Check if the end character is strictly greater than the start character.\n    if (start.codeUnitAt(0) < end.codeUnitAt(0)) {\n      return start + expandRange(start, end, p1, p2, p3) + end;\n    } else {\n      return m.group(0)!; // Return original if not in correct order.\n    }\n  });\n}", "test": "void main() {\n  // Test case 1: Normal case\n  assert(expandString('abcs-w1234-9s-4zz', 1, 2, 1) == 'abcsttuuvvw1234556677889s-4zz');\n\n  // Test case 2: With numbers, order preserved\n  assert(expandString('3-6', 1, 1, 1) == '3456');\n\n  // Test case 3: Mixed characters, inverse order with stars\n  assert(expandString('a-d-d', 2, 3, 2) == 'aCCCBBBd-d');\n}", "entry_point": "expandString", "signature": "String expandString(String input, int p1, int p2, int p3)", "docstring": "#  String Expansion\n\n## Problem Description\n\nIn the preliminary general group's \"Read the Program and Write the Result\" problem, we provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1 2 1\nabcs-w1234-9s-4zz\n```\n\n### Sample Output #1\n\n```\nabcsttuuvvw1234556677889s-4zz\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2 3 2\na-d-d\n```\n\n### Sample Output #2\n\n```\naCCCBBBd-d\n```\n\n## Hints\n\n$40\\%$ of the data satisfies: the length of the string does not exceed $5$.\n\n$100\\%$ of the data satisfies: $1 \\le p_1 \\le 3,1 \\le p_2 \\le 8,1 \\le p_3 \\le 2$. The length of the string does not exceed $100$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  String Expansion\n\n## Problem Description\n\nIn the preliminary general group's \"Read the Program and Write the Result\" problem, we provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n1 2 1\nabcs-w1234-9s-4zz\n```\n\n### Sample Output #1\n\n```\nabcsttuuvvw1234556677889s-4zz\n```\n\n## Sample #2\n\n### Sample Input #2\n\n```\n2 3 2\na-d-d\n```\n\n### Sample Output #2\n\n```\naCCCBBBd-d\n```\n\n## Hints\n\n$40\\%$ of the data satisfies: the length of the string does not exceed $5$.\n\n$100\\%$ of the data satisfies: $1 \\le p_1 \\le 3,1 \\le p_2 \\le 8,1 \\le p_3 \\le 2$. The length of the string does not exceed $100$.\n\n* Incomplete Code:\nString expandString(String input, int p1, int p2, int p3)\n{\n  // Helper function to expand a given range.\n  String expandRange(String start, String end, int p1, int p2, int p3) {\n[MASK]\n      return \"$start$end\"; // Directly return if end is successor of start.\n    }\n\n    List<int> range = [];\n    for (int i = start.codeUnitAt(0) + 1; i < end.codeUnitAt(0); i++) {\n      for (int j = 0; j < p2; j++) { // Repeat according to p2.\n        range.add(i);\n      }\n    }\n\n    if (p3 == 2) {\n      range = range.reversed.toList(); // Reverse if p3 is 2.\n    }\n\n    return String.fromCharCodes(range.map((i) {\n      if (p1 == 3) return 42; // Return '*' for p1 = 3.\n[MASK]\n      return i; // Default behavior.\n    }));\n  }\n\n[MASK]\n[MASK]\n[MASK]\n    String end = m.group(2)!;\n\n    // Check if the end character is strictly greater than the start character.\n    if (start.codeUnitAt(0) < end.codeUnitAt(0)) {\n      return start + expandRange(start, end, p1, p2, p3) + end;\n    } else {\n      return m.group(0)!; // Return original if not in correct order.\n    }\n  });\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  // Helper function to expand a given range.\n  String expandRange(String start, String end, int p1, int p2, int p3) {\n[MASK]\n      return \"$start$end\"; // Directly return if end is successor of start.\n    }\n\n    List<int> range = [];\n    for (int i = start.codeUnitAt(0) + 1; i < end.codeUnitAt(0); i++) {\n      for (int j = 0; j < p2; j++) { // Repeat according to p2.\n        range.add(i);\n      }\n    }\n\n    if (p3 == 2) {\n      range = range.reversed.toList(); // Reverse if p3 is 2.\n    }\n\n    return String.fromCharCodes(range.map((i) {\n      if (p1 == 3) return 42; // Return '*' for p1 = 3.\n[MASK]\n      return i; // Default behavior.\n    }));\n  }\n\n[MASK]\n[MASK]\n[MASK]\n    String end = m.group(2)!;\n\n    // Check if the end character is strictly greater than the start character.\n    if (start.codeUnitAt(0) < end.codeUnitAt(0)) {\n      return start + expandRange(start, end, p1, p2, p3) + end;\n    } else {\n      return m.group(0)!; // Return original if not in correct order.\n    }\n  });\n}"}
{"task_id": "Dart/40-0-multi", "prompt": "int countPairsWithDifference(List<int> numbers, int difference)\n\n/**\n * # A-B Number Pairs\n\n## Problem Background\n\nCreating problems is a taxing endeavor!\n\nExposure to identical problems may lead to aesthetic fatigue. Hence, I have abandoned the familiar A+B Problem in favor of A-B, haha!\n\n## Problem Description\n\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nThe input consists of two lines.\n\nThe first line contains two positive integers $N$ and $C$.\n\nThe second line contains $N$ positive integers, representing the sequence to be processed.\n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 1 2 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Hints\n\nFor $75\\%$ of the data, $1 \\leq N \\leq 2000$.\n\nFor $100\\%$ of the data, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i <2^{30}$, $1 \\leq C < 2^{30}$.\n    \n */", "canonical_solution": "{\n  Map<int, int> countMap = {};\n  int pairCount = 0;\n\n  for (int number in numbers) {\n    pairCount += countMap[number - difference] ?? 0;\n    countMap[number] = (countMap[number] ?? 0) + 1;\n  }\n  return pairCount;\n}", "test": "void main() {\n  testCountPairsWithDifference();\n}\n\nvoid testCountPairsWithDifference() {\n  assert(countPairsWithDifference([1, 1, 2, 3], 1) == 3);\n  assert(countPairsWithDifference([5, 4, 3, 2, 1], 1) == 0);\n  assert(countPairsWithDifference([10, 2, 9, 4, 8, 3, 7], 5) == 1);\n}", "entry_point": "countPairsWithDifference", "signature": "int countPairsWithDifference(List<int> numbers, int difference)", "docstring": "# A-B Number Pairs\n\n## Problem Background\n\nCreating problems is a taxing endeavor!\n\nExposure to identical problems may lead to aesthetic fatigue. Hence, I have abandoned the familiar A+B Problem in favor of A-B, haha!\n\n## Problem Description\n\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nThe input consists of two lines.\n\nThe first line contains two positive integers $N$ and $C$.\n\nThe second line contains $N$ positive integers, representing the sequence to be processed.\n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 1 2 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Hints\n\nFor $75\\%$ of the data, $1 \\leq N \\leq 2000$.\n\nFor $100\\%$ of the data, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i <2^{30}$, $1 \\leq C < 2^{30}$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# A-B Number Pairs\n\n## Problem Background\n\nCreating problems is a taxing endeavor!\n\nExposure to identical problems may lead to aesthetic fatigue. Hence, I have abandoned the familiar A+B Problem in favor of A-B, haha!\n\n## Problem Description\n\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nThe input consists of two lines.\n\nThe first line contains two positive integers $N$ and $C$.\n\nThe second line contains $N$ positive integers, representing the sequence to be processed.\n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 1 2 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Hints\n\nFor $75\\%$ of the data, $1 \\leq N \\leq 2000$.\n\nFor $100\\%$ of the data, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i <2^{30}$, $1 \\leq C < 2^{30}$.\n\n* Incomplete Code:\nint countPairsWithDifference(List<int> numbers, int difference)\n{\n[MASK]\n  int pairCount = 0;\n\n[MASK]\n[MASK]\n[MASK]\n  }\n  return pairCount;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  int pairCount = 0;\n\n[MASK]\n[MASK]\n[MASK]\n  }\n  return pairCount;\n}"}
{"task_id": "Dart/40-1-multi", "prompt": "int countPairsWithDifference(List<int> numbers, int difference)\n\n/**\n * # A-B Number Pairs\n\n## Problem Background\n\nCreating problems is a taxing endeavor!\n\nExposure to identical problems may lead to aesthetic fatigue. Hence, I have abandoned the familiar A+B Problem in favor of A-B, haha!\n\n## Problem Description\n\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nThe input consists of two lines.\n\nThe first line contains two positive integers $N$ and $C$.\n\nThe second line contains $N$ positive integers, representing the sequence to be processed.\n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 1 2 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Hints\n\nFor $75\\%$ of the data, $1 \\leq N \\leq 2000$.\n\nFor $100\\%$ of the data, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i <2^{30}$, $1 \\leq C < 2^{30}$.\n    \n */", "canonical_solution": "{\n  Map<int, int> countMap = {};\n  int pairCount = 0;\n\n  for (int number in numbers) {\n    pairCount += countMap[number - difference] ?? 0;\n    countMap[number] = (countMap[number] ?? 0) + 1;\n  }\n  return pairCount;\n}", "test": "void main() {\n  testCountPairsWithDifference();\n}\n\nvoid testCountPairsWithDifference() {\n  assert(countPairsWithDifference([1, 1, 2, 3], 1) == 3);\n  assert(countPairsWithDifference([5, 4, 3, 2, 1], 1) == 0);\n  assert(countPairsWithDifference([10, 2, 9, 4, 8, 3, 7], 5) == 1);\n}", "entry_point": "countPairsWithDifference", "signature": "int countPairsWithDifference(List<int> numbers, int difference)", "docstring": "# A-B Number Pairs\n\n## Problem Background\n\nCreating problems is a taxing endeavor!\n\nExposure to identical problems may lead to aesthetic fatigue. Hence, I have abandoned the familiar A+B Problem in favor of A-B, haha!\n\n## Problem Description\n\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nThe input consists of two lines.\n\nThe first line contains two positive integers $N$ and $C$.\n\nThe second line contains $N$ positive integers, representing the sequence to be processed.\n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 1 2 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Hints\n\nFor $75\\%$ of the data, $1 \\leq N \\leq 2000$.\n\nFor $100\\%$ of the data, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i <2^{30}$, $1 \\leq C < 2^{30}$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# A-B Number Pairs\n\n## Problem Background\n\nCreating problems is a taxing endeavor!\n\nExposure to identical problems may lead to aesthetic fatigue. Hence, I have abandoned the familiar A+B Problem in favor of A-B, haha!\n\n## Problem Description\n\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nThe input consists of two lines.\n\nThe first line contains two positive integers $N$ and $C$.\n\nThe second line contains $N$ positive integers, representing the sequence to be processed.\n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 1 2 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n## Hints\n\nFor $75\\%$ of the data, $1 \\leq N \\leq 2000$.\n\nFor $100\\%$ of the data, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i <2^{30}$, $1 \\leq C < 2^{30}$.\n\n* Incomplete Code:\nint countPairsWithDifference(List<int> numbers, int difference)\n{\n  Map<int, int> countMap = {};\n  int pairCount = 0;\n\n[MASK]\n[MASK]\n[MASK]\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  Map<int, int> countMap = {};\n  int pairCount = 0;\n\n[MASK]\n[MASK]\n[MASK]\n  }\n[MASK]\n}"}
{"task_id": "Dart/41-0-multi", "prompt": "int minimumUntidiness(List<Book> books, int k)\n\n/**\n * # Book Arrangement Optimization\n\n## Problem Description\n\nFrank is an individual with a profound appreciation for tidiness. He possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading Frank to initially arrange the books in ascending order by height. However, Frank discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\n\nThe first line contains two numbers, $n$ and $k$, representing the total number of books and the number of books to remove, respectively ($1 \\le n \\le 100, 1 \\le k<n$).\n\nThe following $n$ lines each contain two numbers that represent the height and width of a book, both of which are less than or equal to $200$.\n\nIt is guaranteed that no two books share the same height.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 2\n2 4\n3 1\n5 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n */", "canonical_solution": "{\n  books.sort((a, b) => a.height.compareTo(b.height));\n  List<int> prefixSum = List.generate(books.length + 1, (_) => 0);\n\n  for (int i = 1; i < prefixSum.length; i++) {\n    prefixSum[i] = prefixSum[i - 1] + books[i - 1].width;\n  }\n\n  List<List<int>> dp = List.generate(books.length + 1, (_) => List.generate(k + 1, (_) => 0));\n\n  for (int i = 1; i <= books.length; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (j > i) {\n        dp[i][j] = dp[i][j - 1];\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        for (int p = 0; p < i; p++) {\n          dp[i][j] = min(dp[i][j], dp[p][j - 1] + prefixSum[i] - prefixSum[p + 1] - books[p].width);\n        }\n      }\n    }\n  }\n  print(dp[books.length][k]);\n  return dp[books.length][k];\n}\n\nint min(int a, int b) => a < b ? a : b;\n\nclass Book {\n  final int height;\n  final int width;\n  Book(this.height, this.width);\n}", "test": "void main() {\n  testMinimumUntidiness();\n}\n\nvoid testMinimumUntidiness() {\n  assert(minimumUntidiness([\n    Book(1, 2),\n    Book(2, 4),\n    Book(3, 1),\n    Book(5, 3)\n  ], 1) == -4);\n\n  assert(minimumUntidiness([\n    Book(4, 5),\n    Book(1, 2),\n    Book(3, 2),\n    Book(2, 1)\n  ], 2) == -7);\n\n  assert(minimumUntidiness([\n    Book(1, 10),\n    Book(2, 3),\n    Book(3, 7),\n    Book(4, 1),\n    Book(5, 5)\n  ], 3) == -22);\n}", "entry_point": "minimumUntidiness", "signature": "int minimumUntidiness(List<Book> books, int k)", "docstring": "# Book Arrangement Optimization\n\n## Problem Description\n\nFrank is an individual with a profound appreciation for tidiness. He possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading Frank to initially arrange the books in ascending order by height. However, Frank discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$\n$5 \\times 3$\n$2 \\times 4$\n$3 \\times 1$\n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$\n$2 \\times 4$\n$3 \\times 1$\n$5 \\times 3$\n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\n\nThe first line contains two numbers, $n$ and $k$, representing the total number of books and the number of books to remove, respectively ($1 \\le n \\le 100, 1 \\le k<n$).\n\nThe following $n$ lines each contain two numbers that represent the height and width of a book, both of which are less than or equal to $200$.\n\nIt is guaranteed that no two books share the same height.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 2\n2 4\n3 1\n5 3\n```\n\n### Sample Output #1\n\n```\n3\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Book Arrangement Optimization\n\n## Problem Description\n\nFrank is an individual with a profound appreciation for tidiness. He possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading Frank to initially arrange the books in ascending order by height. However, Frank discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$\n$5 \\times 3$\n$2 \\times 4$\n$3 \\times 1$\n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$\n$2 \\times 4$\n$3 \\times 1$\n$5 \\times 3$\n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\n\nThe first line contains two numbers, $n$ and $k$, representing the total number of books and the number of books to remove, respectively ($1 \\le n \\le 100, 1 \\le k<n$).\n\nThe following $n$ lines each contain two numbers that represent the height and width of a book, both of which are less than or equal to $200$.\n\nIt is guaranteed that no two books share the same height.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 2\n2 4\n3 1\n5 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n* Incomplete Code:\nint minimumUntidiness(List<Book> books, int k)\n{\n  books.sort((a, b) => a.height.compareTo(b.height));\n  List<int> prefixSum = List.generate(books.length + 1, (_) => 0);\n\n  for (int i = 1; i < prefixSum.length; i++) {\n    prefixSum[i] = prefixSum[i - 1] + books[i - 1].width;\n  }\n\n[MASK]\n\n  for (int i = 1; i <= books.length; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (j > i) {\n[MASK]\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        for (int p = 0; p < i; p++) {\n[MASK]\n        }\n      }\n    }\n  }\n  print(dp[books.length][k]);\n  return dp[books.length][k];\n}\n\nint min(int a, int b) => a < b ? a : b;\n\n[MASK]\n  final int height;\n[MASK]\n  Book(this.height, this.width);\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  books.sort((a, b) => a.height.compareTo(b.height));\n  List<int> prefixSum = List.generate(books.length + 1, (_) => 0);\n\n  for (int i = 1; i < prefixSum.length; i++) {\n    prefixSum[i] = prefixSum[i - 1] + books[i - 1].width;\n  }\n\n[MASK]\n\n  for (int i = 1; i <= books.length; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (j > i) {\n[MASK]\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        for (int p = 0; p < i; p++) {\n[MASK]\n        }\n      }\n    }\n  }\n  print(dp[books.length][k]);\n  return dp[books.length][k];\n}\n\nint min(int a, int b) => a < b ? a : b;\n\n[MASK]\n  final int height;\n[MASK]\n  Book(this.height, this.width);\n}"}
{"task_id": "Dart/41-1-multi", "prompt": "int minimumUntidiness(List<Book> books, int k)\n\n/**\n * # Book Arrangement Optimization\n\n## Problem Description\n\nFrank is an individual with a profound appreciation for tidiness. He possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading Frank to initially arrange the books in ascending order by height. However, Frank discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\n\nThe first line contains two numbers, $n$ and $k$, representing the total number of books and the number of books to remove, respectively ($1 \\le n \\le 100, 1 \\le k<n$).\n\nThe following $n$ lines each contain two numbers that represent the height and width of a book, both of which are less than or equal to $200$.\n\nIt is guaranteed that no two books share the same height.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 2\n2 4\n3 1\n5 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n */", "canonical_solution": "{\n  books.sort((a, b) => a.height.compareTo(b.height));\n  List<int> prefixSum = List.generate(books.length + 1, (_) => 0);\n\n  for (int i = 1; i < prefixSum.length; i++) {\n    prefixSum[i] = prefixSum[i - 1] + books[i - 1].width;\n  }\n\n  List<List<int>> dp = List.generate(books.length + 1, (_) => List.generate(k + 1, (_) => 0));\n\n  for (int i = 1; i <= books.length; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (j > i) {\n        dp[i][j] = dp[i][j - 1];\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        for (int p = 0; p < i; p++) {\n          dp[i][j] = min(dp[i][j], dp[p][j - 1] + prefixSum[i] - prefixSum[p + 1] - books[p].width);\n        }\n      }\n    }\n  }\n  print(dp[books.length][k]);\n  return dp[books.length][k];\n}\n\nint min(int a, int b) => a < b ? a : b;\n\nclass Book {\n  final int height;\n  final int width;\n  Book(this.height, this.width);\n}", "test": "void main() {\n  testMinimumUntidiness();\n}\n\nvoid testMinimumUntidiness() {\n  assert(minimumUntidiness([\n    Book(1, 2),\n    Book(2, 4),\n    Book(3, 1),\n    Book(5, 3)\n  ], 1) == -4);\n\n  assert(minimumUntidiness([\n    Book(4, 5),\n    Book(1, 2),\n    Book(3, 2),\n    Book(2, 1)\n  ], 2) == -7);\n\n  assert(minimumUntidiness([\n    Book(1, 10),\n    Book(2, 3),\n    Book(3, 7),\n    Book(4, 1),\n    Book(5, 5)\n  ], 3) == -22);\n}", "entry_point": "minimumUntidiness", "signature": "int minimumUntidiness(List<Book> books, int k)", "docstring": "# Book Arrangement Optimization\n\n## Problem Description\n\nFrank is an individual with a profound appreciation for tidiness. He possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading Frank to initially arrange the books in ascending order by height. However, Frank discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$\n$5 \\times 3$\n$2 \\times 4$\n$3 \\times 1$\n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$\n$2 \\times 4$\n$3 \\times 1$\n$5 \\times 3$\n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\n\nThe first line contains two numbers, $n$ and $k$, representing the total number of books and the number of books to remove, respectively ($1 \\le n \\le 100, 1 \\le k<n$).\n\nThe following $n$ lines each contain two numbers that represent the height and width of a book, both of which are less than or equal to $200$.\n\nIt is guaranteed that no two books share the same height.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 2\n2 4\n3 1\n5 3\n```\n\n### Sample Output #1\n\n```\n3\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Book Arrangement Optimization\n\n## Problem Description\n\nFrank is an individual with a profound appreciation for tidiness. He possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading Frank to initially arrange the books in ascending order by height. However, Frank discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$\n$5 \\times 3$\n$2 \\times 4$\n$3 \\times 1$\n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$\n$2 \\times 4$\n$3 \\times 1$\n$5 \\times 3$\n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\n\nThe first line contains two numbers, $n$ and $k$, representing the total number of books and the number of books to remove, respectively ($1 \\le n \\le 100, 1 \\le k<n$).\n\nThe following $n$ lines each contain two numbers that represent the height and width of a book, both of which are less than or equal to $200$.\n\nIt is guaranteed that no two books share the same height.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4 1\n1 2\n2 4\n3 1\n5 3\n```\n\n### Sample Output #1\n\n```\n3\n```\n\n* Incomplete Code:\nint minimumUntidiness(List<Book> books, int k)\n{\n  books.sort((a, b) => a.height.compareTo(b.height));\n  List<int> prefixSum = List.generate(books.length + 1, (_) => 0);\n\n  for (int i = 1; i < prefixSum.length; i++) {\n    prefixSum[i] = prefixSum[i - 1] + books[i - 1].width;\n  }\n\n[MASK]\n\n  for (int i = 1; i <= books.length; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (j > i) {\n        dp[i][j] = dp[i][j - 1];\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        for (int p = 0; p < i; p++) {\n          dp[i][j] = min(dp[i][j], dp[p][j - 1] + prefixSum[i] - prefixSum[p + 1] - books[p].width);\n        }\n      }\n    }\n  }\n  print(dp[books.length][k]);\n[MASK]\n}\n\nint min(int a, int b) => a < b ? a : b;\n\nclass Book {\n  final int height;\n  final int width;\n  Book(this.height, this.width);\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  books.sort((a, b) => a.height.compareTo(b.height));\n  List<int> prefixSum = List.generate(books.length + 1, (_) => 0);\n\n  for (int i = 1; i < prefixSum.length; i++) {\n    prefixSum[i] = prefixSum[i - 1] + books[i - 1].width;\n  }\n\n[MASK]\n\n  for (int i = 1; i <= books.length; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (j > i) {\n        dp[i][j] = dp[i][j - 1];\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        for (int p = 0; p < i; p++) {\n          dp[i][j] = min(dp[i][j], dp[p][j - 1] + prefixSum[i] - prefixSum[p + 1] - books[p].width);\n        }\n      }\n    }\n  }\n  print(dp[books.length][k]);\n[MASK]\n}\n\nint min(int a, int b) => a < b ? a : b;\n\nclass Book {\n  final int height;\n  final int width;\n  Book(this.height, this.width);\n}"}
{"task_id": "Dart/42-0-multi", "prompt": "List<String> sortStudentsByBirthday(List<List<String>> inputList)\n\n/**\n * # Birthday\n\n## Problem Description\n\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\nThe input consists of $n + 1$ lines:\n\nThe first line contains the total number of students in the OI group, $n$;\n\nFrom the second line to the $(n+1)$-th line, each line contains an individual's name $s$, birth year $y$, month $m$, and day $d$.\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n```\n\n### Sample Output #1\n\n```\nLuowen\nYangchu\nQiujingya\n```\n\n## Notes\n\nThe data is guaranteed to have $1<n<100$, $1\\leq |s|<20$. It is assured that the dates provided are valid and the years fall within the range of $[1960,2020]$.\n */", "canonical_solution": "{\n  List<Student> students = inputList.map((data) {\n    String name = data[0];\n    int year = int.parse(data[1]);\n    int month = int.parse(data[2]);\n    int day = int.parse(data[3]);\n    return Student(name, DateTime(year, month, day));\n  }).toList();\n\n  students.sort((a, b) {\n    int comp = b.birthday.compareTo(a.birthday);\n    if (comp == 0) return inputList.indexOf([a.name, '${a.birthday.year}', '${a.birthday.month}', '${a.birthday.day}']).compareTo(inputList.indexOf([b.name, '${b.birthday.year}', '${b.birthday.month}', '${b.birthday.day}']));\n    return comp;\n  });\n  return students.map((student) => student.name).toList();\n}\n\nclass Student {\n  String name;\n  DateTime birthday;\n  Student(this.name, this.birthday);\n}", "test": "void main() {\n  testSortStudentsByBirthday();\n}\n\nvoid testSortStudentsByBirthday() {\n  assert(sortStudentsByBirthday([\n    [\"Alice\", \"1990\", \"5\", \"12\"],\n    [\"Bob\", \"1989\", \"1\", \"15\"],\n    [\"Charlie\", \"1990\", \"5\", \"12\"],\n  ]).join(',') == \"Alice,Charlie,Bob\");\n\n  assert(sortStudentsByBirthday([\n    [\"David\", \"1991\", \"3\", \"11\"],\n    [\"Eve\", \"1992\", \"7\", \"30\"],\n    [\"Frank\", \"1991\", \"3\", \"11\"],\n  ]).join(',') == \"Eve,David,Frank\");\n\n  assert(sortStudentsByBirthday([\n    [\"George\", \"1990\", \"4\", \"22\"],\n    [\"Hannah\", \"1992\", \"10\", \"13\"],\n    [\"Ian\", \"1991\", \"8\", \"1\"],\n  ]).join(',') == \"Hannah,Ian,George\");\n}", "entry_point": "sortStudentsByBirthday", "signature": "List<String> sortStudentsByBirthday(List<List<String>> inputList)", "docstring": "# Birthday\n\n## Problem Description\n\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\nThe input consists of $n + 1$ lines:\n\nThe first line contains the total number of students in the OI group, $n$;\n\nFrom the second line to the $(n+1)$-th line, each line contains an individual's name $s$, birth year $y$, month $m$, and day $d$.\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n```\n\n### Sample Output #1\n\n```\nLuowen\nYangchu\nQiujingya\n```\n\n## Notes\n\nThe data is guaranteed to have $1<n<100$, $1\\leq |s|<20$. It is assured that the dates provided are valid and the years fall within the range of $[1960,2020]$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Birthday\n\n## Problem Description\n\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\nThe input consists of $n + 1$ lines:\n\nThe first line contains the total number of students in the OI group, $n$;\n\nFrom the second line to the $(n+1)$-th line, each line contains an individual's name $s$, birth year $y$, month $m$, and day $d$.\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n```\n\n### Sample Output #1\n\n```\nLuowen\nYangchu\nQiujingya\n```\n\n## Notes\n\nThe data is guaranteed to have $1<n<100$, $1\\leq |s|<20$. It is assured that the dates provided are valid and the years fall within the range of $[1960,2020]$.\n\n* Incomplete Code:\nList<String> sortStudentsByBirthday(List<List<String>> inputList)\n{\n[MASK]\n    String name = data[0];\n    int year = int.parse(data[1]);\n    int month = int.parse(data[2]);\n    int day = int.parse(data[3]);\n    return Student(name, DateTime(year, month, day));\n  }).toList();\n\n  students.sort((a, b) {\n    int comp = b.birthday.compareTo(a.birthday);\n    if (comp == 0) return inputList.indexOf([a.name, '${a.birthday.year}', '${a.birthday.month}', '${a.birthday.day}']).compareTo(inputList.indexOf([b.name, '${b.birthday.year}', '${b.birthday.month}', '${b.birthday.day}']));\n[MASK]\n  });\n  return students.map((student) => student.name).toList();\n}\n\nclass Student {\n  String name;\n  DateTime birthday;\n  Student(this.name, this.birthday);\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n    String name = data[0];\n    int year = int.parse(data[1]);\n    int month = int.parse(data[2]);\n    int day = int.parse(data[3]);\n    return Student(name, DateTime(year, month, day));\n  }).toList();\n\n  students.sort((a, b) {\n    int comp = b.birthday.compareTo(a.birthday);\n    if (comp == 0) return inputList.indexOf([a.name, '${a.birthday.year}', '${a.birthday.month}', '${a.birthday.day}']).compareTo(inputList.indexOf([b.name, '${b.birthday.year}', '${b.birthday.month}', '${b.birthday.day}']));\n[MASK]\n  });\n  return students.map((student) => student.name).toList();\n}\n\nclass Student {\n  String name;\n  DateTime birthday;\n  Student(this.name, this.birthday);\n}"}
{"task_id": "Dart/42-1-multi", "prompt": "List<String> sortStudentsByBirthday(List<List<String>> inputList)\n\n/**\n * # Birthday\n\n## Problem Description\n\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\nThe input consists of $n + 1$ lines:\n\nThe first line contains the total number of students in the OI group, $n$;\n\nFrom the second line to the $(n+1)$-th line, each line contains an individual's name $s$, birth year $y$, month $m$, and day $d$.\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n```\n\n### Sample Output #1\n\n```\nLuowen\nYangchu\nQiujingya\n```\n\n## Notes\n\nThe data is guaranteed to have $1<n<100$, $1\\leq |s|<20$. It is assured that the dates provided are valid and the years fall within the range of $[1960,2020]$.\n */", "canonical_solution": "{\n  List<Student> students = inputList.map((data) {\n    String name = data[0];\n    int year = int.parse(data[1]);\n    int month = int.parse(data[2]);\n    int day = int.parse(data[3]);\n    return Student(name, DateTime(year, month, day));\n  }).toList();\n\n  students.sort((a, b) {\n    int comp = b.birthday.compareTo(a.birthday);\n    if (comp == 0) return inputList.indexOf([a.name, '${a.birthday.year}', '${a.birthday.month}', '${a.birthday.day}']).compareTo(inputList.indexOf([b.name, '${b.birthday.year}', '${b.birthday.month}', '${b.birthday.day}']));\n    return comp;\n  });\n  return students.map((student) => student.name).toList();\n}\n\nclass Student {\n  String name;\n  DateTime birthday;\n  Student(this.name, this.birthday);\n}", "test": "void main() {\n  testSortStudentsByBirthday();\n}\n\nvoid testSortStudentsByBirthday() {\n  assert(sortStudentsByBirthday([\n    [\"Alice\", \"1990\", \"5\", \"12\"],\n    [\"Bob\", \"1989\", \"1\", \"15\"],\n    [\"Charlie\", \"1990\", \"5\", \"12\"],\n  ]).join(',') == \"Alice,Charlie,Bob\");\n\n  assert(sortStudentsByBirthday([\n    [\"David\", \"1991\", \"3\", \"11\"],\n    [\"Eve\", \"1992\", \"7\", \"30\"],\n    [\"Frank\", \"1991\", \"3\", \"11\"],\n  ]).join(',') == \"Eve,David,Frank\");\n\n  assert(sortStudentsByBirthday([\n    [\"George\", \"1990\", \"4\", \"22\"],\n    [\"Hannah\", \"1992\", \"10\", \"13\"],\n    [\"Ian\", \"1991\", \"8\", \"1\"],\n  ]).join(',') == \"Hannah,Ian,George\");\n}", "entry_point": "sortStudentsByBirthday", "signature": "List<String> sortStudentsByBirthday(List<List<String>> inputList)", "docstring": "# Birthday\n\n## Problem Description\n\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\nThe input consists of $n + 1$ lines:\n\nThe first line contains the total number of students in the OI group, $n$;\n\nFrom the second line to the $(n+1)$-th line, each line contains an individual's name $s$, birth year $y$, month $m$, and day $d$.\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n```\n\n### Sample Output #1\n\n```\nLuowen\nYangchu\nQiujingya\n```\n\n## Notes\n\nThe data is guaranteed to have $1<n<100$, $1\\leq |s|<20$. It is assured that the dates provided are valid and the years fall within the range of $[1960,2020]$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Birthday\n\n## Problem Description\n\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\nThe input consists of $n + 1$ lines:\n\nThe first line contains the total number of students in the OI group, $n$;\n\nFrom the second line to the $(n+1)$-th line, each line contains an individual's name $s$, birth year $y$, month $m$, and day $d$.\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\n\n### Sample Input #1\n\n```\n3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n```\n\n### Sample Output #1\n\n```\nLuowen\nYangchu\nQiujingya\n```\n\n## Notes\n\nThe data is guaranteed to have $1<n<100$, $1\\leq |s|<20$. It is assured that the dates provided are valid and the years fall within the range of $[1960,2020]$.\n\n* Incomplete Code:\nList<String> sortStudentsByBirthday(List<List<String>> inputList)\n{\n  List<Student> students = inputList.map((data) {\n[MASK]\n    int year = int.parse(data[1]);\n    int month = int.parse(data[2]);\n    int day = int.parse(data[3]);\n[MASK]\n  }).toList();\n\n  students.sort((a, b) {\n    int comp = b.birthday.compareTo(a.birthday);\n    if (comp == 0) return inputList.indexOf([a.name, '${a.birthday.year}', '${a.birthday.month}', '${a.birthday.day}']).compareTo(inputList.indexOf([b.name, '${b.birthday.year}', '${b.birthday.month}', '${b.birthday.day}']));\n[MASK]\n  });\n[MASK]\n}\n\nclass Student {\n[MASK]\n  DateTime birthday;\n  Student(this.name, this.birthday);\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<Student> students = inputList.map((data) {\n[MASK]\n    int year = int.parse(data[1]);\n    int month = int.parse(data[2]);\n    int day = int.parse(data[3]);\n[MASK]\n  }).toList();\n\n  students.sort((a, b) {\n    int comp = b.birthday.compareTo(a.birthday);\n    if (comp == 0) return inputList.indexOf([a.name, '${a.birthday.year}', '${a.birthday.month}', '${a.birthday.day}']).compareTo(inputList.indexOf([b.name, '${b.birthday.year}', '${b.birthday.month}', '${b.birthday.day}']));\n[MASK]\n  });\n[MASK]\n}\n\nclass Student {\n[MASK]\n  DateTime birthday;\n  Student(this.name, this.birthday);\n}"}
{"task_id": "Dart/43-0-multi", "prompt": "String removeKDigits(String num, int k)\n\n/**\n * # Digit Removal Problem\n\n## Problem Description\n\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nTwo lines of positive integers are inputted.\n\nThe first line contains a high-precision positive integer $n$.\n\nThe second line contains a positive integer $k$, indicating the number of digits to be deleted.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n175438 \n4\n```\n\n### Sample Output #1\n\n```\n13\n```\n */", "canonical_solution": "{\n  List<int> stack = [];\n  for (int i = 0; i < num.length; i++) {\n    int current = num.codeUnitAt(i) - '0'.codeUnitAt(0);\n    while (stack.isNotEmpty && stack.last > current && k > 0) {\n      stack.removeLast();\n      k--;\n    }\n    if (stack.isNotEmpty || current != 0) {\n      stack.add(current);\n    }\n  }\n\n  while (k > 0 && stack.isNotEmpty) {\n    stack.removeLast();\n    k--;\n  }\n\n  if (stack.isEmpty) {\n    return \"0\";\n  }\n\n  return stack.join();\n}", "test": "void main() {\n  testRemoveKDigits();\n}\n\nvoid testRemoveKDigits() {\n  assert(removeKDigits(\"175438\", 4) == \"13\");\n  assert(removeKDigits(\"10200\", 1) == \"200\");\n  assert(removeKDigits(\"1432219\", 3) == \"1219\");\n}", "entry_point": "removeKDigits", "signature": "String removeKDigits(String num, int k)", "docstring": "# Digit Removal Problem\n\n## Problem Description\n\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nTwo lines of positive integers are inputted.\n\nThe first line contains a high-precision positive integer $n$.\n\nThe second line contains a positive integer $k$, indicating the number of digits to be deleted.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n175438\n4\n```\n\n### Sample Output #1\n\n```\n13\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Digit Removal Problem\n\n## Problem Description\n\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nTwo lines of positive integers are inputted.\n\nThe first line contains a high-precision positive integer $n$.\n\nThe second line contains a positive integer $k$, indicating the number of digits to be deleted.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n175438\n4\n```\n\n### Sample Output #1\n\n```\n13\n```\n\n* Incomplete Code:\nString removeKDigits(String num, int k)\n{\n  List<int> stack = [];\n  for (int i = 0; i < num.length; i++) {\n[MASK]\n    while (stack.isNotEmpty && stack.last > current && k > 0) {\n      stack.removeLast();\n      k--;\n    }\n    if (stack.isNotEmpty || current != 0) {\n      stack.add(current);\n    }\n  }\n\n  while (k > 0 && stack.isNotEmpty) {\n    stack.removeLast();\n[MASK]\n  }\n\n  if (stack.isEmpty) {\n    return \"0\";\n  }\n\n  return stack.join();\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> stack = [];\n  for (int i = 0; i < num.length; i++) {\n[MASK]\n    while (stack.isNotEmpty && stack.last > current && k > 0) {\n      stack.removeLast();\n      k--;\n    }\n    if (stack.isNotEmpty || current != 0) {\n      stack.add(current);\n    }\n  }\n\n  while (k > 0 && stack.isNotEmpty) {\n    stack.removeLast();\n[MASK]\n  }\n\n  if (stack.isEmpty) {\n    return \"0\";\n  }\n\n  return stack.join();\n}"}
{"task_id": "Dart/43-1-multi", "prompt": "String removeKDigits(String num, int k)\n\n/**\n * # Digit Removal Problem\n\n## Problem Description\n\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nTwo lines of positive integers are inputted.\n\nThe first line contains a high-precision positive integer $n$.\n\nThe second line contains a positive integer $k$, indicating the number of digits to be deleted.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n175438 \n4\n```\n\n### Sample Output #1\n\n```\n13\n```\n */", "canonical_solution": "{\n  List<int> stack = [];\n  for (int i = 0; i < num.length; i++) {\n    int current = num.codeUnitAt(i) - '0'.codeUnitAt(0);\n    while (stack.isNotEmpty && stack.last > current && k > 0) {\n      stack.removeLast();\n      k--;\n    }\n    if (stack.isNotEmpty || current != 0) {\n      stack.add(current);\n    }\n  }\n\n  while (k > 0 && stack.isNotEmpty) {\n    stack.removeLast();\n    k--;\n  }\n\n  if (stack.isEmpty) {\n    return \"0\";\n  }\n\n  return stack.join();\n}", "test": "void main() {\n  testRemoveKDigits();\n}\n\nvoid testRemoveKDigits() {\n  assert(removeKDigits(\"175438\", 4) == \"13\");\n  assert(removeKDigits(\"10200\", 1) == \"200\");\n  assert(removeKDigits(\"1432219\", 3) == \"1219\");\n}", "entry_point": "removeKDigits", "signature": "String removeKDigits(String num, int k)", "docstring": "# Digit Removal Problem\n\n## Problem Description\n\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nTwo lines of positive integers are inputted.\n\nThe first line contains a high-precision positive integer $n$.\n\nThe second line contains a positive integer $k$, indicating the number of digits to be deleted.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n175438\n4\n```\n\n### Sample Output #1\n\n```\n13\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Digit Removal Problem\n\n## Problem Description\n\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nTwo lines of positive integers are inputted.\n\nThe first line contains a high-precision positive integer $n$.\n\nThe second line contains a positive integer $k$, indicating the number of digits to be deleted.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n175438\n4\n```\n\n### Sample Output #1\n\n```\n13\n```\n\n* Incomplete Code:\nString removeKDigits(String num, int k)\n{\n  List<int> stack = [];\n[MASK]\n    int current = num.codeUnitAt(i) - '0'.codeUnitAt(0);\n[MASK]\n      stack.removeLast();\n      k--;\n    }\n    if (stack.isNotEmpty || current != 0) {\n[MASK]\n    }\n  }\n\n  while (k > 0 && stack.isNotEmpty) {\n    stack.removeLast();\n    k--;\n  }\n\n  if (stack.isEmpty) {\n[MASK]\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  List<int> stack = [];\n[MASK]\n    int current = num.codeUnitAt(i) - '0'.codeUnitAt(0);\n[MASK]\n      stack.removeLast();\n      k--;\n    }\n    if (stack.isNotEmpty || current != 0) {\n[MASK]\n    }\n  }\n\n  while (k > 0 && stack.isNotEmpty) {\n    stack.removeLast();\n    k--;\n  }\n\n  if (stack.isEmpty) {\n[MASK]\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/44-0-multi", "prompt": "import 'dart:math';\n\nint minimumTransfers(int n, List<int> groups, int L, int R)\n\n/**\n * # Student Grouping\n\n## Problem Description\n\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nThe first line contains a single integer $n$, representing the number of student groups;\n\nThe second line contains $n$ integers, representing the number of students in each group;\n\nThe third line contains two integers $L,R$, representing the lower and upper bounds, respectively.\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2\n10 20\n10 15\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\n### Data Range and Agreement\n\nFor all datasets, it is guaranteed that $1\\le n \\le 50$.\n */", "canonical_solution": "{\n  int totalStudents = groups.reduce((a, b) => a + b);\n  if (totalStudents < n * L || totalStudents > n * R) return -1;\n\n  int transfers = 0;\n  List<int> surplus = groups.where((g) => g > R).toList();\n  List<int> deficit = groups.where((g) => g < L).toList();\n\n  while (surplus.isNotEmpty && deficit.isNotEmpty) {\n    int transfer = min(surplus.last - R, L - deficit.first);\n    surplus[surplus.length - 1] -= transfer;\n    deficit[0] += transfer;\n    transfers += transfer;\n    if (surplus.last <= R) surplus.removeLast();\n    if (deficit.first >= L) deficit.removeAt(0);\n  }\n  return transfers;\n}", "test": "void testMinimumTransfers() {\n  assert(minimumTransfers(2, [10, 20], 10, 15) == 0);\n  assert(minimumTransfers(3, [8, 16, 8], 9, 12) == 2);\n  assert(minimumTransfers(4, [10, 10, 10, 10], 5, 15) == 0);\n}\n\nvoid main() {\n  testMinimumTransfers();\n}", "entry_point": "minimumTransfers", "signature": "int minimumTransfers(int n, List<int> groups, int L, int R)", "docstring": "# Student Grouping\n\n## Problem Description\n\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nThe first line contains a single integer $n$, representing the number of student groups;\n\nThe second line contains $n$ integers, representing the number of students in each group;\n\nThe third line contains two integers $L,R$, representing the lower and upper bounds, respectively.\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2\n10 20\n10 15\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\n### Data Range and Agreement\n\nFor all datasets, it is guaranteed that $1\\le n \\le 50$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Student Grouping\n\n## Problem Description\n\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nThe first line contains a single integer $n$, representing the number of student groups;\n\nThe second line contains $n$ integers, representing the number of students in each group;\n\nThe third line contains two integers $L,R$, representing the lower and upper bounds, respectively.\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2\n10 20\n10 15\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\n### Data Range and Agreement\n\nFor all datasets, it is guaranteed that $1\\le n \\le 50$.\n\n* Incomplete Code:\nint minimumTransfers(int n, List<int> groups, int L, int R)\n{\n  int totalStudents = groups.reduce((a, b) => a + b);\n  if (totalStudents < n * L || totalStudents > n * R) return -1;\n\n[MASK]\n  List<int> surplus = groups.where((g) => g > R).toList();\n  List<int> deficit = groups.where((g) => g < L).toList();\n\n  while (surplus.isNotEmpty && deficit.isNotEmpty) {\n[MASK]\n    surplus[surplus.length - 1] -= transfer;\n[MASK]\n    transfers += transfer;\n    if (surplus.last <= R) surplus.removeLast();\n    if (deficit.first >= L) deficit.removeAt(0);\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int totalStudents = groups.reduce((a, b) => a + b);\n  if (totalStudents < n * L || totalStudents > n * R) return -1;\n\n[MASK]\n  List<int> surplus = groups.where((g) => g > R).toList();\n  List<int> deficit = groups.where((g) => g < L).toList();\n\n  while (surplus.isNotEmpty && deficit.isNotEmpty) {\n[MASK]\n    surplus[surplus.length - 1] -= transfer;\n[MASK]\n    transfers += transfer;\n    if (surplus.last <= R) surplus.removeLast();\n    if (deficit.first >= L) deficit.removeAt(0);\n  }\n[MASK]\n}"}
{"task_id": "Dart/44-1-multi", "prompt": "import 'dart:math';\n\nint minimumTransfers(int n, List<int> groups, int L, int R)\n\n/**\n * # Student Grouping\n\n## Problem Description\n\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nThe first line contains a single integer $n$, representing the number of student groups;\n\nThe second line contains $n$ integers, representing the number of students in each group;\n\nThe third line contains two integers $L,R$, representing the lower and upper bounds, respectively.\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2\n10 20\n10 15\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\n### Data Range and Agreement\n\nFor all datasets, it is guaranteed that $1\\le n \\le 50$.\n */", "canonical_solution": "{\n  int totalStudents = groups.reduce((a, b) => a + b);\n  if (totalStudents < n * L || totalStudents > n * R) return -1;\n\n  int transfers = 0;\n  List<int> surplus = groups.where((g) => g > R).toList();\n  List<int> deficit = groups.where((g) => g < L).toList();\n\n  while (surplus.isNotEmpty && deficit.isNotEmpty) {\n    int transfer = min(surplus.last - R, L - deficit.first);\n    surplus[surplus.length - 1] -= transfer;\n    deficit[0] += transfer;\n    transfers += transfer;\n    if (surplus.last <= R) surplus.removeLast();\n    if (deficit.first >= L) deficit.removeAt(0);\n  }\n  return transfers;\n}", "test": "void testMinimumTransfers() {\n  assert(minimumTransfers(2, [10, 20], 10, 15) == 0);\n  assert(minimumTransfers(3, [8, 16, 8], 9, 12) == 2);\n  assert(minimumTransfers(4, [10, 10, 10, 10], 5, 15) == 0);\n}\n\nvoid main() {\n  testMinimumTransfers();\n}", "entry_point": "minimumTransfers", "signature": "int minimumTransfers(int n, List<int> groups, int L, int R)", "docstring": "# Student Grouping\n\n## Problem Description\n\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nThe first line contains a single integer $n$, representing the number of student groups;\n\nThe second line contains $n$ integers, representing the number of students in each group;\n\nThe third line contains two integers $L,R$, representing the lower and upper bounds, respectively.\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2\n10 20\n10 15\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\n### Data Range and Agreement\n\nFor all datasets, it is guaranteed that $1\\le n \\le 50$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Student Grouping\n\n## Problem Description\n\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nThe first line contains a single integer $n$, representing the number of student groups;\n\nThe second line contains $n$ integers, representing the number of students in each group;\n\nThe third line contains two integers $L,R$, representing the lower and upper bounds, respectively.\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n2\n10 20\n10 15\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\n### Data Range and Agreement\n\nFor all datasets, it is guaranteed that $1\\le n \\le 50$.\n\n* Incomplete Code:\nint minimumTransfers(int n, List<int> groups, int L, int R)\n{\n  int totalStudents = groups.reduce((a, b) => a + b);\n  if (totalStudents < n * L || totalStudents > n * R) return -1;\n\n  int transfers = 0;\n  List<int> surplus = groups.where((g) => g > R).toList();\n[MASK]\n\n  while (surplus.isNotEmpty && deficit.isNotEmpty) {\n    int transfer = min(surplus.last - R, L - deficit.first);\n    surplus[surplus.length - 1] -= transfer;\n    deficit[0] += transfer;\n[MASK]\n    if (surplus.last <= R) surplus.removeLast();\n    if (deficit.first >= L) deficit.removeAt(0);\n  }\n  return transfers;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int totalStudents = groups.reduce((a, b) => a + b);\n  if (totalStudents < n * L || totalStudents > n * R) return -1;\n\n  int transfers = 0;\n  List<int> surplus = groups.where((g) => g > R).toList();\n[MASK]\n\n  while (surplus.isNotEmpty && deficit.isNotEmpty) {\n    int transfer = min(surplus.last - R, L - deficit.first);\n    surplus[surplus.length - 1] -= transfer;\n    deficit[0] += transfer;\n[MASK]\n    if (surplus.last <= R) surplus.removeLast();\n    if (deficit.first >= L) deficit.removeAt(0);\n  }\n  return transfers;\n}"}
{"task_id": "Dart/45-0-multi", "prompt": "int findEarliestTime(int N, int M, List<Road> roads)\n\n/**\n * # Highway Repair\n\n## Background\n\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\n\n## Problem Description\n\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\nFor all data, it is guaranteed that $1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.\n */", "canonical_solution": "{\n  roads.sort((a, b) => a.repairTime.compareTo(b.repairTime));\n  List<int> parent = List.generate(N + 1, (index) => index);\n\n  int find(int v) {\n    return v == parent[v] ? v : parent[v] = find(parent[v]);\n  }\n\n  void union(int a, int b) {\n    parent[find(a)] = find(b);\n  }\n\n  int maxTime = 0;\n  int components = N;\n\n  for (Road road in roads) {\n    if (find(road.village1) != find(road.village2)) {\n      union(road.village1, road.village2);\n      maxTime = road.repairTime;\n      components--;\n    }\n    if (components == 1) break;\n  }\n\n  return components == 1 ? maxTime : -1;\n}", "test": "class Road {\n  int village1;\n  int village2;\n  int repairTime;\n\n  Road(this.village1, this.village2, this.repairTime);\n\n  @override\n  String toString() => 'Road(village1: $village1, village2: $village2, repairTime: $repairTime)';\n}\n\nvoid testFindEarliestTime() {\n  assert(findEarliestTime(4, 4, [\n    Road(1, 2, 6),\n    Road(1, 3, 4),\n    Road(1, 4, 5),\n    Road(4, 2, 3)\n  ]) == 5);\n\n  assert(findEarliestTime(3, 3, [\n    Road(1, 2, 2),\n    Road(2, 3, 5),\n    Road(1, 3, 1)\n  ]) == 2);\n\n  assert(findEarliestTime(5, 3, [\n    Road(1, 2, 3),\n    Road(2, 3, 4),\n    Road(4, 5, 5)\n  ]) == -1);\n}\n\nvoid main() {\n  testFindEarliestTime();\n}", "entry_point": "findEarliestTime", "signature": "int findEarliestTime(int N, int M, List<Road> roads)", "docstring": "# Highway Repair\n\n## Background\n\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\n\n## Problem Description\n\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\nFor all data, it is guaranteed that $1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Highway Repair\n\n## Background\n\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\n\n## Problem Description\n\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\nFor all data, it is guaranteed that $1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.\n\n* Incomplete Code:\nint findEarliestTime(int N, int M, List<Road> roads)\n{\n  roads.sort((a, b) => a.repairTime.compareTo(b.repairTime));\n  List<int> parent = List.generate(N + 1, (index) => index);\n\n[MASK]\n    return v == parent[v] ? v : parent[v] = find(parent[v]);\n  }\n\n  void union(int a, int b) {\n    parent[find(a)] = find(b);\n  }\n\n  int maxTime = 0;\n  int components = N;\n\n  for (Road road in roads) {\n    if (find(road.village1) != find(road.village2)) {\n      union(road.village1, road.village2);\n      maxTime = road.repairTime;\n      components--;\n    }\n    if (components == 1) break;\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  roads.sort((a, b) => a.repairTime.compareTo(b.repairTime));\n  List<int> parent = List.generate(N + 1, (index) => index);\n\n[MASK]\n    return v == parent[v] ? v : parent[v] = find(parent[v]);\n  }\n\n  void union(int a, int b) {\n    parent[find(a)] = find(b);\n  }\n\n  int maxTime = 0;\n  int components = N;\n\n  for (Road road in roads) {\n    if (find(road.village1) != find(road.village2)) {\n      union(road.village1, road.village2);\n      maxTime = road.repairTime;\n      components--;\n    }\n    if (components == 1) break;\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/45-1-multi", "prompt": "int findEarliestTime(int N, int M, List<Road> roads)\n\n/**\n * # Highway Repair\n\n## Background\n\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\n\n## Problem Description\n\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\nFor all data, it is guaranteed that $1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.\n */", "canonical_solution": "{\n  roads.sort((a, b) => a.repairTime.compareTo(b.repairTime));\n  List<int> parent = List.generate(N + 1, (index) => index);\n\n  int find(int v) {\n    return v == parent[v] ? v : parent[v] = find(parent[v]);\n  }\n\n  void union(int a, int b) {\n    parent[find(a)] = find(b);\n  }\n\n  int maxTime = 0;\n  int components = N;\n\n  for (Road road in roads) {\n    if (find(road.village1) != find(road.village2)) {\n      union(road.village1, road.village2);\n      maxTime = road.repairTime;\n      components--;\n    }\n    if (components == 1) break;\n  }\n\n  return components == 1 ? maxTime : -1;\n}", "test": "class Road {\n  int village1;\n  int village2;\n  int repairTime;\n\n  Road(this.village1, this.village2, this.repairTime);\n\n  @override\n  String toString() => 'Road(village1: $village1, village2: $village2, repairTime: $repairTime)';\n}\n\nvoid testFindEarliestTime() {\n  assert(findEarliestTime(4, 4, [\n    Road(1, 2, 6),\n    Road(1, 3, 4),\n    Road(1, 4, 5),\n    Road(4, 2, 3)\n  ]) == 5);\n\n  assert(findEarliestTime(3, 3, [\n    Road(1, 2, 2),\n    Road(2, 3, 5),\n    Road(1, 3, 1)\n  ]) == 2);\n\n  assert(findEarliestTime(5, 3, [\n    Road(1, 2, 3),\n    Road(2, 3, 4),\n    Road(4, 5, 5)\n  ]) == -1);\n}\n\nvoid main() {\n  testFindEarliestTime();\n}", "entry_point": "findEarliestTime", "signature": "int findEarliestTime(int N, int M, List<Road> roads)", "docstring": "# Highway Repair\n\n## Background\n\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\n\n## Problem Description\n\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\nFor all data, it is guaranteed that $1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Highway Repair\n\n## Background\n\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\n\n## Problem Description\n\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3\n```\n\n### Sample Output #1\n\n```\n5\n```\n\n## Notes\n\nFor all data, it is guaranteed that $1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.\n\n* Incomplete Code:\nint findEarliestTime(int N, int M, List<Road> roads)\n{\n[MASK]\n  List<int> parent = List.generate(N + 1, (index) => index);\n\n  int find(int v) {\n    return v == parent[v] ? v : parent[v] = find(parent[v]);\n  }\n\n  void union(int a, int b) {\n    parent[find(a)] = find(b);\n  }\n\n[MASK]\n[MASK]\n\n  for (Road road in roads) {\n    if (find(road.village1) != find(road.village2)) {\n      union(road.village1, road.village2);\n[MASK]\n      components--;\n    }\n[MASK]\n  }\n\n  return components == 1 ? maxTime : -1;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  List<int> parent = List.generate(N + 1, (index) => index);\n\n  int find(int v) {\n    return v == parent[v] ? v : parent[v] = find(parent[v]);\n  }\n\n  void union(int a, int b) {\n    parent[find(a)] = find(b);\n  }\n\n[MASK]\n[MASK]\n\n  for (Road road in roads) {\n    if (find(road.village1) != find(road.village2)) {\n      union(road.village1, road.village2);\n[MASK]\n      components--;\n    }\n[MASK]\n  }\n\n  return components == 1 ? maxTime : -1;\n}"}
{"task_id": "Dart/46-0-multi", "prompt": "import 'dart:math';\n\nint calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)\n\n/**\n * # Miscellaneous Tasks\n\n## Problem Description\n\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. For instance, it is necessary to gather the cows, herd them into the barn, clean their udders, and perform various other duties. It is essential to finish all miscellaneous tasks as early as possible to allocate more time for milking and thus produce a greater quantity of milk.\n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks. For example, cleaning the cow's udders can only commence after the cows have been herded into the barn, and milking cannot occur before the udders have been cleaned. Such tasks are referred to as preparatory work for the respective task at hand. There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\nLine 1: A single integer $n\\ (3 \\le n \\le 10{,}000)$, indicating the number of miscellaneous tasks that must be completed.\n\nLines $2$ to $n+1$: Each line contains a series of integers separated by spaces, representing:\n\n- Task number (guaranteed to be sequentially increasing from $1$ to $n$ in the input file);\n- Time required to complete the task $len\\ (1 \\le len \\le 100)$;\n- A series of prerequisite tasks that must be completed beforehand, not exceeding $100$ in total, ending with the digit $0$. Some tasks do not require any preparatory work and are simply described by a lone $0$.\n\nThe entire input file is guaranteed to be void of any extraneous spaces.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n```\n\n### Sample Output #1\n\n```\n23\n```\n */", "canonical_solution": "{\n  int n = tasks.length;\n  List<int> maxPreTaskTime = List.filled(n, 0);\n\n  for (int i = 0; i < n; i++) {\n    for (int preTask in tasks[i]) {\n      maxPreTaskTime[i] = max(maxPreTaskTime[i], maxPreTaskTime[preTask] + timeToComplete[preTask]);\n    }\n  }\n\n  int totalTime = 0;\n  for (int i = 0; i < n; i++) {\n    totalTime = max(totalTime, maxPreTaskTime[i] + timeToComplete[i]);\n  }\n\n  return totalTime;\n}", "test": "void testCalculateMinimumTime() {\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [1],\n    [0],\n    [1, 3],\n    [1, 3],\n    [2, 4, 5]\n  ],\n  [5, 2, 3, 6, 1, 8, 4]) == 23);\n\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [1],\n    [1, 2]\n  ],\n  [4, 3, 2, 5]) == 14);\n\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [0],\n    [0],\n    [1, 2, 3]\n  ],\n  [1, 2, 3, 4, 5]) == 10);\n}\n\nvoid main() {\n  testCalculateMinimumTime();\n}", "entry_point": "calculateMinimumTime", "signature": "int calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)", "docstring": "# Miscellaneous Tasks\n\n## Problem Description\n\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. For instance, it is necessary to gather the cows, herd them into the barn, clean their udders, and perform various other duties. It is essential to finish all miscellaneous tasks as early as possible to allocate more time for milking and thus produce a greater quantity of milk.\n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks. For example, cleaning the cow's udders can only commence after the cows have been herded into the barn, and milking cannot occur before the udders have been cleaned. Such tasks are referred to as preparatory work for the respective task at hand. There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\nLine 1: A single integer $n\\ (3 \\le n \\le 10{,}000)$, indicating the number of miscellaneous tasks that must be completed.\n\nLines $2$ to $n+1$: Each line contains a series of integers separated by spaces, representing:\n\n- Task number (guaranteed to be sequentially increasing from $1$ to $n$ in the input file);\n- Time required to complete the task $len\\ (1 \\le len \\le 100)$;\n- A series of prerequisite tasks that must be completed beforehand, not exceeding $100$ in total, ending with the digit $0$. Some tasks do not require any preparatory work and are simply described by a lone $0$.\n\nThe entire input file is guaranteed to be void of any extraneous spaces.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n```\n\n### Sample Output #1\n\n```\n23\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Miscellaneous Tasks\n\n## Problem Description\n\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. For instance, it is necessary to gather the cows, herd them into the barn, clean their udders, and perform various other duties. It is essential to finish all miscellaneous tasks as early as possible to allocate more time for milking and thus produce a greater quantity of milk.\n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks. For example, cleaning the cow's udders can only commence after the cows have been herded into the barn, and milking cannot occur before the udders have been cleaned. Such tasks are referred to as preparatory work for the respective task at hand. There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\nLine 1: A single integer $n\\ (3 \\le n \\le 10{,}000)$, indicating the number of miscellaneous tasks that must be completed.\n\nLines $2$ to $n+1$: Each line contains a series of integers separated by spaces, representing:\n\n- Task number (guaranteed to be sequentially increasing from $1$ to $n$ in the input file);\n- Time required to complete the task $len\\ (1 \\le len \\le 100)$;\n- A series of prerequisite tasks that must be completed beforehand, not exceeding $100$ in total, ending with the digit $0$. Some tasks do not require any preparatory work and are simply described by a lone $0$.\n\nThe entire input file is guaranteed to be void of any extraneous spaces.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n```\n\n### Sample Output #1\n\n```\n23\n```\n\n* Incomplete Code:\nint calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)\n{\n[MASK]\n[MASK]\n\n  for (int i = 0; i < n; i++) {\n    for (int preTask in tasks[i]) {\n[MASK]\n    }\n  }\n\n  int totalTime = 0;\n[MASK]\n    totalTime = max(totalTime, maxPreTaskTime[i] + timeToComplete[i]);\n  }\n\n  return totalTime;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n[MASK]\n\n  for (int i = 0; i < n; i++) {\n    for (int preTask in tasks[i]) {\n[MASK]\n    }\n  }\n\n  int totalTime = 0;\n[MASK]\n    totalTime = max(totalTime, maxPreTaskTime[i] + timeToComplete[i]);\n  }\n\n  return totalTime;\n}"}
{"task_id": "Dart/46-1-multi", "prompt": "import 'dart:math';\n\nint calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)\n\n/**\n * # Miscellaneous Tasks\n\n## Problem Description\n\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. For instance, it is necessary to gather the cows, herd them into the barn, clean their udders, and perform various other duties. It is essential to finish all miscellaneous tasks as early as possible to allocate more time for milking and thus produce a greater quantity of milk.\n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks. For example, cleaning the cow's udders can only commence after the cows have been herded into the barn, and milking cannot occur before the udders have been cleaned. Such tasks are referred to as preparatory work for the respective task at hand. There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\nLine 1: A single integer $n\\ (3 \\le n \\le 10{,}000)$, indicating the number of miscellaneous tasks that must be completed.\n\nLines $2$ to $n+1$: Each line contains a series of integers separated by spaces, representing:\n\n- Task number (guaranteed to be sequentially increasing from $1$ to $n$ in the input file);\n- Time required to complete the task $len\\ (1 \\le len \\le 100)$;\n- A series of prerequisite tasks that must be completed beforehand, not exceeding $100$ in total, ending with the digit $0$. Some tasks do not require any preparatory work and are simply described by a lone $0$.\n\nThe entire input file is guaranteed to be void of any extraneous spaces.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n```\n\n### Sample Output #1\n\n```\n23\n```\n */", "canonical_solution": "{\n  int n = tasks.length;\n  List<int> maxPreTaskTime = List.filled(n, 0);\n\n  for (int i = 0; i < n; i++) {\n    for (int preTask in tasks[i]) {\n      maxPreTaskTime[i] = max(maxPreTaskTime[i], maxPreTaskTime[preTask] + timeToComplete[preTask]);\n    }\n  }\n\n  int totalTime = 0;\n  for (int i = 0; i < n; i++) {\n    totalTime = max(totalTime, maxPreTaskTime[i] + timeToComplete[i]);\n  }\n\n  return totalTime;\n}", "test": "void testCalculateMinimumTime() {\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [1],\n    [0],\n    [1, 3],\n    [1, 3],\n    [2, 4, 5]\n  ],\n  [5, 2, 3, 6, 1, 8, 4]) == 23);\n\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [1],\n    [1, 2]\n  ],\n  [4, 3, 2, 5]) == 14);\n\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [0],\n    [0],\n    [1, 2, 3]\n  ],\n  [1, 2, 3, 4, 5]) == 10);\n}\n\nvoid main() {\n  testCalculateMinimumTime();\n}", "entry_point": "calculateMinimumTime", "signature": "int calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)", "docstring": "# Miscellaneous Tasks\n\n## Problem Description\n\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. For instance, it is necessary to gather the cows, herd them into the barn, clean their udders, and perform various other duties. It is essential to finish all miscellaneous tasks as early as possible to allocate more time for milking and thus produce a greater quantity of milk.\n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks. For example, cleaning the cow's udders can only commence after the cows have been herded into the barn, and milking cannot occur before the udders have been cleaned. Such tasks are referred to as preparatory work for the respective task at hand. There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\nLine 1: A single integer $n\\ (3 \\le n \\le 10{,}000)$, indicating the number of miscellaneous tasks that must be completed.\n\nLines $2$ to $n+1$: Each line contains a series of integers separated by spaces, representing:\n\n- Task number (guaranteed to be sequentially increasing from $1$ to $n$ in the input file);\n- Time required to complete the task $len\\ (1 \\le len \\le 100)$;\n- A series of prerequisite tasks that must be completed beforehand, not exceeding $100$ in total, ending with the digit $0$. Some tasks do not require any preparatory work and are simply described by a lone $0$.\n\nThe entire input file is guaranteed to be void of any extraneous spaces.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n```\n\n### Sample Output #1\n\n```\n23\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Miscellaneous Tasks\n\n## Problem Description\n\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. For instance, it is necessary to gather the cows, herd them into the barn, clean their udders, and perform various other duties. It is essential to finish all miscellaneous tasks as early as possible to allocate more time for milking and thus produce a greater quantity of milk.\n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks. For example, cleaning the cow's udders can only commence after the cows have been herded into the barn, and milking cannot occur before the udders have been cleaned. Such tasks are referred to as preparatory work for the respective task at hand. There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\nLine 1: A single integer $n\\ (3 \\le n \\le 10{,}000)$, indicating the number of miscellaneous tasks that must be completed.\n\nLines $2$ to $n+1$: Each line contains a series of integers separated by spaces, representing:\n\n- Task number (guaranteed to be sequentially increasing from $1$ to $n$ in the input file);\n- Time required to complete the task $len\\ (1 \\le len \\le 100)$;\n- A series of prerequisite tasks that must be completed beforehand, not exceeding $100$ in total, ending with the digit $0$. Some tasks do not require any preparatory work and are simply described by a lone $0$.\n\nThe entire input file is guaranteed to be void of any extraneous spaces.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n```\n\n### Sample Output #1\n\n```\n23\n```\n\n* Incomplete Code:\nint calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)\n{\n  int n = tasks.length;\n[MASK]\n\n  for (int i = 0; i < n; i++) {\n    for (int preTask in tasks[i]) {\n      maxPreTaskTime[i] = max(maxPreTaskTime[i], maxPreTaskTime[preTask] + timeToComplete[preTask]);\n    }\n  }\n\n  int totalTime = 0;\n  for (int i = 0; i < n; i++) {\n    totalTime = max(totalTime, maxPreTaskTime[i] + timeToComplete[i]);\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int n = tasks.length;\n[MASK]\n\n  for (int i = 0; i < n; i++) {\n    for (int preTask in tasks[i]) {\n      maxPreTaskTime[i] = max(maxPreTaskTime[i], maxPreTaskTime[preTask] + timeToComplete[preTask]);\n    }\n  }\n\n  int totalTime = 0;\n  for (int i = 0; i < n; i++) {\n    totalTime = max(totalTime, maxPreTaskTime[i] + timeToComplete[i]);\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/47-0-multi", "prompt": "import 'dart:math';\n\nint longestBalancedSubsequence(List<int> students)\n\n/**\n * # \"Perfect Pairing\" Project\n\n## Problem Description\n\nRecently, a young student in the first year of junior high, referred to here as `XXX`, has dedicated himself to investigating the matter of pairing classmates (not to be overthought, simply for dance partners). Through various deductions and experiments, he has accumulated a wealth of practical experience. For instance, his observations suggest that individuals of similar height tend to get along better.\n\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nThe first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people at the school.\n\nThe second line contains $n$ numbers separated by spaces, which can only be $0$ or $1$. Here, $0$ indicates a female student, and $1$ indicates a male student.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n9\n0 1 0 0 0 1 1 0 0\n```\n\n### Sample Output #1\n\n```\n6\n```\n */", "canonical_solution": "{\n  int n = students.length;\n  Map<int, int> firstOccurrence = {0: -1};\n  int maxLength = 0;\n  int balance = 0;\n\n  for (int i = 0; i < n; i++) {\n    balance += students[i] == 0 ? -1 : 1;\n    if (firstOccurrence.containsKey(balance)) {\n      maxLength = max(maxLength, i - firstOccurrence[balance]!);\n    } else {\n      firstOccurrence[balance] = i;\n    }\n  }\n\n  return maxLength;\n}", "test": "void testLongestBalancedSubsequence() {\n  assert(longestBalancedSubsequence([0, 1, 0, 0, 0, 1, 1, 0, 0]) == 6);\n  assert(longestBalancedSubsequence([1, 1, 0, 0, 0, 1, 0, 1, 1]) == 8);\n  assert(longestBalancedSubsequence([0, 1, 1, 0, 1, 1, 0, 0]) == 8);\n}\n\nvoid main() {\n  testLongestBalancedSubsequence();\n}", "entry_point": "longestBalancedSubsequence", "signature": "int longestBalancedSubsequence(List<int> students)", "docstring": "# \"Perfect Pairing\" Project\n\n## Problem Description\n\nRecently, a young student in the first year of junior high, referred to here as `XXX`, has dedicated himself to investigating the matter of pairing classmates (not to be overthought, simply for dance partners). Through various deductions and experiments, he has accumulated a wealth of practical experience. For instance, his observations suggest that individuals of similar height tend to get along better.\n\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nThe first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people at the school.\n\nThe second line contains $n$ numbers separated by spaces, which can only be $0$ or $1$. Here, $0$ indicates a female student, and $1$ indicates a male student.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n9\n0 1 0 0 0 1 1 0 0\n```\n\n### Sample Output #1\n\n```\n6\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# \"Perfect Pairing\" Project\n\n## Problem Description\n\nRecently, a young student in the first year of junior high, referred to here as `XXX`, has dedicated himself to investigating the matter of pairing classmates (not to be overthought, simply for dance partners). Through various deductions and experiments, he has accumulated a wealth of practical experience. For instance, his observations suggest that individuals of similar height tend to get along better.\n\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nThe first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people at the school.\n\nThe second line contains $n$ numbers separated by spaces, which can only be $0$ or $1$. Here, $0$ indicates a female student, and $1$ indicates a male student.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n9\n0 1 0 0 0 1 1 0 0\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n* Incomplete Code:\nint longestBalancedSubsequence(List<int> students)\n{\n  int n = students.length;\n[MASK]\n  int maxLength = 0;\n  int balance = 0;\n\n[MASK]\n    balance += students[i] == 0 ? -1 : 1;\n    if (firstOccurrence.containsKey(balance)) {\n      maxLength = max(maxLength, i - firstOccurrence[balance]!);\n[MASK]\n[MASK]\n    }\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int n = students.length;\n[MASK]\n  int maxLength = 0;\n  int balance = 0;\n\n[MASK]\n    balance += students[i] == 0 ? -1 : 1;\n    if (firstOccurrence.containsKey(balance)) {\n      maxLength = max(maxLength, i - firstOccurrence[balance]!);\n[MASK]\n[MASK]\n    }\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/47-1-multi", "prompt": "import 'dart:math';\n\nint longestBalancedSubsequence(List<int> students)\n\n/**\n * # \"Perfect Pairing\" Project\n\n## Problem Description\n\nRecently, a young student in the first year of junior high, referred to here as `XXX`, has dedicated himself to investigating the matter of pairing classmates (not to be overthought, simply for dance partners). Through various deductions and experiments, he has accumulated a wealth of practical experience. For instance, his observations suggest that individuals of similar height tend to get along better.\n\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nThe first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people at the school.\n\nThe second line contains $n$ numbers separated by spaces, which can only be $0$ or $1$. Here, $0$ indicates a female student, and $1$ indicates a male student.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n9\n0 1 0 0 0 1 1 0 0\n```\n\n### Sample Output #1\n\n```\n6\n```\n */", "canonical_solution": "{\n  int n = students.length;\n  Map<int, int> firstOccurrence = {0: -1};\n  int maxLength = 0;\n  int balance = 0;\n\n  for (int i = 0; i < n; i++) {\n    balance += students[i] == 0 ? -1 : 1;\n    if (firstOccurrence.containsKey(balance)) {\n      maxLength = max(maxLength, i - firstOccurrence[balance]!);\n    } else {\n      firstOccurrence[balance] = i;\n    }\n  }\n\n  return maxLength;\n}", "test": "void testLongestBalancedSubsequence() {\n  assert(longestBalancedSubsequence([0, 1, 0, 0, 0, 1, 1, 0, 0]) == 6);\n  assert(longestBalancedSubsequence([1, 1, 0, 0, 0, 1, 0, 1, 1]) == 8);\n  assert(longestBalancedSubsequence([0, 1, 1, 0, 1, 1, 0, 0]) == 8);\n}\n\nvoid main() {\n  testLongestBalancedSubsequence();\n}", "entry_point": "longestBalancedSubsequence", "signature": "int longestBalancedSubsequence(List<int> students)", "docstring": "# \"Perfect Pairing\" Project\n\n## Problem Description\n\nRecently, a young student in the first year of junior high, referred to here as `XXX`, has dedicated himself to investigating the matter of pairing classmates (not to be overthought, simply for dance partners). Through various deductions and experiments, he has accumulated a wealth of practical experience. For instance, his observations suggest that individuals of similar height tend to get along better.\n\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nThe first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people at the school.\n\nThe second line contains $n$ numbers separated by spaces, which can only be $0$ or $1$. Here, $0$ indicates a female student, and $1$ indicates a male student.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n9\n0 1 0 0 0 1 1 0 0\n```\n\n### Sample Output #1\n\n```\n6\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# \"Perfect Pairing\" Project\n\n## Problem Description\n\nRecently, a young student in the first year of junior high, referred to here as `XXX`, has dedicated himself to investigating the matter of pairing classmates (not to be overthought, simply for dance partners). Through various deductions and experiments, he has accumulated a wealth of practical experience. For instance, his observations suggest that individuals of similar height tend to get along better.\n\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nThe first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people at the school.\n\nThe second line contains $n$ numbers separated by spaces, which can only be $0$ or $1$. Here, $0$ indicates a female student, and $1$ indicates a male student.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n9\n0 1 0 0 0 1 1 0 0\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n* Incomplete Code:\nint longestBalancedSubsequence(List<int> students)\n{\n  int n = students.length;\n  Map<int, int> firstOccurrence = {0: -1};\n  int maxLength = 0;\n  int balance = 0;\n\n[MASK]\n    balance += students[i] == 0 ? -1 : 1;\n[MASK]\n      maxLength = max(maxLength, i - firstOccurrence[balance]!);\n    } else {\n      firstOccurrence[balance] = i;\n    }\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  int n = students.length;\n  Map<int, int> firstOccurrence = {0: -1};\n  int maxLength = 0;\n  int balance = 0;\n\n[MASK]\n    balance += students[i] == 0 ? -1 : 1;\n[MASK]\n      maxLength = max(maxLength, i - firstOccurrence[balance]!);\n    } else {\n      firstOccurrence[balance] = i;\n    }\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/48-0-multi", "prompt": "import 'dart:math';\n\nint maxSubarraySum(List<int> a)\n\n/**\n * # Maximum Subarray Sum\n\n## Problem Description\n\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\n\nThe first line is an integer representing the length of the sequence $n$.\n\nThe second line contains $n$ integers, where the $i$-th integer represents the $i$-th element $a_i$ of the sequence.\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n2 -4 3 -1 2 -4 3\n```\n\n### Sample Output #1\n\n```\n4\n```\n\n## Hints\n\n#### Explanation for Sample 1\n\nSelect the subsegment $[3, 5]$ $\\{3, -1, 2\\}$, which sums up to $4$.\n\n#### Data Scale and Conventions\n\n- For $40\\%$ of the data, it is guaranteed that $n \\leq 2 \\times 10^3$.\n- For $100\\%$ of the data, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $-10^4 \\leq a_i \\leq 10^4$.\n */", "canonical_solution": "{\n  int maxSum = a[0], currentSum = a[0];\n  for (int i = 1; i < a.length; i++) {\n    currentSum = currentSum > 0 ? currentSum + a[i] : a[i];\n    maxSum = max(maxSum, currentSum);\n  }\n  return maxSum;\n}", "test": "void testMaxSubarraySum() {\n  assert(maxSubarraySum([2, -4, 3, -1, 2, -4, 3]) == 4);\n  assert(maxSubarraySum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7);\n  assert(maxSubarraySum([-1, -2, -3, -4]) == -1);\n}\n\nvoid main() {\n  testMaxSubarraySum();\n}", "entry_point": "maxSubarraySum", "signature": "int maxSubarraySum(List<int> a)", "docstring": "# Maximum Subarray Sum\n\n## Problem Description\n\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\n\nThe first line is an integer representing the length of the sequence $n$.\n\nThe second line contains $n$ integers, where the $i$-th integer represents the $i$-th element $a_i$ of the sequence.\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n2 -4 3 -1 2 -4 3\n```\n\n### Sample Output #1\n\n```\n4\n```\n\n## Hints\n\n#### Explanation for Sample 1\n\nSelect the subsegment $[3, 5]$ $\\{3, -1, 2\\}$, which sums up to $4$.\n\n#### Data Scale and Conventions\n\n- For $40\\%$ of the data, it is guaranteed that $n \\leq 2 \\times 10^3$.\n- For $100\\%$ of the data, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $-10^4 \\leq a_i \\leq 10^4$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Maximum Subarray Sum\n\n## Problem Description\n\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\n\nThe first line is an integer representing the length of the sequence $n$.\n\nThe second line contains $n$ integers, where the $i$-th integer represents the $i$-th element $a_i$ of the sequence.\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n2 -4 3 -1 2 -4 3\n```\n\n### Sample Output #1\n\n```\n4\n```\n\n## Hints\n\n#### Explanation for Sample 1\n\nSelect the subsegment $[3, 5]$ $\\{3, -1, 2\\}$, which sums up to $4$.\n\n#### Data Scale and Conventions\n\n- For $40\\%$ of the data, it is guaranteed that $n \\leq 2 \\times 10^3$.\n- For $100\\%$ of the data, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $-10^4 \\leq a_i \\leq 10^4$.\n\n* Incomplete Code:\nint maxSubarraySum(List<int> a)\n{\n[MASK]\n  for (int i = 1; i < a.length; i++) {\n[MASK]\n[MASK]\n  }\n  return maxSum;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  for (int i = 1; i < a.length; i++) {\n[MASK]\n[MASK]\n  }\n  return maxSum;\n}"}
{"task_id": "Dart/48-1-multi", "prompt": "import 'dart:math';\n\nint maxSubarraySum(List<int> a)\n\n/**\n * # Maximum Subarray Sum\n\n## Problem Description\n\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\n\nThe first line is an integer representing the length of the sequence $n$.\n\nThe second line contains $n$ integers, where the $i$-th integer represents the $i$-th element $a_i$ of the sequence.\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n2 -4 3 -1 2 -4 3\n```\n\n### Sample Output #1\n\n```\n4\n```\n\n## Hints\n\n#### Explanation for Sample 1\n\nSelect the subsegment $[3, 5]$ $\\{3, -1, 2\\}$, which sums up to $4$.\n\n#### Data Scale and Conventions\n\n- For $40\\%$ of the data, it is guaranteed that $n \\leq 2 \\times 10^3$.\n- For $100\\%$ of the data, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $-10^4 \\leq a_i \\leq 10^4$.\n */", "canonical_solution": "{\n  int maxSum = a[0], currentSum = a[0];\n  for (int i = 1; i < a.length; i++) {\n    currentSum = currentSum > 0 ? currentSum + a[i] : a[i];\n    maxSum = max(maxSum, currentSum);\n  }\n  return maxSum;\n}", "test": "void testMaxSubarraySum() {\n  assert(maxSubarraySum([2, -4, 3, -1, 2, -4, 3]) == 4);\n  assert(maxSubarraySum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7);\n  assert(maxSubarraySum([-1, -2, -3, -4]) == -1);\n}\n\nvoid main() {\n  testMaxSubarraySum();\n}", "entry_point": "maxSubarraySum", "signature": "int maxSubarraySum(List<int> a)", "docstring": "# Maximum Subarray Sum\n\n## Problem Description\n\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\n\nThe first line is an integer representing the length of the sequence $n$.\n\nThe second line contains $n$ integers, where the $i$-th integer represents the $i$-th element $a_i$ of the sequence.\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n2 -4 3 -1 2 -4 3\n```\n\n### Sample Output #1\n\n```\n4\n```\n\n## Hints\n\n#### Explanation for Sample 1\n\nSelect the subsegment $[3, 5]$ $\\{3, -1, 2\\}$, which sums up to $4$.\n\n#### Data Scale and Conventions\n\n- For $40\\%$ of the data, it is guaranteed that $n \\leq 2 \\times 10^3$.\n- For $100\\%$ of the data, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $-10^4 \\leq a_i \\leq 10^4$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Maximum Subarray Sum\n\n## Problem Description\n\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\n\nThe first line is an integer representing the length of the sequence $n$.\n\nThe second line contains $n$ integers, where the $i$-th integer represents the $i$-th element $a_i$ of the sequence.\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n7\n2 -4 3 -1 2 -4 3\n```\n\n### Sample Output #1\n\n```\n4\n```\n\n## Hints\n\n#### Explanation for Sample 1\n\nSelect the subsegment $[3, 5]$ $\\{3, -1, 2\\}$, which sums up to $4$.\n\n#### Data Scale and Conventions\n\n- For $40\\%$ of the data, it is guaranteed that $n \\leq 2 \\times 10^3$.\n- For $100\\%$ of the data, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $-10^4 \\leq a_i \\leq 10^4$.\n\n* Incomplete Code:\nint maxSubarraySum(List<int> a)\n{\n[MASK]\n  for (int i = 1; i < a.length; i++) {\n    currentSum = currentSum > 0 ? currentSum + a[i] : a[i];\n    maxSum = max(maxSum, currentSum);\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  for (int i = 1; i < a.length; i++) {\n    currentSum = currentSum > 0 ? currentSum + a[i] : a[i];\n    maxSum = max(maxSum, currentSum);\n  }\n[MASK]\n}"}
{"task_id": "Dart/49-0-multi", "prompt": "int minimumSwaps(List<int> train)\n/**\n * # Railway Carriage Reorganization\n\n## Problem Description\n\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\nThere are two lines in total.\n\nThe first line contains the total number of carriages $N ( \\le 10000)$.\n\nThe second line consists of $N$ distinct numbers representing the initial order of the carriages.  \n(**Note**: In reality, the data may not all be entered on the same line and may be input in multiple lines.)\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4\n4 3 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n */", "canonical_solution": "{\n  int count = 0;\n  for (int i = 0; i < train.length; i++) {\n    while (train[i] != i + 1) {\n      int temp = train[i];\n      train[i] = train[temp - 1];\n      train[temp - 1] = temp;\n      count++;\n    }\n  }\n  return count;\n}", "test": "void testMinimumSwaps() {\n  assert(minimumSwaps([4, 3, 2, 1]) == 2);\n  assert(minimumSwaps([1, 3, 5, 2, 4, 6]) == 3);\n  assert(minimumSwaps([1, 5, 4, 3, 2]) == 2);\n}\n\nvoid main() {\n  testMinimumSwaps();\n}", "entry_point": "minimumSwaps", "signature": "int minimumSwaps(List<int> train)", "docstring": "# Railway Carriage Reorganization\n\n## Problem Description\n\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\nThere are two lines in total.\n\nThe first line contains the total number of carriages $N ( \\le 10000)$.\n\nThe second line consists of $N$ distinct numbers representing the initial order of the carriages.\n(**Note**: In reality, the data may not all be entered on the same line and may be input in multiple lines.)\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4\n4 3 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Railway Carriage Reorganization\n\n## Problem Description\n\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\nThere are two lines in total.\n\nThe first line contains the total number of carriages $N ( \\le 10000)$.\n\nThe second line consists of $N$ distinct numbers representing the initial order of the carriages.\n(**Note**: In reality, the data may not all be entered on the same line and may be input in multiple lines.)\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4\n4 3 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n* Incomplete Code:\nint minimumSwaps(List<int> train)\n{\n[MASK]\n[MASK]\n[MASK]\n      int temp = train[i];\n      train[i] = train[temp - 1];\n      train[temp - 1] = temp;\n[MASK]\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n[MASK]\n[MASK]\n      int temp = train[i];\n      train[i] = train[temp - 1];\n      train[temp - 1] = temp;\n[MASK]\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/49-1-multi", "prompt": "int minimumSwaps(List<int> train)\n/**\n * # Railway Carriage Reorganization\n\n## Problem Description\n\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\nThere are two lines in total.\n\nThe first line contains the total number of carriages $N ( \\le 10000)$.\n\nThe second line consists of $N$ distinct numbers representing the initial order of the carriages.  \n(**Note**: In reality, the data may not all be entered on the same line and may be input in multiple lines.)\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4\n4 3 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n */", "canonical_solution": "{\n  int count = 0;\n  for (int i = 0; i < train.length; i++) {\n    while (train[i] != i + 1) {\n      int temp = train[i];\n      train[i] = train[temp - 1];\n      train[temp - 1] = temp;\n      count++;\n    }\n  }\n  return count;\n}", "test": "void testMinimumSwaps() {\n  assert(minimumSwaps([4, 3, 2, 1]) == 2);\n  assert(minimumSwaps([1, 3, 5, 2, 4, 6]) == 3);\n  assert(minimumSwaps([1, 5, 4, 3, 2]) == 2);\n}\n\nvoid main() {\n  testMinimumSwaps();\n}", "entry_point": "minimumSwaps", "signature": "int minimumSwaps(List<int> train)", "docstring": "# Railway Carriage Reorganization\n\n## Problem Description\n\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\nThere are two lines in total.\n\nThe first line contains the total number of carriages $N ( \\le 10000)$.\n\nThe second line consists of $N$ distinct numbers representing the initial order of the carriages.\n(**Note**: In reality, the data may not all be entered on the same line and may be input in multiple lines.)\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4\n4 3 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Railway Carriage Reorganization\n\n## Problem Description\n\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\nThere are two lines in total.\n\nThe first line contains the total number of carriages $N ( \\le 10000)$.\n\nThe second line consists of $N$ distinct numbers representing the initial order of the carriages.\n(**Note**: In reality, the data may not all be entered on the same line and may be input in multiple lines.)\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\n\n### Sample Input #1\n\n```\n4\n4 3 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n* Incomplete Code:\nint minimumSwaps(List<int> train)\n{\n[MASK]\n  for (int i = 0; i < train.length; i++) {\n    while (train[i] != i + 1) {\n      int temp = train[i];\n[MASK]\n[MASK]\n      count++;\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  for (int i = 0; i < train.length; i++) {\n    while (train[i] != i + 1) {\n      int temp = train[i];\n[MASK]\n[MASK]\n      count++;\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/50-0-multi", "prompt": "int countExcellentSplits(String s)\n\n/**\n * #  Excellent Decomposition\n\n## Problem Description\n\nA decomposition of a string into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any **non-empty** strings, is deemed excellent.  \nFor instance, with the string $ \\texttt{aabaabaa} $, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we establish an excellent decomposition of the string into $\\text{AABB}$.\n\nA string may not possess any excellent decompositions or could have multiple such decompositions.  \nFor example, by setting $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the aforementioned string can also be represented by $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ lacks any excellent decomposition.\n\nCurrently, a string of length $n$, denoted as $S$, is provided, and the task is to determine the total number of excellent decompositions among all possible decompositions of all its substrings. Here, a substring refers to a consecutive segment within the string.\n\nThe following considerations should be noted:\n\n1. Identical substrings occurring at different positions are considered distinct, and their excellent decompositions are each counted towards the answer.\n2. Within a decomposition, $\\text{A}=\\text{B}$ is permissible. For instance, $\\texttt{cccc}$ admits a decomposition with $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.\n\n## Input Format\n\nEach input file contains multiple sets of data.\n\nThe first line of the input file contains a single integer $T$, indicating the number of data sets.\n\nThe following $T$ lines each contain a string $S$ composed solely of lowercase English letters, with the significance as described in the problem.\n\n## Output Format\n\nOutput $T$ lines, each containing an integer, indicating the total number of excellent decompositions among all decompositions of all substrings of string $S$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n```\n\n### Sample Output #1\n\n```\n3\n5\n4\n7\n```\n\n## Hints\n\n### Sample Explanation\n\nWe denote $S[i, j]$ as the substring of string $S$ from the $i$-th to the $j$-th character (counting starts from $1$).\n\nIn the first dataset, there are three substrings with excellent decompositions:  \n$S[1,4]=\\texttt{aabb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$;  \n$S[3,6]=\\texttt{bbbb}$, with the excellent decomposition $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$;  \n$S[1,6]=\\texttt{aabbbb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$.  \nThe remaining substrings lack excellent decompositions, thus the answer for the first dataset is $3$.\n\nIn the second dataset, there are two types, totaling four substrings with excellent decompositions:  \nFor the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, their excellent decompositions are identical, set as $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, yet given the distinct positions of these substrings, they are counted thrice;  \nFor the substring $S[1,6]=\\texttt{cccccc}$, there are two excellent decompositions: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, both of which are different decompositions of the same substring and thus included in the answer.  \nHence, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent decompositions, where $S[1,8]$ is the example provided in the problem description, resulting in an answer of $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, $S[1,8]$ each have one excellent decomposition, and $S[3,14]$ has two, leading to an answer of $5+2=7$.\n\n### Data Range\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The constraints mentioned below apply to each individual set of input data within a test point, meaning that all $T$ sets of data under a test point meet the conditions specified.\n\nAssuming $n$ is the length of string $S$, the detailed data range for each test point is as follows:\n\n| Test Point No. | $n \\leq$  | Special Properties      |\n| -------------- | --------- | ----------------------- |\n| $1 \\sim 2$     | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$     | $2,000$   | All characters in $S$ are the same |\n| $5 \\sim 6$     | $10$      |                         |\n| $7 \\sim 8$     | $20$      |                         |\n| $9 \\sim 10$    | $30$      |                         |\n| $11 \\sim 12$   | $50$      |                         |\n| $13 \\sim 14$   | $100$     |                         |\n| $15$           | $200$     |                         |\n| $16$           | $300$     |                         |\n| $17$           | $500$     |                         |\n| $18$           | $1,000$   |                         |\n| $19$           | $2,000$   |                         |\n| $20$           | $30,000$  |                         |\n */", "canonical_solution": "{\n  int n = s.length;\n  List<int> prefix = List.filled(n + 1, 0);\n  for (int i = 0; i < n; ++i) {\n    prefix[i + 1] = prefix[i] + (s[i] == s[n ~/ 2] ? 1 : 0);\n  }\n\n  int ans = 0;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] == s[n ~/ 2] && s[i - 1] == s[n ~/ 2]) {\n      ans += prefix[i] * (prefix[n] - prefix[i + 1]);\n    }\n  }\n  return ans;\n}", "test": "void testCountExcellentSplits() {\n  assert(countExcellentSplits(\"aabbbb\") == 4);\n  assert(countExcellentSplits(\"cccccc\") == 20);\n  assert(countExcellentSplits(\"aabaabaabaa\") == 0);\n}\n\nvoid main() {\n  testCountExcellentSplits();\n}", "entry_point": "countExcellentSplits", "signature": "int countExcellentSplits(String s)", "docstring": "#  Excellent Decomposition\n\n## Problem Description\n\nA decomposition of a string into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any **non-empty** strings, is deemed excellent.\nFor instance, with the string $ \\texttt{aabaabaa} $, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we establish an excellent decomposition of the string into $\\text{AABB}$.\n\nA string may not possess any excellent decompositions or could have multiple such decompositions.\nFor example, by setting $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the aforementioned string can also be represented by $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ lacks any excellent decomposition.\n\nCurrently, a string of length $n$, denoted as $S$, is provided, and the task is to determine the total number of excellent decompositions among all possible decompositions of all its substrings. Here, a substring refers to a consecutive segment within the string.\n\nThe following considerations should be noted:\n\n1. Identical substrings occurring at different positions are considered distinct, and their excellent decompositions are each counted towards the answer.\n2. Within a decomposition, $\\text{A}=\\text{B}$ is permissible. For instance, $\\texttt{cccc}$ admits a decomposition with $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.\n\n## Input Format\n\nEach input file contains multiple sets of data.\n\nThe first line of the input file contains a single integer $T$, indicating the number of data sets.\n\nThe following $T$ lines each contain a string $S$ composed solely of lowercase English letters, with the significance as described in the problem.\n\n## Output Format\n\nOutput $T$ lines, each containing an integer, indicating the total number of excellent decompositions among all decompositions of all substrings of string $S$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n```\n\n### Sample Output #1\n\n```\n3\n5\n4\n7\n```\n\n## Hints\n\n### Sample Explanation\n\nWe denote $S[i, j]$ as the substring of string $S$ from the $i$-th to the $j$-th character (counting starts from $1$).\n\nIn the first dataset, there are three substrings with excellent decompositions:\n$S[1,4]=\\texttt{aabb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$;\n$S[3,6]=\\texttt{bbbb}$, with the excellent decomposition $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$;\n$S[1,6]=\\texttt{aabbbb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$.\nThe remaining substrings lack excellent decompositions, thus the answer for the first dataset is $3$.\n\nIn the second dataset, there are two types, totaling four substrings with excellent decompositions:\nFor the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, their excellent decompositions are identical, set as $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, yet given the distinct positions of these substrings, they are counted thrice;\nFor the substring $S[1,6]=\\texttt{cccccc}$, there are two excellent decompositions: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, both of which are different decompositions of the same substring and thus included in the answer.\nHence, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent decompositions, where $S[1,8]$ is the example provided in the problem description, resulting in an answer of $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, $S[1,8]$ each have one excellent decomposition, and $S[3,14]$ has two, leading to an answer of $5+2=7$.\n\n### Data Range\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The constraints mentioned below apply to each individual set of input data within a test point, meaning that all $T$ sets of data under a test point meet the conditions specified.\n\nAssuming $n$ is the length of string $S$, the detailed data range for each test point is as follows:\n\n| Test Point No. | $n \\leq$  | Special Properties      |\n| -------------- | --------- | ----------------------- |\n| $1 \\sim 2$     | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$     | $2,000$   | All characters in $S$ are the same |\n| $5 \\sim 6$     | $10$      |                         |\n| $7 \\sim 8$     | $20$      |                         |\n| $9 \\sim 10$    | $30$      |                         |\n| $11 \\sim 12$   | $50$      |                         |\n| $13 \\sim 14$   | $100$     |                         |\n| $15$           | $200$     |                         |\n| $16$           | $300$     |                         |\n| $17$           | $500$     |                         |\n| $18$           | $1,000$   |                         |\n| $19$           | $2,000$   |                         |\n| $20$           | $30,000$  |                         |", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Excellent Decomposition\n\n## Problem Description\n\nA decomposition of a string into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any **non-empty** strings, is deemed excellent.\nFor instance, with the string $ \\texttt{aabaabaa} $, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we establish an excellent decomposition of the string into $\\text{AABB}$.\n\nA string may not possess any excellent decompositions or could have multiple such decompositions.\nFor example, by setting $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the aforementioned string can also be represented by $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ lacks any excellent decomposition.\n\nCurrently, a string of length $n$, denoted as $S$, is provided, and the task is to determine the total number of excellent decompositions among all possible decompositions of all its substrings. Here, a substring refers to a consecutive segment within the string.\n\nThe following considerations should be noted:\n\n1. Identical substrings occurring at different positions are considered distinct, and their excellent decompositions are each counted towards the answer.\n2. Within a decomposition, $\\text{A}=\\text{B}$ is permissible. For instance, $\\texttt{cccc}$ admits a decomposition with $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.\n\n## Input Format\n\nEach input file contains multiple sets of data.\n\nThe first line of the input file contains a single integer $T$, indicating the number of data sets.\n\nThe following $T$ lines each contain a string $S$ composed solely of lowercase English letters, with the significance as described in the problem.\n\n## Output Format\n\nOutput $T$ lines, each containing an integer, indicating the total number of excellent decompositions among all decompositions of all substrings of string $S$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n```\n\n### Sample Output #1\n\n```\n3\n5\n4\n7\n```\n\n## Hints\n\n### Sample Explanation\n\nWe denote $S[i, j]$ as the substring of string $S$ from the $i$-th to the $j$-th character (counting starts from $1$).\n\nIn the first dataset, there are three substrings with excellent decompositions:\n$S[1,4]=\\texttt{aabb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$;\n$S[3,6]=\\texttt{bbbb}$, with the excellent decomposition $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$;\n$S[1,6]=\\texttt{aabbbb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$.\nThe remaining substrings lack excellent decompositions, thus the answer for the first dataset is $3$.\n\nIn the second dataset, there are two types, totaling four substrings with excellent decompositions:\nFor the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, their excellent decompositions are identical, set as $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, yet given the distinct positions of these substrings, they are counted thrice;\nFor the substring $S[1,6]=\\texttt{cccccc}$, there are two excellent decompositions: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, both of which are different decompositions of the same substring and thus included in the answer.\nHence, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent decompositions, where $S[1,8]$ is the example provided in the problem description, resulting in an answer of $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, $S[1,8]$ each have one excellent decomposition, and $S[3,14]$ has two, leading to an answer of $5+2=7$.\n\n### Data Range\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The constraints mentioned below apply to each individual set of input data within a test point, meaning that all $T$ sets of data under a test point meet the conditions specified.\n\nAssuming $n$ is the length of string $S$, the detailed data range for each test point is as follows:\n\n| Test Point No. | $n \\leq$  | Special Properties      |\n| -------------- | --------- | ----------------------- |\n| $1 \\sim 2$     | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$     | $2,000$   | All characters in $S$ are the same |\n| $5 \\sim 6$     | $10$      |                         |\n| $7 \\sim 8$     | $20$      |                         |\n| $9 \\sim 10$    | $30$      |                         |\n| $11 \\sim 12$   | $50$      |                         |\n| $13 \\sim 14$   | $100$     |                         |\n| $15$           | $200$     |                         |\n| $16$           | $300$     |                         |\n| $17$           | $500$     |                         |\n| $18$           | $1,000$   |                         |\n| $19$           | $2,000$   |                         |\n| $20$           | $30,000$  |                         |\n\n* Incomplete Code:\nint countExcellentSplits(String s)\n{\n[MASK]\n[MASK]\n  for (int i = 0; i < n; ++i) {\n    prefix[i + 1] = prefix[i] + (s[i] == s[n ~/ 2] ? 1 : 0);\n  }\n\n[MASK]\n  for (int i = 1; i < n; ++i) {\n[MASK]\n      ans += prefix[i] * (prefix[n] - prefix[i + 1]);\n    }\n  }\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n[MASK]\n  for (int i = 0; i < n; ++i) {\n    prefix[i + 1] = prefix[i] + (s[i] == s[n ~/ 2] ? 1 : 0);\n  }\n\n[MASK]\n  for (int i = 1; i < n; ++i) {\n[MASK]\n      ans += prefix[i] * (prefix[n] - prefix[i + 1]);\n    }\n  }\n[MASK]\n}"}
{"task_id": "Dart/50-1-multi", "prompt": "int countExcellentSplits(String s)\n\n/**\n * #  Excellent Decomposition\n\n## Problem Description\n\nA decomposition of a string into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any **non-empty** strings, is deemed excellent.  \nFor instance, with the string $ \\texttt{aabaabaa} $, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we establish an excellent decomposition of the string into $\\text{AABB}$.\n\nA string may not possess any excellent decompositions or could have multiple such decompositions.  \nFor example, by setting $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the aforementioned string can also be represented by $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ lacks any excellent decomposition.\n\nCurrently, a string of length $n$, denoted as $S$, is provided, and the task is to determine the total number of excellent decompositions among all possible decompositions of all its substrings. Here, a substring refers to a consecutive segment within the string.\n\nThe following considerations should be noted:\n\n1. Identical substrings occurring at different positions are considered distinct, and their excellent decompositions are each counted towards the answer.\n2. Within a decomposition, $\\text{A}=\\text{B}$ is permissible. For instance, $\\texttt{cccc}$ admits a decomposition with $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.\n\n## Input Format\n\nEach input file contains multiple sets of data.\n\nThe first line of the input file contains a single integer $T$, indicating the number of data sets.\n\nThe following $T$ lines each contain a string $S$ composed solely of lowercase English letters, with the significance as described in the problem.\n\n## Output Format\n\nOutput $T$ lines, each containing an integer, indicating the total number of excellent decompositions among all decompositions of all substrings of string $S$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n```\n\n### Sample Output #1\n\n```\n3\n5\n4\n7\n```\n\n## Hints\n\n### Sample Explanation\n\nWe denote $S[i, j]$ as the substring of string $S$ from the $i$-th to the $j$-th character (counting starts from $1$).\n\nIn the first dataset, there are three substrings with excellent decompositions:  \n$S[1,4]=\\texttt{aabb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$;  \n$S[3,6]=\\texttt{bbbb}$, with the excellent decomposition $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$;  \n$S[1,6]=\\texttt{aabbbb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$.  \nThe remaining substrings lack excellent decompositions, thus the answer for the first dataset is $3$.\n\nIn the second dataset, there are two types, totaling four substrings with excellent decompositions:  \nFor the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, their excellent decompositions are identical, set as $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, yet given the distinct positions of these substrings, they are counted thrice;  \nFor the substring $S[1,6]=\\texttt{cccccc}$, there are two excellent decompositions: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, both of which are different decompositions of the same substring and thus included in the answer.  \nHence, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent decompositions, where $S[1,8]$ is the example provided in the problem description, resulting in an answer of $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, $S[1,8]$ each have one excellent decomposition, and $S[3,14]$ has two, leading to an answer of $5+2=7$.\n\n### Data Range\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The constraints mentioned below apply to each individual set of input data within a test point, meaning that all $T$ sets of data under a test point meet the conditions specified.\n\nAssuming $n$ is the length of string $S$, the detailed data range for each test point is as follows:\n\n| Test Point No. | $n \\leq$  | Special Properties      |\n| -------------- | --------- | ----------------------- |\n| $1 \\sim 2$     | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$     | $2,000$   | All characters in $S$ are the same |\n| $5 \\sim 6$     | $10$      |                         |\n| $7 \\sim 8$     | $20$      |                         |\n| $9 \\sim 10$    | $30$      |                         |\n| $11 \\sim 12$   | $50$      |                         |\n| $13 \\sim 14$   | $100$     |                         |\n| $15$           | $200$     |                         |\n| $16$           | $300$     |                         |\n| $17$           | $500$     |                         |\n| $18$           | $1,000$   |                         |\n| $19$           | $2,000$   |                         |\n| $20$           | $30,000$  |                         |\n */", "canonical_solution": "{\n  int n = s.length;\n  List<int> prefix = List.filled(n + 1, 0);\n  for (int i = 0; i < n; ++i) {\n    prefix[i + 1] = prefix[i] + (s[i] == s[n ~/ 2] ? 1 : 0);\n  }\n\n  int ans = 0;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] == s[n ~/ 2] && s[i - 1] == s[n ~/ 2]) {\n      ans += prefix[i] * (prefix[n] - prefix[i + 1]);\n    }\n  }\n  return ans;\n}", "test": "void testCountExcellentSplits() {\n  assert(countExcellentSplits(\"aabbbb\") == 4);\n  assert(countExcellentSplits(\"cccccc\") == 20);\n  assert(countExcellentSplits(\"aabaabaabaa\") == 0);\n}\n\nvoid main() {\n  testCountExcellentSplits();\n}", "entry_point": "countExcellentSplits", "signature": "int countExcellentSplits(String s)", "docstring": "#  Excellent Decomposition\n\n## Problem Description\n\nA decomposition of a string into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any **non-empty** strings, is deemed excellent.\nFor instance, with the string $ \\texttt{aabaabaa} $, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we establish an excellent decomposition of the string into $\\text{AABB}$.\n\nA string may not possess any excellent decompositions or could have multiple such decompositions.\nFor example, by setting $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the aforementioned string can also be represented by $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ lacks any excellent decomposition.\n\nCurrently, a string of length $n$, denoted as $S$, is provided, and the task is to determine the total number of excellent decompositions among all possible decompositions of all its substrings. Here, a substring refers to a consecutive segment within the string.\n\nThe following considerations should be noted:\n\n1. Identical substrings occurring at different positions are considered distinct, and their excellent decompositions are each counted towards the answer.\n2. Within a decomposition, $\\text{A}=\\text{B}$ is permissible. For instance, $\\texttt{cccc}$ admits a decomposition with $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.\n\n## Input Format\n\nEach input file contains multiple sets of data.\n\nThe first line of the input file contains a single integer $T$, indicating the number of data sets.\n\nThe following $T$ lines each contain a string $S$ composed solely of lowercase English letters, with the significance as described in the problem.\n\n## Output Format\n\nOutput $T$ lines, each containing an integer, indicating the total number of excellent decompositions among all decompositions of all substrings of string $S$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n```\n\n### Sample Output #1\n\n```\n3\n5\n4\n7\n```\n\n## Hints\n\n### Sample Explanation\n\nWe denote $S[i, j]$ as the substring of string $S$ from the $i$-th to the $j$-th character (counting starts from $1$).\n\nIn the first dataset, there are three substrings with excellent decompositions:\n$S[1,4]=\\texttt{aabb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$;\n$S[3,6]=\\texttt{bbbb}$, with the excellent decomposition $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$;\n$S[1,6]=\\texttt{aabbbb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$.\nThe remaining substrings lack excellent decompositions, thus the answer for the first dataset is $3$.\n\nIn the second dataset, there are two types, totaling four substrings with excellent decompositions:\nFor the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, their excellent decompositions are identical, set as $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, yet given the distinct positions of these substrings, they are counted thrice;\nFor the substring $S[1,6]=\\texttt{cccccc}$, there are two excellent decompositions: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, both of which are different decompositions of the same substring and thus included in the answer.\nHence, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent decompositions, where $S[1,8]$ is the example provided in the problem description, resulting in an answer of $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, $S[1,8]$ each have one excellent decomposition, and $S[3,14]$ has two, leading to an answer of $5+2=7$.\n\n### Data Range\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The constraints mentioned below apply to each individual set of input data within a test point, meaning that all $T$ sets of data under a test point meet the conditions specified.\n\nAssuming $n$ is the length of string $S$, the detailed data range for each test point is as follows:\n\n| Test Point No. | $n \\leq$  | Special Properties      |\n| -------------- | --------- | ----------------------- |\n| $1 \\sim 2$     | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$     | $2,000$   | All characters in $S$ are the same |\n| $5 \\sim 6$     | $10$      |                         |\n| $7 \\sim 8$     | $20$      |                         |\n| $9 \\sim 10$    | $30$      |                         |\n| $11 \\sim 12$   | $50$      |                         |\n| $13 \\sim 14$   | $100$     |                         |\n| $15$           | $200$     |                         |\n| $16$           | $300$     |                         |\n| $17$           | $500$     |                         |\n| $18$           | $1,000$   |                         |\n| $19$           | $2,000$   |                         |\n| $20$           | $30,000$  |                         |", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n#  Excellent Decomposition\n\n## Problem Description\n\nA decomposition of a string into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any **non-empty** strings, is deemed excellent.\nFor instance, with the string $ \\texttt{aabaabaa} $, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we establish an excellent decomposition of the string into $\\text{AABB}$.\n\nA string may not possess any excellent decompositions or could have multiple such decompositions.\nFor example, by setting $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the aforementioned string can also be represented by $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ lacks any excellent decomposition.\n\nCurrently, a string of length $n$, denoted as $S$, is provided, and the task is to determine the total number of excellent decompositions among all possible decompositions of all its substrings. Here, a substring refers to a consecutive segment within the string.\n\nThe following considerations should be noted:\n\n1. Identical substrings occurring at different positions are considered distinct, and their excellent decompositions are each counted towards the answer.\n2. Within a decomposition, $\\text{A}=\\text{B}$ is permissible. For instance, $\\texttt{cccc}$ admits a decomposition with $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.\n\n## Input Format\n\nEach input file contains multiple sets of data.\n\nThe first line of the input file contains a single integer $T$, indicating the number of data sets.\n\nThe following $T$ lines each contain a string $S$ composed solely of lowercase English letters, with the significance as described in the problem.\n\n## Output Format\n\nOutput $T$ lines, each containing an integer, indicating the total number of excellent decompositions among all decompositions of all substrings of string $S$.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n```\n\n### Sample Output #1\n\n```\n3\n5\n4\n7\n```\n\n## Hints\n\n### Sample Explanation\n\nWe denote $S[i, j]$ as the substring of string $S$ from the $i$-th to the $j$-th character (counting starts from $1$).\n\nIn the first dataset, there are three substrings with excellent decompositions:\n$S[1,4]=\\texttt{aabb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$;\n$S[3,6]=\\texttt{bbbb}$, with the excellent decomposition $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$;\n$S[1,6]=\\texttt{aabbbb}$, with the excellent decomposition $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$.\nThe remaining substrings lack excellent decompositions, thus the answer for the first dataset is $3$.\n\nIn the second dataset, there are two types, totaling four substrings with excellent decompositions:\nFor the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, their excellent decompositions are identical, set as $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, yet given the distinct positions of these substrings, they are counted thrice;\nFor the substring $S[1,6]=\\texttt{cccccc}$, there are two excellent decompositions: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, both of which are different decompositions of the same substring and thus included in the answer.\nHence, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent decompositions, where $S[1,8]$ is the example provided in the problem description, resulting in an answer of $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, $S[1,8]$ each have one excellent decomposition, and $S[3,14]$ has two, leading to an answer of $5+2=7$.\n\n### Data Range\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The constraints mentioned below apply to each individual set of input data within a test point, meaning that all $T$ sets of data under a test point meet the conditions specified.\n\nAssuming $n$ is the length of string $S$, the detailed data range for each test point is as follows:\n\n| Test Point No. | $n \\leq$  | Special Properties      |\n| -------------- | --------- | ----------------------- |\n| $1 \\sim 2$     | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$     | $2,000$   | All characters in $S$ are the same |\n| $5 \\sim 6$     | $10$      |                         |\n| $7 \\sim 8$     | $20$      |                         |\n| $9 \\sim 10$    | $30$      |                         |\n| $11 \\sim 12$   | $50$      |                         |\n| $13 \\sim 14$   | $100$     |                         |\n| $15$           | $200$     |                         |\n| $16$           | $300$     |                         |\n| $17$           | $500$     |                         |\n| $18$           | $1,000$   |                         |\n| $19$           | $2,000$   |                         |\n| $20$           | $30,000$  |                         |\n\n* Incomplete Code:\nint countExcellentSplits(String s)\n{\n[MASK]\n[MASK]\n[MASK]\n    prefix[i + 1] = prefix[i] + (s[i] == s[n ~/ 2] ? 1 : 0);\n  }\n\n  int ans = 0;\n[MASK]\n    if (s[i] == s[n ~/ 2] && s[i - 1] == s[n ~/ 2]) {\n      ans += prefix[i] * (prefix[n] - prefix[i + 1]);\n    }\n  }\n  return ans;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n[MASK]\n[MASK]\n    prefix[i + 1] = prefix[i] + (s[i] == s[n ~/ 2] ? 1 : 0);\n  }\n\n  int ans = 0;\n[MASK]\n    if (s[i] == s[n ~/ 2] && s[i - 1] == s[n ~/ 2]) {\n      ans += prefix[i] * (prefix[n] - prefix[i + 1]);\n    }\n  }\n  return ans;\n}"}
{"task_id": "Dart/51-0-multi", "prompt": "bool canFormOriginal(int targetLength, List<int> sticks, List<int> slots, int index)\n/**\n * # Small Sticks\n\n\n## Problem Description\n\nGeorge has several small sticks of equal length, which he has randomly cut into several pieces, ensuring that each piece does not exceed a length of $50$.\n\nHe now wishes to reassemble the small sticks to their original form but has forgotten the number of sticks he had initially and their lengths.\n\nGiven the length of each stick segment, write a program to help him determine the minimum possible length of the original sticks.\n\n## Input Format\n\nThe first line contains an integer $n$, representing the number of stick segments.\nThe second line contains $n$ integers, representing the lengths of the stick segments $a_i$.\n\n## Output Format\n\nOutput a single integer on a line representing the answer.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n9\n5 2 1 5 2 1 5 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hints\n\nFor all test cases, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.\n */", "canonical_solution": "{\n  if (index == sticks.length) {\n    return true;\n  }\n\n  for (int i = 0; i < slots.length; i++) {\n    if (slots[i] + sticks[index] <= targetLength) {\n      slots[i] += sticks[index];\n      if (canFormOriginal(targetLength, sticks, slots, index + 1)) {\n        return true;\n      }\n      slots[i] -= sticks[index];\n    }\n\n    if (slots[i] == 0 || slots[i] + sticks[index] == targetLength) {\n      break;\n    }\n  }\n\n  return false;\n}", "test": "void testCanFormOriginal() {\n  // Test case 1\n  assert(canFormOriginal(6, [5, 2, 1, 5, 2, 1, 5, 2, 1], [0, 0, 0, 0, 0, 0], 0) == true);\n\n  // Test case 2\n  assert(canFormOriginal(4, [1, 1, 1, 1], [0, 0, 0, 0], 0) == true);\n\n  // Test case 3\n  assert(canFormOriginal(5, [3, 2, 2, 1], [0, 0, 0, 0, 0], 0) == true);\n}\n\nvoid main() {\n  testCanFormOriginal();\n}", "entry_point": "canFormOriginal", "signature": "bool canFormOriginal(int targetLength, List<int> sticks, List<int> slots, int index)", "docstring": "# Small Sticks\n\n\n## Problem Description\n\nGeorge has several small sticks of equal length, which he has randomly cut into several pieces, ensuring that each piece does not exceed a length of $50$.\n\nHe now wishes to reassemble the small sticks to their original form but has forgotten the number of sticks he had initially and their lengths.\n\nGiven the length of each stick segment, write a program to help him determine the minimum possible length of the original sticks.\n\n## Input Format\n\nThe first line contains an integer $n$, representing the number of stick segments.\nThe second line contains $n$ integers, representing the lengths of the stick segments $a_i$.\n\n## Output Format\n\nOutput a single integer on a line representing the answer.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n9\n5 2 1 5 2 1 5 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hints\n\nFor all test cases, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Small Sticks\n\n\n## Problem Description\n\nGeorge has several small sticks of equal length, which he has randomly cut into several pieces, ensuring that each piece does not exceed a length of $50$.\n\nHe now wishes to reassemble the small sticks to their original form but has forgotten the number of sticks he had initially and their lengths.\n\nGiven the length of each stick segment, write a program to help him determine the minimum possible length of the original sticks.\n\n## Input Format\n\nThe first line contains an integer $n$, representing the number of stick segments.\nThe second line contains $n$ integers, representing the lengths of the stick segments $a_i$.\n\n## Output Format\n\nOutput a single integer on a line representing the answer.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n9\n5 2 1 5 2 1 5 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hints\n\nFor all test cases, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.\n\n* Incomplete Code:\nbool canFormOriginal(int targetLength, List<int> sticks, List<int> slots, int index)\n{\n[MASK]\n    return true;\n  }\n\n  for (int i = 0; i < slots.length; i++) {\n    if (slots[i] + sticks[index] <= targetLength) {\n      slots[i] += sticks[index];\n      if (canFormOriginal(targetLength, sticks, slots, index + 1)) {\n        return true;\n      }\n      slots[i] -= sticks[index];\n    }\n\n[MASK]\n      break;\n    }\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n    return true;\n  }\n\n  for (int i = 0; i < slots.length; i++) {\n    if (slots[i] + sticks[index] <= targetLength) {\n      slots[i] += sticks[index];\n      if (canFormOriginal(targetLength, sticks, slots, index + 1)) {\n        return true;\n      }\n      slots[i] -= sticks[index];\n    }\n\n[MASK]\n      break;\n    }\n  }\n\n[MASK]\n}"}
{"task_id": "Dart/51-1-multi", "prompt": "bool canFormOriginal(int targetLength, List<int> sticks, List<int> slots, int index)\n/**\n * # Small Sticks\n\n\n## Problem Description\n\nGeorge has several small sticks of equal length, which he has randomly cut into several pieces, ensuring that each piece does not exceed a length of $50$.\n\nHe now wishes to reassemble the small sticks to their original form but has forgotten the number of sticks he had initially and their lengths.\n\nGiven the length of each stick segment, write a program to help him determine the minimum possible length of the original sticks.\n\n## Input Format\n\nThe first line contains an integer $n$, representing the number of stick segments.\nThe second line contains $n$ integers, representing the lengths of the stick segments $a_i$.\n\n## Output Format\n\nOutput a single integer on a line representing the answer.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n9\n5 2 1 5 2 1 5 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hints\n\nFor all test cases, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.\n */", "canonical_solution": "{\n  if (index == sticks.length) {\n    return true;\n  }\n\n  for (int i = 0; i < slots.length; i++) {\n    if (slots[i] + sticks[index] <= targetLength) {\n      slots[i] += sticks[index];\n      if (canFormOriginal(targetLength, sticks, slots, index + 1)) {\n        return true;\n      }\n      slots[i] -= sticks[index];\n    }\n\n    if (slots[i] == 0 || slots[i] + sticks[index] == targetLength) {\n      break;\n    }\n  }\n\n  return false;\n}", "test": "void testCanFormOriginal() {\n  // Test case 1\n  assert(canFormOriginal(6, [5, 2, 1, 5, 2, 1, 5, 2, 1], [0, 0, 0, 0, 0, 0], 0) == true);\n\n  // Test case 2\n  assert(canFormOriginal(4, [1, 1, 1, 1], [0, 0, 0, 0], 0) == true);\n\n  // Test case 3\n  assert(canFormOriginal(5, [3, 2, 2, 1], [0, 0, 0, 0, 0], 0) == true);\n}\n\nvoid main() {\n  testCanFormOriginal();\n}", "entry_point": "canFormOriginal", "signature": "bool canFormOriginal(int targetLength, List<int> sticks, List<int> slots, int index)", "docstring": "# Small Sticks\n\n\n## Problem Description\n\nGeorge has several small sticks of equal length, which he has randomly cut into several pieces, ensuring that each piece does not exceed a length of $50$.\n\nHe now wishes to reassemble the small sticks to their original form but has forgotten the number of sticks he had initially and their lengths.\n\nGiven the length of each stick segment, write a program to help him determine the minimum possible length of the original sticks.\n\n## Input Format\n\nThe first line contains an integer $n$, representing the number of stick segments.\nThe second line contains $n$ integers, representing the lengths of the stick segments $a_i$.\n\n## Output Format\n\nOutput a single integer on a line representing the answer.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n9\n5 2 1 5 2 1 5 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hints\n\nFor all test cases, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.", "instruction": "Below is a explanation of dart code and incomplete code implementation.\n\n* Docstring: \n# Small Sticks\n\n\n## Problem Description\n\nGeorge has several small sticks of equal length, which he has randomly cut into several pieces, ensuring that each piece does not exceed a length of $50$.\n\nHe now wishes to reassemble the small sticks to their original form but has forgotten the number of sticks he had initially and their lengths.\n\nGiven the length of each stick segment, write a program to help him determine the minimum possible length of the original sticks.\n\n## Input Format\n\nThe first line contains an integer $n$, representing the number of stick segments.\nThe second line contains $n$ integers, representing the lengths of the stick segments $a_i$.\n\n## Output Format\n\nOutput a single integer on a line representing the answer.\n\n## Sample #1\n\n### Sample Input #1\n\n```\n9\n5 2 1 5 2 1 5 2 1\n```\n\n### Sample Output #1\n\n```\n6\n```\n\n## Hints\n\nFor all test cases, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.\n\n* Incomplete Code:\nbool canFormOriginal(int targetLength, List<int> sticks, List<int> slots, int index)\n{\n  if (index == sticks.length) {\n    return true;\n  }\n\n  for (int i = 0; i < slots.length; i++) {\n[MASK]\n      slots[i] += sticks[index];\n      if (canFormOriginal(targetLength, sticks, slots, index + 1)) {\n        return true;\n      }\n      slots[i] -= sticks[index];\n    }\n\n    if (slots[i] == 0 || slots[i] + sticks[index] == targetLength) {\n[MASK]\n    }\n  }\n\n  return false;\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  if (index == sticks.length) {\n    return true;\n  }\n\n  for (int i = 0; i < slots.length; i++) {\n[MASK]\n      slots[i] += sticks[index];\n      if (canFormOriginal(targetLength, sticks, slots, index + 1)) {\n        return true;\n      }\n      slots[i] -= sticks[index];\n    }\n\n    if (slots[i] == 0 || slots[i] + sticks[index] == targetLength) {\n[MASK]\n    }\n  }\n\n  return false;\n}"}
