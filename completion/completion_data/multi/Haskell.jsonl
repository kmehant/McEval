{"task_id": "Haskell/2-0-multi", "prompt": "module Main where\n\nimport Data.List (sort, nub)\n\n{- \n  Returns the third largest number in a non-empty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is non-empty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n-}\nthirdLargest :: [Int] -> Int\nthirdLargest numbers = ", "canonical_solution": "  case uniqueSortedNumbers of\n    (x:_:_:_) -> uniqueSortedNumbers !! 2\n    otherwise -> head uniqueSortedNumbers\n  where\n    uniqueSortedNumbers = reverse . sort . nub $ numbers", "test": "check :: ([Int] -> Int) -> IO ()\ncheck thirdLargestFunc = do\n  let testCases =\n        [ ([3, 2, 1], 1),\n          ([1, 2], 2),\n          ([10, 15, 5, 4, 20], 10),\n          ([5], 5)\n        ]\n\n  mapM_ (\\(numbers, expected) -> testCase numbers expected) testCases\n  where\n    testCase numbers expected = do\n      let result = thirdLargestFunc numbers\n      putStrLn $\n        \"Input: \" ++ show numbers ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check thirdLargest", "entry_point": "thirdLargest", "signature": "thirdLargest :: [Int] -> Int", "docstring": " \n  Returns the third largest number in a nonempty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is nonempty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the third largest number in a nonempty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is nonempty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n\n\n\n* Incomplete Code:\nthirdLargest :: [Int] -> Int\n[MASK]\n[MASK]\n    otherwise -> head uniqueSortedNumbers\n  where\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n    otherwise -> head uniqueSortedNumbers\n  where\n[MASK]"}
{"task_id": "Haskell/2-1-multi", "prompt": "module Main where\n\nimport Data.List (sort, nub)\n\n{- \n  Returns the third largest number in a non-empty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is non-empty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n-}\nthirdLargest :: [Int] -> Int\nthirdLargest numbers = ", "canonical_solution": "  case uniqueSortedNumbers of\n    (x:_:_:_) -> uniqueSortedNumbers !! 2\n    otherwise -> head uniqueSortedNumbers\n  where\n    uniqueSortedNumbers = reverse . sort . nub $ numbers", "test": "check :: ([Int] -> Int) -> IO ()\ncheck thirdLargestFunc = do\n  let testCases =\n        [ ([3, 2, 1], 1),\n          ([1, 2], 2),\n          ([10, 15, 5, 4, 20], 10),\n          ([5], 5)\n        ]\n\n  mapM_ (\\(numbers, expected) -> testCase numbers expected) testCases\n  where\n    testCase numbers expected = do\n      let result = thirdLargestFunc numbers\n      putStrLn $\n        \"Input: \" ++ show numbers ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check thirdLargest", "entry_point": "thirdLargest", "signature": "thirdLargest :: [Int] -> Int", "docstring": " \n  Returns the third largest number in a nonempty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is nonempty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the third largest number in a nonempty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is nonempty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n\n\n\n* Incomplete Code:\nthirdLargest :: [Int] -> Int\n  case uniqueSortedNumbers of\n    (x:_:_:_) -> uniqueSortedNumbers !! 2\n[MASK]\n  where\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "  case uniqueSortedNumbers of\n    (x:_:_:_) -> uniqueSortedNumbers !! 2\n[MASK]\n  where\n[MASK]"}
{"task_id": "Haskell/3-0-multi", "prompt": "module Main where\n\n{- \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n-}\ndiagonalSum :: [[Int]] -> Int", "canonical_solution": "diagonalSum mat = sum mainDiagonal + sum secondaryDiagonal - intersect\n  where\n    size = length mat\n    mainDiagonal = [mat !! i !! i | i <- [0..size-1]]\n    secondaryDiagonal = [mat !! i !! (size - 1 - i) | i <- [0..size-1]]\n    intersect = if odd size then mat !! middle !! middle else 0\n    middle = size `div` 2", "test": "check :: ([[Int]] -> Int) -> IO ()\ncheck diagonalSumFunc = do\n  let testCases =\n        [ ([[1,2,3], [4,5,6], [7,8,9]], 25),\n          ([[1,1], [1,1]], 4),\n          ([[5]], 5),\n          ([[1,2], [3,4]], 10),\n          ([[2,0,0], [0,1,0], [0,0,3]], 6)\n        ]\n\n  mapM_ (\\(mat, expected) -> testCase mat expected) testCases\n  where\n    testCase mat expected = do\n      let result = diagonalSumFunc mat\n      putStrLn $\n        \"Input: \" ++ show mat ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check diagonalSum", "entry_point": "diagonalSum", "signature": "diagonalSum :: [[Int]] -> Int", "docstring": " \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n\n\n\n* Incomplete Code:\ndiagonalSum :: [[Int]] -> Int\ndiagonalSum mat = sum mainDiagonal + sum secondaryDiagonal - intersect\n[MASK]\n[MASK]\n[MASK]\n    secondaryDiagonal = [mat !! i !! (size - 1 - i) | i <- [0..size-1]]\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "diagonalSum mat = sum mainDiagonal + sum secondaryDiagonal - intersect\n[MASK]\n[MASK]\n[MASK]\n    secondaryDiagonal = [mat !! i !! (size - 1 - i) | i <- [0..size-1]]\n[MASK]\n[MASK]"}
{"task_id": "Haskell/3-1-multi", "prompt": "module Main where\n\n{- \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n-}\ndiagonalSum :: [[Int]] -> Int", "canonical_solution": "diagonalSum mat = sum mainDiagonal + sum secondaryDiagonal - intersect\n  where\n    size = length mat\n    mainDiagonal = [mat !! i !! i | i <- [0..size-1]]\n    secondaryDiagonal = [mat !! i !! (size - 1 - i) | i <- [0..size-1]]\n    intersect = if odd size then mat !! middle !! middle else 0\n    middle = size `div` 2", "test": "check :: ([[Int]] -> Int) -> IO ()\ncheck diagonalSumFunc = do\n  let testCases =\n        [ ([[1,2,3], [4,5,6], [7,8,9]], 25),\n          ([[1,1], [1,1]], 4),\n          ([[5]], 5),\n          ([[1,2], [3,4]], 10),\n          ([[2,0,0], [0,1,0], [0,0,3]], 6)\n        ]\n\n  mapM_ (\\(mat, expected) -> testCase mat expected) testCases\n  where\n    testCase mat expected = do\n      let result = diagonalSumFunc mat\n      putStrLn $\n        \"Input: \" ++ show mat ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check diagonalSum", "entry_point": "diagonalSum", "signature": "diagonalSum :: [[Int]] -> Int", "docstring": " \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n\n\n\n* Incomplete Code:\ndiagonalSum :: [[Int]] -> Int\n[MASK]\n  where\n    size = length mat\n    mainDiagonal = [mat !! i !! i | i <- [0..size-1]]\n    secondaryDiagonal = [mat !! i !! (size - 1 - i) | i <- [0..size-1]]\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n  where\n    size = length mat\n    mainDiagonal = [mat !! i !! i | i <- [0..size-1]]\n    secondaryDiagonal = [mat !! i !! (size - 1 - i) | i <- [0..size-1]]\n[MASK]\n[MASK]"}
{"task_id": "Haskell/5-0-multi", "prompt": "module Main where\n\nimport Data.List (delete, sort)\n\n{- \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n-}\naverageWithoutExtremes :: [Int] -> Maybe Float", "canonical_solution": "averageWithoutExtremes arr\n  | length arr < 3 = Nothing\n  | otherwise = Just $ fromIntegral (sum newArr) / fromIntegral (length newArr)\n  where\n    sortedArr = sort arr\n    newArr = delete (maximum arr) (delete (minimum arr) sortedArr)", "test": "check :: ([Int] -> Maybe Float) -> IO ()\ncheck averageWithoutExtremesFunc = do\n  let testCases =\n        [ ([1,2,3,4,5], Just 3.0),\n          ([1,2], Nothing),\n          ([10,20,30,40,50], Just 30.0),\n          ([5,5,5,5,5], Just 5.0),\n          ([7], Nothing)\n        ]\n\n  mapM_ (\\(arr, expected) -> testCase arr expected) testCases\n  where\n    testCase arr expected = do\n      let result = averageWithoutExtremesFunc arr\n      putStrLn $\n        \"Input: \" ++ show arr ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check averageWithoutExtremes", "entry_point": "averageWithoutExtremes", "signature": "averageWithoutExtremes :: [Int] -> Maybe Float", "docstring": " \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n\n\n\n* Incomplete Code:\naverageWithoutExtremes :: [Int] -> Maybe Float\naverageWithoutExtremes arr\n[MASK]\n[MASK]\n  where\n    sortedArr = sort arr\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "averageWithoutExtremes arr\n[MASK]\n[MASK]\n  where\n    sortedArr = sort arr\n[MASK]"}
{"task_id": "Haskell/5-1-multi", "prompt": "module Main where\n\nimport Data.List (delete, sort)\n\n{- \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n-}\naverageWithoutExtremes :: [Int] -> Maybe Float", "canonical_solution": "averageWithoutExtremes arr\n  | length arr < 3 = Nothing\n  | otherwise = Just $ fromIntegral (sum newArr) / fromIntegral (length newArr)\n  where\n    sortedArr = sort arr\n    newArr = delete (maximum arr) (delete (minimum arr) sortedArr)", "test": "check :: ([Int] -> Maybe Float) -> IO ()\ncheck averageWithoutExtremesFunc = do\n  let testCases =\n        [ ([1,2,3,4,5], Just 3.0),\n          ([1,2], Nothing),\n          ([10,20,30,40,50], Just 30.0),\n          ([5,5,5,5,5], Just 5.0),\n          ([7], Nothing)\n        ]\n\n  mapM_ (\\(arr, expected) -> testCase arr expected) testCases\n  where\n    testCase arr expected = do\n      let result = averageWithoutExtremesFunc arr\n      putStrLn $\n        \"Input: \" ++ show arr ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check averageWithoutExtremes", "entry_point": "averageWithoutExtremes", "signature": "averageWithoutExtremes :: [Int] -> Maybe Float", "docstring": " \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n\n\n\n* Incomplete Code:\naverageWithoutExtremes :: [Int] -> Maybe Float\naverageWithoutExtremes arr\n  | length arr < 3 = Nothing\n[MASK]\n[MASK]\n    sortedArr = sort arr\n    newArr = delete (maximum arr) (delete (minimum arr) sortedArr)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "averageWithoutExtremes arr\n  | length arr < 3 = Nothing\n[MASK]\n[MASK]\n    sortedArr = sort arr\n    newArr = delete (maximum arr) (delete (minimum arr) sortedArr)"}
{"task_id": "Haskell/6-0-multi", "prompt": "module Main where\n\nimport Data.List (sortBy, group, sort)\nimport Data.Ord (comparing)\n\n{- \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n-}\nfrequencySort :: [Int] -> [Int]", "canonical_solution": "frequencySort nums = concat . sortBy compareFrequency $ grouped\n  where\n    grouped = group . sort $ nums\n    compareFrequency a b = case comparing length a b of\n                              EQ -> comparing (negate . head) a b\n                              ord -> ord", "test": "check :: ([Int] -> [Int]) -> IO ()\ncheck frequencySortFunc = do\n  let testCases =\n        [ ([1,1,2,2,2,3], [3,1,1,2,2,2]),\n          ([2,3,1,3,2], [1,3,3,2,2]),\n          ([5,5,4,6,4], [6,5,5,4,4]),\n          ([-1,1,-6,4,5,-6,1,4,1], [5,-1,4,4,-6,-6,1,1,1]),\n          ([1], [1])\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = frequencySortFunc nums\n      putStrLn $\n        \"Input: \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check frequencySort", "entry_point": "frequencySort", "signature": "frequencySort :: [Int] -> [Int]", "docstring": " \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n\n\n\n* Incomplete Code:\nfrequencySort :: [Int] -> [Int]\n[MASK]\n  where\n    grouped = group . sort $ nums\n    compareFrequency a b = case comparing length a b of\n                              EQ -> comparing (negate . head) a b\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n  where\n    grouped = group . sort $ nums\n    compareFrequency a b = case comparing length a b of\n                              EQ -> comparing (negate . head) a b\n[MASK]"}
{"task_id": "Haskell/6-1-multi", "prompt": "module Main where\n\nimport Data.List (sortBy, group, sort)\nimport Data.Ord (comparing)\n\n{- \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n-}\nfrequencySort :: [Int] -> [Int]", "canonical_solution": "frequencySort nums = concat . sortBy compareFrequency $ grouped\n  where\n    grouped = group . sort $ nums\n    compareFrequency a b = case comparing length a b of\n                              EQ -> comparing (negate . head) a b\n                              ord -> ord", "test": "check :: ([Int] -> [Int]) -> IO ()\ncheck frequencySortFunc = do\n  let testCases =\n        [ ([1,1,2,2,2,3], [3,1,1,2,2,2]),\n          ([2,3,1,3,2], [1,3,3,2,2]),\n          ([5,5,4,6,4], [6,5,5,4,4]),\n          ([-1,1,-6,4,5,-6,1,4,1], [5,-1,4,4,-6,-6,1,1,1]),\n          ([1], [1])\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = frequencySortFunc nums\n      putStrLn $\n        \"Input: \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check frequencySort", "entry_point": "frequencySort", "signature": "frequencySort :: [Int] -> [Int]", "docstring": " \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n\n\n\n* Incomplete Code:\nfrequencySort :: [Int] -> [Int]\n[MASK]\n[MASK]\n    grouped = group . sort $ nums\n    compareFrequency a b = case comparing length a b of\n                              EQ -> comparing (negate . head) a b\n                              ord -> ord\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n    grouped = group . sort $ nums\n    compareFrequency a b = case comparing length a b of\n                              EQ -> comparing (negate . head) a b\n                              ord -> ord"}
{"task_id": "Haskell/7-0-multi", "prompt": "module Main where\n\nimport Data.List (find,isPrefixOf)\n\n{- \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n-}\ncanFormArray :: [Int] -> [[Int]] -> Bool", "canonical_solution": "canFormArray [] _ = True\ncanFormArray arr pieces = maybe False (\\piece -> canFormArray (drop (length piece) arr) (filter (/= piece) pieces)) matchedPiece\n  where\n    matchedPiece = find (`isPrefixOf` arr) pieces", "test": "check :: ([Int] -> [[Int]] -> Bool) -> IO ()\ncheck canFormArrayFunc = do\n  let testCases =\n        [ ([85], [[85]], True),\n          ([15,88], [[88],[15]], True),\n          ([49,18,16], [[16,18,49]], False),\n          ([91,4,64,78], [[78],[4,64],[91]], True),\n          ([1,3,5,7], [[2,4,6,8]], False)\n        ]\n\n  mapM_ (\\(arr, pieces, expected) -> testCase arr pieces expected) testCases\n  where\n    testCase arr pieces expected = do\n      let result = canFormArrayFunc arr pieces\n      putStrLn $\n        \"Input: arr = \" ++ show arr ++ \", pieces = \" ++ show pieces ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check canFormArray", "entry_point": "canFormArray", "signature": "canFormArray :: [Int] -> [[Int]] -> Bool", "docstring": " \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n\n\n\n* Incomplete Code:\ncanFormArray :: [Int] -> [[Int]] -> Bool\ncanFormArray [] _ = True\n[MASK]\n  where\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "canFormArray [] _ = True\n[MASK]\n  where\n[MASK]"}
{"task_id": "Haskell/7-1-multi", "prompt": "module Main where\n\nimport Data.List (find,isPrefixOf)\n\n{- \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n-}\ncanFormArray :: [Int] -> [[Int]] -> Bool", "canonical_solution": "canFormArray [] _ = True\ncanFormArray arr pieces = maybe False (\\piece -> canFormArray (drop (length piece) arr) (filter (/= piece) pieces)) matchedPiece\n  where\n    matchedPiece = find (`isPrefixOf` arr) pieces", "test": "check :: ([Int] -> [[Int]] -> Bool) -> IO ()\ncheck canFormArrayFunc = do\n  let testCases =\n        [ ([85], [[85]], True),\n          ([15,88], [[88],[15]], True),\n          ([49,18,16], [[16,18,49]], False),\n          ([91,4,64,78], [[78],[4,64],[91]], True),\n          ([1,3,5,7], [[2,4,6,8]], False)\n        ]\n\n  mapM_ (\\(arr, pieces, expected) -> testCase arr pieces expected) testCases\n  where\n    testCase arr pieces expected = do\n      let result = canFormArrayFunc arr pieces\n      putStrLn $\n        \"Input: arr = \" ++ show arr ++ \", pieces = \" ++ show pieces ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check canFormArray", "entry_point": "canFormArray", "signature": "canFormArray :: [Int] -> [[Int]] -> Bool", "docstring": " \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n\n\n\n* Incomplete Code:\ncanFormArray :: [Int] -> [[Int]] -> Bool\n[MASK]\n[MASK]\n  where\n    matchedPiece = find (`isPrefixOf` arr) pieces\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n  where\n    matchedPiece = find (`isPrefixOf` arr) pieces"}
{"task_id": "Haskell/8-0-multi", "prompt": "module Main where\n\n{- \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] -2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n-}\ndecrypt :: [Int] -> Int -> [Int]", "canonical_solution": "decrypt code k\n  | k == 0 = replicate (length code) 0\n  | k > 0 = map (\\i -> sum . take k . drop (i + 1) $ cycle code) [0 .. length code - 1]\n  | otherwise = map (\\i -> sum . take (abs k) . drop (i + length code + k) $ cycle code) [0 .. length code - 1]", "test": "check :: ([Int] -> Int -> [Int]) -> IO ()\ncheck decryptFunc = do\n  let testCases =\n        [ ([5,7,1,4], 3, [12,10,16,13]),\n          ([1,2,3,4], 0, [0,0,0,0]),\n          ([2,4,9,3], -2, [12,5,6,13]),\n          ([10,5,7,7], 1, [5,7,7,10]),\n          ([1,2,3,4], 4, [10,10,10,10])\n        ]\n\n  mapM_ (\\(code, k, expected) -> testCase code k expected) testCases\n  where\n    testCase code k expected = do\n      let result = decryptFunc code k\n      putStrLn $\n        \"Input: code = \" ++ show code ++ \", k = \" ++ show k ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check decrypt", "entry_point": "decrypt", "signature": "decrypt :: [Int] -> Int -> [Int]", "docstring": " \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] 2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] 2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n\n\n\n* Incomplete Code:\ndecrypt :: [Int] -> Int -> [Int]\n[MASK]\n[MASK]\n  | k > 0 = map (\\i -> sum . take k . drop (i + 1) $ cycle code) [0 .. length code - 1]\n  | otherwise = map (\\i -> sum . take (abs k) . drop (i + length code + k) $ cycle code) [0 .. length code - 1]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n  | k > 0 = map (\\i -> sum . take k . drop (i + 1) $ cycle code) [0 .. length code - 1]\n  | otherwise = map (\\i -> sum . take (abs k) . drop (i + length code + k) $ cycle code) [0 .. length code - 1]"}
{"task_id": "Haskell/8-1-multi", "prompt": "module Main where\n\n{- \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] -2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n-}\ndecrypt :: [Int] -> Int -> [Int]", "canonical_solution": "decrypt code k\n  | k == 0 = replicate (length code) 0\n  | k > 0 = map (\\i -> sum . take k . drop (i + 1) $ cycle code) [0 .. length code - 1]\n  | otherwise = map (\\i -> sum . take (abs k) . drop (i + length code + k) $ cycle code) [0 .. length code - 1]", "test": "check :: ([Int] -> Int -> [Int]) -> IO ()\ncheck decryptFunc = do\n  let testCases =\n        [ ([5,7,1,4], 3, [12,10,16,13]),\n          ([1,2,3,4], 0, [0,0,0,0]),\n          ([2,4,9,3], -2, [12,5,6,13]),\n          ([10,5,7,7], 1, [5,7,7,10]),\n          ([1,2,3,4], 4, [10,10,10,10])\n        ]\n\n  mapM_ (\\(code, k, expected) -> testCase code k expected) testCases\n  where\n    testCase code k expected = do\n      let result = decryptFunc code k\n      putStrLn $\n        \"Input: code = \" ++ show code ++ \", k = \" ++ show k ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check decrypt", "entry_point": "decrypt", "signature": "decrypt :: [Int] -> Int -> [Int]", "docstring": " \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] 2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] 2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n\n\n\n* Incomplete Code:\ndecrypt :: [Int] -> Int -> [Int]\ndecrypt code k\n[MASK]\n  | k > 0 = map (\\i -> sum . take k . drop (i + 1) $ cycle code) [0 .. length code - 1]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "decrypt code k\n[MASK]\n  | k > 0 = map (\\i -> sum . take k . drop (i + 1) $ cycle code) [0 .. length code - 1]\n[MASK]"}
{"task_id": "Haskell/12-0-multi", "prompt": "module Main where\n\nimport Data.List (delete)\n\n{- \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n-}\ncountUnsatisfiedStudents :: [Int] -> [Int] -> Int", "canonical_solution": "countUnsatisfiedStudents students sandwiches = length (snd (until noOneLikesTopSandwich takeSandwich (students, sandwiches)))\n  where\n    takeSandwich (st:sts, s:ss)\n      | st == s = (sts, ss)\n      | otherwise = (sts ++ [st], s:ss)\n    takeSandwich ([], ss) = ([], ss)\n    noOneLikesTopSandwich (sts, s:ss) = null sts || all (/= s) sts\n    noOneLikesTopSandwich (_, []) = True", "test": "check :: ([Int] -> [Int] -> Int) -> IO ()\ncheck countUnsatisfiedStudentsFunc = do\n  let testCases =\n        [ ([1,1,0,0], [0,1,0,1], 0),\n          ([1,1,1,0,0,1], [1,0,0,0,1,1], 3),\n          ([1,0,0,1,1], [1,1,0,0,0], 1),\n          ([0,0,1,1], [0,1,0,1], 0)\n        ]\n\n  mapM_ (\\(students, sandwiches, expected) -> testCase students sandwiches expected) testCases\n  where\n    testCase students sandwiches expected = do\n      let result = countUnsatisfiedStudentsFunc students sandwiches\n      putStrLn $\n        \"Input: students = \" ++ show students ++ \", sandwiches = \" ++ show sandwiches ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countUnsatisfiedStudents", "entry_point": "countUnsatisfiedStudents", "signature": "countUnsatisfiedStudents :: [Int] -> [Int] -> Int", "docstring": " \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n\n\n\n* Incomplete Code:\ncountUnsatisfiedStudents :: [Int] -> [Int] -> Int\ncountUnsatisfiedStudents students sandwiches = length (snd (until noOneLikesTopSandwich takeSandwich (students, sandwiches)))\n[MASK]\n    takeSandwich (st:sts, s:ss)\n      | st == s = (sts, ss)\n      | otherwise = (sts ++ [st], s:ss)\n    takeSandwich ([], ss) = ([], ss)\n[MASK]\n    noOneLikesTopSandwich (_, []) = True\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "countUnsatisfiedStudents students sandwiches = length (snd (until noOneLikesTopSandwich takeSandwich (students, sandwiches)))\n[MASK]\n    takeSandwich (st:sts, s:ss)\n      | st == s = (sts, ss)\n      | otherwise = (sts ++ [st], s:ss)\n    takeSandwich ([], ss) = ([], ss)\n[MASK]\n    noOneLikesTopSandwich (_, []) = True"}
{"task_id": "Haskell/12-1-multi", "prompt": "module Main where\n\nimport Data.List (delete)\n\n{- \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n-}\ncountUnsatisfiedStudents :: [Int] -> [Int] -> Int", "canonical_solution": "countUnsatisfiedStudents students sandwiches = length (snd (until noOneLikesTopSandwich takeSandwich (students, sandwiches)))\n  where\n    takeSandwich (st:sts, s:ss)\n      | st == s = (sts, ss)\n      | otherwise = (sts ++ [st], s:ss)\n    takeSandwich ([], ss) = ([], ss)\n    noOneLikesTopSandwich (sts, s:ss) = null sts || all (/= s) sts\n    noOneLikesTopSandwich (_, []) = True", "test": "check :: ([Int] -> [Int] -> Int) -> IO ()\ncheck countUnsatisfiedStudentsFunc = do\n  let testCases =\n        [ ([1,1,0,0], [0,1,0,1], 0),\n          ([1,1,1,0,0,1], [1,0,0,0,1,1], 3),\n          ([1,0,0,1,1], [1,1,0,0,0], 1),\n          ([0,0,1,1], [0,1,0,1], 0)\n        ]\n\n  mapM_ (\\(students, sandwiches, expected) -> testCase students sandwiches expected) testCases\n  where\n    testCase students sandwiches expected = do\n      let result = countUnsatisfiedStudentsFunc students sandwiches\n      putStrLn $\n        \"Input: students = \" ++ show students ++ \", sandwiches = \" ++ show sandwiches ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countUnsatisfiedStudents", "entry_point": "countUnsatisfiedStudents", "signature": "countUnsatisfiedStudents :: [Int] -> [Int] -> Int", "docstring": " \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n\n\n\n* Incomplete Code:\ncountUnsatisfiedStudents :: [Int] -> [Int] -> Int\n[MASK]\n  where\n    takeSandwich (st:sts, s:ss)\n      | st == s = (sts, ss)\n[MASK]\n    takeSandwich ([], ss) = ([], ss)\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n  where\n    takeSandwich (st:sts, s:ss)\n      | st == s = (sts, ss)\n[MASK]\n    takeSandwich ([], ss) = ([], ss)\n[MASK]\n[MASK]"}
{"task_id": "Haskell/17-0-multi", "prompt": "module Main where\n\n{- \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n-}\ncountMatches :: [[String]] -> String -> String -> Int", "canonical_solution": "countMatches items ruleKey ruleValue =\n  length $ filter (matchesRule ruleKey ruleValue) items\n  where\n    matchesRule key value item =\n      case key of\n        \"type\"  -> item !! 0 == value\n        \"color\" -> item !! 1 == value\n        \"name\"  -> item !! 2 == value\n        _       -> False", "test": "check :: ([[String]] -> String -> String -> Int) -> IO ()\ncheck countMatchesFunc = do\n  let testCases =\n        [ ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"color\", \"silver\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], \"type\", \"phone\", 2),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"name\", \"iphone\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"color\", \"blue\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"name\", \"lenovo\", 1)\n        ]\n\n  mapM_ (\\(items, ruleKey, ruleValue, expected) -> testCase items ruleKey ruleValue expected) testCases\n  where\n    testCase items ruleKey ruleValue expected = do\n      let result = countMatchesFunc items ruleKey ruleValue\n      putStrLn $\n        \"Input: items = \" ++ show items ++ \", ruleKey = \" ++ show ruleKey ++ \", ruleValue = \" ++ show ruleValue ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countMatches", "entry_point": "countMatches", "signature": "countMatches :: [[String]] -> String -> String -> Int", "docstring": " \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n\n\n\n* Incomplete Code:\ncountMatches :: [[String]] -> String -> String -> Int\n[MASK]\n  length $ filter (matchesRule ruleKey ruleValue) items\n[MASK]\n    matchesRule key value item =\n[MASK]\n        \"type\"  -> item !! 0 == value\n        \"color\" -> item !! 1 == value\n        \"name\"  -> item !! 2 == value\n        _       -> False\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n  length $ filter (matchesRule ruleKey ruleValue) items\n[MASK]\n    matchesRule key value item =\n[MASK]\n        \"type\"  -> item !! 0 == value\n        \"color\" -> item !! 1 == value\n        \"name\"  -> item !! 2 == value\n        _       -> False"}
{"task_id": "Haskell/17-1-multi", "prompt": "module Main where\n\n{- \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n-}\ncountMatches :: [[String]] -> String -> String -> Int", "canonical_solution": "countMatches items ruleKey ruleValue =\n  length $ filter (matchesRule ruleKey ruleValue) items\n  where\n    matchesRule key value item =\n      case key of\n        \"type\"  -> item !! 0 == value\n        \"color\" -> item !! 1 == value\n        \"name\"  -> item !! 2 == value\n        _       -> False", "test": "check :: ([[String]] -> String -> String -> Int) -> IO ()\ncheck countMatchesFunc = do\n  let testCases =\n        [ ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"color\", \"silver\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], \"type\", \"phone\", 2),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"name\", \"iphone\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"color\", \"blue\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"name\", \"lenovo\", 1)\n        ]\n\n  mapM_ (\\(items, ruleKey, ruleValue, expected) -> testCase items ruleKey ruleValue expected) testCases\n  where\n    testCase items ruleKey ruleValue expected = do\n      let result = countMatchesFunc items ruleKey ruleValue\n      putStrLn $\n        \"Input: items = \" ++ show items ++ \", ruleKey = \" ++ show ruleKey ++ \", ruleValue = \" ++ show ruleValue ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countMatches", "entry_point": "countMatches", "signature": "countMatches :: [[String]] -> String -> String -> Int", "docstring": " \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n\n\n\n* Incomplete Code:\ncountMatches :: [[String]] -> String -> String -> Int\n[MASK]\n[MASK]\n  where\n[MASK]\n      case key of\n        \"type\"  -> item !! 0 == value\n        \"color\" -> item !! 1 == value\n        \"name\"  -> item !! 2 == value\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n[MASK]\n  where\n[MASK]\n      case key of\n        \"type\"  -> item !! 0 == value\n        \"color\" -> item !! 1 == value\n        \"name\"  -> item !! 2 == value\n[MASK]"}
{"task_id": "Haskell/19-0-multi", "prompt": "module Main where\n\n{- \n  Defines a function signFunc that returns 1 for positive x, -1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,-2,3,4,5]\n  -1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [-1,-2,-3,-4,-5]\n  -1\n  >>> signOfProduct [1,5,0,2,-3]\n  0\n  >>> signOfProduct []\n  1\n-}\nsignOfProduct :: [Int] -> Int", "canonical_solution": "signOfProduct nums = signFunc $ product nums\nsignFunc :: Int -> Int\nsignFunc x\n  | x > 0 = 1\n  | x < 0 = -1\n  | otherwise = 0", "test": "check :: ([Int] -> Int) -> IO ()\ncheck signOfProductFunc = do\n  let testCases =\n        [ ([1,-2,3,4,5], -1),\n          ([1,2,3,4,5], 1),\n          ([-1,-2,-3,-4,-5], -1),\n          ([1,5,0,2,-3], 0),\n          ([], 1)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = signOfProductFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check signOfProduct", "entry_point": "signOfProduct", "signature": "signOfProduct :: [Int] -> Int", "docstring": " \n  Defines a function signFunc that returns 1 for positive x, 1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,5,0,2,3]\n  0\n  >>> signOfProduct []\n  1\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Defines a function signFunc that returns 1 for positive x, 1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,5,0,2,3]\n  0\n  >>> signOfProduct []\n  1\n\n\n\n* Incomplete Code:\nsignOfProduct :: [Int] -> Int\n[MASK]\nsignFunc :: Int -> Int\nsignFunc x\n  | x > 0 = 1\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nsignFunc :: Int -> Int\nsignFunc x\n  | x > 0 = 1\n[MASK]\n[MASK]"}
{"task_id": "Haskell/19-1-multi", "prompt": "module Main where\n\n{- \n  Defines a function signFunc that returns 1 for positive x, -1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,-2,3,4,5]\n  -1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [-1,-2,-3,-4,-5]\n  -1\n  >>> signOfProduct [1,5,0,2,-3]\n  0\n  >>> signOfProduct []\n  1\n-}\nsignOfProduct :: [Int] -> Int", "canonical_solution": "signOfProduct nums = signFunc $ product nums\nsignFunc :: Int -> Int\nsignFunc x\n  | x > 0 = 1\n  | x < 0 = -1\n  | otherwise = 0", "test": "check :: ([Int] -> Int) -> IO ()\ncheck signOfProductFunc = do\n  let testCases =\n        [ ([1,-2,3,4,5], -1),\n          ([1,2,3,4,5], 1),\n          ([-1,-2,-3,-4,-5], -1),\n          ([1,5,0,2,-3], 0),\n          ([], 1)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = signOfProductFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check signOfProduct", "entry_point": "signOfProduct", "signature": "signOfProduct :: [Int] -> Int", "docstring": " \n  Defines a function signFunc that returns 1 for positive x, 1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,5,0,2,3]\n  0\n  >>> signOfProduct []\n  1\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Defines a function signFunc that returns 1 for positive x, 1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,5,0,2,3]\n  0\n  >>> signOfProduct []\n  1\n\n\n\n* Incomplete Code:\nsignOfProduct :: [Int] -> Int\n[MASK]\nsignFunc :: Int -> Int\nsignFunc x\n  | x > 0 = 1\n  | x < 0 = -1\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nsignFunc :: Int -> Int\nsignFunc x\n  | x > 0 = 1\n  | x < 0 = -1\n[MASK]"}
{"task_id": "Haskell/20-0-multi", "prompt": "module Main where\n\n{- \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n-}\nminOperationsToIncrease :: [Int] -> Int", "canonical_solution": "minOperationsToIncrease nums = snd $ foldl accumulate (head nums, 0) (tail nums)\n  where\n    accumulate (prev, ops) cur =\n      let newOps = ops + max 0 (prev + 1 - cur)\n      in (max cur (prev + 1), newOps)", "test": "check :: ([Int] -> Int) -> IO ()\ncheck minOperationsToIncreaseFunc = do\n  let testCases =\n        [ ([1,2,3], 0),\n          ([1,1,1], 3),\n          ([1,5,2,4,1], 14),\n          ([8,5,9,2,6], 20),\n          ([3], 0)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = minOperationsToIncreaseFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check minOperationsToIncrease", "entry_point": "minOperationsToIncrease", "signature": "minOperationsToIncrease :: [Int] -> Int", "docstring": " \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n\n\n\n* Incomplete Code:\nminOperationsToIncrease :: [Int] -> Int\nminOperationsToIncrease nums = snd $ foldl accumulate (head nums, 0) (tail nums)\n  where\n[MASK]\n[MASK]\n      in (max cur (prev + 1), newOps)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "minOperationsToIncrease nums = snd $ foldl accumulate (head nums, 0) (tail nums)\n  where\n[MASK]\n[MASK]\n      in (max cur (prev + 1), newOps)"}
{"task_id": "Haskell/20-1-multi", "prompt": "module Main where\n\n{- \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n-}\nminOperationsToIncrease :: [Int] -> Int", "canonical_solution": "minOperationsToIncrease nums = snd $ foldl accumulate (head nums, 0) (tail nums)\n  where\n    accumulate (prev, ops) cur =\n      let newOps = ops + max 0 (prev + 1 - cur)\n      in (max cur (prev + 1), newOps)", "test": "check :: ([Int] -> Int) -> IO ()\ncheck minOperationsToIncreaseFunc = do\n  let testCases =\n        [ ([1,2,3], 0),\n          ([1,1,1], 3),\n          ([1,5,2,4,1], 14),\n          ([8,5,9,2,6], 20),\n          ([3], 0)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = minOperationsToIncreaseFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check minOperationsToIncrease", "entry_point": "minOperationsToIncrease", "signature": "minOperationsToIncrease :: [Int] -> Int", "docstring": " \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n\n\n\n* Incomplete Code:\nminOperationsToIncrease :: [Int] -> Int\nminOperationsToIncrease nums = snd $ foldl accumulate (head nums, 0) (tail nums)\n[MASK]\n    accumulate (prev, ops) cur =\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "minOperationsToIncrease nums = snd $ foldl accumulate (head nums, 0) (tail nums)\n[MASK]\n    accumulate (prev, ops) cur =\n[MASK]\n[MASK]"}
{"task_id": "Haskell/23-0-multi", "prompt": "module Main where\nimport Data.List (find)\n\ngoldbachConjecture :: Int -> Maybe (Int, Int, Int)\n{- \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (3, 11, 13)\n\n  >>> goldbachConjecture 31\n  Just (3, 13, 15)\n\n  >>> goldbachConjecture 45\n  Just (7, 17, 21)\n\n  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n-}", "canonical_solution": "-- Checks if a number is prime\nisPrime :: Int -> Bool\nisPrime n = n > 1 && all (\\x -> n `mod` x /= 0) [2..floor . sqrt $ fromIntegral n]\n\n-- Generates a list of primes up to a given number\nprimesUpTo :: Int -> [Int]\nprimesUpTo n = filter isPrime [2..n]\n\n-- Implementation of the Goldbach Conjecture\n\ngoldbachConjecture n = find (\\(x, y, z) -> isPrime x && isPrime y && isPrime z) \n    [(x, y, n - x - y) | x <- primes, y <- primes, x <= y, y <= n - x - y]\n    where primes = primesUpTo n", "test": "check :: (Int -> Maybe (Int, Int, Int)) -> IO ()\ncheck goldbachConjectureFunc = do\n  let testCases =\n        [ (27, Just (3, 11, 13)),\n          (31, Just (3, 13, 15)),\n          (45, Just (7, 17, 21)),\n          (29, Just (2, 13, 14)),\n          (53, Just (2, 23, 28))\n        ]\n\n  mapM_ (\\(n, expected) -> testCase n expected) testCases\n  where\n    testCase n expected = do\n      let result = goldbachConjectureFunc n\n      putStrLn $\n        \"Input: \" ++ show n ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else \" (Fail)\"\n\nmain :: IO ()\nmain = check goldbachConjecture", "entry_point": "goldbachConjecture", "signature": "goldbachConjecture :: Int -> Maybe (Int, Int, Int)", "docstring": " \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (3, 11, 13)\n\n  >>> goldbachConjecture 31\n  Just (3, 13, 15)\n\n  >>> goldbachConjecture 45\n  Just (7, 17, 21)\n\n  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (3, 11, 13)\n\n  >>> goldbachConjecture 31\n  Just (3, 13, 15)\n\n  >>> goldbachConjecture 45\n  Just (7, 17, 21)\n\n  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n\n\n* Incomplete Code:\ngoldbachConjecture :: Int -> Maybe (Int, Int, Int)\n[MASK]\nisPrime :: Int -> Bool\n[MASK]\n\n-- Generates a list of primes up to a given number\nprimesUpTo :: Int -> [Int]\nprimesUpTo n = filter isPrime [2..n]\n\n-- Implementation of the Goldbach Conjecture\n\ngoldbachConjecture n = find (\\(x, y, z) -> isPrime x && isPrime y && isPrime z) \n[MASK]\n    where primes = primesUpTo n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\nisPrime :: Int -> Bool\n[MASK]\n\n-- Generates a list of primes up to a given number\nprimesUpTo :: Int -> [Int]\nprimesUpTo n = filter isPrime [2..n]\n\n-- Implementation of the Goldbach Conjecture\n\ngoldbachConjecture n = find (\\(x, y, z) -> isPrime x && isPrime y && isPrime z) \n[MASK]\n    where primes = primesUpTo n"}
{"task_id": "Haskell/23-1-multi", "prompt": "module Main where\nimport Data.List (find)\n\ngoldbachConjecture :: Int -> Maybe (Int, Int, Int)\n{- \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (3, 11, 13)\n\n  >>> goldbachConjecture 31\n  Just (3, 13, 15)\n\n  >>> goldbachConjecture 45\n  Just (7, 17, 21)\n\n  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n-}", "canonical_solution": "-- Checks if a number is prime\nisPrime :: Int -> Bool\nisPrime n = n > 1 && all (\\x -> n `mod` x /= 0) [2..floor . sqrt $ fromIntegral n]\n\n-- Generates a list of primes up to a given number\nprimesUpTo :: Int -> [Int]\nprimesUpTo n = filter isPrime [2..n]\n\n-- Implementation of the Goldbach Conjecture\n\ngoldbachConjecture n = find (\\(x, y, z) -> isPrime x && isPrime y && isPrime z) \n    [(x, y, n - x - y) | x <- primes, y <- primes, x <= y, y <= n - x - y]\n    where primes = primesUpTo n", "test": "check :: (Int -> Maybe (Int, Int, Int)) -> IO ()\ncheck goldbachConjectureFunc = do\n  let testCases =\n        [ (27, Just (3, 11, 13)),\n          (31, Just (3, 13, 15)),\n          (45, Just (7, 17, 21)),\n          (29, Just (2, 13, 14)),\n          (53, Just (2, 23, 28))\n        ]\n\n  mapM_ (\\(n, expected) -> testCase n expected) testCases\n  where\n    testCase n expected = do\n      let result = goldbachConjectureFunc n\n      putStrLn $\n        \"Input: \" ++ show n ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else \" (Fail)\"\n\nmain :: IO ()\nmain = check goldbachConjecture", "entry_point": "goldbachConjecture", "signature": "goldbachConjecture :: Int -> Maybe (Int, Int, Int)", "docstring": " \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (3, 11, 13)\n\n  >>> goldbachConjecture 31\n  Just (3, 13, 15)\n\n  >>> goldbachConjecture 45\n  Just (7, 17, 21)\n\n  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (3, 11, 13)\n\n  >>> goldbachConjecture 31\n  Just (3, 13, 15)\n\n  >>> goldbachConjecture 45\n  Just (7, 17, 21)\n\n  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n\n\n* Incomplete Code:\ngoldbachConjecture :: Int -> Maybe (Int, Int, Int)\n-- Checks if a number is prime\n[MASK]\n[MASK]\n\n[MASK]\nprimesUpTo :: Int -> [Int]\n[MASK]\n\n-- Implementation of the Goldbach Conjecture\n\ngoldbachConjecture n = find (\\(x, y, z) -> isPrime x && isPrime y && isPrime z) \n    [(x, y, n - x - y) | x <- primes, y <- primes, x <= y, y <= n - x - y]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "-- Checks if a number is prime\n[MASK]\n[MASK]\n\n[MASK]\nprimesUpTo :: Int -> [Int]\n[MASK]\n\n-- Implementation of the Goldbach Conjecture\n\ngoldbachConjecture n = find (\\(x, y, z) -> isPrime x && isPrime y && isPrime z) \n    [(x, y, n - x - y) | x <- primes, y <- primes, x <= y, y <= n - x - y]\n[MASK]"}
{"task_id": "Haskell/24-0-multi", "prompt": "module Main where\nimport Data.List (group, sort)\ncountDigitInFactorial :: Int -> Int -> Int\n{- \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n-}", "canonical_solution": "countDigitInFactorial n a = length . filter (== intToDigit a) . show . factorial $ n\n  where\n    factorial 0 = 1\n    factorial x = x * factorial (x - 1)\n    intToDigit x = head $ show x", "test": "check :: (Int -> Int -> Int) -> IO ()\ncheck countDigitInFactorialFunc = do\n  let testCases =\n        [ ((4, 2), 1),\n          ((5, 1), 1),\n          ((10, 0), 2),\n          ((6, 3), 0),\n          ((9, 5), 0)\n        ]\n\n  mapM_ (\\((n, a), expected) -> testCase n a expected) testCases\n  where\n    testCase n a expected = do\n      let result = countDigitInFactorialFunc n a\n      putStrLn $\n        \"Input: n = \" ++ show n ++ \", a = \" ++ show a ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countDigitInFactorial", "entry_point": "countDigitInFactorial", "signature": "countDigitInFactorial :: Int -> Int -> Int", "docstring": " \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n\n\n* Incomplete Code:\ncountDigitInFactorial :: Int -> Int -> Int\n[MASK]\n[MASK]\n    factorial 0 = 1\n    factorial x = x * factorial (x - 1)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n    factorial 0 = 1\n    factorial x = x * factorial (x - 1)\n[MASK]"}
{"task_id": "Haskell/24-1-multi", "prompt": "module Main where\nimport Data.List (group, sort)\ncountDigitInFactorial :: Int -> Int -> Int\n{- \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n-}", "canonical_solution": "countDigitInFactorial n a = length . filter (== intToDigit a) . show . factorial $ n\n  where\n    factorial 0 = 1\n    factorial x = x * factorial (x - 1)\n    intToDigit x = head $ show x", "test": "check :: (Int -> Int -> Int) -> IO ()\ncheck countDigitInFactorialFunc = do\n  let testCases =\n        [ ((4, 2), 1),\n          ((5, 1), 1),\n          ((10, 0), 2),\n          ((6, 3), 0),\n          ((9, 5), 0)\n        ]\n\n  mapM_ (\\((n, a), expected) -> testCase n a expected) testCases\n  where\n    testCase n a expected = do\n      let result = countDigitInFactorialFunc n a\n      putStrLn $\n        \"Input: n = \" ++ show n ++ \", a = \" ++ show a ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countDigitInFactorial", "entry_point": "countDigitInFactorial", "signature": "countDigitInFactorial :: Int -> Int -> Int", "docstring": " \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n\n\n* Incomplete Code:\ncountDigitInFactorial :: Int -> Int -> Int\n[MASK]\n  where\n[MASK]\n    factorial x = x * factorial (x - 1)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n  where\n[MASK]\n    factorial x = x * factorial (x - 1)\n[MASK]"}
{"task_id": "Haskell/25-0-multi", "prompt": "module Main where\nmisplacedLetters :: Int -> Int\n{-\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n-}", "canonical_solution": "misplacedLetters n = derangement n\n  where\n    derangement 0 = 1\n    derangement 1 = 0\n    derangement n = (n - 1) * (derangement (n - 1) + derangement (n - 2))", "test": "check :: (Int -> Int) -> IO ()\ncheck misplacedLettersFunc = do\n  let testCases =\n        [ (1, 0),\n          (4, 9),\n          (5, 44),\n          (6, 265)\n        ]\n\n  mapM_ (\\(letters, expected) -> testCase letters expected) testCases\n  where\n    testCase letters expected = do\n      let result = misplacedLettersFunc letters\n      putStrLn $\n        \"Input: \" ++ show letters ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check misplacedLetters", "entry_point": "misplacedLetters", "signature": "misplacedLetters :: Int -> Int", "docstring": "\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n\n\n* Incomplete Code:\nmisplacedLetters :: Int -> Int\n[MASK]\n[MASK]\n    derangement 0 = 1\n[MASK]\n    derangement n = (n - 1) * (derangement (n - 1) + derangement (n - 2))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n    derangement 0 = 1\n[MASK]\n    derangement n = (n - 1) * (derangement (n - 1) + derangement (n - 2))"}
{"task_id": "Haskell/25-1-multi", "prompt": "module Main where\nmisplacedLetters :: Int -> Int\n{-\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n-}", "canonical_solution": "misplacedLetters n = derangement n\n  where\n    derangement 0 = 1\n    derangement 1 = 0\n    derangement n = (n - 1) * (derangement (n - 1) + derangement (n - 2))", "test": "check :: (Int -> Int) -> IO ()\ncheck misplacedLettersFunc = do\n  let testCases =\n        [ (1, 0),\n          (4, 9),\n          (5, 44),\n          (6, 265)\n        ]\n\n  mapM_ (\\(letters, expected) -> testCase letters expected) testCases\n  where\n    testCase letters expected = do\n      let result = misplacedLettersFunc letters\n      putStrLn $\n        \"Input: \" ++ show letters ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check misplacedLetters", "entry_point": "misplacedLetters", "signature": "misplacedLetters :: Int -> Int", "docstring": "\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n\n\n* Incomplete Code:\nmisplacedLetters :: Int -> Int\n[MASK]\n[MASK]\n[MASK]\n    derangement 1 = 0\n    derangement n = (n - 1) * (derangement (n - 1) + derangement (n - 2))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n[MASK]\n    derangement 1 = 0\n    derangement n = (n - 1) * (derangement (n - 1) + derangement (n - 2))"}
{"task_id": "Haskell/26-0-multi", "prompt": "module Main where\nimport Numeric (showIntAtBase, readInt)\nimport Data.Char (intToDigit, digitToInt)\n\nbaseAddition :: Int -> String -> String -> String\n{- \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n-}", "canonical_solution": "baseAddition base num1 num2 = \n  showIntAtBase base intToDigit (num1AsInt + num2AsInt) \"\"\n  where\n    num1AsInt = baseStringToInt base num1\n    num2AsInt = baseStringToInt base num2\n    baseStringToInt b str = fst $ head $ readInt b (const True) digitToInt str", "test": "check :: (Int -> String -> String -> String) -> IO ()\ncheck baseAdditionFunc = do\n  let testCases =\n        [ ((4, \"123\", \"321\"), \"1110\"),\n          ((2, \"1010\", \"1101\"), \"10111\"),\n          ((16, \"1A3\", \"2B4\"), \"457\"),\n          ((10, \"123\", \"456\"), \"579\"),\n          ((8, \"123\", \"456\"), \"601\")\n        ]\n\n  mapM_ (\\((base, num1, num2), expected) -> testCase base num1 num2 expected) testCases\n  where\n    testCase base num1 num2 expected = do\n      let result = baseAdditionFunc base num1 num2\n      putStrLn $\n        \"Base: \" ++ show base ++\n        \", Input 1: \" ++ num1 ++\n        \", Input 2: \" ++ num2 ++\n        \", Expected: \" ++ expected ++ \", Result: \" ++ result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check baseAddition", "entry_point": "baseAddition", "signature": "baseAddition :: Int -> String -> String -> String", "docstring": " \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n\n\n* Incomplete Code:\nbaseAddition :: Int -> String -> String -> String\n[MASK]\n[MASK]\n  where\n    num1AsInt = baseStringToInt base num1\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n  where\n    num1AsInt = baseStringToInt base num1\n[MASK]\n[MASK]"}
{"task_id": "Haskell/26-1-multi", "prompt": "module Main where\nimport Numeric (showIntAtBase, readInt)\nimport Data.Char (intToDigit, digitToInt)\n\nbaseAddition :: Int -> String -> String -> String\n{- \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n-}", "canonical_solution": "baseAddition base num1 num2 = \n  showIntAtBase base intToDigit (num1AsInt + num2AsInt) \"\"\n  where\n    num1AsInt = baseStringToInt base num1\n    num2AsInt = baseStringToInt base num2\n    baseStringToInt b str = fst $ head $ readInt b (const True) digitToInt str", "test": "check :: (Int -> String -> String -> String) -> IO ()\ncheck baseAdditionFunc = do\n  let testCases =\n        [ ((4, \"123\", \"321\"), \"1110\"),\n          ((2, \"1010\", \"1101\"), \"10111\"),\n          ((16, \"1A3\", \"2B4\"), \"457\"),\n          ((10, \"123\", \"456\"), \"579\"),\n          ((8, \"123\", \"456\"), \"601\")\n        ]\n\n  mapM_ (\\((base, num1, num2), expected) -> testCase base num1 num2 expected) testCases\n  where\n    testCase base num1 num2 expected = do\n      let result = baseAdditionFunc base num1 num2\n      putStrLn $\n        \"Base: \" ++ show base ++\n        \", Input 1: \" ++ num1 ++\n        \", Input 2: \" ++ num2 ++\n        \", Expected: \" ++ expected ++ \", Result: \" ++ result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check baseAddition", "entry_point": "baseAddition", "signature": "baseAddition :: Int -> String -> String -> String", "docstring": " \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n\n\n* Incomplete Code:\nbaseAddition :: Int -> String -> String -> String\n[MASK]\n  showIntAtBase base intToDigit (num1AsInt + num2AsInt) \"\"\n[MASK]\n[MASK]\n[MASK]\n    baseStringToInt b str = fst $ head $ readInt b (const True) digitToInt str\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n  showIntAtBase base intToDigit (num1AsInt + num2AsInt) \"\"\n[MASK]\n[MASK]\n[MASK]\n    baseStringToInt b str = fst $ head $ readInt b (const True) digitToInt str"}
{"task_id": "Haskell/27-0-multi", "prompt": "module Main where\nimport qualified Data.Set as Set\n\ncountMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int\n{-\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n-}", "canonical_solution": "countMazePaths n m t start end obstacles\n  | start == end = 1\n  | otherwise = sum $ map (\\next -> if Set.member next obstacles || not (isValid next)\n                                    then 0\n                                    else countMazePaths n m t next end (Set.insert start obstacles))\n                          [(sx-1, sy), (sx+1, sy), (sx, sy-1), (sx, sy+1)]\n  where\n    (sx, sy) = start\n    isValid (x, y) = x > 0 && x <= n && y > 0 && y <= m", "test": "check :: (Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int) -> IO ()\ncheck countMazePathsFunc = do\n  let testCases =\n        [ ((3, 3, 1, (1, 1), (3, 3), Set.fromList [(2, 2)]), 2),\n          ((4, 4, 2, (1, 1), (4, 4), Set.fromList [(2, 2), (3, 3)]), 4),\n          ((2, 3, 0, (1, 1), (2, 3), Set.empty), 4)\n        ]\n\n  mapM_ (\\(params, expected) -> testCase params expected) testCases\n  where\n    testCase (n, m, t, start, end, obstacles) expected = do\n      let result = countMazePathsFunc n m t start end obstacles\n      putStrLn $\n        \"Input: \" ++ show (n, m, t, start, end, obstacles) ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countMazePaths", "entry_point": "countMazePaths", "signature": "countMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int", "docstring": "\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n\n\n* Incomplete Code:\ncountMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int\ncountMazePaths n m t start end obstacles\n  | start == end = 1\n  | otherwise = sum $ map (\\next -> if Set.member next obstacles || not (isValid next)\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n    (sx, sy) = start\n    isValid (x, y) = x > 0 && x <= n && y > 0 && y <= m\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "countMazePaths n m t start end obstacles\n  | start == end = 1\n  | otherwise = sum $ map (\\next -> if Set.member next obstacles || not (isValid next)\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n    (sx, sy) = start\n    isValid (x, y) = x > 0 && x <= n && y > 0 && y <= m"}
{"task_id": "Haskell/27-1-multi", "prompt": "module Main where\nimport qualified Data.Set as Set\n\ncountMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int\n{-\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n-}", "canonical_solution": "countMazePaths n m t start end obstacles\n  | start == end = 1\n  | otherwise = sum $ map (\\next -> if Set.member next obstacles || not (isValid next)\n                                    then 0\n                                    else countMazePaths n m t next end (Set.insert start obstacles))\n                          [(sx-1, sy), (sx+1, sy), (sx, sy-1), (sx, sy+1)]\n  where\n    (sx, sy) = start\n    isValid (x, y) = x > 0 && x <= n && y > 0 && y <= m", "test": "check :: (Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int) -> IO ()\ncheck countMazePathsFunc = do\n  let testCases =\n        [ ((3, 3, 1, (1, 1), (3, 3), Set.fromList [(2, 2)]), 2),\n          ((4, 4, 2, (1, 1), (4, 4), Set.fromList [(2, 2), (3, 3)]), 4),\n          ((2, 3, 0, (1, 1), (2, 3), Set.empty), 4)\n        ]\n\n  mapM_ (\\(params, expected) -> testCase params expected) testCases\n  where\n    testCase (n, m, t, start, end, obstacles) expected = do\n      let result = countMazePathsFunc n m t start end obstacles\n      putStrLn $\n        \"Input: \" ++ show (n, m, t, start, end, obstacles) ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countMazePaths", "entry_point": "countMazePaths", "signature": "countMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int", "docstring": "\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n\n\n* Incomplete Code:\ncountMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int\ncountMazePaths n m t start end obstacles\n[MASK]\n  | otherwise = sum $ map (\\next -> if Set.member next obstacles || not (isValid next)\n                                    then 0\n[MASK]\n                          [(sx-1, sy), (sx+1, sy), (sx, sy-1), (sx, sy+1)]\n[MASK]\n    (sx, sy) = start\n    isValid (x, y) = x > 0 && x <= n && y > 0 && y <= m\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "countMazePaths n m t start end obstacles\n[MASK]\n  | otherwise = sum $ map (\\next -> if Set.member next obstacles || not (isValid next)\n                                    then 0\n[MASK]\n                          [(sx-1, sy), (sx+1, sy), (sx, sy-1), (sx, sy+1)]\n[MASK]\n    (sx, sy) = start\n    isValid (x, y) = x > 0 && x <= n && y > 0 && y <= m"}
{"task_id": "Haskell/28-0-multi", "prompt": "module Main where\nimport Data.List (sort)\n\nmaxRemovableLamps :: Int -> Int -> [Int] -> Int\n{- \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n-}", "canonical_solution": "maxRemovableLamps n dist positions = length $ filter removable (tail $ init sortedPositions)\n  where\n    sortedPositions = sort positions\n    removable p = let\n      left = last $ takeWhile (< p) sortedPositions\n      right = head $ dropWhile (<= p) sortedPositions\n      in right - left <= dist", "test": "check :: (Int -> Int -> [Int] -> Int) -> IO ()\ncheck maxRemovableLampsFunc = do\n  let testCases =\n        [ (3, 3, [1, 2, 3], 1),\n          (5, 2, [1, 3, 4, 6, 8], 0),\n          (4, 5, [2, 5, 7, 12], 1),\n          (6, 4, [3, 5, 8, 12, 16, 20], 0),\n          (3, 10, [5, 15, 25], 0)\n        ]\n\n  mapM_ (\\(n, dist, positions, expected) -> testCase n dist positions expected) testCases\n  where\n    testCase n dist positions expected = do\n      let result = maxRemovableLampsFunc n dist positions\n      putStrLn $\n        \"Input: n=\" ++ show n ++ \", dist=\" ++ show dist ++ \", positions=\" ++ show positions ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check maxRemovableLamps", "entry_point": "maxRemovableLamps", "signature": "maxRemovableLamps :: Int -> Int -> [Int] -> Int", "docstring": " \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n\n\n* Incomplete Code:\nmaxRemovableLamps :: Int -> Int -> [Int] -> Int\nmaxRemovableLamps n dist positions = length $ filter removable (tail $ init sortedPositions)\n  where\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "maxRemovableLamps n dist positions = length $ filter removable (tail $ init sortedPositions)\n  where\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n[MASK]"}
{"task_id": "Haskell/28-1-multi", "prompt": "module Main where\nimport Data.List (sort)\n\nmaxRemovableLamps :: Int -> Int -> [Int] -> Int\n{- \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n-}", "canonical_solution": "maxRemovableLamps n dist positions = length $ filter removable (tail $ init sortedPositions)\n  where\n    sortedPositions = sort positions\n    removable p = let\n      left = last $ takeWhile (< p) sortedPositions\n      right = head $ dropWhile (<= p) sortedPositions\n      in right - left <= dist", "test": "check :: (Int -> Int -> [Int] -> Int) -> IO ()\ncheck maxRemovableLampsFunc = do\n  let testCases =\n        [ (3, 3, [1, 2, 3], 1),\n          (5, 2, [1, 3, 4, 6, 8], 0),\n          (4, 5, [2, 5, 7, 12], 1),\n          (6, 4, [3, 5, 8, 12, 16, 20], 0),\n          (3, 10, [5, 15, 25], 0)\n        ]\n\n  mapM_ (\\(n, dist, positions, expected) -> testCase n dist positions expected) testCases\n  where\n    testCase n dist positions expected = do\n      let result = maxRemovableLampsFunc n dist positions\n      putStrLn $\n        \"Input: n=\" ++ show n ++ \", dist=\" ++ show dist ++ \", positions=\" ++ show positions ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check maxRemovableLamps", "entry_point": "maxRemovableLamps", "signature": "maxRemovableLamps :: Int -> Int -> [Int] -> Int", "docstring": " \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n\n\n* Incomplete Code:\nmaxRemovableLamps :: Int -> Int -> [Int] -> Int\n[MASK]\n  where\n    sortedPositions = sort positions\n    removable p = let\n      left = last $ takeWhile (< p) sortedPositions\n[MASK]\n      in right - left <= dist\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n  where\n    sortedPositions = sort positions\n    removable p = let\n      left = last $ takeWhile (< p) sortedPositions\n[MASK]\n      in right - left <= dist"}
{"task_id": "Haskell/30-0-multi", "prompt": "module Main where\n\nimport Data.List (permutations, nub, sort)\n\nfindNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]\n{- \n  Finds all possible sets of three 3-digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n-}", "canonical_solution": "findNumberTriplets (a, b, c) = nub [ (x, y, z) | \n    p <- permutations [1..9], \n    let x = toNumber (take 3 p),\n    let y = toNumber (take 3 $ drop 3 p),\n    let z = toNumber (drop 6 p),\n    a * y == b * x, \n    a * z == c * x ]\n\ntoNumber :: [Int] -> Int\ntoNumber = foldl (\\acc x -> acc * 10 + x) 0", "test": "check :: ((Int, Int, Int) -> [(Int, Int, Int)]) -> IO ()\ncheck findNumberTripletsFunc = do\n  let testCases =\n        [ ((1, 2, 3), [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]),\n          ((2, 5, 7), []),\n          ((3, 3, 3), [])\n        ]\n\n  mapM_ (\\(ratios, expected) -> testCase ratios expected) testCases\n  where\n    testCase ratios expected = do\n      let result = findNumberTripletsFunc ratios\n      putStrLn $\n        \"Input: \" ++ show ratios ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if sort result == sort expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check findNumberTriplets", "entry_point": "findNumberTriplets", "signature": "findNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]", "docstring": " \n  Finds all possible sets of three 3digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Finds all possible sets of three 3digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n\n\n* Incomplete Code:\nfindNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]\nfindNumberTriplets (a, b, c) = nub [ (x, y, z) | \n    p <- permutations [1..9], \n[MASK]\n    let y = toNumber (take 3 $ drop 3 p),\n[MASK]\n[MASK]\n[MASK]\n\ntoNumber :: [Int] -> Int\ntoNumber = foldl (\\acc x -> acc * 10 + x) 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "findNumberTriplets (a, b, c) = nub [ (x, y, z) | \n    p <- permutations [1..9], \n[MASK]\n    let y = toNumber (take 3 $ drop 3 p),\n[MASK]\n[MASK]\n[MASK]\n\ntoNumber :: [Int] -> Int\ntoNumber = foldl (\\acc x -> acc * 10 + x) 0"}
{"task_id": "Haskell/30-1-multi", "prompt": "module Main where\n\nimport Data.List (permutations, nub, sort)\n\nfindNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]\n{- \n  Finds all possible sets of three 3-digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n-}", "canonical_solution": "findNumberTriplets (a, b, c) = nub [ (x, y, z) | \n    p <- permutations [1..9], \n    let x = toNumber (take 3 p),\n    let y = toNumber (take 3 $ drop 3 p),\n    let z = toNumber (drop 6 p),\n    a * y == b * x, \n    a * z == c * x ]\n\ntoNumber :: [Int] -> Int\ntoNumber = foldl (\\acc x -> acc * 10 + x) 0", "test": "check :: ((Int, Int, Int) -> [(Int, Int, Int)]) -> IO ()\ncheck findNumberTripletsFunc = do\n  let testCases =\n        [ ((1, 2, 3), [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]),\n          ((2, 5, 7), []),\n          ((3, 3, 3), [])\n        ]\n\n  mapM_ (\\(ratios, expected) -> testCase ratios expected) testCases\n  where\n    testCase ratios expected = do\n      let result = findNumberTripletsFunc ratios\n      putStrLn $\n        \"Input: \" ++ show ratios ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if sort result == sort expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check findNumberTriplets", "entry_point": "findNumberTriplets", "signature": "findNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]", "docstring": " \n  Finds all possible sets of three 3digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Finds all possible sets of three 3digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n\n\n* Incomplete Code:\nfindNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]\nfindNumberTriplets (a, b, c) = nub [ (x, y, z) | \n    p <- permutations [1..9], \n    let x = toNumber (take 3 p),\n[MASK]\n[MASK]\n[MASK]\n    a * z == c * x ]\n\ntoNumber :: [Int] -> Int\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "findNumberTriplets (a, b, c) = nub [ (x, y, z) | \n    p <- permutations [1..9], \n    let x = toNumber (take 3 p),\n[MASK]\n[MASK]\n[MASK]\n    a * z == c * x ]\n\ntoNumber :: [Int] -> Int\n[MASK]"}
{"task_id": "Haskell/31-0-multi", "prompt": "module Main where\ncollatzSequence :: Int -> [Int]\n{- \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n-}", "canonical_solution": "collatzSequence n = reverse $ collatz n\n  where\n    collatz 1 = [1]\n    collatz x\n      | even x = x : collatz (x `div` 2)\n      | otherwise = x : collatz (3 * x + 1)", "test": "check :: (Int -> [Int]) -> IO ()\ncheck collatzSequenceFunc = do\n  let testCases =\n        [ (6, [1, 2, 4, 8,16, 5, 10, 3, 6]),\n          (15, [1,2,4,8,16,5,10,20,40,80,160,53,106,35,70,23,46,15]),\n          (1, [1])\n        ]\n\n  mapM_ (\\(input, expected) -> testCase input expected) testCases\n  where\n    testCase input expected = do\n      let result = collatzSequenceFunc input\n      putStrLn $\n        \"Input: \" ++ show input ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check collatzSequence", "entry_point": "collatzSequence", "signature": "collatzSequence :: Int -> [Int]", "docstring": " \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n\n\n* Incomplete Code:\ncollatzSequence :: Int -> [Int]\ncollatzSequence n = reverse $ collatz n\n[MASK]\n[MASK]\n[MASK]\n      | even x = x : collatz (x `div` 2)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "collatzSequence n = reverse $ collatz n\n[MASK]\n[MASK]\n[MASK]\n      | even x = x : collatz (x `div` 2)\n[MASK]"}
{"task_id": "Haskell/31-1-multi", "prompt": "module Main where\ncollatzSequence :: Int -> [Int]\n{- \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n-}", "canonical_solution": "collatzSequence n = reverse $ collatz n\n  where\n    collatz 1 = [1]\n    collatz x\n      | even x = x : collatz (x `div` 2)\n      | otherwise = x : collatz (3 * x + 1)", "test": "check :: (Int -> [Int]) -> IO ()\ncheck collatzSequenceFunc = do\n  let testCases =\n        [ (6, [1, 2, 4, 8,16, 5, 10, 3, 6]),\n          (15, [1,2,4,8,16,5,10,20,40,80,160,53,106,35,70,23,46,15]),\n          (1, [1])\n        ]\n\n  mapM_ (\\(input, expected) -> testCase input expected) testCases\n  where\n    testCase input expected = do\n      let result = collatzSequenceFunc input\n      putStrLn $\n        \"Input: \" ++ show input ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check collatzSequence", "entry_point": "collatzSequence", "signature": "collatzSequence :: Int -> [Int]", "docstring": " \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n\n\n* Incomplete Code:\ncollatzSequence :: Int -> [Int]\ncollatzSequence n = reverse $ collatz n\n  where\n    collatz 1 = [1]\n[MASK]\n[MASK]\n      | otherwise = x : collatz (3 * x + 1)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "collatzSequence n = reverse $ collatz n\n  where\n    collatz 1 = [1]\n[MASK]\n[MASK]\n      | otherwise = x : collatz (3 * x + 1)"}
{"task_id": "Haskell/35-0-multi", "prompt": "module Main where\ndaysInMonth :: Int -> Int -> Int\n{- \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n-}", "canonical_solution": "isLeapYear :: Int -> Bool\nisLeapYear year = (year `mod` 4 == 0 && year `mod` 100 /= 0) || year `mod` 400 == 0\n\ndaysInMonth year month\n  | month `elem` [1, 3, 5, 7, 8, 10, 12] = 31\n  | month `elem` [4, 6, 9, 11]           = 30\n  | month == 2 && isLeapYear year        = 29\n  | otherwise                             = 28", "test": "check :: (Int -> Int -> Int) -> IO ()\ncheck daysInMonthFunc = do\n  let testCases =\n        [ ((2021, 2), 28),\n          ((2024, 2), 29),\n          ((2021, 4), 30),\n          ((2021, 12), 31),\n          ((1900, 2), 28),\n          ((2000, 2), 29)\n        ]\n\n  mapM_ (\\((year, month), expected) -> testCase year month expected) testCases\n  where\n    testCase year month expected = do\n      let result = daysInMonthFunc year month\n      putStrLn $\n        \"Input: Year \" ++ show year ++ \" Month \" ++ show month ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check daysInMonth", "entry_point": "daysInMonth", "signature": "daysInMonth :: Int -> Int -> Int", "docstring": " \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n\n\n* Incomplete Code:\ndaysInMonth :: Int -> Int -> Int\nisLeapYear :: Int -> Bool\nisLeapYear year = (year `mod` 4 == 0 && year `mod` 100 /= 0) || year `mod` 400 == 0\n\ndaysInMonth year month\n[MASK]\n  | month `elem` [4, 6, 9, 11]           = 30\n  | month == 2 && isLeapYear year        = 29\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "isLeapYear :: Int -> Bool\nisLeapYear year = (year `mod` 4 == 0 && year `mod` 100 /= 0) || year `mod` 400 == 0\n\ndaysInMonth year month\n[MASK]\n  | month `elem` [4, 6, 9, 11]           = 30\n  | month == 2 && isLeapYear year        = 29\n[MASK]"}
{"task_id": "Haskell/35-1-multi", "prompt": "module Main where\ndaysInMonth :: Int -> Int -> Int\n{- \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n-}", "canonical_solution": "isLeapYear :: Int -> Bool\nisLeapYear year = (year `mod` 4 == 0 && year `mod` 100 /= 0) || year `mod` 400 == 0\n\ndaysInMonth year month\n  | month `elem` [1, 3, 5, 7, 8, 10, 12] = 31\n  | month `elem` [4, 6, 9, 11]           = 30\n  | month == 2 && isLeapYear year        = 29\n  | otherwise                             = 28", "test": "check :: (Int -> Int -> Int) -> IO ()\ncheck daysInMonthFunc = do\n  let testCases =\n        [ ((2021, 2), 28),\n          ((2024, 2), 29),\n          ((2021, 4), 30),\n          ((2021, 12), 31),\n          ((1900, 2), 28),\n          ((2000, 2), 29)\n        ]\n\n  mapM_ (\\((year, month), expected) -> testCase year month expected) testCases\n  where\n    testCase year month expected = do\n      let result = daysInMonthFunc year month\n      putStrLn $\n        \"Input: Year \" ++ show year ++ \" Month \" ++ show month ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check daysInMonth", "entry_point": "daysInMonth", "signature": "daysInMonth :: Int -> Int -> Int", "docstring": " \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n\n\n* Incomplete Code:\ndaysInMonth :: Int -> Int -> Int\n[MASK]\nisLeapYear year = (year `mod` 4 == 0 && year `mod` 100 /= 0) || year `mod` 400 == 0\n\n[MASK]\n  | month `elem` [1, 3, 5, 7, 8, 10, 12] = 31\n[MASK]\n  | month == 2 && isLeapYear year        = 29\n  | otherwise                             = 28\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\nisLeapYear year = (year `mod` 4 == 0 && year `mod` 100 /= 0) || year `mod` 400 == 0\n\n[MASK]\n  | month `elem` [1, 3, 5, 7, 8, 10, 12] = 31\n[MASK]\n  | month == 2 && isLeapYear year        = 29\n  | otherwise                             = 28"}
{"task_id": "Haskell/37-0-multi", "prompt": "module Main where\n\naverageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)\n{- \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n  -- 2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n  -- 1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n-}", "canonical_solution": "averageOfDivisibleAndNonDivisible n k = (average aClass, average bClass)\n  where\n    numbers = [1..n]\n    aClass = filter (\\x -> x `mod` k == 0) numbers\n    bClass = filter (\\x -> x `mod` k /= 0) numbers\n    average xs = fromIntegral (sum xs) / fromIntegral (length xs)", "test": "check :: (Int -> Int -> (Float, Float)) -> IO ()\ncheck averageFunc = do\n  let testCases =\n        [ ((10, 2), (6.0, 5.0)),\n          ((15, 5), (10.0, 7.5)),\n          ((20, 4), (12.0, 10.0)),\n          ((9, 3), (6.0, 4.5))\n        ]\n\n  mapM_ (\\((n, k), (expectedA, expectedB)) -> testCase n k expectedA expectedB) testCases\n  where\n    testCase n k expectedA expectedB = do\n      let (resultA, resultB) = averageFunc n k\n      putStrLn $\n        \"Input: \" ++ show (n, k) ++\n        \", Expected A: \" ++ show expectedA ++ \", Result A: \" ++ show resultA ++\n        \", Expected B: \" ++ show expectedB ++ \", Result B: \" ++ show resultB ++\n        if (resultA, resultB) == (expectedA, expectedB) then \" (Pass)\" else error \"Test failed. Exiting...\"\nmain :: IO ()\nmain = check averageOfDivisibleAndNonDivisible", "entry_point": "averageOfDivisibleAndNonDivisible", "signature": "averageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)", "docstring": " \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n   2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n   1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n   2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n   1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n\n\n* Incomplete Code:\naverageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)\naverageOfDivisibleAndNonDivisible n k = (average aClass, average bClass)\n[MASK]\n    numbers = [1..n]\n    aClass = filter (\\x -> x `mod` k == 0) numbers\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "averageOfDivisibleAndNonDivisible n k = (average aClass, average bClass)\n[MASK]\n    numbers = [1..n]\n    aClass = filter (\\x -> x `mod` k == 0) numbers\n[MASK]\n[MASK]"}
{"task_id": "Haskell/37-1-multi", "prompt": "module Main where\n\naverageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)\n{- \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n  -- 2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n  -- 1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n-}", "canonical_solution": "averageOfDivisibleAndNonDivisible n k = (average aClass, average bClass)\n  where\n    numbers = [1..n]\n    aClass = filter (\\x -> x `mod` k == 0) numbers\n    bClass = filter (\\x -> x `mod` k /= 0) numbers\n    average xs = fromIntegral (sum xs) / fromIntegral (length xs)", "test": "check :: (Int -> Int -> (Float, Float)) -> IO ()\ncheck averageFunc = do\n  let testCases =\n        [ ((10, 2), (6.0, 5.0)),\n          ((15, 5), (10.0, 7.5)),\n          ((20, 4), (12.0, 10.0)),\n          ((9, 3), (6.0, 4.5))\n        ]\n\n  mapM_ (\\((n, k), (expectedA, expectedB)) -> testCase n k expectedA expectedB) testCases\n  where\n    testCase n k expectedA expectedB = do\n      let (resultA, resultB) = averageFunc n k\n      putStrLn $\n        \"Input: \" ++ show (n, k) ++\n        \", Expected A: \" ++ show expectedA ++ \", Result A: \" ++ show resultA ++\n        \", Expected B: \" ++ show expectedB ++ \", Result B: \" ++ show resultB ++\n        if (resultA, resultB) == (expectedA, expectedB) then \" (Pass)\" else error \"Test failed. Exiting...\"\nmain :: IO ()\nmain = check averageOfDivisibleAndNonDivisible", "entry_point": "averageOfDivisibleAndNonDivisible", "signature": "averageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)", "docstring": " \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n   2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n   1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n   2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n   1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n\n\n* Incomplete Code:\naverageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)\naverageOfDivisibleAndNonDivisible n k = (average aClass, average bClass)\n[MASK]\n[MASK]\n    aClass = filter (\\x -> x `mod` k == 0) numbers\n[MASK]\n    average xs = fromIntegral (sum xs) / fromIntegral (length xs)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "averageOfDivisibleAndNonDivisible n k = (average aClass, average bClass)\n[MASK]\n[MASK]\n    aClass = filter (\\x -> x `mod` k == 0) numbers\n[MASK]\n    average xs = fromIntegral (sum xs) / fromIntegral (length xs)"}
{"task_id": "Haskell/42-0-multi", "prompt": "signOfNumber :: Int -> String\n{- \n  Determines whether a given integer is positive, negative, or zero.\n  Returns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n  \n  Examples:\n  >>> signOfNumber 95\n  \"positive\"\n  >>> signOfNumber (-5)\n  \"negative\"\n  >>> signOfNumber 0\n  \"zero\"\n-}", "canonical_solution": "signOfNumber n\n  | n > 0 = \"positive\"\n  | n == 0 = \"zero\"\n  | otherwise = \"negative\"", "test": "check :: (Int -> String) -> IO ()\ncheck signOfNumberFunc = do\n  let testCases = \n        [ (95, \"positive\"),\n          (-5, \"negative\"),\n          (0, \"zero\"),\n          (-1000000000, \"negative\"),\n          (1000000000, \"positive\")\n        ]\n\n  mapM_ (\\(number, expected) -> testCase number expected) testCases\n  where\n    testCase number expected = do\n      let result = signOfNumberFunc number\n      putStrLn $\n        \"Input: \" ++ show number ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check signOfNumber", "entry_point": "signOfNumber", "signature": "signOfNumber :: Int -> String", "docstring": " \nDetermines whether a given integer is positive, negative, or zero.\nReturns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n\nExamples:\n>>> signOfNumber 95\n\"positive\"\n>>> signOfNumber (-5)\n\"negative\"\n>>> signOfNumber 0\n\"zero\"\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \nDetermines whether a given integer is positive, negative, or zero.\nReturns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n\nExamples:\n>>> signOfNumber 95\n\"positive\"\n>>> signOfNumber (-5)\n\"negative\"\n>>> signOfNumber 0\n\"zero\"\n\n\n* Incomplete Code:\nsignOfNumber :: Int -> String\n[MASK]\n  | n > 0 = \"positive\"\n  | n == 0 = \"zero\"\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n  | n > 0 = \"positive\"\n  | n == 0 = \"zero\"\n[MASK]"}
{"task_id": "Haskell/42-1-multi", "prompt": "signOfNumber :: Int -> String\n{- \n  Determines whether a given integer is positive, negative, or zero.\n  Returns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n  \n  Examples:\n  >>> signOfNumber 95\n  \"positive\"\n  >>> signOfNumber (-5)\n  \"negative\"\n  >>> signOfNumber 0\n  \"zero\"\n-}", "canonical_solution": "signOfNumber n\n  | n > 0 = \"positive\"\n  | n == 0 = \"zero\"\n  | otherwise = \"negative\"", "test": "check :: (Int -> String) -> IO ()\ncheck signOfNumberFunc = do\n  let testCases = \n        [ (95, \"positive\"),\n          (-5, \"negative\"),\n          (0, \"zero\"),\n          (-1000000000, \"negative\"),\n          (1000000000, \"positive\")\n        ]\n\n  mapM_ (\\(number, expected) -> testCase number expected) testCases\n  where\n    testCase number expected = do\n      let result = signOfNumberFunc number\n      putStrLn $\n        \"Input: \" ++ show number ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check signOfNumber", "entry_point": "signOfNumber", "signature": "signOfNumber :: Int -> String", "docstring": " \nDetermines whether a given integer is positive, negative, or zero.\nReturns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n\nExamples:\n>>> signOfNumber 95\n\"positive\"\n>>> signOfNumber (-5)\n\"negative\"\n>>> signOfNumber 0\n\"zero\"\n", "instruction": "Below is a explanation of Haskell code and incomplete code implementation.\n\n* Docstring: \n \nDetermines whether a given integer is positive, negative, or zero.\nReturns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n\nExamples:\n>>> signOfNumber 95\n\"positive\"\n>>> signOfNumber (-5)\n\"negative\"\n>>> signOfNumber 0\n\"zero\"\n\n\n* Incomplete Code:\nsignOfNumber :: Int -> String\nsignOfNumber n\n[MASK]\n[MASK]\n  | otherwise = \"negative\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "signOfNumber n\n[MASK]\n[MASK]\n  | otherwise = \"negative\""}
