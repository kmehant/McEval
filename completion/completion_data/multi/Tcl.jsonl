{"task_id": "Tcl/1-0-multi", "prompt": "proc has_close_elements {numbers threshold} {\n# Check if in given list of numbers, are any two numbers closer to each other than\n# given threshold.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True", "canonical_solution": "set length [llength $numbers]\nfor {set idx 0} {$idx < $length} {incr idx} {\nset elem [lindex $numbers $idx]\nfor {set idx2 0} {$idx2 < $length} {incr idx2} {\nset elem2 [lindex $numbers $idx2]\nif {$idx != $idx2} {\nset distance [expr {abs($elem - $elem2)}]\nif {$distance < $threshold} {\nreturn 1\n}\n}\n}\n}\nreturn 0\n}", "test": "# Test cases\nproc check {has_close_elements} {\nif {[has_close_elements {1.0 2.0 3.9 4.0 5.0 2.2} 0.3] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 3.9 4.0 5.0 2.2} 0.05] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.95] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.8] == 0} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 3.0 4.0 5.0 2.0} 0.1] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 1.0] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 0.5] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck has_close_elements", "entry_point": "has_close_elements", "signature": "proc has_close_elements {numbers threshold} {", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n* Incomplete Code:\nproc has_close_elements {numbers threshold} {\nset length [llength $numbers]\n[MASK]\nset elem [lindex $numbers $idx]\nfor {set idx2 0} {$idx2 < $length} {incr idx2} {\n[MASK]\nif {$idx != $idx2} {\nset distance [expr {abs($elem - $elem2)}]\nif {$distance < $threshold} {\nreturn 1\n}\n}\n}\n}\nreturn 0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set length [llength $numbers]\n[MASK]\nset elem [lindex $numbers $idx]\nfor {set idx2 0} {$idx2 < $length} {incr idx2} {\n[MASK]\nif {$idx != $idx2} {\nset distance [expr {abs($elem - $elem2)}]\nif {$distance < $threshold} {\nreturn 1\n}\n}\n}\n}\nreturn 0\n}"}
{"task_id": "Tcl/1-1-multi", "prompt": "proc has_close_elements {numbers threshold} {\n# Check if in given list of numbers, are any two numbers closer to each other than\n# given threshold.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True", "canonical_solution": "set length [llength $numbers]\nfor {set idx 0} {$idx < $length} {incr idx} {\nset elem [lindex $numbers $idx]\nfor {set idx2 0} {$idx2 < $length} {incr idx2} {\nset elem2 [lindex $numbers $idx2]\nif {$idx != $idx2} {\nset distance [expr {abs($elem - $elem2)}]\nif {$distance < $threshold} {\nreturn 1\n}\n}\n}\n}\nreturn 0\n}", "test": "# Test cases\nproc check {has_close_elements} {\nif {[has_close_elements {1.0 2.0 3.9 4.0 5.0 2.2} 0.3] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 3.9 4.0 5.0 2.2} 0.05] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.95] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.8] == 0} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 3.0 4.0 5.0 2.0} 0.1] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 1.0] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 0.5] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck has_close_elements", "entry_point": "has_close_elements", "signature": "proc has_close_elements {numbers threshold} {", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n* Incomplete Code:\nproc has_close_elements {numbers threshold} {\n[MASK]\n[MASK]\nset elem [lindex $numbers $idx]\nfor {set idx2 0} {$idx2 < $length} {incr idx2} {\n[MASK]\nif {$idx != $idx2} {\nset distance [expr {abs($elem - $elem2)}]\nif {$distance < $threshold} {\nreturn 1\n}\n}\n}\n}\nreturn 0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\nset elem [lindex $numbers $idx]\nfor {set idx2 0} {$idx2 < $length} {incr idx2} {\n[MASK]\nif {$idx != $idx2} {\nset distance [expr {abs($elem - $elem2)}]\nif {$distance < $threshold} {\nreturn 1\n}\n}\n}\n}\nreturn 0\n}"}
{"task_id": "Tcl/2-0-multi", "prompt": "proc find_third_largest {numbers} {\n# This function returns the third largest number in a non-empty array.\n# If the third largest number does not exist, it returns the largest number.\n# Examples:\n# >>> find_third_largest [1, 2, 3, 4, 5]\n# 3\n# >>> find_third_largest [12, 35, 1, 10, 34, 1]\n# 12\n# >>> find_third_largest [10, 10, 10]\n# 10", "canonical_solution": "set unique_numbers [lsort -unique -decreasing $numbers]\nif {[llength $unique_numbers] < 3} {\nreturn [lindex $unique_numbers 0]\n} else {\nreturn [lindex $unique_numbers 2]\n}\n}", "test": "proc check {find_third_largest} {\nif {[find_third_largest {5 4 3 2 1}] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_third_largest {10 10 10 10}] == 10} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_third_largest {5 7 3 9 6}] == 6} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_third_largest {1 2}] == 2} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_third_largest {20 10 20 30 40}] == 20} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_third_largest {1}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_third_largest {-1 -2 -3 -4}] == -2} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_third_largest", "entry_point": "find_third_largest", "signature": "proc find_third_largest {numbers} {", "docstring": "This function returns the third largest number in a non-empty array.\nIf the third largest number does not exist, it returns the largest number.\nExamples:\n>>> find_third_largest [1, 2, 3, 4, 5]\n3\n>>> find_third_largest [12, 35, 1, 10, 34, 1]\n12\n>>> find_third_largest [10, 10, 10]\n10", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function returns the third largest number in a non-empty array.\nIf the third largest number does not exist, it returns the largest number.\nExamples:\n>>> find_third_largest [1, 2, 3, 4, 5]\n3\n>>> find_third_largest [12, 35, 1, 10, 34, 1]\n12\n>>> find_third_largest [10, 10, 10]\n10\n\n* Incomplete Code:\nproc find_third_largest {numbers} {\n[MASK]\nif {[llength $unique_numbers] < 3} {\n[MASK]\n} else {\n[MASK]\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nif {[llength $unique_numbers] < 3} {\n[MASK]\n} else {\n[MASK]\n}\n}"}
{"task_id": "Tcl/2-1-multi", "prompt": "proc find_third_largest {numbers} {\n# This function returns the third largest number in a non-empty array.\n# If the third largest number does not exist, it returns the largest number.\n# Examples:\n# >>> find_third_largest [1, 2, 3, 4, 5]\n# 3\n# >>> find_third_largest [12, 35, 1, 10, 34, 1]\n# 12\n# >>> find_third_largest [10, 10, 10]\n# 10", "canonical_solution": "set unique_numbers [lsort -unique -decreasing $numbers]\nif {[llength $unique_numbers] < 3} {\nreturn [lindex $unique_numbers 0]\n} else {\nreturn [lindex $unique_numbers 2]\n}\n}", "test": "proc check {find_third_largest} {\nif {[find_third_largest {5 4 3 2 1}] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_third_largest {10 10 10 10}] == 10} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_third_largest {5 7 3 9 6}] == 6} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_third_largest {1 2}] == 2} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_third_largest {20 10 20 30 40}] == 20} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_third_largest {1}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_third_largest {-1 -2 -3 -4}] == -2} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_third_largest", "entry_point": "find_third_largest", "signature": "proc find_third_largest {numbers} {", "docstring": "This function returns the third largest number in a non-empty array.\nIf the third largest number does not exist, it returns the largest number.\nExamples:\n>>> find_third_largest [1, 2, 3, 4, 5]\n3\n>>> find_third_largest [12, 35, 1, 10, 34, 1]\n12\n>>> find_third_largest [10, 10, 10]\n10", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function returns the third largest number in a non-empty array.\nIf the third largest number does not exist, it returns the largest number.\nExamples:\n>>> find_third_largest [1, 2, 3, 4, 5]\n3\n>>> find_third_largest [12, 35, 1, 10, 34, 1]\n12\n>>> find_third_largest [10, 10, 10]\n10\n\n* Incomplete Code:\nproc find_third_largest {numbers} {\nset unique_numbers [lsort -unique -decreasing $numbers]\nif {[llength $unique_numbers] < 3} {\nreturn [lindex $unique_numbers 0]\n[MASK]\n[MASK]\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set unique_numbers [lsort -unique -decreasing $numbers]\nif {[llength $unique_numbers] < 3} {\nreturn [lindex $unique_numbers 0]\n[MASK]\n[MASK]\n}\n}"}
{"task_id": "Tcl/3-0-multi", "prompt": "proc is_covered {ranges left right} {\n# Check if every integer in the interval [left, right] is covered\n# by at least one interval in 'ranges'.\n# Each element in 'ranges' is a two-element list [start, end] representing\n# a closed interval.\n# >>> is_covered {{1 2} {3 4} {5 6}} 2 5\n# True\n# >>> is_covered {{1 10} {10 20}} 10 15\n# True\n# >>> is_covered {{1 5} {10 15}} 5 10\n# False", "canonical_solution": "for {set num $left} {$num <= $right} {incr num} {\nset covered 0\nforeach range $ranges {\nif {$num >= [lindex $range 0] && $num <= [lindex $range 1]} {\nset covered 1\nbreak\n}\n}\nif {!$covered} {\nreturn 0\n}\n}\n\nreturn 1\n}", "test": "proc check {is_covered} {\nif {[is_covered {{1 2} {3 4} {5 6}} 2 5] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[is_covered {{1 10} {10 20}} 10 15] == 1} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[is_covered {{1 5} {10 15}} 5 10] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[is_covered {{1 3} {4 6} {7 9}} 1 9] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[is_covered {{5 10}} 1 4] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[is_covered {{0 0} {2 2} {4 4}} 0 4] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[is_covered {{10 20} {20 30} {30 40}} 15 25] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck is_covered", "entry_point": "is_covered", "signature": "proc is_covered {ranges left right} {", "docstring": "Check if every integer in the interval [left, right] is covered\nby at least one interval in 'ranges'.\nEach element in 'ranges' is a two-element list [start, end] representing\na closed interval.\n>>> is_covered {{1 2} {3 4} {5 6}} 2 5\nTrue\n>>> is_covered {{1 10} {10 20}} 10 15\nTrue\n>>> is_covered {{1 5} {10 15}} 5 10\nFalse", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if every integer in the interval [left, right] is covered\nby at least one interval in 'ranges'.\nEach element in 'ranges' is a two-element list [start, end] representing\na closed interval.\n>>> is_covered {{1 2} {3 4} {5 6}} 2 5\nTrue\n>>> is_covered {{1 10} {10 20}} 10 15\nTrue\n>>> is_covered {{1 5} {10 15}} 5 10\nFalse\n\n* Incomplete Code:\nproc is_covered {ranges left right} {\n[MASK]\nset covered 0\n[MASK]\n[MASK]\nset covered 1\nbreak\n}\n}\nif {!$covered} {\n[MASK]\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset covered 0\n[MASK]\n[MASK]\nset covered 1\nbreak\n}\n}\nif {!$covered} {\n[MASK]\n}\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/3-1-multi", "prompt": "proc is_covered {ranges left right} {\n# Check if every integer in the interval [left, right] is covered\n# by at least one interval in 'ranges'.\n# Each element in 'ranges' is a two-element list [start, end] representing\n# a closed interval.\n# >>> is_covered {{1 2} {3 4} {5 6}} 2 5\n# True\n# >>> is_covered {{1 10} {10 20}} 10 15\n# True\n# >>> is_covered {{1 5} {10 15}} 5 10\n# False", "canonical_solution": "for {set num $left} {$num <= $right} {incr num} {\nset covered 0\nforeach range $ranges {\nif {$num >= [lindex $range 0] && $num <= [lindex $range 1]} {\nset covered 1\nbreak\n}\n}\nif {!$covered} {\nreturn 0\n}\n}\n\nreturn 1\n}", "test": "proc check {is_covered} {\nif {[is_covered {{1 2} {3 4} {5 6}} 2 5] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[is_covered {{1 10} {10 20}} 10 15] == 1} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[is_covered {{1 5} {10 15}} 5 10] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[is_covered {{1 3} {4 6} {7 9}} 1 9] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[is_covered {{5 10}} 1 4] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[is_covered {{0 0} {2 2} {4 4}} 0 4] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[is_covered {{10 20} {20 30} {30 40}} 15 25] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck is_covered", "entry_point": "is_covered", "signature": "proc is_covered {ranges left right} {", "docstring": "Check if every integer in the interval [left, right] is covered\nby at least one interval in 'ranges'.\nEach element in 'ranges' is a two-element list [start, end] representing\na closed interval.\n>>> is_covered {{1 2} {3 4} {5 6}} 2 5\nTrue\n>>> is_covered {{1 10} {10 20}} 10 15\nTrue\n>>> is_covered {{1 5} {10 15}} 5 10\nFalse", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if every integer in the interval [left, right] is covered\nby at least one interval in 'ranges'.\nEach element in 'ranges' is a two-element list [start, end] representing\na closed interval.\n>>> is_covered {{1 2} {3 4} {5 6}} 2 5\nTrue\n>>> is_covered {{1 10} {10 20}} 10 15\nTrue\n>>> is_covered {{1 5} {10 15}} 5 10\nFalse\n\n* Incomplete Code:\nproc is_covered {ranges left right} {\nfor {set num $left} {$num <= $right} {incr num} {\nset covered 0\n[MASK]\nif {$num >= [lindex $range 0] && $num <= [lindex $range 1]} {\n[MASK]\nbreak\n}\n}\n[MASK]\n[MASK]\n}\n}\n\nreturn 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "for {set num $left} {$num <= $right} {incr num} {\nset covered 0\n[MASK]\nif {$num >= [lindex $range 0] && $num <= [lindex $range 1]} {\n[MASK]\nbreak\n}\n}\n[MASK]\n[MASK]\n}\n}\n\nreturn 1\n}"}
{"task_id": "Tcl/4-0-multi", "prompt": "proc can_be_increasing {nums} {\n# Check if removing exactly one element from 'nums' makes it strictly increasing.\n# If the array is already strictly increasing, return true.\n# >>> can_be_increasing {1 3 2 4}\n# True\n# >>> can_be_increasing {2 3 1 2}\n# False\n# >>> can_be_increasing {1 2 3}\n# True", "canonical_solution": "set length [llength $nums]\nset remove_count 0\n\nfor {set i 1} {$i < $length} {incr i} {\nif {[lindex $nums $i] <= [lindex $nums [expr {$i - 1}]]} {\nincr remove_count\nif {$remove_count > 1} {\nreturn 0\n}\nif {$i > 1 && $i < $length - 1 && [lindex $nums $i] <= [lindex $nums [expr {$i - 2}]] && [lindex $nums [expr {$i + 1}]] <= [lindex $nums [expr {$i - 1}]]} {\nreturn 0\n}\n}\n}\nreturn 1\n}", "test": "proc check {can_be_increasing} {\nif {[can_be_increasing {1 3 2 4}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[can_be_increasing {2 3 1 2}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[can_be_increasing {1 2 3}] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[can_be_increasing {10 1 2 3 4}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[can_be_increasing {1 2 10 3 4}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[can_be_increasing {1 2 3 4 3}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[can_be_increasing {5 4 3 2 1}] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck can_be_increasing", "entry_point": "can_be_increasing", "signature": "proc can_be_increasing {nums} {", "docstring": "Check if removing exactly one element from 'nums' makes it strictly increasing.\nIf the array is already strictly increasing, return true.\n>>> can_be_increasing {1 3 2 4}\nTrue\n>>> can_be_increasing {2 3 1 2}\nFalse\n>>> can_be_increasing {1 2 3}\nTrue", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if removing exactly one element from 'nums' makes it strictly increasing.\nIf the array is already strictly increasing, return true.\n>>> can_be_increasing {1 3 2 4}\nTrue\n>>> can_be_increasing {2 3 1 2}\nFalse\n>>> can_be_increasing {1 2 3}\nTrue\n\n* Incomplete Code:\nproc can_be_increasing {nums} {\nset length [llength $nums]\n[MASK]\n\n[MASK]\nif {[lindex $nums $i] <= [lindex $nums [expr {$i - 1}]]} {\nincr remove_count\nif {$remove_count > 1} {\nreturn 0\n}\n[MASK]\nreturn 0\n}\n}\n}\nreturn 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set length [llength $nums]\n[MASK]\n\n[MASK]\nif {[lindex $nums $i] <= [lindex $nums [expr {$i - 1}]]} {\nincr remove_count\nif {$remove_count > 1} {\nreturn 0\n}\n[MASK]\nreturn 0\n}\n}\n}\nreturn 1\n}"}
{"task_id": "Tcl/4-1-multi", "prompt": "proc can_be_increasing {nums} {\n# Check if removing exactly one element from 'nums' makes it strictly increasing.\n# If the array is already strictly increasing, return true.\n# >>> can_be_increasing {1 3 2 4}\n# True\n# >>> can_be_increasing {2 3 1 2}\n# False\n# >>> can_be_increasing {1 2 3}\n# True", "canonical_solution": "set length [llength $nums]\nset remove_count 0\n\nfor {set i 1} {$i < $length} {incr i} {\nif {[lindex $nums $i] <= [lindex $nums [expr {$i - 1}]]} {\nincr remove_count\nif {$remove_count > 1} {\nreturn 0\n}\nif {$i > 1 && $i < $length - 1 && [lindex $nums $i] <= [lindex $nums [expr {$i - 2}]] && [lindex $nums [expr {$i + 1}]] <= [lindex $nums [expr {$i - 1}]]} {\nreturn 0\n}\n}\n}\nreturn 1\n}", "test": "proc check {can_be_increasing} {\nif {[can_be_increasing {1 3 2 4}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[can_be_increasing {2 3 1 2}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[can_be_increasing {1 2 3}] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[can_be_increasing {10 1 2 3 4}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[can_be_increasing {1 2 10 3 4}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[can_be_increasing {1 2 3 4 3}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[can_be_increasing {5 4 3 2 1}] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck can_be_increasing", "entry_point": "can_be_increasing", "signature": "proc can_be_increasing {nums} {", "docstring": "Check if removing exactly one element from 'nums' makes it strictly increasing.\nIf the array is already strictly increasing, return true.\n>>> can_be_increasing {1 3 2 4}\nTrue\n>>> can_be_increasing {2 3 1 2}\nFalse\n>>> can_be_increasing {1 2 3}\nTrue", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if removing exactly one element from 'nums' makes it strictly increasing.\nIf the array is already strictly increasing, return true.\n>>> can_be_increasing {1 3 2 4}\nTrue\n>>> can_be_increasing {2 3 1 2}\nFalse\n>>> can_be_increasing {1 2 3}\nTrue\n\n* Incomplete Code:\nproc can_be_increasing {nums} {\nset length [llength $nums]\nset remove_count 0\n\nfor {set i 1} {$i < $length} {incr i} {\n[MASK]\n[MASK]\nif {$remove_count > 1} {\nreturn 0\n}\nif {$i > 1 && $i < $length - 1 && [lindex $nums $i] <= [lindex $nums [expr {$i - 2}]] && [lindex $nums [expr {$i + 1}]] <= [lindex $nums [expr {$i - 1}]]} {\nreturn 0\n}\n}\n}\nreturn 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set length [llength $nums]\nset remove_count 0\n\nfor {set i 1} {$i < $length} {incr i} {\n[MASK]\n[MASK]\nif {$remove_count > 1} {\nreturn 0\n}\nif {$i > 1 && $i < $length - 1 && [lindex $nums $i] <= [lindex $nums [expr {$i - 2}]] && [lindex $nums [expr {$i + 1}]] <= [lindex $nums [expr {$i - 1}]]} {\nreturn 0\n}\n}\n}\nreturn 1\n}"}
{"task_id": "Tcl/5-0-multi", "prompt": "proc build_concatenated_array {nums} {\n# Construct an array 'ans' of length 2n from 'nums' such that \n# ans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\n# The 'ans' array is formed by concatenating two 'nums' arrays.\n# >>> build_concatenated_array {1 2 3}\n# {1 2 3 1 2 3}\n# >>> build_concatenated_array {4 5 6 7}\n# {4 5 6 7 4 5 6 7}", "canonical_solution": "set ans $nums\nforeach num $nums {\nlappend ans $num\n}\nreturn $ans\n}", "test": "proc check {build_concatenated_array} {\nif {[build_concatenated_array {1 2 3}] eq {1 2 3 1 2 3}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[build_concatenated_array {4 5 6 7}] eq {4 5 6 7 4 5 6 7}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[build_concatenated_array {0}] eq {0 0}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[build_concatenated_array {9 8 7 6 5}] eq {9 8 7 6 5 9 8 7 6 5}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[build_concatenated_array {1 1 1 1}] eq {1 1 1 1 1 1 1 1}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[build_concatenated_array {10 20 30}] eq {10 20 30 10 20 30}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[build_concatenated_array {0 0 0 0 0 0}] eq {0 0 0 0 0 0 0 0 0 0 0 0}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck build_concatenated_array", "entry_point": "build_concatenated_array", "signature": "proc build_concatenated_array {nums} {", "docstring": "Construct an array 'ans' of length 2n from 'nums' such that \nans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\nThe 'ans' array is formed by concatenating two 'nums' arrays.\n>>> build_concatenated_array {1 2 3}\n{1 2 3 1 2 3}\n>>> build_concatenated_array {4 5 6 7}\n{4 5 6 7 4 5 6 7}", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nConstruct an array 'ans' of length 2n from 'nums' such that \nans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\nThe 'ans' array is formed by concatenating two 'nums' arrays.\n>>> build_concatenated_array {1 2 3}\n{1 2 3 1 2 3}\n>>> build_concatenated_array {4 5 6 7}\n{4 5 6 7 4 5 6 7}\n\n* Incomplete Code:\nproc build_concatenated_array {nums} {\nset ans $nums\n[MASK]\nlappend ans $num\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set ans $nums\n[MASK]\nlappend ans $num\n}\n[MASK]\n}"}
{"task_id": "Tcl/5-1-multi", "prompt": "proc build_concatenated_array {nums} {\n# Construct an array 'ans' of length 2n from 'nums' such that \n# ans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\n# The 'ans' array is formed by concatenating two 'nums' arrays.\n# >>> build_concatenated_array {1 2 3}\n# {1 2 3 1 2 3}\n# >>> build_concatenated_array {4 5 6 7}\n# {4 5 6 7 4 5 6 7}", "canonical_solution": "set ans $nums\nforeach num $nums {\nlappend ans $num\n}\nreturn $ans\n}", "test": "proc check {build_concatenated_array} {\nif {[build_concatenated_array {1 2 3}] eq {1 2 3 1 2 3}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[build_concatenated_array {4 5 6 7}] eq {4 5 6 7 4 5 6 7}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[build_concatenated_array {0}] eq {0 0}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[build_concatenated_array {9 8 7 6 5}] eq {9 8 7 6 5 9 8 7 6 5}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[build_concatenated_array {1 1 1 1}] eq {1 1 1 1 1 1 1 1}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[build_concatenated_array {10 20 30}] eq {10 20 30 10 20 30}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[build_concatenated_array {0 0 0 0 0 0}] eq {0 0 0 0 0 0 0 0 0 0 0 0}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck build_concatenated_array", "entry_point": "build_concatenated_array", "signature": "proc build_concatenated_array {nums} {", "docstring": "Construct an array 'ans' of length 2n from 'nums' such that \nans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\nThe 'ans' array is formed by concatenating two 'nums' arrays.\n>>> build_concatenated_array {1 2 3}\n{1 2 3 1 2 3}\n>>> build_concatenated_array {4 5 6 7}\n{4 5 6 7 4 5 6 7}", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nConstruct an array 'ans' of length 2n from 'nums' such that \nans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\nThe 'ans' array is formed by concatenating two 'nums' arrays.\n>>> build_concatenated_array {1 2 3}\n{1 2 3 1 2 3}\n>>> build_concatenated_array {4 5 6 7}\n{4 5 6 7 4 5 6 7}\n\n* Incomplete Code:\nproc build_concatenated_array {nums} {\n[MASK]\n[MASK]\nlappend ans $num\n}\nreturn $ans\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\nlappend ans $num\n}\nreturn $ans\n}"}
{"task_id": "Tcl/6-0-multi", "prompt": "proc is_prefix_string {s words} {\n# Check if 's' is a prefix string of 'words'.\n# 's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n# >>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\n# True\n# >>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\n# False", "canonical_solution": "set concatenated \"\"\nforeach word $words {\nappend concatenated $word\nif {$concatenated eq $s} {\nreturn 1\n}\nif {[string length $concatenated] > [string length $s]} {\nbreak\n}\n}\nreturn 0\n}", "test": "proc check {is_prefix_string} {\nif {[is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[is_prefix_string \"hello\" {\"hello\" \"world\"}] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[is_prefix_string \"helloworld\" {\"hello\" \"world\"}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[is_prefix_string \"hell\" {\"hello\" \"world\"}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[is_prefix_string \"\" {\"a\" \"b\" \"c\"}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[is_prefix_string \"abc\" {\"a\" \"b\" \"c\"}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck is_prefix_string", "entry_point": "is_prefix_string", "signature": "proc is_prefix_string {s words} {", "docstring": "Check if 's' is a prefix string of 'words'.\n's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n>>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nTrue\n>>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nFalse", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if 's' is a prefix string of 'words'.\n's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n>>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nTrue\n>>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nFalse\n\n* Incomplete Code:\nproc is_prefix_string {s words} {\nset concatenated \"\"\nforeach word $words {\nappend concatenated $word\n[MASK]\n[MASK]\n}\n[MASK]\nbreak\n}\n}\nreturn 0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set concatenated \"\"\nforeach word $words {\nappend concatenated $word\n[MASK]\n[MASK]\n}\n[MASK]\nbreak\n}\n}\nreturn 0\n}"}
{"task_id": "Tcl/6-1-multi", "prompt": "proc is_prefix_string {s words} {\n# Check if 's' is a prefix string of 'words'.\n# 's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n# >>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\n# True\n# >>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\n# False", "canonical_solution": "set concatenated \"\"\nforeach word $words {\nappend concatenated $word\nif {$concatenated eq $s} {\nreturn 1\n}\nif {[string length $concatenated] > [string length $s]} {\nbreak\n}\n}\nreturn 0\n}", "test": "proc check {is_prefix_string} {\nif {[is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[is_prefix_string \"hello\" {\"hello\" \"world\"}] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[is_prefix_string \"helloworld\" {\"hello\" \"world\"}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[is_prefix_string \"hell\" {\"hello\" \"world\"}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[is_prefix_string \"\" {\"a\" \"b\" \"c\"}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[is_prefix_string \"abc\" {\"a\" \"b\" \"c\"}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck is_prefix_string", "entry_point": "is_prefix_string", "signature": "proc is_prefix_string {s words} {", "docstring": "Check if 's' is a prefix string of 'words'.\n's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n>>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nTrue\n>>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nFalse", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if 's' is a prefix string of 'words'.\n's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n>>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nTrue\n>>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nFalse\n\n* Incomplete Code:\nproc is_prefix_string {s words} {\nset concatenated \"\"\n[MASK]\n[MASK]\n[MASK]\nreturn 1\n}\nif {[string length $concatenated] > [string length $s]} {\nbreak\n}\n}\nreturn 0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set concatenated \"\"\n[MASK]\n[MASK]\n[MASK]\nreturn 1\n}\nif {[string length $concatenated] > [string length $s]} {\nbreak\n}\n}\nreturn 0\n}"}
{"task_id": "Tcl/7-0-multi", "prompt": "proc max_min_gcd {nums} {\n# Find the greatest common divisor of the maximum and minimum numbers in 'nums'.\n# >>> max_min_gcd {2 4 6 8 10}\n# 2 (GCD of 2 and 10)\n# >>> max_min_gcd {7 5 12 16 35}\n# 5 (GCD of 5 and 35)", "canonical_solution": "set max_num [lindex $nums 0]\nset min_num [lindex $nums 0]\nforeach num $nums {\nif {$num > $max_num} {\nset max_num $num\n}\nif {$num < $min_num} {\nset min_num $num\n}\n}\nreturn [gcd $max_num $min_num]\n}\n\nproc gcd {a b} {\n# Helper function to find the greatest common divisor of two numbers.\nwhile {$b != 0} {\nset temp $b\nset b [expr {$a % $b}]\nset a $temp\n}\nreturn $a\n}", "test": "proc check {max_min_gcd} {\nif {[max_min_gcd {2 4 6 8 10}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_min_gcd {7 5 12 16 35}] == 5} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_min_gcd {15 45 75}] == 15} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_min_gcd {11 13 17 19}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_min_gcd {20 40 60 80}] == 20} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_min_gcd {5 5 5 5}] == 5} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_min_gcd {100 200 300 400 500}] == 100} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_min_gcd", "entry_point": "max_min_gcd", "signature": "proc max_min_gcd {nums} {", "docstring": "Find the greatest common divisor of the maximum and minimum numbers in 'nums'.\n>>> max_min_gcd {2 4 6 8 10}\n2 (GCD of 2 and 10)\n>>> max_min_gcd {7 5 12 16 35}\n5 (GCD of 5 and 35)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nFind the greatest common divisor of the maximum and minimum numbers in 'nums'.\n>>> max_min_gcd {2 4 6 8 10}\n2 (GCD of 2 and 10)\n>>> max_min_gcd {7 5 12 16 35}\n5 (GCD of 5 and 35)\n\n* Incomplete Code:\nproc max_min_gcd {nums} {\n[MASK]\nset min_num [lindex $nums 0]\n[MASK]\nif {$num > $max_num} {\n[MASK]\n}\nif {$num < $min_num} {\nset min_num $num\n}\n}\n[MASK]\n}\n\nproc gcd {a b} {\n# Helper function to find the greatest common divisor of two numbers.\nwhile {$b != 0} {\nset temp $b\nset b [expr {$a % $b}]\nset a $temp\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\nset min_num [lindex $nums 0]\n[MASK]\nif {$num > $max_num} {\n[MASK]\n}\nif {$num < $min_num} {\nset min_num $num\n}\n}\n[MASK]\n}\n\nproc gcd {a b} {\n# Helper function to find the greatest common divisor of two numbers.\nwhile {$b != 0} {\nset temp $b\nset b [expr {$a % $b}]\nset a $temp\n}\n[MASK]\n}"}
{"task_id": "Tcl/7-1-multi", "prompt": "proc max_min_gcd {nums} {\n# Find the greatest common divisor of the maximum and minimum numbers in 'nums'.\n# >>> max_min_gcd {2 4 6 8 10}\n# 2 (GCD of 2 and 10)\n# >>> max_min_gcd {7 5 12 16 35}\n# 5 (GCD of 5 and 35)", "canonical_solution": "set max_num [lindex $nums 0]\nset min_num [lindex $nums 0]\nforeach num $nums {\nif {$num > $max_num} {\nset max_num $num\n}\nif {$num < $min_num} {\nset min_num $num\n}\n}\nreturn [gcd $max_num $min_num]\n}\n\nproc gcd {a b} {\n# Helper function to find the greatest common divisor of two numbers.\nwhile {$b != 0} {\nset temp $b\nset b [expr {$a % $b}]\nset a $temp\n}\nreturn $a\n}", "test": "proc check {max_min_gcd} {\nif {[max_min_gcd {2 4 6 8 10}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_min_gcd {7 5 12 16 35}] == 5} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_min_gcd {15 45 75}] == 15} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_min_gcd {11 13 17 19}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_min_gcd {20 40 60 80}] == 20} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_min_gcd {5 5 5 5}] == 5} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_min_gcd {100 200 300 400 500}] == 100} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_min_gcd", "entry_point": "max_min_gcd", "signature": "proc max_min_gcd {nums} {", "docstring": "Find the greatest common divisor of the maximum and minimum numbers in 'nums'.\n>>> max_min_gcd {2 4 6 8 10}\n2 (GCD of 2 and 10)\n>>> max_min_gcd {7 5 12 16 35}\n5 (GCD of 5 and 35)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nFind the greatest common divisor of the maximum and minimum numbers in 'nums'.\n>>> max_min_gcd {2 4 6 8 10}\n2 (GCD of 2 and 10)\n>>> max_min_gcd {7 5 12 16 35}\n5 (GCD of 5 and 35)\n\n* Incomplete Code:\nproc max_min_gcd {nums} {\nset max_num [lindex $nums 0]\nset min_num [lindex $nums 0]\nforeach num $nums {\nif {$num > $max_num} {\nset max_num $num\n}\nif {$num < $min_num} {\nset min_num $num\n}\n}\n[MASK]\n}\n\nproc gcd {a b} {\n# Helper function to find the greatest common divisor of two numbers.\nwhile {$b != 0} {\nset temp $b\nset b [expr {$a % $b}]\nset a $temp\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set max_num [lindex $nums 0]\nset min_num [lindex $nums 0]\nforeach num $nums {\nif {$num > $max_num} {\nset max_num $num\n}\nif {$num < $min_num} {\nset min_num $num\n}\n}\n[MASK]\n}\n\nproc gcd {a b} {\n# Helper function to find the greatest common divisor of two numbers.\nwhile {$b != 0} {\nset temp $b\nset b [expr {$a % $b}]\nset a $temp\n}\n[MASK]\n}"}
{"task_id": "Tcl/8-0-multi", "prompt": "proc count_quadruplets {nums} {\n# Count the number of unique quadruplets (a, b, c, d) in 'nums' such that\n# nums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n# >>> count_quadruplets {1 2 3 6}\n# 1 (The quadruplet is (0, 1, 2, 3))\n# >>> count_quadruplets {3 3 6 4 5}\n# 0 (No such quadruplets exist)", "canonical_solution": "set count 0\nset length [llength $nums]\nfor {set a 0} {$a < $length - 3} {incr a} {\nfor {set b [expr {$a + 1}]} {$b < $length - 2} {incr b} {\nfor {set c [expr {$b + 1}]} {$c < $length - 1} {incr c} {\nfor {set d [expr {$c + 1}]} {$d < $length} {incr d} {\nif {[expr {[lindex $nums $a] + [lindex $nums $b] + [lindex $nums $c]}] == [lindex $nums $d]} {\nincr count\n}\n}\n}\n}\n}\nreturn $count\n}", "test": "proc check {count_quadruplets} {\nif {[count_quadruplets {1 2 3 6}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_quadruplets {3 3 6 4 5}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_quadruplets {1 1 1 1 1}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_quadruplets {0 0 0 0}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_quadruplets {1 2 3 4 5}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_quadruplets {1 1 2 3 4 5 6}] == 5} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_quadruplets {-1 0 1 0}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_quadruplets", "entry_point": "count_quadruplets", "signature": "proc count_quadruplets {nums} {", "docstring": "Count the number of unique quadruplets (a, b, c, d) in 'nums' such that\nnums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n>>> count_quadruplets {1 2 3 6}\n1 (The quadruplet is (0, 1, 2, 3))\n>>> count_quadruplets {3 3 6 4 5}\n0 (No such quadruplets exist)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of unique quadruplets (a, b, c, d) in 'nums' such that\nnums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n>>> count_quadruplets {1 2 3 6}\n1 (The quadruplet is (0, 1, 2, 3))\n>>> count_quadruplets {3 3 6 4 5}\n0 (No such quadruplets exist)\n\n* Incomplete Code:\nproc count_quadruplets {nums} {\nset count 0\n[MASK]\nfor {set a 0} {$a < $length - 3} {incr a} {\n[MASK]\n[MASK]\nfor {set d [expr {$c + 1}]} {$d < $length} {incr d} {\n[MASK]\nincr count\n}\n}\n}\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set count 0\n[MASK]\nfor {set a 0} {$a < $length - 3} {incr a} {\n[MASK]\n[MASK]\nfor {set d [expr {$c + 1}]} {$d < $length} {incr d} {\n[MASK]\nincr count\n}\n}\n}\n}\n}\n[MASK]\n}"}
{"task_id": "Tcl/8-1-multi", "prompt": "proc count_quadruplets {nums} {\n# Count the number of unique quadruplets (a, b, c, d) in 'nums' such that\n# nums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n# >>> count_quadruplets {1 2 3 6}\n# 1 (The quadruplet is (0, 1, 2, 3))\n# >>> count_quadruplets {3 3 6 4 5}\n# 0 (No such quadruplets exist)", "canonical_solution": "set count 0\nset length [llength $nums]\nfor {set a 0} {$a < $length - 3} {incr a} {\nfor {set b [expr {$a + 1}]} {$b < $length - 2} {incr b} {\nfor {set c [expr {$b + 1}]} {$c < $length - 1} {incr c} {\nfor {set d [expr {$c + 1}]} {$d < $length} {incr d} {\nif {[expr {[lindex $nums $a] + [lindex $nums $b] + [lindex $nums $c]}] == [lindex $nums $d]} {\nincr count\n}\n}\n}\n}\n}\nreturn $count\n}", "test": "proc check {count_quadruplets} {\nif {[count_quadruplets {1 2 3 6}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_quadruplets {3 3 6 4 5}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_quadruplets {1 1 1 1 1}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_quadruplets {0 0 0 0}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_quadruplets {1 2 3 4 5}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_quadruplets {1 1 2 3 4 5 6}] == 5} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_quadruplets {-1 0 1 0}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_quadruplets", "entry_point": "count_quadruplets", "signature": "proc count_quadruplets {nums} {", "docstring": "Count the number of unique quadruplets (a, b, c, d) in 'nums' such that\nnums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n>>> count_quadruplets {1 2 3 6}\n1 (The quadruplet is (0, 1, 2, 3))\n>>> count_quadruplets {3 3 6 4 5}\n0 (No such quadruplets exist)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of unique quadruplets (a, b, c, d) in 'nums' such that\nnums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n>>> count_quadruplets {1 2 3 6}\n1 (The quadruplet is (0, 1, 2, 3))\n>>> count_quadruplets {3 3 6 4 5}\n0 (No such quadruplets exist)\n\n* Incomplete Code:\nproc count_quadruplets {nums} {\nset count 0\n[MASK]\nfor {set a 0} {$a < $length - 3} {incr a} {\nfor {set b [expr {$a + 1}]} {$b < $length - 2} {incr b} {\nfor {set c [expr {$b + 1}]} {$c < $length - 1} {incr c} {\nfor {set d [expr {$c + 1}]} {$d < $length} {incr d} {\nif {[expr {[lindex $nums $a] + [lindex $nums $b] + [lindex $nums $c]}] == [lindex $nums $d]} {\n[MASK]\n}\n}\n}\n}\n}\nreturn $count\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set count 0\n[MASK]\nfor {set a 0} {$a < $length - 3} {incr a} {\nfor {set b [expr {$a + 1}]} {$b < $length - 2} {incr b} {\nfor {set c [expr {$b + 1}]} {$c < $length - 1} {incr c} {\nfor {set d [expr {$c + 1}]} {$d < $length} {incr d} {\nif {[expr {[lindex $nums $a] + [lindex $nums $b] + [lindex $nums $c]}] == [lindex $nums $d]} {\n[MASK]\n}\n}\n}\n}\n}\nreturn $count\n}"}
{"task_id": "Tcl/9-0-multi", "prompt": "proc count_pairs_with_diff_k {nums k} {\n# Count the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n# >>> count_pairs_with_diff_k {1 2 3 4} 1\n# 3 (The pairs are (0, 1), (1, 2), and (2, 3))\n# >>> count_pairs_with_diff_k {1 3 5 7} 2\n# 3 (The pairs are (0, 1), (1, 2), and (2, 3))", "canonical_solution": "set count 0\nset length [llength $nums]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[expr {abs([lindex $nums $i] - [lindex $nums $j])}] == $k} {\nincr count\n}\n}\n}\nreturn $count\n}", "test": "proc check {count_pairs_with_diff_k} {\nif {[count_pairs_with_diff_k {1 2 3 4} 1] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 3 5 7} 2] == 3} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 1 1 1} 0] == 6} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 5 9 1 5 9} 4] == 8} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_pairs_with_diff_k {4 7 10 13 16} 3] == 4} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_pairs_with_diff_k {-2 2 4 6} 4] == 2} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_pairs_with_diff_k {0 0 0 0} 1] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_pairs_with_diff_k", "entry_point": "count_pairs_with_diff_k", "signature": "proc count_pairs_with_diff_k {nums k} {", "docstring": "Count the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n>>> count_pairs_with_diff_k {1 2 3 4} 1\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n>>> count_pairs_with_diff_k {1 3 5 7} 2\n3 (The pairs are (0, 1), (1, 2), and (2, 3))", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n>>> count_pairs_with_diff_k {1 2 3 4} 1\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n>>> count_pairs_with_diff_k {1 3 5 7} 2\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n\n* Incomplete Code:\nproc count_pairs_with_diff_k {nums k} {\n[MASK]\nset length [llength $nums]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[expr {abs([lindex $nums $i] - [lindex $nums $j])}] == $k} {\nincr count\n}\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset length [llength $nums]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[expr {abs([lindex $nums $i] - [lindex $nums $j])}] == $k} {\nincr count\n}\n}\n}\n[MASK]\n}"}
{"task_id": "Tcl/9-1-multi", "prompt": "proc count_pairs_with_diff_k {nums k} {\n# Count the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n# >>> count_pairs_with_diff_k {1 2 3 4} 1\n# 3 (The pairs are (0, 1), (1, 2), and (2, 3))\n# >>> count_pairs_with_diff_k {1 3 5 7} 2\n# 3 (The pairs are (0, 1), (1, 2), and (2, 3))", "canonical_solution": "set count 0\nset length [llength $nums]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[expr {abs([lindex $nums $i] - [lindex $nums $j])}] == $k} {\nincr count\n}\n}\n}\nreturn $count\n}", "test": "proc check {count_pairs_with_diff_k} {\nif {[count_pairs_with_diff_k {1 2 3 4} 1] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 3 5 7} 2] == 3} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 1 1 1} 0] == 6} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 5 9 1 5 9} 4] == 8} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_pairs_with_diff_k {4 7 10 13 16} 3] == 4} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_pairs_with_diff_k {-2 2 4 6} 4] == 2} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_pairs_with_diff_k {0 0 0 0} 1] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_pairs_with_diff_k", "entry_point": "count_pairs_with_diff_k", "signature": "proc count_pairs_with_diff_k {nums k} {", "docstring": "Count the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n>>> count_pairs_with_diff_k {1 2 3 4} 1\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n>>> count_pairs_with_diff_k {1 3 5 7} 2\n3 (The pairs are (0, 1), (1, 2), and (2, 3))", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n>>> count_pairs_with_diff_k {1 2 3 4} 1\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n>>> count_pairs_with_diff_k {1 3 5 7} 2\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n\n* Incomplete Code:\nproc count_pairs_with_diff_k {nums k} {\nset count 0\n[MASK]\nfor {set i 0} {$i < $length - 1} {incr i} {\n[MASK]\nif {[expr {abs([lindex $nums $i] - [lindex $nums $j])}] == $k} {\n[MASK]\n}\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set count 0\n[MASK]\nfor {set i 0} {$i < $length - 1} {incr i} {\n[MASK]\nif {[expr {abs([lindex $nums $i] - [lindex $nums $j])}] == $k} {\n[MASK]\n}\n}\n}\n[MASK]\n}"}
{"task_id": "Tcl/10-0-multi", "prompt": "proc final_value_after_operations {operations} {\n# Calculate the final value of X after performing the operations in 'operations'.\n# X starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n# >>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n# 2\n# >>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n# 0", "canonical_solution": "set X 0\nforeach operation $operations {\nif {$operation eq \"++X\" || $operation eq \"X++\"} {\nincr X\n} elseif {$operation eq \"--X\" || $operation eq \"X--\"} {\nincr X -1\n}\n}\nreturn $X\n}", "test": "proc check {final_value_after_operations} {\nif {[final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[final_value_after_operations {\"++X\" \"++X\" \"++X\"}] == 3} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[final_value_after_operations {\"X--\" \"X--\" \"X--\"}] == -3} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[final_value_after_operations {\"X++\" \"X++\" \"X--\" \"X--\"}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[final_value_after_operations {\"--X\" \"X++\" \"X++\"}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[final_value_after_operations {\"++X\" \"++X\" \"X--\"}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck final_value_after_operations", "entry_point": "final_value_after_operations", "signature": "proc final_value_after_operations {operations} {", "docstring": "Calculate the final value of X after performing the operations in 'operations'.\nX starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n>>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n2\n>>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n0", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the final value of X after performing the operations in 'operations'.\nX starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n>>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n2\n>>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n0\n\n* Incomplete Code:\nproc final_value_after_operations {operations} {\nset X 0\nforeach operation $operations {\nif {$operation eq \"++X\" || $operation eq \"X++\"} {\n[MASK]\n[MASK]\nincr X -1\n}\n}\nreturn $X\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set X 0\nforeach operation $operations {\nif {$operation eq \"++X\" || $operation eq \"X++\"} {\n[MASK]\n[MASK]\nincr X -1\n}\n}\nreturn $X\n}"}
{"task_id": "Tcl/10-1-multi", "prompt": "proc final_value_after_operations {operations} {\n# Calculate the final value of X after performing the operations in 'operations'.\n# X starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n# >>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n# 2\n# >>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n# 0", "canonical_solution": "set X 0\nforeach operation $operations {\nif {$operation eq \"++X\" || $operation eq \"X++\"} {\nincr X\n} elseif {$operation eq \"--X\" || $operation eq \"X--\"} {\nincr X -1\n}\n}\nreturn $X\n}", "test": "proc check {final_value_after_operations} {\nif {[final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[final_value_after_operations {\"++X\" \"++X\" \"++X\"}] == 3} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[final_value_after_operations {\"X--\" \"X--\" \"X--\"}] == -3} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[final_value_after_operations {\"X++\" \"X++\" \"X--\" \"X--\"}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[final_value_after_operations {\"--X\" \"X++\" \"X++\"}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[final_value_after_operations {\"++X\" \"++X\" \"X--\"}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck final_value_after_operations", "entry_point": "final_value_after_operations", "signature": "proc final_value_after_operations {operations} {", "docstring": "Calculate the final value of X after performing the operations in 'operations'.\nX starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n>>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n2\n>>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n0", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the final value of X after performing the operations in 'operations'.\nX starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n>>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n2\n>>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n0\n\n* Incomplete Code:\nproc final_value_after_operations {operations} {\nset X 0\n[MASK]\nif {$operation eq \"++X\" || $operation eq \"X++\"} {\nincr X\n[MASK]\nincr X -1\n}\n}\nreturn $X\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set X 0\n[MASK]\nif {$operation eq \"++X\" || $operation eq \"X++\"} {\nincr X\n[MASK]\nincr X -1\n}\n}\nreturn $X\n}"}
{"task_id": "Tcl/11-0-multi", "prompt": "proc max_difference {nums} {\n# Calculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\n# and nums[i] < nums[j]. Return -1 if no such i and j exist.\n# >>> max_difference {7 1 5 4}\n# 4 (The difference is 5 - 1)\n# >>> max_difference {9 4 3 2}\n# -1 (No such i and j exist)", "canonical_solution": "set max_diff -1\nset min_element [lindex $nums 0]\n\nforeach num $nums {\nif {$num > $min_element} {\nset max_diff [expr {max($max_diff, $num - $min_element)}]\n} else {\nset min_element $num\n}\n}\n\nreturn $max_diff\n}\n\n# Helper function to get the maximum of two numbers\nproc max {a b} {\nif {$a > $b} {return $a} else {return $b}\n}", "test": "proc check {max_difference} {\nif {[max_difference {7 1 5 4}] == 4} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_difference {9 4 3 2}] == -1} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_difference {2 3 10 6 4 8 1}] == 8} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_difference {7 9 5 6 3 2}] == 2} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_difference {1 5 2 10}] == 9} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_difference {10 10 10 10}] == -1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_difference {1 2 3 4 5 6 7 8 9 10}] == 9} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_difference", "entry_point": "max_difference", "signature": "proc max_difference {nums} {", "docstring": "Calculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\nand nums[i] < nums[j]. Return -1 if no such i and j exist.\n>>> max_difference {7 1 5 4}\n4 (The difference is 5 - 1)\n>>> max_difference {9 4 3 2}\n-1 (No such i and j exist)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\nand nums[i] < nums[j]. Return -1 if no such i and j exist.\n>>> max_difference {7 1 5 4}\n4 (The difference is 5 - 1)\n>>> max_difference {9 4 3 2}\n-1 (No such i and j exist)\n\n* Incomplete Code:\nproc max_difference {nums} {\nset max_diff -1\n[MASK]\n\nforeach num $nums {\nif {$num > $min_element} {\nset max_diff [expr {max($max_diff, $num - $min_element)}]\n[MASK]\nset min_element $num\n}\n}\n\n[MASK]\n}\n\n# Helper function to get the maximum of two numbers\nproc max {a b} {\nif {$a > $b} {return $a} else {return $b}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set max_diff -1\n[MASK]\n\nforeach num $nums {\nif {$num > $min_element} {\nset max_diff [expr {max($max_diff, $num - $min_element)}]\n[MASK]\nset min_element $num\n}\n}\n\n[MASK]\n}\n\n# Helper function to get the maximum of two numbers\nproc max {a b} {\nif {$a > $b} {return $a} else {return $b}\n}"}
{"task_id": "Tcl/11-1-multi", "prompt": "proc max_difference {nums} {\n# Calculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\n# and nums[i] < nums[j]. Return -1 if no such i and j exist.\n# >>> max_difference {7 1 5 4}\n# 4 (The difference is 5 - 1)\n# >>> max_difference {9 4 3 2}\n# -1 (No such i and j exist)", "canonical_solution": "set max_diff -1\nset min_element [lindex $nums 0]\n\nforeach num $nums {\nif {$num > $min_element} {\nset max_diff [expr {max($max_diff, $num - $min_element)}]\n} else {\nset min_element $num\n}\n}\n\nreturn $max_diff\n}\n\n# Helper function to get the maximum of two numbers\nproc max {a b} {\nif {$a > $b} {return $a} else {return $b}\n}", "test": "proc check {max_difference} {\nif {[max_difference {7 1 5 4}] == 4} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_difference {9 4 3 2}] == -1} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_difference {2 3 10 6 4 8 1}] == 8} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_difference {7 9 5 6 3 2}] == 2} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_difference {1 5 2 10}] == 9} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_difference {10 10 10 10}] == -1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_difference {1 2 3 4 5 6 7 8 9 10}] == 9} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_difference", "entry_point": "max_difference", "signature": "proc max_difference {nums} {", "docstring": "Calculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\nand nums[i] < nums[j]. Return -1 if no such i and j exist.\n>>> max_difference {7 1 5 4}\n4 (The difference is 5 - 1)\n>>> max_difference {9 4 3 2}\n-1 (No such i and j exist)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\nand nums[i] < nums[j]. Return -1 if no such i and j exist.\n>>> max_difference {7 1 5 4}\n4 (The difference is 5 - 1)\n>>> max_difference {9 4 3 2}\n-1 (No such i and j exist)\n\n* Incomplete Code:\nproc max_difference {nums} {\n[MASK]\nset min_element [lindex $nums 0]\n\n[MASK]\nif {$num > $min_element} {\nset max_diff [expr {max($max_diff, $num - $min_element)}]\n} else {\nset min_element $num\n}\n}\n\nreturn $max_diff\n}\n\n# Helper function to get the maximum of two numbers\n[MASK]\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset min_element [lindex $nums 0]\n\n[MASK]\nif {$num > $min_element} {\nset max_diff [expr {max($max_diff, $num - $min_element)}]\n} else {\nset min_element $num\n}\n}\n\nreturn $max_diff\n}\n\n# Helper function to get the maximum of two numbers\n[MASK]\n[MASK]\n}"}
{"task_id": "Tcl/12-0-multi", "prompt": "proc create_2d_array {original m n} {\n# Create an m x n 2D array from the 1D array 'original'.\n# Return an empty array if it's not possible.\n# >>> create_2d_array {1 2 3 4} 2 2\n# {{1 2} {3 4}}\n# >>> create_2d_array {1 2 3} 2 2\n# {} (Not enough elements to fill a 2x2 array)", "canonical_solution": "set total_elements [expr {$m * $n}]\nif {[llength $original] != $total_elements} {\nreturn {}\n}\n\nset result [list]\nfor {set i 0} {$i < $total_elements} {incr i $n} {\nlappend result [lrange $original $i [expr {$i + $n - 1}]]\n}\n\nreturn $result\n}", "test": "proc check {create_2d_array} {\nif {[create_2d_array {1 2 3 4} 2 2] eq {{1 2} {3 4}}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[create_2d_array {1 2 3} 2 2] eq {}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6} 2 3] eq {{1 2 3} {4 5 6}}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8 9} 3 3] eq {{1 2 3} {4 5 6} {7 8 9}}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8} 4 2] eq {{1 2} {3 4} {5 6} {7 8}}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8 9 10 11 12} 3 4] eq {{1 2 3 4} {5 6 7 8} {9 10 11 12}}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\n}\n\n# Call the check procedure\ncheck create_2d_array", "entry_point": "create_2d_array", "signature": "proc create_2d_array {original m n} {", "docstring": "Create an m x n 2D array from the 1D array 'original'.\nReturn an empty array if it's not possible.\n>>> create_2d_array {1 2 3 4} 2 2\n{{1 2} {3 4}}\n>>> create_2d_array {1 2 3} 2 2\n{} (Not enough elements to fill a 2x2 array)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCreate an m x n 2D array from the 1D array 'original'.\nReturn an empty array if it's not possible.\n>>> create_2d_array {1 2 3 4} 2 2\n{{1 2} {3 4}}\n>>> create_2d_array {1 2 3} 2 2\n{} (Not enough elements to fill a 2x2 array)\n\n* Incomplete Code:\nproc create_2d_array {original m n} {\nset total_elements [expr {$m * $n}]\n[MASK]\n[MASK]\n}\n\n[MASK]\nfor {set i 0} {$i < $total_elements} {incr i $n} {\nlappend result [lrange $original $i [expr {$i + $n - 1}]]\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set total_elements [expr {$m * $n}]\n[MASK]\n[MASK]\n}\n\n[MASK]\nfor {set i 0} {$i < $total_elements} {incr i $n} {\nlappend result [lrange $original $i [expr {$i + $n - 1}]]\n}\n\nreturn $result\n}"}
{"task_id": "Tcl/12-1-multi", "prompt": "proc create_2d_array {original m n} {\n# Create an m x n 2D array from the 1D array 'original'.\n# Return an empty array if it's not possible.\n# >>> create_2d_array {1 2 3 4} 2 2\n# {{1 2} {3 4}}\n# >>> create_2d_array {1 2 3} 2 2\n# {} (Not enough elements to fill a 2x2 array)", "canonical_solution": "set total_elements [expr {$m * $n}]\nif {[llength $original] != $total_elements} {\nreturn {}\n}\n\nset result [list]\nfor {set i 0} {$i < $total_elements} {incr i $n} {\nlappend result [lrange $original $i [expr {$i + $n - 1}]]\n}\n\nreturn $result\n}", "test": "proc check {create_2d_array} {\nif {[create_2d_array {1 2 3 4} 2 2] eq {{1 2} {3 4}}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[create_2d_array {1 2 3} 2 2] eq {}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6} 2 3] eq {{1 2 3} {4 5 6}}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8 9} 3 3] eq {{1 2 3} {4 5 6} {7 8 9}}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8} 4 2] eq {{1 2} {3 4} {5 6} {7 8}}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8 9 10 11 12} 3 4] eq {{1 2 3 4} {5 6 7 8} {9 10 11 12}}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\n}\n\n# Call the check procedure\ncheck create_2d_array", "entry_point": "create_2d_array", "signature": "proc create_2d_array {original m n} {", "docstring": "Create an m x n 2D array from the 1D array 'original'.\nReturn an empty array if it's not possible.\n>>> create_2d_array {1 2 3 4} 2 2\n{{1 2} {3 4}}\n>>> create_2d_array {1 2 3} 2 2\n{} (Not enough elements to fill a 2x2 array)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCreate an m x n 2D array from the 1D array 'original'.\nReturn an empty array if it's not possible.\n>>> create_2d_array {1 2 3 4} 2 2\n{{1 2} {3 4}}\n>>> create_2d_array {1 2 3} 2 2\n{} (Not enough elements to fill a 2x2 array)\n\n* Incomplete Code:\nproc create_2d_array {original m n} {\nset total_elements [expr {$m * $n}]\nif {[llength $original] != $total_elements} {\nreturn {}\n}\n\n[MASK]\nfor {set i 0} {$i < $total_elements} {incr i $n} {\n[MASK]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set total_elements [expr {$m * $n}]\nif {[llength $original] != $total_elements} {\nreturn {}\n}\n\n[MASK]\nfor {set i 0} {$i < $total_elements} {incr i $n} {\n[MASK]\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/13-0-multi", "prompt": "proc construct_common_elements_array {nums1 nums2 nums3} {\n# Construct an array of unique elements that appear in at least two out of three arrays.\n# The elements are in ascending order.\n# >>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n# {2 3}\n# >>> construct_common_elements_array {3 1} {2 3} {1}\n# {1 3}", "canonical_solution": "array set count_nums1 {}\narray set count_nums2 {}\narray set count_nums3 {}\nforeach num $nums1 {incr count_nums1($num)}\nforeach num $nums2 {incr count_nums2($num)}\nforeach num $nums3 {incr count_nums3($num)}\n\n# Create a dictionary to store the count of each element across all arrays\narray set total_count {}\nforeach num [array names count_nums1] {incr total_count($num)}\nforeach num [array names count_nums2] {incr total_count($num)}\nforeach num [array names count_nums3] {incr total_count($num)}\n\n# Create the result array with elements appearing at least in two arrays\nset result [list]\nforeach num [array names total_count] {\nif {$total_count($num) > 1} {\nlappend result $num\n}\n}\n\nreturn [lsort -integer $result]\n}", "test": "proc check {} {\nif {[construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}] eq {2 3}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[construct_common_elements_array {3 1} {2 3} {1}] eq {1 3}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[construct_common_elements_array {1 4 5} {2 4 6} {3 4 7}] eq {4}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[construct_common_elements_array {10 20 30} {30 40 50} {50 60 70}] eq {30 50}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[construct_common_elements_array {1 2 3} {4 5 6} {7 8 9}] eq {}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[construct_common_elements_array {1 1 1} {1 1} {1}] eq {1}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[construct_common_elements_array {1 2 3 4} {2 3 4 5} {3 4 5 6}] eq {2 3 4 5}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck", "entry_point": "construct_common_elements_array", "signature": "proc construct_common_elements_array {nums1 nums2 nums3} {", "docstring": "Construct an array of unique elements that appear in at least two out of three arrays.\nThe elements are in ascending order.\n>>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n{2 3}\n>>> construct_common_elements_array {3 1} {2 3} {1}\n{1 3}", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nConstruct an array of unique elements that appear in at least two out of three arrays.\nThe elements are in ascending order.\n>>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n{2 3}\n>>> construct_common_elements_array {3 1} {2 3} {1}\n{1 3}\n\n* Incomplete Code:\nproc construct_common_elements_array {nums1 nums2 nums3} {\narray set count_nums1 {}\narray set count_nums2 {}\narray set count_nums3 {}\nforeach num $nums1 {incr count_nums1($num)}\n[MASK]\nforeach num $nums3 {incr count_nums3($num)}\n\n# Create a dictionary to store the count of each element across all arrays\narray set total_count {}\nforeach num [array names count_nums1] {incr total_count($num)}\nforeach num [array names count_nums2] {incr total_count($num)}\nforeach num [array names count_nums3] {incr total_count($num)}\n\n# Create the result array with elements appearing at least in two arrays\nset result [list]\nforeach num [array names total_count] {\n[MASK]\n[MASK]\n}\n}\n\nreturn [lsort -integer $result]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "array set count_nums1 {}\narray set count_nums2 {}\narray set count_nums3 {}\nforeach num $nums1 {incr count_nums1($num)}\n[MASK]\nforeach num $nums3 {incr count_nums3($num)}\n\n# Create a dictionary to store the count of each element across all arrays\narray set total_count {}\nforeach num [array names count_nums1] {incr total_count($num)}\nforeach num [array names count_nums2] {incr total_count($num)}\nforeach num [array names count_nums3] {incr total_count($num)}\n\n# Create the result array with elements appearing at least in two arrays\nset result [list]\nforeach num [array names total_count] {\n[MASK]\n[MASK]\n}\n}\n\nreturn [lsort -integer $result]\n}"}
{"task_id": "Tcl/13-1-multi", "prompt": "proc construct_common_elements_array {nums1 nums2 nums3} {\n# Construct an array of unique elements that appear in at least two out of three arrays.\n# The elements are in ascending order.\n# >>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n# {2 3}\n# >>> construct_common_elements_array {3 1} {2 3} {1}\n# {1 3}", "canonical_solution": "array set count_nums1 {}\narray set count_nums2 {}\narray set count_nums3 {}\nforeach num $nums1 {incr count_nums1($num)}\nforeach num $nums2 {incr count_nums2($num)}\nforeach num $nums3 {incr count_nums3($num)}\n\n# Create a dictionary to store the count of each element across all arrays\narray set total_count {}\nforeach num [array names count_nums1] {incr total_count($num)}\nforeach num [array names count_nums2] {incr total_count($num)}\nforeach num [array names count_nums3] {incr total_count($num)}\n\n# Create the result array with elements appearing at least in two arrays\nset result [list]\nforeach num [array names total_count] {\nif {$total_count($num) > 1} {\nlappend result $num\n}\n}\n\nreturn [lsort -integer $result]\n}", "test": "proc check {} {\nif {[construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}] eq {2 3}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[construct_common_elements_array {3 1} {2 3} {1}] eq {1 3}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[construct_common_elements_array {1 4 5} {2 4 6} {3 4 7}] eq {4}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[construct_common_elements_array {10 20 30} {30 40 50} {50 60 70}] eq {30 50}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[construct_common_elements_array {1 2 3} {4 5 6} {7 8 9}] eq {}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[construct_common_elements_array {1 1 1} {1 1} {1}] eq {1}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[construct_common_elements_array {1 2 3 4} {2 3 4 5} {3 4 5 6}] eq {2 3 4 5}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck", "entry_point": "construct_common_elements_array", "signature": "proc construct_common_elements_array {nums1 nums2 nums3} {", "docstring": "Construct an array of unique elements that appear in at least two out of three arrays.\nThe elements are in ascending order.\n>>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n{2 3}\n>>> construct_common_elements_array {3 1} {2 3} {1}\n{1 3}", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nConstruct an array of unique elements that appear in at least two out of three arrays.\nThe elements are in ascending order.\n>>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n{2 3}\n>>> construct_common_elements_array {3 1} {2 3} {1}\n{1 3}\n\n* Incomplete Code:\nproc construct_common_elements_array {nums1 nums2 nums3} {\narray set count_nums1 {}\n[MASK]\narray set count_nums3 {}\nforeach num $nums1 {incr count_nums1($num)}\nforeach num $nums2 {incr count_nums2($num)}\nforeach num $nums3 {incr count_nums3($num)}\n\n# Create a dictionary to store the count of each element across all arrays\narray set total_count {}\nforeach num [array names count_nums1] {incr total_count($num)}\nforeach num [array names count_nums2] {incr total_count($num)}\nforeach num [array names count_nums3] {incr total_count($num)}\n\n# Create the result array with elements appearing at least in two arrays\nset result [list]\nforeach num [array names total_count] {\nif {$total_count($num) > 1} {\n[MASK]\n}\n}\n\nreturn [lsort -integer $result]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "array set count_nums1 {}\n[MASK]\narray set count_nums3 {}\nforeach num $nums1 {incr count_nums1($num)}\nforeach num $nums2 {incr count_nums2($num)}\nforeach num $nums3 {incr count_nums3($num)}\n\n# Create a dictionary to store the count of each element across all arrays\narray set total_count {}\nforeach num [array names count_nums1] {incr total_count($num)}\nforeach num [array names count_nums2] {incr total_count($num)}\nforeach num [array names count_nums3] {incr total_count($num)}\n\n# Create the result array with elements appearing at least in two arrays\nset result [list]\nforeach num [array names total_count] {\nif {$total_count($num) > 1} {\n[MASK]\n}\n}\n\nreturn [lsort -integer $result]\n}"}
{"task_id": "Tcl/14-0-multi", "prompt": "proc min_moves_to_seat {seats students} {\n# Calculate the minimum number of moves to seat all students.\n# Students can be moved one position at a time.\n# >>> min_moves_to_seat {3 1 5} {2 7 4}\n# 4 (Move student from 7 to 5 and from 2 to 1)\n# >>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n# 7 (Various moves to match each student to a seat", "canonical_solution": "set sorted_seats [lsort -integer $seats]\nset sorted_students [lsort -integer $students]\nset moves 0\n\nforeach seat $sorted_seats student $sorted_students {\nincr moves [expr {abs($seat - $student)}]\n}\n\nreturn $moves\n}", "test": "proc check {min_moves_to_seat} {\nif {[min_moves_to_seat {3 1 5} {2 7 4}] == 4} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[min_moves_to_seat {4 1 5 9} {1 3 2 6}] == 7} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[min_moves_to_seat {10 2 6} {3 8 9}] == 4} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[min_moves_to_seat {1 4 2 3} {4 1 3 2}] == 0} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[min_moves_to_seat {5 5 5} {1 2 3}] == 9} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[min_moves_to_seat {1 2 3} {3 2 1}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[min_moves_to_seat {5 6 7} {5 6 7}] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck min_moves_to_seat", "entry_point": "min_moves_to_seat", "signature": "proc min_moves_to_seat {seats students} {", "docstring": "Calculate the minimum number of moves to seat all students.\nStudents can be moved one position at a time.\n>>> min_moves_to_seat {3 1 5} {2 7 4}\n4 (Move student from 7 to 5 and from 2 to 1)\n>>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n7 (Various moves to match each student to a seat", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum number of moves to seat all students.\nStudents can be moved one position at a time.\n>>> min_moves_to_seat {3 1 5} {2 7 4}\n4 (Move student from 7 to 5 and from 2 to 1)\n>>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n7 (Various moves to match each student to a seat\n\n* Incomplete Code:\nproc min_moves_to_seat {seats students} {\n[MASK]\nset sorted_students [lsort -integer $students]\n[MASK]\n\nforeach seat $sorted_seats student $sorted_students {\nincr moves [expr {abs($seat - $student)}]\n}\n\nreturn $moves\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset sorted_students [lsort -integer $students]\n[MASK]\n\nforeach seat $sorted_seats student $sorted_students {\nincr moves [expr {abs($seat - $student)}]\n}\n\nreturn $moves\n}"}
{"task_id": "Tcl/14-1-multi", "prompt": "proc min_moves_to_seat {seats students} {\n# Calculate the minimum number of moves to seat all students.\n# Students can be moved one position at a time.\n# >>> min_moves_to_seat {3 1 5} {2 7 4}\n# 4 (Move student from 7 to 5 and from 2 to 1)\n# >>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n# 7 (Various moves to match each student to a seat", "canonical_solution": "set sorted_seats [lsort -integer $seats]\nset sorted_students [lsort -integer $students]\nset moves 0\n\nforeach seat $sorted_seats student $sorted_students {\nincr moves [expr {abs($seat - $student)}]\n}\n\nreturn $moves\n}", "test": "proc check {min_moves_to_seat} {\nif {[min_moves_to_seat {3 1 5} {2 7 4}] == 4} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[min_moves_to_seat {4 1 5 9} {1 3 2 6}] == 7} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[min_moves_to_seat {10 2 6} {3 8 9}] == 4} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[min_moves_to_seat {1 4 2 3} {4 1 3 2}] == 0} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[min_moves_to_seat {5 5 5} {1 2 3}] == 9} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[min_moves_to_seat {1 2 3} {3 2 1}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[min_moves_to_seat {5 6 7} {5 6 7}] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck min_moves_to_seat", "entry_point": "min_moves_to_seat", "signature": "proc min_moves_to_seat {seats students} {", "docstring": "Calculate the minimum number of moves to seat all students.\nStudents can be moved one position at a time.\n>>> min_moves_to_seat {3 1 5} {2 7 4}\n4 (Move student from 7 to 5 and from 2 to 1)\n>>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n7 (Various moves to match each student to a seat", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum number of moves to seat all students.\nStudents can be moved one position at a time.\n>>> min_moves_to_seat {3 1 5} {2 7 4}\n4 (Move student from 7 to 5 and from 2 to 1)\n>>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n7 (Various moves to match each student to a seat\n\n* Incomplete Code:\nproc min_moves_to_seat {seats students} {\n[MASK]\n[MASK]\nset moves 0\n\n[MASK]\nincr moves [expr {abs($seat - $student)}]\n}\n\nreturn $moves\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\nset moves 0\n\n[MASK]\nincr moves [expr {abs($seat - $student)}]\n}\n\nreturn $moves\n}"}
{"task_id": "Tcl/15-0-multi", "prompt": "proc kth_unique_string {arr k} {\n# Return the k-th unique string from 'arr'.\n# A unique string appears exactly once in 'arr'.\n# >>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n# \"\"\n# >>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n# \"\"", "canonical_solution": "array set count {}\nforeach str $arr {\nincr count($str)\n}\n\n# Find the k-th unique string\nset unique_count 0\nforeach str $arr {\nif {$count($str) == 1} {\nincr unique_count\nif {$unique_count == $k} {\nreturn $str\n}\n}\n}\n\nreturn \"\"\n}", "test": "proc check {kth_unique_string} {\nif {[kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2] eq \"\"} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3] eq \"\"} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[kth_unique_string {\"apple\" \"banana\" \"apple\" \"orange\"} 1] eq \"banana\"} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[kth_unique_string {\"hello\" \"hello\" \"world\"} 1] eq \"world\"} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[kth_unique_string {\"x\" \"y\" \"z\" \"x\" \"y\"} 1] eq \"z\"} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[kth_unique_string {\"one\" \"two\" \"three\" \"four\"} 2] eq \"two\"} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[kth_unique_string {\"one\" \"one\" \"one\"} 1] eq \"\"} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck kth_unique_string", "entry_point": "kth_unique_string", "signature": "proc kth_unique_string {arr k} {", "docstring": "Return the k-th unique string from 'arr'.\nA unique string appears exactly once in 'arr'.\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n\"\"\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n\"\"", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nReturn the k-th unique string from 'arr'.\nA unique string appears exactly once in 'arr'.\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n\"\"\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n\"\"\n\n* Incomplete Code:\nproc kth_unique_string {arr k} {\n[MASK]\nforeach str $arr {\nincr count($str)\n}\n\n# Find the k-th unique string\n[MASK]\nforeach str $arr {\nif {$count($str) == 1} {\n[MASK]\nif {$unique_count == $k} {\nreturn $str\n}\n}\n}\n\nreturn \"\"\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nforeach str $arr {\nincr count($str)\n}\n\n# Find the k-th unique string\n[MASK]\nforeach str $arr {\nif {$count($str) == 1} {\n[MASK]\nif {$unique_count == $k} {\nreturn $str\n}\n}\n}\n\nreturn \"\"\n}"}
{"task_id": "Tcl/15-1-multi", "prompt": "proc kth_unique_string {arr k} {\n# Return the k-th unique string from 'arr'.\n# A unique string appears exactly once in 'arr'.\n# >>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n# \"\"\n# >>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n# \"\"", "canonical_solution": "array set count {}\nforeach str $arr {\nincr count($str)\n}\n\n# Find the k-th unique string\nset unique_count 0\nforeach str $arr {\nif {$count($str) == 1} {\nincr unique_count\nif {$unique_count == $k} {\nreturn $str\n}\n}\n}\n\nreturn \"\"\n}", "test": "proc check {kth_unique_string} {\nif {[kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2] eq \"\"} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3] eq \"\"} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[kth_unique_string {\"apple\" \"banana\" \"apple\" \"orange\"} 1] eq \"banana\"} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[kth_unique_string {\"hello\" \"hello\" \"world\"} 1] eq \"world\"} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[kth_unique_string {\"x\" \"y\" \"z\" \"x\" \"y\"} 1] eq \"z\"} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[kth_unique_string {\"one\" \"two\" \"three\" \"four\"} 2] eq \"two\"} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[kth_unique_string {\"one\" \"one\" \"one\"} 1] eq \"\"} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck kth_unique_string", "entry_point": "kth_unique_string", "signature": "proc kth_unique_string {arr k} {", "docstring": "Return the k-th unique string from 'arr'.\nA unique string appears exactly once in 'arr'.\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n\"\"\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n\"\"", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nReturn the k-th unique string from 'arr'.\nA unique string appears exactly once in 'arr'.\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n\"\"\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n\"\"\n\n* Incomplete Code:\nproc kth_unique_string {arr k} {\narray set count {}\n[MASK]\nincr count($str)\n}\n\n# Find the k-th unique string\n[MASK]\nforeach str $arr {\n[MASK]\nincr unique_count\nif {$unique_count == $k} {\nreturn $str\n}\n}\n}\n\nreturn \"\"\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "array set count {}\n[MASK]\nincr count($str)\n}\n\n# Find the k-th unique string\n[MASK]\nforeach str $arr {\n[MASK]\nincr unique_count\nif {$unique_count == $k} {\nreturn $str\n}\n}\n}\n\nreturn \"\"\n}"}
{"task_id": "Tcl/16-0-multi", "prompt": "proc time_to_buy_tickets {tickets k} {\n# Calculate the time for the person at position k to buy their tickets.\n# Each person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n# >>> time_to_buy_tickets {5 1 1 1} 0\n# 8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n# >>> time_to_buy_tickets {2 3 2} 2\n# 6 (The person at position 2 takes 6 seconds to buy 2 tickets)", "canonical_solution": "set time 0\nset length [llength $tickets]\nfor {set i 0} {$i < $length} {incr i} {\nset min_tickets [min [lindex $tickets $i] [expr {[lindex $tickets $k] - ($i > $k)}]]\nincr time $min_tickets\n}\nreturn $time\n}\n\n# Helper function to get the minimum of two numbers\nproc min {a b} {\nif {$a < $b} {return $a} else {return $b}\n}", "test": "proc check {time_to_buy_tickets} {\nif {[time_to_buy_tickets {5 1 1 1} 0] == 8} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[time_to_buy_tickets {2 3 2} 2] == 6} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[time_to_buy_tickets {1 2 3 4 5} 3] == 13} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[time_to_buy_tickets {2 2 2 2 2} 4] == 10} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[time_to_buy_tickets {1 1 1 1 1} 2] == 3} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[time_to_buy_tickets {3 3 3 3 3} 0] == 11} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[time_to_buy_tickets {1 1 1 1 1} 0] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck time_to_buy_tickets", "entry_point": "time_to_buy_tickets", "signature": "proc time_to_buy_tickets {tickets k} {", "docstring": "Calculate the time for the person at position k to buy their tickets.\nEach person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n>>> time_to_buy_tickets {5 1 1 1} 0\n8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n>>> time_to_buy_tickets {2 3 2} 2\n6 (The person at position 2 takes 6 seconds to buy 2 tickets)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the time for the person at position k to buy their tickets.\nEach person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n>>> time_to_buy_tickets {5 1 1 1} 0\n8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n>>> time_to_buy_tickets {2 3 2} 2\n6 (The person at position 2 takes 6 seconds to buy 2 tickets)\n\n* Incomplete Code:\nproc time_to_buy_tickets {tickets k} {\nset time 0\nset length [llength $tickets]\nfor {set i 0} {$i < $length} {incr i} {\nset min_tickets [min [lindex $tickets $i] [expr {[lindex $tickets $k] - ($i > $k)}]]\nincr time $min_tickets\n}\nreturn $time\n}\n\n# Helper function to get the minimum of two numbers\n[MASK]\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set time 0\nset length [llength $tickets]\nfor {set i 0} {$i < $length} {incr i} {\nset min_tickets [min [lindex $tickets $i] [expr {[lindex $tickets $k] - ($i > $k)}]]\nincr time $min_tickets\n}\nreturn $time\n}\n\n# Helper function to get the minimum of two numbers\n[MASK]\n[MASK]\n}"}
{"task_id": "Tcl/16-1-multi", "prompt": "proc time_to_buy_tickets {tickets k} {\n# Calculate the time for the person at position k to buy their tickets.\n# Each person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n# >>> time_to_buy_tickets {5 1 1 1} 0\n# 8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n# >>> time_to_buy_tickets {2 3 2} 2\n# 6 (The person at position 2 takes 6 seconds to buy 2 tickets)", "canonical_solution": "set time 0\nset length [llength $tickets]\nfor {set i 0} {$i < $length} {incr i} {\nset min_tickets [min [lindex $tickets $i] [expr {[lindex $tickets $k] - ($i > $k)}]]\nincr time $min_tickets\n}\nreturn $time\n}\n\n# Helper function to get the minimum of two numbers\nproc min {a b} {\nif {$a < $b} {return $a} else {return $b}\n}", "test": "proc check {time_to_buy_tickets} {\nif {[time_to_buy_tickets {5 1 1 1} 0] == 8} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[time_to_buy_tickets {2 3 2} 2] == 6} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[time_to_buy_tickets {1 2 3 4 5} 3] == 13} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[time_to_buy_tickets {2 2 2 2 2} 4] == 10} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[time_to_buy_tickets {1 1 1 1 1} 2] == 3} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[time_to_buy_tickets {3 3 3 3 3} 0] == 11} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[time_to_buy_tickets {1 1 1 1 1} 0] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck time_to_buy_tickets", "entry_point": "time_to_buy_tickets", "signature": "proc time_to_buy_tickets {tickets k} {", "docstring": "Calculate the time for the person at position k to buy their tickets.\nEach person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n>>> time_to_buy_tickets {5 1 1 1} 0\n8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n>>> time_to_buy_tickets {2 3 2} 2\n6 (The person at position 2 takes 6 seconds to buy 2 tickets)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the time for the person at position k to buy their tickets.\nEach person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n>>> time_to_buy_tickets {5 1 1 1} 0\n8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n>>> time_to_buy_tickets {2 3 2} 2\n6 (The person at position 2 takes 6 seconds to buy 2 tickets)\n\n* Incomplete Code:\nproc time_to_buy_tickets {tickets k} {\nset time 0\nset length [llength $tickets]\n[MASK]\nset min_tickets [min [lindex $tickets $i] [expr {[lindex $tickets $k] - ($i > $k)}]]\nincr time $min_tickets\n}\nreturn $time\n}\n\n# Helper function to get the minimum of two numbers\nproc min {a b} {\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set time 0\nset length [llength $tickets]\n[MASK]\nset min_tickets [min [lindex $tickets $i] [expr {[lindex $tickets $k] - ($i > $k)}]]\nincr time $min_tickets\n}\nreturn $time\n}\n\n# Helper function to get the minimum of two numbers\nproc min {a b} {\n[MASK]\n}"}
{"task_id": "Tcl/17-0-multi", "prompt": "proc max_distance_different_colors {colors} {\n# Calculate the maximum distance between two houses of different colors.\n# >>> max_distance_different_colors {1 1 1 6 1 1 1}\n# 3 (Max distance between colors 1 and 6)\n# >>> max_distance_different_colors {1 2 1 2 1 2 1}\n# 5 (Max distance between any two different colors)", "canonical_solution": "set max_distance 0\nset length [llength $colors]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[lindex $colors $i] ne [lindex $colors $j]} {\nset distance [expr {abs($i - $j)}]\nif {$distance > $max_distance} {\nset max_distance $distance\n}\n}\n}\n}\nreturn $max_distance\n}", "test": "proc check {max_distance_different_colors} {\nif {[max_distance_different_colors {1 1 1 6 1 1 1}] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_distance_different_colors {1 2 1 2 1 2 1}] == 5} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_distance_different_colors {1 1 1 1 1}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_distance_different_colors {2 2 3 3 3 2 2}] == 4} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_distance_different_colors {1 3 2 4 5}] == 4} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_distance_different_colors {1}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_distance_different_colors {1 2 3 4 5 6}] == 5} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_distance_different_colors", "entry_point": "max_distance_different_colors", "signature": "proc max_distance_different_colors {colors} {", "docstring": "Calculate the maximum distance between two houses of different colors.\n>>> max_distance_different_colors {1 1 1 6 1 1 1}\n3 (Max distance between colors 1 and 6)\n>>> max_distance_different_colors {1 2 1 2 1 2 1}\n5 (Max distance between any two different colors)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum distance between two houses of different colors.\n>>> max_distance_different_colors {1 1 1 6 1 1 1}\n3 (Max distance between colors 1 and 6)\n>>> max_distance_different_colors {1 2 1 2 1 2 1}\n5 (Max distance between any two different colors)\n\n* Incomplete Code:\nproc max_distance_different_colors {colors} {\n[MASK]\nset length [llength $colors]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n[MASK]\n[MASK]\nif {$distance > $max_distance} {\n[MASK]\n}\n}\n}\n}\nreturn $max_distance\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset length [llength $colors]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\n[MASK]\n[MASK]\nif {$distance > $max_distance} {\n[MASK]\n}\n}\n}\n}\nreturn $max_distance\n}"}
{"task_id": "Tcl/17-1-multi", "prompt": "proc max_distance_different_colors {colors} {\n# Calculate the maximum distance between two houses of different colors.\n# >>> max_distance_different_colors {1 1 1 6 1 1 1}\n# 3 (Max distance between colors 1 and 6)\n# >>> max_distance_different_colors {1 2 1 2 1 2 1}\n# 5 (Max distance between any two different colors)", "canonical_solution": "set max_distance 0\nset length [llength $colors]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[lindex $colors $i] ne [lindex $colors $j]} {\nset distance [expr {abs($i - $j)}]\nif {$distance > $max_distance} {\nset max_distance $distance\n}\n}\n}\n}\nreturn $max_distance\n}", "test": "proc check {max_distance_different_colors} {\nif {[max_distance_different_colors {1 1 1 6 1 1 1}] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_distance_different_colors {1 2 1 2 1 2 1}] == 5} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_distance_different_colors {1 1 1 1 1}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_distance_different_colors {2 2 3 3 3 2 2}] == 4} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_distance_different_colors {1 3 2 4 5}] == 4} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_distance_different_colors {1}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_distance_different_colors {1 2 3 4 5 6}] == 5} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_distance_different_colors", "entry_point": "max_distance_different_colors", "signature": "proc max_distance_different_colors {colors} {", "docstring": "Calculate the maximum distance between two houses of different colors.\n>>> max_distance_different_colors {1 1 1 6 1 1 1}\n3 (Max distance between colors 1 and 6)\n>>> max_distance_different_colors {1 2 1 2 1 2 1}\n5 (Max distance between any two different colors)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum distance between two houses of different colors.\n>>> max_distance_different_colors {1 1 1 6 1 1 1}\n3 (Max distance between colors 1 and 6)\n>>> max_distance_different_colors {1 2 1 2 1 2 1}\n5 (Max distance between any two different colors)\n\n* Incomplete Code:\nproc max_distance_different_colors {colors} {\nset max_distance 0\nset length [llength $colors]\nfor {set i 0} {$i < $length - 1} {incr i} {\n[MASK]\n[MASK]\n[MASK]\nif {$distance > $max_distance} {\nset max_distance $distance\n}\n}\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set max_distance 0\nset length [llength $colors]\nfor {set i 0} {$i < $length - 1} {incr i} {\n[MASK]\n[MASK]\n[MASK]\nif {$distance > $max_distance} {\nset max_distance $distance\n}\n}\n}\n}\n[MASK]\n}"}
{"task_id": "Tcl/18-0-multi", "prompt": "proc count_unique_strings {words1 words2} {\n# Count the number of strings that appear exactly once in both arrays.\n# >>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n# 2 (\"banana\" appears exactly once in both arrays)\n# >>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n# 2 (\"b\" and \"c\" appear exactly once in both arrays)", "canonical_solution": "array set count_words1 {}\narray set count_words2 {}\nforeach word $words1 {\nincr count_words1($word)\n}\nforeach word $words2 {\nincr count_words2($word)\n}\n\nset unique_count 0\nforeach word $words1 {\nif {[info exists count_words1($word)] && [info exists count_words2($word)] && \n$count_words1($word) == 1 && $count_words2($word) == 1} {\nincr unique_count\n}\n}\nreturn $unique_count\n}", "test": "proc check {count_unique_strings} {\nif {[count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}] == 2} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_unique_strings {\"one\" \"two\" \"three\"} {\"four\" \"five\" \"six\"}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_unique_strings {\"alpha\" \"beta\" \"gamma\"} {\"alpha\" \"beta\" \"gamma\"}] == 3} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_unique_strings {\"x\" \"y\" \"z\"} {\"a\" \"b\" \"z\"}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_unique_strings {\"cat\" \"dog\" \"cat\"} {\"dog\" \"dog\" \"cat\"}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_unique_strings {\"hello\" \"world\"} {\"world\" \"hello\"}] == 2} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_unique_strings", "entry_point": "count_unique_strings", "signature": "proc count_unique_strings {words1 words2} {", "docstring": "Count the number of strings that appear exactly once in both arrays.\n>>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n2 (\"banana\" appears exactly once in both arrays)\n>>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n2 (\"b\" and \"c\" appear exactly once in both arrays)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of strings that appear exactly once in both arrays.\n>>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n2 (\"banana\" appears exactly once in both arrays)\n>>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n2 (\"b\" and \"c\" appear exactly once in both arrays)\n\n* Incomplete Code:\nproc count_unique_strings {words1 words2} {\n[MASK]\narray set count_words2 {}\n[MASK]\nincr count_words1($word)\n}\nforeach word $words2 {\nincr count_words2($word)\n}\n\n[MASK]\nforeach word $words1 {\nif {[info exists count_words1($word)] && [info exists count_words2($word)] && \n$count_words1($word) == 1 && $count_words2($word) == 1} {\nincr unique_count\n}\n}\nreturn $unique_count\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\narray set count_words2 {}\n[MASK]\nincr count_words1($word)\n}\nforeach word $words2 {\nincr count_words2($word)\n}\n\n[MASK]\nforeach word $words1 {\nif {[info exists count_words1($word)] && [info exists count_words2($word)] && \n$count_words1($word) == 1 && $count_words2($word) == 1} {\nincr unique_count\n}\n}\nreturn $unique_count\n}"}
{"task_id": "Tcl/18-1-multi", "prompt": "proc count_unique_strings {words1 words2} {\n# Count the number of strings that appear exactly once in both arrays.\n# >>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n# 2 (\"banana\" appears exactly once in both arrays)\n# >>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n# 2 (\"b\" and \"c\" appear exactly once in both arrays)", "canonical_solution": "array set count_words1 {}\narray set count_words2 {}\nforeach word $words1 {\nincr count_words1($word)\n}\nforeach word $words2 {\nincr count_words2($word)\n}\n\nset unique_count 0\nforeach word $words1 {\nif {[info exists count_words1($word)] && [info exists count_words2($word)] && \n$count_words1($word) == 1 && $count_words2($word) == 1} {\nincr unique_count\n}\n}\nreturn $unique_count\n}", "test": "proc check {count_unique_strings} {\nif {[count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}] == 2} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_unique_strings {\"one\" \"two\" \"three\"} {\"four\" \"five\" \"six\"}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_unique_strings {\"alpha\" \"beta\" \"gamma\"} {\"alpha\" \"beta\" \"gamma\"}] == 3} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_unique_strings {\"x\" \"y\" \"z\"} {\"a\" \"b\" \"z\"}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_unique_strings {\"cat\" \"dog\" \"cat\"} {\"dog\" \"dog\" \"cat\"}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_unique_strings {\"hello\" \"world\"} {\"world\" \"hello\"}] == 2} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_unique_strings", "entry_point": "count_unique_strings", "signature": "proc count_unique_strings {words1 words2} {", "docstring": "Count the number of strings that appear exactly once in both arrays.\n>>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n2 (\"banana\" appears exactly once in both arrays)\n>>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n2 (\"b\" and \"c\" appear exactly once in both arrays)", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of strings that appear exactly once in both arrays.\n>>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n2 (\"banana\" appears exactly once in both arrays)\n>>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n2 (\"b\" and \"c\" appear exactly once in both arrays)\n\n* Incomplete Code:\nproc count_unique_strings {words1 words2} {\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n}\nforeach word $words2 {\nincr count_words2($word)\n}\n\nset unique_count 0\nforeach word $words1 {\nif {[info exists count_words1($word)] && [info exists count_words2($word)] && \n$count_words1($word) == 1 && $count_words2($word) == 1} {\n[MASK]\n}\n}\nreturn $unique_count\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n[MASK]\n[MASK]\n}\nforeach word $words2 {\nincr count_words2($word)\n}\n\nset unique_count 0\nforeach word $words1 {\nif {[info exists count_words1($word)] && [info exists count_words2($word)] && \n$count_words1($word) == 1 && $count_words2($word) == 1} {\n[MASK]\n}\n}\nreturn $unique_count\n}"}
{"task_id": "Tcl/19-0-multi", "prompt": "proc find_even_numbers {digits} {\n# Find all unique even numbers formed by concatenating three digits from 'digits'.\n# Exclude numbers with leading zeros.\n# >>> find_even_numbers {1 2 3}\n# {132 312}\n# >>> find_even_numbers {0 1 2}\n# {102 120 201 210}", "canonical_solution": "set unique_numbers {}\nset length [llength $digits]\n\nfor {set i 0} {$i < $length} {incr i} {\nfor {set j 0} {$j < $length} {incr j} {\nfor {set k 0} {$k < $length} {incr k} {\nif {$i == $j || $j == $k || $i == $k} continue\nset number [expr {[lindex $digits $i] * 100 + [lindex $digits $j] * 10 + [lindex $digits $k]}]\nif {[lindex $digits $i] != 0 && $number % 2 == 0} {\nlappend unique_numbers $number\n}\n}\n}\n}\n\nreturn [lsort -integer -unique $unique_numbers]\n}", "test": "proc check {find_even_numbers} {\nif {[find_even_numbers {1 2 3}] eq {132 312}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_even_numbers {0 1 2}] eq {102 120 210}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_even_numbers {4 6 8}] eq {468 486 648 684 846 864}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_even_numbers {0 0 2}] eq {200}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_even_numbers {5 7 9}] eq {}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_even_numbers {1 1 2}] eq {112}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_even_numbers {0 1 1}] eq {110}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_even_numbers", "entry_point": "find_even_numbers", "signature": "proc find_even_numbers {digits} {", "docstring": "Find all unique even numbers formed by concatenating three digits from 'digits'.\nExclude numbers with leading zeros.\n>>> find_even_numbers {1 2 3}\n{132 312}\n>>> find_even_numbers {0 1 2}\n{102 120 201 210}", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nFind all unique even numbers formed by concatenating three digits from 'digits'.\nExclude numbers with leading zeros.\n>>> find_even_numbers {1 2 3}\n{132 312}\n>>> find_even_numbers {0 1 2}\n{102 120 201 210}\n\n* Incomplete Code:\nproc find_even_numbers {digits} {\n[MASK]\n[MASK]\n\nfor {set i 0} {$i < $length} {incr i} {\nfor {set j 0} {$j < $length} {incr j} {\nfor {set k 0} {$k < $length} {incr k} {\nif {$i == $j || $j == $k || $i == $k} continue\n[MASK]\nif {[lindex $digits $i] != 0 && $number % 2 == 0} {\nlappend unique_numbers $number\n}\n}\n}\n}\n\nreturn [lsort -integer -unique $unique_numbers]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n\nfor {set i 0} {$i < $length} {incr i} {\nfor {set j 0} {$j < $length} {incr j} {\nfor {set k 0} {$k < $length} {incr k} {\nif {$i == $j || $j == $k || $i == $k} continue\n[MASK]\nif {[lindex $digits $i] != 0 && $number % 2 == 0} {\nlappend unique_numbers $number\n}\n}\n}\n}\n\nreturn [lsort -integer -unique $unique_numbers]\n}"}
{"task_id": "Tcl/19-1-multi", "prompt": "proc find_even_numbers {digits} {\n# Find all unique even numbers formed by concatenating three digits from 'digits'.\n# Exclude numbers with leading zeros.\n# >>> find_even_numbers {1 2 3}\n# {132 312}\n# >>> find_even_numbers {0 1 2}\n# {102 120 201 210}", "canonical_solution": "set unique_numbers {}\nset length [llength $digits]\n\nfor {set i 0} {$i < $length} {incr i} {\nfor {set j 0} {$j < $length} {incr j} {\nfor {set k 0} {$k < $length} {incr k} {\nif {$i == $j || $j == $k || $i == $k} continue\nset number [expr {[lindex $digits $i] * 100 + [lindex $digits $j] * 10 + [lindex $digits $k]}]\nif {[lindex $digits $i] != 0 && $number % 2 == 0} {\nlappend unique_numbers $number\n}\n}\n}\n}\n\nreturn [lsort -integer -unique $unique_numbers]\n}", "test": "proc check {find_even_numbers} {\nif {[find_even_numbers {1 2 3}] eq {132 312}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_even_numbers {0 1 2}] eq {102 120 210}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_even_numbers {4 6 8}] eq {468 486 648 684 846 864}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_even_numbers {0 0 2}] eq {200}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_even_numbers {5 7 9}] eq {}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_even_numbers {1 1 2}] eq {112}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_even_numbers {0 1 1}] eq {110}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_even_numbers", "entry_point": "find_even_numbers", "signature": "proc find_even_numbers {digits} {", "docstring": "Find all unique even numbers formed by concatenating three digits from 'digits'.\nExclude numbers with leading zeros.\n>>> find_even_numbers {1 2 3}\n{132 312}\n>>> find_even_numbers {0 1 2}\n{102 120 201 210}", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nFind all unique even numbers formed by concatenating three digits from 'digits'.\nExclude numbers with leading zeros.\n>>> find_even_numbers {1 2 3}\n{132 312}\n>>> find_even_numbers {0 1 2}\n{102 120 201 210}\n\n* Incomplete Code:\nproc find_even_numbers {digits} {\n[MASK]\nset length [llength $digits]\n\nfor {set i 0} {$i < $length} {incr i} {\n[MASK]\nfor {set k 0} {$k < $length} {incr k} {\nif {$i == $j || $j == $k || $i == $k} continue\nset number [expr {[lindex $digits $i] * 100 + [lindex $digits $j] * 10 + [lindex $digits $k]}]\nif {[lindex $digits $i] != 0 && $number % 2 == 0} {\n[MASK]\n}\n}\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\nset length [llength $digits]\n\nfor {set i 0} {$i < $length} {incr i} {\n[MASK]\nfor {set k 0} {$k < $length} {incr k} {\nif {$i == $j || $j == $k || $i == $k} continue\nset number [expr {[lindex $digits $i] * 100 + [lindex $digits $j] * 10 + [lindex $digits $k]}]\nif {[lindex $digits $i] != 0 && $number % 2 == 0} {\n[MASK]\n}\n}\n}\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/21-0-multi", "prompt": "proc find_max_population_year {logs} {\n# This function finds the earliest year with the highest population.\n# Each element in 'logs' is a two-element list [birth, death] representing\n# the birth and death years of a person.\n# A person is counted in the population for each year from their birth year\n# up to the year before their death.\n# >>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n# 1940\n# >>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n# 2000", "canonical_solution": "array set year_count {}\nforeach log $logs {\nfor {set year [lindex $log 0]} {$year < [lindex $log 1]} {incr year} {\nincr year_count($year)\n}\n}\n\nset max_population 0\nset max_population_year 0\nforeach year [array names year_count] {\nif {$year_count($year) > $max_population} {\nset max_population $year_count($year)\nset max_population_year $year\n} elseif {$year_count($year) == $max_population && $year < $max_population_year} {\nset max_population_year $year\n}\n}\n\nreturn $max_population_year\n}", "test": "proc check {find_max_population_year} {\nif {[find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}] == 1940} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}] == 2000} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_max_population_year {{1990 1995} {1995 2000} {2000 2005}}] == 1990} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_max_population_year {{1800 1801} {1800 1802} {1801 1802}}] == 1800} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_max_population_year {{1950 1960} {1950 1960} {1950 1960}}] == 1950} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_max_population_year {{1600 1700} {1601 1701} {1602 1702}}] == 1602} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_max_population_year {{2000 2005} {2001 2006} {2002 2007}}] == 2002} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_max_population_year", "entry_point": "find_max_population_year", "signature": "proc find_max_population_year {logs} {", "docstring": "This function finds the earliest year with the highest population.\nEach element in 'logs' is a two-element list [birth, death] representing\nthe birth and death years of a person.\nA person is counted in the population for each year from their birth year\nup to the year before their death.\n>>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n1940\n>>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n2000", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function finds the earliest year with the highest population.\nEach element in 'logs' is a two-element list [birth, death] representing\nthe birth and death years of a person.\nA person is counted in the population for each year from their birth year\nup to the year before their death.\n>>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n1940\n>>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n2000\n\n* Incomplete Code:\nproc find_max_population_year {logs} {\narray set year_count {}\nforeach log $logs {\n[MASK]\n[MASK]\n}\n}\n\nset max_population 0\n[MASK]\nforeach year [array names year_count] {\nif {$year_count($year) > $max_population} {\nset max_population $year_count($year)\nset max_population_year $year\n} elseif {$year_count($year) == $max_population && $year < $max_population_year} {\n[MASK]\n}\n}\n\nreturn $max_population_year\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "array set year_count {}\nforeach log $logs {\n[MASK]\n[MASK]\n}\n}\n\nset max_population 0\n[MASK]\nforeach year [array names year_count] {\nif {$year_count($year) > $max_population} {\nset max_population $year_count($year)\nset max_population_year $year\n} elseif {$year_count($year) == $max_population && $year < $max_population_year} {\n[MASK]\n}\n}\n\nreturn $max_population_year\n}"}
{"task_id": "Tcl/21-1-multi", "prompt": "proc find_max_population_year {logs} {\n# This function finds the earliest year with the highest population.\n# Each element in 'logs' is a two-element list [birth, death] representing\n# the birth and death years of a person.\n# A person is counted in the population for each year from their birth year\n# up to the year before their death.\n# >>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n# 1940\n# >>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n# 2000", "canonical_solution": "array set year_count {}\nforeach log $logs {\nfor {set year [lindex $log 0]} {$year < [lindex $log 1]} {incr year} {\nincr year_count($year)\n}\n}\n\nset max_population 0\nset max_population_year 0\nforeach year [array names year_count] {\nif {$year_count($year) > $max_population} {\nset max_population $year_count($year)\nset max_population_year $year\n} elseif {$year_count($year) == $max_population && $year < $max_population_year} {\nset max_population_year $year\n}\n}\n\nreturn $max_population_year\n}", "test": "proc check {find_max_population_year} {\nif {[find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}] == 1940} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}] == 2000} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_max_population_year {{1990 1995} {1995 2000} {2000 2005}}] == 1990} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_max_population_year {{1800 1801} {1800 1802} {1801 1802}}] == 1800} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_max_population_year {{1950 1960} {1950 1960} {1950 1960}}] == 1950} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_max_population_year {{1600 1700} {1601 1701} {1602 1702}}] == 1602} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_max_population_year {{2000 2005} {2001 2006} {2002 2007}}] == 2002} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_max_population_year", "entry_point": "find_max_population_year", "signature": "proc find_max_population_year {logs} {", "docstring": "This function finds the earliest year with the highest population.\nEach element in 'logs' is a two-element list [birth, death] representing\nthe birth and death years of a person.\nA person is counted in the population for each year from their birth year\nup to the year before their death.\n>>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n1940\n>>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n2000", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function finds the earliest year with the highest population.\nEach element in 'logs' is a two-element list [birth, death] representing\nthe birth and death years of a person.\nA person is counted in the population for each year from their birth year\nup to the year before their death.\n>>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n1940\n>>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n2000\n\n* Incomplete Code:\nproc find_max_population_year {logs} {\narray set year_count {}\nforeach log $logs {\nfor {set year [lindex $log 0]} {$year < [lindex $log 1]} {incr year} {\nincr year_count($year)\n}\n}\n\nset max_population 0\nset max_population_year 0\nforeach year [array names year_count] {\nif {$year_count($year) > $max_population} {\n[MASK]\nset max_population_year $year\n} elseif {$year_count($year) == $max_population && $year < $max_population_year} {\nset max_population_year $year\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "array set year_count {}\nforeach log $logs {\nfor {set year [lindex $log 0]} {$year < [lindex $log 1]} {incr year} {\nincr year_count($year)\n}\n}\n\nset max_population 0\nset max_population_year 0\nforeach year [array names year_count] {\nif {$year_count($year) > $max_population} {\n[MASK]\nset max_population_year $year\n} elseif {$year_count($year) == $max_population && $year < $max_population_year} {\nset max_population_year $year\n}\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/22-0-multi", "prompt": "proc can_be_equal_by_rotation {mat target} {\n# Check if rotating 'mat' 90 degrees clockwise any number of times\n# can make it identical to 'target'.\n# >>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n# 1\n# >>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n# 0", "canonical_solution": "for {set i 0} {$i < 4} {incr i} {\nif {[is_matrix_equal $mat $target]} {\nreturn 1\n}\nset mat [rotate_matrix $mat]\n}\n\nreturn 0\n}\n\nproc rotate_matrix {matrix} {\n# Rotate a square matrix 90 degrees clockwise.\nset n [llength $matrix]\nset rotated_matrix [list]\n\nfor {set i 0} {$i < $n} {incr i} {\nset row [list]\nfor {set j [expr {$n - 1}]} {$j >= 0} {incr j -1} {\nlappend row [lindex $matrix $j $i]\n}\nlappend rotated_matrix $row\n}\n\nreturn $rotated_matrix\n}\n\nproc is_matrix_equal {mat1 mat2} {\n# Check if two matrices are equal.\nset n [llength $mat1]\nfor {set i 0} {$i < $n} {incr i} {\nfor {set j 0} {$j < $n} {incr j} {\nif {[lindex $mat1 $i $j] ne [lindex $mat2 $i $j]} {\nreturn 0\n}\n}\n}\nreturn 1\n}", "test": "proc check {can_be_equal_by_rotation} {\nif {[can_be_equal_by_rotation {{1 0} {0 1}} {{0 1} {1 0}}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 1 0} {0 0 1} {0 1 0}} {{0 0 1} {1 1 0} {0 1 0}}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 1} {1 0}} {{0 1} {1 1}}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{0 0} {0 0}} {{0 0} {0 0}}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 0 0} {0 1 0} {0 0 1}} {{0 0 1} {0 1 0} {1 0 0}}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 0 1} {0 1 0} {1 0 1}} {{1 0 1} {0 1 0} {1 0 1}}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck can_be_equal_by_rotation", "entry_point": "can_be_equal_by_rotation", "signature": "proc can_be_equal_by_rotation {mat target} {", "docstring": "Check if rotating 'mat' 90 degrees clockwise any number of times\ncan make it identical to 'target'.\n>>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n1\n>>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n0", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if rotating 'mat' 90 degrees clockwise any number of times\ncan make it identical to 'target'.\n>>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n1\n>>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n0\n\n* Incomplete Code:\nproc can_be_equal_by_rotation {mat target} {\nfor {set i 0} {$i < 4} {incr i} {\n[MASK]\nreturn 1\n}\nset mat [rotate_matrix $mat]\n}\n\nreturn 0\n}\n\nproc rotate_matrix {matrix} {\n# Rotate a square matrix 90 degrees clockwise.\nset n [llength $matrix]\n[MASK]\n\nfor {set i 0} {$i < $n} {incr i} {\nset row [list]\nfor {set j [expr {$n - 1}]} {$j >= 0} {incr j -1} {\nlappend row [lindex $matrix $j $i]\n}\n[MASK]\n}\n\nreturn $rotated_matrix\n}\n\nproc is_matrix_equal {mat1 mat2} {\n# Check if two matrices are equal.\n[MASK]\nfor {set i 0} {$i < $n} {incr i} {\n[MASK]\nif {[lindex $mat1 $i $j] ne [lindex $mat2 $i $j]} {\nreturn 0\n}\n}\n}\nreturn 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "for {set i 0} {$i < 4} {incr i} {\n[MASK]\nreturn 1\n}\nset mat [rotate_matrix $mat]\n}\n\nreturn 0\n}\n\nproc rotate_matrix {matrix} {\n# Rotate a square matrix 90 degrees clockwise.\nset n [llength $matrix]\n[MASK]\n\nfor {set i 0} {$i < $n} {incr i} {\nset row [list]\nfor {set j [expr {$n - 1}]} {$j >= 0} {incr j -1} {\nlappend row [lindex $matrix $j $i]\n}\n[MASK]\n}\n\nreturn $rotated_matrix\n}\n\nproc is_matrix_equal {mat1 mat2} {\n# Check if two matrices are equal.\n[MASK]\nfor {set i 0} {$i < $n} {incr i} {\n[MASK]\nif {[lindex $mat1 $i $j] ne [lindex $mat2 $i $j]} {\nreturn 0\n}\n}\n}\nreturn 1\n}"}
{"task_id": "Tcl/22-1-multi", "prompt": "proc can_be_equal_by_rotation {mat target} {\n# Check if rotating 'mat' 90 degrees clockwise any number of times\n# can make it identical to 'target'.\n# >>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n# 1\n# >>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n# 0", "canonical_solution": "for {set i 0} {$i < 4} {incr i} {\nif {[is_matrix_equal $mat $target]} {\nreturn 1\n}\nset mat [rotate_matrix $mat]\n}\n\nreturn 0\n}\n\nproc rotate_matrix {matrix} {\n# Rotate a square matrix 90 degrees clockwise.\nset n [llength $matrix]\nset rotated_matrix [list]\n\nfor {set i 0} {$i < $n} {incr i} {\nset row [list]\nfor {set j [expr {$n - 1}]} {$j >= 0} {incr j -1} {\nlappend row [lindex $matrix $j $i]\n}\nlappend rotated_matrix $row\n}\n\nreturn $rotated_matrix\n}\n\nproc is_matrix_equal {mat1 mat2} {\n# Check if two matrices are equal.\nset n [llength $mat1]\nfor {set i 0} {$i < $n} {incr i} {\nfor {set j 0} {$j < $n} {incr j} {\nif {[lindex $mat1 $i $j] ne [lindex $mat2 $i $j]} {\nreturn 0\n}\n}\n}\nreturn 1\n}", "test": "proc check {can_be_equal_by_rotation} {\nif {[can_be_equal_by_rotation {{1 0} {0 1}} {{0 1} {1 0}}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 1 0} {0 0 1} {0 1 0}} {{0 0 1} {1 1 0} {0 1 0}}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 1} {1 0}} {{0 1} {1 1}}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{0 0} {0 0}} {{0 0} {0 0}}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 0 0} {0 1 0} {0 0 1}} {{0 0 1} {0 1 0} {1 0 0}}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 0 1} {0 1 0} {1 0 1}} {{1 0 1} {0 1 0} {1 0 1}}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck can_be_equal_by_rotation", "entry_point": "can_be_equal_by_rotation", "signature": "proc can_be_equal_by_rotation {mat target} {", "docstring": "Check if rotating 'mat' 90 degrees clockwise any number of times\ncan make it identical to 'target'.\n>>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n1\n>>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n0", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCheck if rotating 'mat' 90 degrees clockwise any number of times\ncan make it identical to 'target'.\n>>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n1\n>>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n0\n\n* Incomplete Code:\nproc can_be_equal_by_rotation {mat target} {\nfor {set i 0} {$i < 4} {incr i} {\nif {[is_matrix_equal $mat $target]} {\n[MASK]\n}\nset mat [rotate_matrix $mat]\n}\n\nreturn 0\n}\n\n[MASK]\n# Rotate a square matrix 90 degrees clockwise.\nset n [llength $matrix]\nset rotated_matrix [list]\n\nfor {set i 0} {$i < $n} {incr i} {\nset row [list]\nfor {set j [expr {$n - 1}]} {$j >= 0} {incr j -1} {\nlappend row [lindex $matrix $j $i]\n}\nlappend rotated_matrix $row\n}\n\nreturn $rotated_matrix\n}\n\nproc is_matrix_equal {mat1 mat2} {\n# Check if two matrices are equal.\nset n [llength $mat1]\nfor {set i 0} {$i < $n} {incr i} {\nfor {set j 0} {$j < $n} {incr j} {\n[MASK]\nreturn 0\n}\n}\n}\nreturn 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "for {set i 0} {$i < 4} {incr i} {\nif {[is_matrix_equal $mat $target]} {\n[MASK]\n}\nset mat [rotate_matrix $mat]\n}\n\nreturn 0\n}\n\n[MASK]\n# Rotate a square matrix 90 degrees clockwise.\nset n [llength $matrix]\nset rotated_matrix [list]\n\nfor {set i 0} {$i < $n} {incr i} {\nset row [list]\nfor {set j [expr {$n - 1}]} {$j >= 0} {incr j -1} {\nlappend row [lindex $matrix $j $i]\n}\nlappend rotated_matrix $row\n}\n\nreturn $rotated_matrix\n}\n\nproc is_matrix_equal {mat1 mat2} {\n# Check if two matrices are equal.\nset n [llength $mat1]\nfor {set i 0} {$i < $n} {incr i} {\nfor {set j 0} {$j < $n} {incr j} {\n[MASK]\nreturn 0\n}\n}\n}\nreturn 1\n}"}
{"task_id": "Tcl/23-0-multi", "prompt": "proc findTriplets {A B C} {\n# This function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\n# The numbers are composed of the digits 1 to 9, each used exactly once.\n# It returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\n# Example usage:\n# >>> findTriplets 1 2 3\n# {192 384 576} {219 438 657} {273 546 819} {327 654 981}\n# >>> findTriplets 1 1 1\n# No!!!", "canonical_solution": "set digits {1 2 3 4 5 6 7 8 9}\nset result {}\n\nforeach a [permute $digits 3] {\nforeach b [permute $digits 3] {\nforeach c [permute $digits 3] {\nif {![uniqueDigits $a $b $c]} continue\nset numA [join $a \"\"]\nset numB [join $b \"\"]\nset numC [join $c \"\"]\n\nif {$numB * $A == $numA * $B && $numC * $A == $numA * $C} {\nlappend result [list $numA $numB $numC]\n}\n}\n}\n}\n\nif {[llength $result] == 0} {\nreturn \"No!!!\"\n} else {\nreturn [lsort $result]\n}\n}\n\nproc permute {list n} {\n# Generate all n-length permutations of the list\n}\n\nproc uniqueDigits {list1 list2 list3} {\n# Check if all digits in the three lists are unique\n}", "test": "proc check {findTriplets} {\n# Test Cases\nset test1 [findTriplets 1 2 3]\nif {[llength $test1] > 0} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nset test2 [findTriplets 2 3 4]\nif {[llength $test2] > 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nset test3 [findTriplets 1 1 1]\nif {$test3 eq \"No!!!\"} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nset test4 [findTriplets 3 3 3]\nif {$test4 eq \"No!!!\"} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nset test5 [findTriplets 5 7 9]\nif {[llength $test5] > 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n}\n\n# Call the check procedure\ncheck findTriplets", "entry_point": "findTriplets", "signature": "proc findTriplets {A B C} {", "docstring": "This function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\nThe numbers are composed of the digits 1 to 9, each used exactly once.\nIt returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\nExample usage:\n>>> findTriplets 1 2 3\n{192 384 576} {219 438 657} {273 546 819} {327 654 981}\n>>> findTriplets 1 1 1\nNo!!!", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\nThe numbers are composed of the digits 1 to 9, each used exactly once.\nIt returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\nExample usage:\n>>> findTriplets 1 2 3\n{192 384 576} {219 438 657} {273 546 819} {327 654 981}\n>>> findTriplets 1 1 1\nNo!!!\n\n* Incomplete Code:\nproc findTriplets {A B C} {\nset digits {1 2 3 4 5 6 7 8 9}\nset result {}\n\nforeach a [permute $digits 3] {\nforeach b [permute $digits 3] {\nforeach c [permute $digits 3] {\nif {![uniqueDigits $a $b $c]} continue\nset numA [join $a \"\"]\n[MASK]\nset numC [join $c \"\"]\n\nif {$numB * $A == $numA * $B && $numC * $A == $numA * $C} {\n[MASK]\n}\n}\n}\n}\n\nif {[llength $result] == 0} {\nreturn \"No!!!\"\n} else {\n[MASK]\n}\n}\n\nproc permute {list n} {\n# Generate all n-length permutations of the list\n}\n\nproc uniqueDigits {list1 list2 list3} {\n# Check if all digits in the three lists are unique\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "set digits {1 2 3 4 5 6 7 8 9}\nset result {}\n\nforeach a [permute $digits 3] {\nforeach b [permute $digits 3] {\nforeach c [permute $digits 3] {\nif {![uniqueDigits $a $b $c]} continue\nset numA [join $a \"\"]\n[MASK]\nset numC [join $c \"\"]\n\nif {$numB * $A == $numA * $B && $numC * $A == $numA * $C} {\n[MASK]\n}\n}\n}\n}\n\nif {[llength $result] == 0} {\nreturn \"No!!!\"\n} else {\n[MASK]\n}\n}\n\nproc permute {list n} {\n# Generate all n-length permutations of the list\n}\n\nproc uniqueDigits {list1 list2 list3} {\n# Check if all digits in the three lists are unique\n}"}
{"task_id": "Tcl/23-1-multi", "prompt": "proc findTriplets {A B C} {\n# This function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\n# The numbers are composed of the digits 1 to 9, each used exactly once.\n# It returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\n# Example usage:\n# >>> findTriplets 1 2 3\n# {192 384 576} {219 438 657} {273 546 819} {327 654 981}\n# >>> findTriplets 1 1 1\n# No!!!", "canonical_solution": "set digits {1 2 3 4 5 6 7 8 9}\nset result {}\n\nforeach a [permute $digits 3] {\nforeach b [permute $digits 3] {\nforeach c [permute $digits 3] {\nif {![uniqueDigits $a $b $c]} continue\nset numA [join $a \"\"]\nset numB [join $b \"\"]\nset numC [join $c \"\"]\n\nif {$numB * $A == $numA * $B && $numC * $A == $numA * $C} {\nlappend result [list $numA $numB $numC]\n}\n}\n}\n}\n\nif {[llength $result] == 0} {\nreturn \"No!!!\"\n} else {\nreturn [lsort $result]\n}\n}\n\nproc permute {list n} {\n# Generate all n-length permutations of the list\n}\n\nproc uniqueDigits {list1 list2 list3} {\n# Check if all digits in the three lists are unique\n}", "test": "proc check {findTriplets} {\n# Test Cases\nset test1 [findTriplets 1 2 3]\nif {[llength $test1] > 0} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nset test2 [findTriplets 2 3 4]\nif {[llength $test2] > 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nset test3 [findTriplets 1 1 1]\nif {$test3 eq \"No!!!\"} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nset test4 [findTriplets 3 3 3]\nif {$test4 eq \"No!!!\"} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nset test5 [findTriplets 5 7 9]\nif {[llength $test5] > 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n}\n\n# Call the check procedure\ncheck findTriplets", "entry_point": "findTriplets", "signature": "proc findTriplets {A B C} {", "docstring": "This function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\nThe numbers are composed of the digits 1 to 9, each used exactly once.\nIt returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\nExample usage:\n>>> findTriplets 1 2 3\n{192 384 576} {219 438 657} {273 546 819} {327 654 981}\n>>> findTriplets 1 1 1\nNo!!!", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\nThe numbers are composed of the digits 1 to 9, each used exactly once.\nIt returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\nExample usage:\n>>> findTriplets 1 2 3\n{192 384 576} {219 438 657} {273 546 819} {327 654 981}\n>>> findTriplets 1 1 1\nNo!!!\n\n* Incomplete Code:\nproc findTriplets {A B C} {\n[MASK]\nset result {}\n\nforeach a [permute $digits 3] {\nforeach b [permute $digits 3] {\nforeach c [permute $digits 3] {\nif {![uniqueDigits $a $b $c]} continue\nset numA [join $a \"\"]\nset numB [join $b \"\"]\nset numC [join $c \"\"]\n\nif {$numB * $A == $numA * $B && $numC * $A == $numA * $C} {\nlappend result [list $numA $numB $numC]\n}\n}\n}\n}\n\n[MASK]\nreturn \"No!!!\"\n} else {\nreturn [lsort $result]\n}\n}\n\nproc permute {list n} {\n# Generate all n-length permutations of the list\n}\n\nproc uniqueDigits {list1 list2 list3} {\n# Check if all digits in the three lists are unique\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\nset result {}\n\nforeach a [permute $digits 3] {\nforeach b [permute $digits 3] {\nforeach c [permute $digits 3] {\nif {![uniqueDigits $a $b $c]} continue\nset numA [join $a \"\"]\nset numB [join $b \"\"]\nset numC [join $c \"\"]\n\nif {$numB * $A == $numA * $B && $numC * $A == $numA * $C} {\nlappend result [list $numA $numB $numC]\n}\n}\n}\n}\n\n[MASK]\nreturn \"No!!!\"\n} else {\nreturn [lsort $result]\n}\n}\n\nproc permute {list n} {\n# Generate all n-length permutations of the list\n}\n\nproc uniqueDigits {list1 list2 list3} {\n# Check if all digits in the three lists are unique\n}"}
{"task_id": "Tcl/24-0-multi", "prompt": "proc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {\n# Calculate the perimeter of a triangle given the coordinates of its three vertices.\n# The coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\n# The function returns the perimeter of the triangle rounded to two decimal places.\n#\n# Example usage:\n# >>> calculate_triangle_perimeter 0 0 3 0 0 4\n# 12.00\n# >>> calculate_triangle_perimeter 1 1 4 1 1 5\n# 12.00", "canonical_solution": "# Helper function to calculate distance between two points\nproc distance {x1 y1 x2 y2} {\nreturn [expr {sqrt(pow($x2 - $x1, 2) + pow($y2 - $y1, 2))}]\n}\n\n# Calculate distances between each pair of points\nset d1 [distance $x1 $y1 $x2 $y2]\nset d2 [distance $x2 $y2 $x3 $y3]\nset d3 [distance $x3 $y3 $x1 $y1]\n\n# Sum the distances and round to two decimal places\nreturn [format \"%.2f\" [expr {$d1 + $d2 + $d3}]]\n}", "test": "proc check {calculate_triangle_perimeter} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_triangle_perimeter 0 0 3 0 0 4] \"12.00\" \"Test case 1\"\nassert_equal [calculate_triangle_perimeter 1 1 4 1 1 5] \"12.00\" \"Test case 2\"\nassert_equal [calculate_triangle_perimeter 0 0 0 6 8 0] \"24.00\" \"Test case 3\"\nassert_equal [calculate_triangle_perimeter 1 2 3 4 5 6] \"11.31\" \"Test case 4\"\nassert_equal [calculate_triangle_perimeter -1 -2 -3 -4 -5 -6] \"11.31\" \"Test case 5\"\nassert_equal [calculate_triangle_perimeter 10 10 20 20 30 30] \"56.57\" \"Test case 6\"\n}\n\n# Call the check procedure\ncheck calculate_triangle_perimeter", "entry_point": "calculate_triangle_perimeter", "signature": "proc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {", "docstring": "Calculate the perimeter of a triangle given the coordinates of its three vertices.\nThe coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\nThe function returns the perimeter of the triangle rounded to two decimal places.\n\nExample usage:\n>>> calculate_triangle_perimeter 0 0 3 0 0 4\n12.00\n>>> calculate_triangle_perimeter 1 1 4 1 1 5\n12.00", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the perimeter of a triangle given the coordinates of its three vertices.\nThe coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\nThe function returns the perimeter of the triangle rounded to two decimal places.\n\nExample usage:\n>>> calculate_triangle_perimeter 0 0 3 0 0 4\n12.00\n>>> calculate_triangle_perimeter 1 1 4 1 1 5\n12.00\n\n* Incomplete Code:\nproc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {\n# Helper function to calculate distance between two points\nproc distance {x1 y1 x2 y2} {\n[MASK]\n}\n\n# Calculate distances between each pair of points\n[MASK]\n[MASK]\nset d3 [distance $x3 $y3 $x1 $y1]\n\n# Sum the distances and round to two decimal places\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "# Helper function to calculate distance between two points\nproc distance {x1 y1 x2 y2} {\n[MASK]\n}\n\n# Calculate distances between each pair of points\n[MASK]\n[MASK]\nset d3 [distance $x3 $y3 $x1 $y1]\n\n# Sum the distances and round to two decimal places\n[MASK]\n}"}
{"task_id": "Tcl/24-1-multi", "prompt": "proc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {\n# Calculate the perimeter of a triangle given the coordinates of its three vertices.\n# The coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\n# The function returns the perimeter of the triangle rounded to two decimal places.\n#\n# Example usage:\n# >>> calculate_triangle_perimeter 0 0 3 0 0 4\n# 12.00\n# >>> calculate_triangle_perimeter 1 1 4 1 1 5\n# 12.00", "canonical_solution": "# Helper function to calculate distance between two points\nproc distance {x1 y1 x2 y2} {\nreturn [expr {sqrt(pow($x2 - $x1, 2) + pow($y2 - $y1, 2))}]\n}\n\n# Calculate distances between each pair of points\nset d1 [distance $x1 $y1 $x2 $y2]\nset d2 [distance $x2 $y2 $x3 $y3]\nset d3 [distance $x3 $y3 $x1 $y1]\n\n# Sum the distances and round to two decimal places\nreturn [format \"%.2f\" [expr {$d1 + $d2 + $d3}]]\n}", "test": "proc check {calculate_triangle_perimeter} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_triangle_perimeter 0 0 3 0 0 4] \"12.00\" \"Test case 1\"\nassert_equal [calculate_triangle_perimeter 1 1 4 1 1 5] \"12.00\" \"Test case 2\"\nassert_equal [calculate_triangle_perimeter 0 0 0 6 8 0] \"24.00\" \"Test case 3\"\nassert_equal [calculate_triangle_perimeter 1 2 3 4 5 6] \"11.31\" \"Test case 4\"\nassert_equal [calculate_triangle_perimeter -1 -2 -3 -4 -5 -6] \"11.31\" \"Test case 5\"\nassert_equal [calculate_triangle_perimeter 10 10 20 20 30 30] \"56.57\" \"Test case 6\"\n}\n\n# Call the check procedure\ncheck calculate_triangle_perimeter", "entry_point": "calculate_triangle_perimeter", "signature": "proc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {", "docstring": "Calculate the perimeter of a triangle given the coordinates of its three vertices.\nThe coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\nThe function returns the perimeter of the triangle rounded to two decimal places.\n\nExample usage:\n>>> calculate_triangle_perimeter 0 0 3 0 0 4\n12.00\n>>> calculate_triangle_perimeter 1 1 4 1 1 5\n12.00", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculate the perimeter of a triangle given the coordinates of its three vertices.\nThe coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\nThe function returns the perimeter of the triangle rounded to two decimal places.\n\nExample usage:\n>>> calculate_triangle_perimeter 0 0 3 0 0 4\n12.00\n>>> calculate_triangle_perimeter 1 1 4 1 1 5\n12.00\n\n* Incomplete Code:\nproc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {\n# Helper function to calculate distance between two points\nproc distance {x1 y1 x2 y2} {\n[MASK]\n}\n\n# Calculate distances between each pair of points\nset d1 [distance $x1 $y1 $x2 $y2]\n[MASK]\nset d3 [distance $x3 $y3 $x1 $y1]\n\n# Sum the distances and round to two decimal places\nreturn [format \"%.2f\" [expr {$d1 + $d2 + $d3}]]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "# Helper function to calculate distance between two points\nproc distance {x1 y1 x2 y2} {\n[MASK]\n}\n\n# Calculate distances between each pair of points\nset d1 [distance $x1 $y1 $x2 $y2]\n[MASK]\nset d3 [distance $x3 $y3 $x1 $y1]\n\n# Sum the distances and round to two decimal places\nreturn [format \"%.2f\" [expr {$d1 + $d2 + $d3}]]\n}"}
{"task_id": "Tcl/25-0-multi", "prompt": "proc count_leap_years {x y} {\n# Count the number of leap years within a given range [x, y] and list them.\n# Leap years are years divisible by 4, but not by 100, unless also divisible by 400.\n# The function returns the count of leap years and a list of these leap years.\n# The input x and y should be non-negative integers with x <= y.\n#\n# Example usage:\n# >>> count_leap_years 2000 2020\n# 6\n# 2000 2004 2008 2012 2016 2020\n# >>> count_leap_years 1900 1920\n# 5\n# 1904 1908 1912 1916 1920", "canonical_solution": "set leap_years {}\nset count 0\n\nfor {set i $x} {$i <= $y} {incr i} {\nif {[is_leap_year $i]} {\nlappend leap_years $i\nincr count\n}\n}\n\n# Format the output as a single string\nreturn [format \"%d\\n%s\" $count [join $leap_years \" \"]]\n}\nproc is_leap_year {year} {\nexpr {($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0)}\n}", "test": "proc test_count_leap_years {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual ne $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [count_leap_years 2000 2020] \"6\\n2000 2004 2008 2012 2016 2020\" \"Test case 1\"\nassert_equal [count_leap_years 1900 1920] \"5\\n1904 1908 1912 1916 1920\" \"Test case 2\"\nassert_equal [count_leap_years 1950 1960] \"3\\n1952 1956 1960\" \"Test case 3\"\nassert_equal [count_leap_years 1985 1995] \"2\\n1988 1992\" \"Test case 4\" \nassert_equal [count_leap_years 2010 2015] \"1\\n2012\" \"Test case 5\"\n}\n\n# Call the test procedure\ntest_count_leap_years", "entry_point": "count_leap_years", "signature": "proc count_leap_years {x y} {", "docstring": "Count the number of leap years within a given range [x, y] and list them.\nLeap years are years divisible by 4, but not by 100, unless also divisible by 400.\nThe function returns the count of leap years and a list of these leap years.\nThe input x and y should be non-negative integers with x <= y.\n\nExample usage:\n>>> count_leap_years 2000 2020\n6\n2000 2004 2008 2012 2016 2020\n>>> count_leap_years 1900 1920\n5\n1904 1908 1912 1916 1920", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of leap years within a given range [x, y] and list them.\nLeap years are years divisible by 4, but not by 100, unless also divisible by 400.\nThe function returns the count of leap years and a list of these leap years.\nThe input x and y should be non-negative integers with x <= y.\n\nExample usage:\n>>> count_leap_years 2000 2020\n6\n2000 2004 2008 2012 2016 2020\n>>> count_leap_years 1900 1920\n5\n1904 1908 1912 1916 1920\n\n* Incomplete Code:\nproc count_leap_years {x y} {\n[MASK]\nset count 0\n\nfor {set i $x} {$i <= $y} {incr i} {\nif {[is_leap_year $i]} {\n[MASK]\n[MASK]\n}\n}\n\n# Format the output as a single string\n[MASK]\n}\nproc is_leap_year {year} {\nexpr {($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0)}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset count 0\n\nfor {set i $x} {$i <= $y} {incr i} {\nif {[is_leap_year $i]} {\n[MASK]\n[MASK]\n}\n}\n\n# Format the output as a single string\n[MASK]\n}\nproc is_leap_year {year} {\nexpr {($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0)}\n}"}
{"task_id": "Tcl/25-1-multi", "prompt": "proc count_leap_years {x y} {\n# Count the number of leap years within a given range [x, y] and list them.\n# Leap years are years divisible by 4, but not by 100, unless also divisible by 400.\n# The function returns the count of leap years and a list of these leap years.\n# The input x and y should be non-negative integers with x <= y.\n#\n# Example usage:\n# >>> count_leap_years 2000 2020\n# 6\n# 2000 2004 2008 2012 2016 2020\n# >>> count_leap_years 1900 1920\n# 5\n# 1904 1908 1912 1916 1920", "canonical_solution": "set leap_years {}\nset count 0\n\nfor {set i $x} {$i <= $y} {incr i} {\nif {[is_leap_year $i]} {\nlappend leap_years $i\nincr count\n}\n}\n\n# Format the output as a single string\nreturn [format \"%d\\n%s\" $count [join $leap_years \" \"]]\n}\nproc is_leap_year {year} {\nexpr {($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0)}\n}", "test": "proc test_count_leap_years {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual ne $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [count_leap_years 2000 2020] \"6\\n2000 2004 2008 2012 2016 2020\" \"Test case 1\"\nassert_equal [count_leap_years 1900 1920] \"5\\n1904 1908 1912 1916 1920\" \"Test case 2\"\nassert_equal [count_leap_years 1950 1960] \"3\\n1952 1956 1960\" \"Test case 3\"\nassert_equal [count_leap_years 1985 1995] \"2\\n1988 1992\" \"Test case 4\" \nassert_equal [count_leap_years 2010 2015] \"1\\n2012\" \"Test case 5\"\n}\n\n# Call the test procedure\ntest_count_leap_years", "entry_point": "count_leap_years", "signature": "proc count_leap_years {x y} {", "docstring": "Count the number of leap years within a given range [x, y] and list them.\nLeap years are years divisible by 4, but not by 100, unless also divisible by 400.\nThe function returns the count of leap years and a list of these leap years.\nThe input x and y should be non-negative integers with x <= y.\n\nExample usage:\n>>> count_leap_years 2000 2020\n6\n2000 2004 2008 2012 2016 2020\n>>> count_leap_years 1900 1920\n5\n1904 1908 1912 1916 1920", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCount the number of leap years within a given range [x, y] and list them.\nLeap years are years divisible by 4, but not by 100, unless also divisible by 400.\nThe function returns the count of leap years and a list of these leap years.\nThe input x and y should be non-negative integers with x <= y.\n\nExample usage:\n>>> count_leap_years 2000 2020\n6\n2000 2004 2008 2012 2016 2020\n>>> count_leap_years 1900 1920\n5\n1904 1908 1912 1916 1920\n\n* Incomplete Code:\nproc count_leap_years {x y} {\nset leap_years {}\nset count 0\n\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\n# Format the output as a single string\nreturn [format \"%d\\n%s\" $count [join $leap_years \" \"]]\n}\nproc is_leap_year {year} {\nexpr {($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0)}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set leap_years {}\nset count 0\n\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\n# Format the output as a single string\nreturn [format \"%d\\n%s\" $count [join $leap_years \" \"]]\n}\nproc is_leap_year {year} {\nexpr {($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0)}\n}"}
{"task_id": "Tcl/26-0-multi", "prompt": "proc calculate_peaches {n} {\n# This function calculates the total number of peaches a monkey bought,\n# based on the number of days it ate them.\n# Each day the monkey eats half of the peaches plus one.\n# On the nth day, only one peach is left.\n# The function expects a positive integer n, representing the number of days,\n# and returns the total number of peaches initially bought by the monkey.\n#\n# Example usage:\n# >>> calculate_peaches 3\n# 10\n# >>> calculate_peaches 5\n# 46", "canonical_solution": "set peaches 1\nfor {set i 1} {$i < $n} {incr i} {\nset peaches [expr {($peaches + 1) * 2}]\n}\nreturn $peaches\n}", "test": "proc check {calculate_peaches} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_peaches 3] \"10\" \"Test case 1\"\nassert_equal [calculate_peaches 5] \"46\" \"Test case 2\"\nassert_equal [calculate_peaches 6] \"94\" \"Test case 3\"\nassert_equal [calculate_peaches 7] \"190\" \"Test case 4\"\nassert_equal [calculate_peaches 8] \"382\" \"Test case 5\"\nassert_equal [calculate_peaches 2] \"4\" \"Test case 6\"\n}\n\n# Call the check procedure\ncheck calculate_peaches", "entry_point": "calculate_peaches", "signature": "proc calculate_peaches {n} {", "docstring": "This function calculates the total number of peaches a monkey bought,\nbased on the number of days it ate them.\nEach day the monkey eats half of the peaches plus one.\nOn the nth day, only one peach is left.\nThe function expects a positive integer n, representing the number of days,\nand returns the total number of peaches initially bought by the monkey.\n\nExample usage:\n>>> calculate_peaches 3\n10\n>>> calculate_peaches 5\n46", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the total number of peaches a monkey bought,\nbased on the number of days it ate them.\nEach day the monkey eats half of the peaches plus one.\nOn the nth day, only one peach is left.\nThe function expects a positive integer n, representing the number of days,\nand returns the total number of peaches initially bought by the monkey.\n\nExample usage:\n>>> calculate_peaches 3\n10\n>>> calculate_peaches 5\n46\n\n* Incomplete Code:\nproc calculate_peaches {n} {\nset peaches 1\n[MASK]\n[MASK]\n}\nreturn $peaches\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set peaches 1\n[MASK]\n[MASK]\n}\nreturn $peaches\n}"}
{"task_id": "Tcl/26-1-multi", "prompt": "proc calculate_peaches {n} {\n# This function calculates the total number of peaches a monkey bought,\n# based on the number of days it ate them.\n# Each day the monkey eats half of the peaches plus one.\n# On the nth day, only one peach is left.\n# The function expects a positive integer n, representing the number of days,\n# and returns the total number of peaches initially bought by the monkey.\n#\n# Example usage:\n# >>> calculate_peaches 3\n# 10\n# >>> calculate_peaches 5\n# 46", "canonical_solution": "set peaches 1\nfor {set i 1} {$i < $n} {incr i} {\nset peaches [expr {($peaches + 1) * 2}]\n}\nreturn $peaches\n}", "test": "proc check {calculate_peaches} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_peaches 3] \"10\" \"Test case 1\"\nassert_equal [calculate_peaches 5] \"46\" \"Test case 2\"\nassert_equal [calculate_peaches 6] \"94\" \"Test case 3\"\nassert_equal [calculate_peaches 7] \"190\" \"Test case 4\"\nassert_equal [calculate_peaches 8] \"382\" \"Test case 5\"\nassert_equal [calculate_peaches 2] \"4\" \"Test case 6\"\n}\n\n# Call the check procedure\ncheck calculate_peaches", "entry_point": "calculate_peaches", "signature": "proc calculate_peaches {n} {", "docstring": "This function calculates the total number of peaches a monkey bought,\nbased on the number of days it ate them.\nEach day the monkey eats half of the peaches plus one.\nOn the nth day, only one peach is left.\nThe function expects a positive integer n, representing the number of days,\nand returns the total number of peaches initially bought by the monkey.\n\nExample usage:\n>>> calculate_peaches 3\n10\n>>> calculate_peaches 5\n46", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the total number of peaches a monkey bought,\nbased on the number of days it ate them.\nEach day the monkey eats half of the peaches plus one.\nOn the nth day, only one peach is left.\nThe function expects a positive integer n, representing the number of days,\nand returns the total number of peaches initially bought by the monkey.\n\nExample usage:\n>>> calculate_peaches 3\n10\n>>> calculate_peaches 5\n46\n\n* Incomplete Code:\nproc calculate_peaches {n} {\n[MASK]\nfor {set i 1} {$i < $n} {incr i} {\n[MASK]\n}\nreturn $peaches\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nfor {set i 1} {$i < $n} {incr i} {\n[MASK]\n}\nreturn $peaches\n}"}
{"task_id": "Tcl/27-0-multi", "prompt": "proc update_student_info {students} {\n# This function updates the information of students who have undergone a year of training.\n# Each student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\n# After a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n#\n# Arguments:\n# students: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n#\n# Returns:\n# A list of updated student information with increased age and improved NOIP scores.\n#\n# Example usage:\n# >>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\n# Alice 16 360 Bob 18 540 Charlie 17 600", "canonical_solution": "set updated_students {}\n\nforeach student $students {\nlassign $student name age score\n\n# Increase age and calculate new score\nincr age\nset new_score [expr {min(600, int($score * 1.2))}]\n\n# Append updated student info to the list\nlappend updated_students [list $name $age $new_score]\n}\n\nreturn $updated_students\n}", "test": "proc check {update_student_info} {\n# Test case utility\nproc assert_equal {actual expected message} {\nset actual_str \"\"\nforeach student $actual {\nappend actual_str [join $student \" \"] \" \"\n}\nset actual_str [string trim $actual_str]\n\nif {$actual_str != $expected} {\nerror \"$message. Expected $expected but got $actual_str\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}] \"Alice 16 360 Bob 18 540 Charlie 17 600\" \"Test case 1\"\nassert_equal [update_student_info {{\"Daniel\" 14 100} {\"Eve\" 18 580} {\"Frank\" 17 500}}] \"Daniel 15 120 Eve 19 600 Frank 18 600\" \"Test case 2\"\nassert_equal [update_student_info {{\"Grace\" 15 0} {\"Henry\" 16 600}}] \"Grace 16 0 Henry 17 600\" \"Test case 3\"\n}\n\n# Call the check procedure\ncheck update_student_info", "entry_point": "update_student_info", "signature": "proc update_student_info {students} {", "docstring": "This function updates the information of students who have undergone a year of training.\nEach student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\nAfter a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n\nArguments:\nstudents: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n\nReturns:\nA list of updated student information with increased age and improved NOIP scores.\n\nExample usage:\n>>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\nAlice 16 360 Bob 18 540 Charlie 17 600", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function updates the information of students who have undergone a year of training.\nEach student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\nAfter a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n\nArguments:\nstudents: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n\nReturns:\nA list of updated student information with increased age and improved NOIP scores.\n\nExample usage:\n>>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\nAlice 16 360 Bob 18 540 Charlie 17 600\n\n* Incomplete Code:\nproc update_student_info {students} {\nset updated_students {}\n\n[MASK]\nlassign $student name age score\n\n# Increase age and calculate new score\nincr age\n[MASK]\n\n# Append updated student info to the list\nlappend updated_students [list $name $age $new_score]\n}\n\nreturn $updated_students\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set updated_students {}\n\n[MASK]\nlassign $student name age score\n\n# Increase age and calculate new score\nincr age\n[MASK]\n\n# Append updated student info to the list\nlappend updated_students [list $name $age $new_score]\n}\n\nreturn $updated_students\n}"}
{"task_id": "Tcl/27-1-multi", "prompt": "proc update_student_info {students} {\n# This function updates the information of students who have undergone a year of training.\n# Each student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\n# After a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n#\n# Arguments:\n# students: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n#\n# Returns:\n# A list of updated student information with increased age and improved NOIP scores.\n#\n# Example usage:\n# >>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\n# Alice 16 360 Bob 18 540 Charlie 17 600", "canonical_solution": "set updated_students {}\n\nforeach student $students {\nlassign $student name age score\n\n# Increase age and calculate new score\nincr age\nset new_score [expr {min(600, int($score * 1.2))}]\n\n# Append updated student info to the list\nlappend updated_students [list $name $age $new_score]\n}\n\nreturn $updated_students\n}", "test": "proc check {update_student_info} {\n# Test case utility\nproc assert_equal {actual expected message} {\nset actual_str \"\"\nforeach student $actual {\nappend actual_str [join $student \" \"] \" \"\n}\nset actual_str [string trim $actual_str]\n\nif {$actual_str != $expected} {\nerror \"$message. Expected $expected but got $actual_str\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}] \"Alice 16 360 Bob 18 540 Charlie 17 600\" \"Test case 1\"\nassert_equal [update_student_info {{\"Daniel\" 14 100} {\"Eve\" 18 580} {\"Frank\" 17 500}}] \"Daniel 15 120 Eve 19 600 Frank 18 600\" \"Test case 2\"\nassert_equal [update_student_info {{\"Grace\" 15 0} {\"Henry\" 16 600}}] \"Grace 16 0 Henry 17 600\" \"Test case 3\"\n}\n\n# Call the check procedure\ncheck update_student_info", "entry_point": "update_student_info", "signature": "proc update_student_info {students} {", "docstring": "This function updates the information of students who have undergone a year of training.\nEach student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\nAfter a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n\nArguments:\nstudents: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n\nReturns:\nA list of updated student information with increased age and improved NOIP scores.\n\nExample usage:\n>>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\nAlice 16 360 Bob 18 540 Charlie 17 600", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function updates the information of students who have undergone a year of training.\nEach student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\nAfter a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n\nArguments:\nstudents: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n\nReturns:\nA list of updated student information with increased age and improved NOIP scores.\n\nExample usage:\n>>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\nAlice 16 360 Bob 18 540 Charlie 17 600\n\n* Incomplete Code:\nproc update_student_info {students} {\nset updated_students {}\n\nforeach student $students {\n[MASK]\n\n# Increase age and calculate new score\nincr age\n[MASK]\n\n# Append updated student info to the list\nlappend updated_students [list $name $age $new_score]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set updated_students {}\n\nforeach student $students {\n[MASK]\n\n# Increase age and calculate new score\nincr age\n[MASK]\n\n# Append updated student info to the list\nlappend updated_students [list $name $age $new_score]\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/28-0-multi", "prompt": "proc calculate_max_necklace_length {totalVolume lossPerBead} {\n# This function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\n# The diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\n# The function returns the maximum length of the necklace by determining the optimal number of beads.\n# It returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n#\n# Example usage:\n# >>> calculate_max_necklace_length 100 10\n# Result: 5", "canonical_solution": "set maxLen 0\nset numOfBeads 0\n\nfor {set i 1} {$i * $lossPerBead < $totalVolume} {incr i} {\nset volumePerBead [expr {$totalVolume / double($i)}]\nif {$volumePerBead <= $lossPerBead} break\n\nset diameter [expr {0.3 * sqrt($volumePerBead - $lossPerBead)}]\nset length [expr {$diameter * $i}]\nif {$length > $maxLen} {\nset maxLen $length\nset numOfBeads $i\n}\n}\n\nif {$numOfBeads == 0 || $maxLen == [expr {0.3 * sqrt($totalVolume - $lossPerBead) * 2}]} {\nreturn 0\n} else {\nreturn $numOfBeads\n}\n}", "test": "proc check {calculate_max_necklace_length} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_max_necklace_length 100 10] \"5\" {Test case 1}\nassert_equal [calculate_max_necklace_length 15 4] \"2\" {Test case 2}\nassert_equal [calculate_max_necklace_length 5000 50] \"50\" {Test case 3}\nassert_equal [calculate_max_necklace_length 300 30] \"5\" {Test case 4}\nassert_equal [calculate_max_necklace_length 2000 200] \"5\" {Test case 5}\n}\n\n# Call the check procedure\ncheck calculate_max_necklace_length", "entry_point": "calculate_max_necklace_length", "signature": "proc calculate_max_necklace_length {totalVolume lossPerBead} {", "docstring": "This function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\nThe diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\nThe function returns the maximum length of the necklace by determining the optimal number of beads.\nIt returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n\nExample usage:\n>>> calculate_max_necklace_length 100 10\nResult: 5", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\nThe diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\nThe function returns the maximum length of the necklace by determining the optimal number of beads.\nIt returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n\nExample usage:\n>>> calculate_max_necklace_length 100 10\nResult: 5\n\n* Incomplete Code:\nproc calculate_max_necklace_length {totalVolume lossPerBead} {\nset maxLen 0\nset numOfBeads 0\n\n[MASK]\nset volumePerBead [expr {$totalVolume / double($i)}]\nif {$volumePerBead <= $lossPerBead} break\n\nset diameter [expr {0.3 * sqrt($volumePerBead - $lossPerBead)}]\nset length [expr {$diameter * $i}]\nif {$length > $maxLen} {\nset maxLen $length\nset numOfBeads $i\n}\n}\n\nif {$numOfBeads == 0 || $maxLen == [expr {0.3 * sqrt($totalVolume - $lossPerBead) * 2}]} {\nreturn 0\n} else {\n[MASK]\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set maxLen 0\nset numOfBeads 0\n\n[MASK]\nset volumePerBead [expr {$totalVolume / double($i)}]\nif {$volumePerBead <= $lossPerBead} break\n\nset diameter [expr {0.3 * sqrt($volumePerBead - $lossPerBead)}]\nset length [expr {$diameter * $i}]\nif {$length > $maxLen} {\nset maxLen $length\nset numOfBeads $i\n}\n}\n\nif {$numOfBeads == 0 || $maxLen == [expr {0.3 * sqrt($totalVolume - $lossPerBead) * 2}]} {\nreturn 0\n} else {\n[MASK]\n}\n}"}
{"task_id": "Tcl/28-1-multi", "prompt": "proc calculate_max_necklace_length {totalVolume lossPerBead} {\n# This function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\n# The diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\n# The function returns the maximum length of the necklace by determining the optimal number of beads.\n# It returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n#\n# Example usage:\n# >>> calculate_max_necklace_length 100 10\n# Result: 5", "canonical_solution": "set maxLen 0\nset numOfBeads 0\n\nfor {set i 1} {$i * $lossPerBead < $totalVolume} {incr i} {\nset volumePerBead [expr {$totalVolume / double($i)}]\nif {$volumePerBead <= $lossPerBead} break\n\nset diameter [expr {0.3 * sqrt($volumePerBead - $lossPerBead)}]\nset length [expr {$diameter * $i}]\nif {$length > $maxLen} {\nset maxLen $length\nset numOfBeads $i\n}\n}\n\nif {$numOfBeads == 0 || $maxLen == [expr {0.3 * sqrt($totalVolume - $lossPerBead) * 2}]} {\nreturn 0\n} else {\nreturn $numOfBeads\n}\n}", "test": "proc check {calculate_max_necklace_length} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_max_necklace_length 100 10] \"5\" {Test case 1}\nassert_equal [calculate_max_necklace_length 15 4] \"2\" {Test case 2}\nassert_equal [calculate_max_necklace_length 5000 50] \"50\" {Test case 3}\nassert_equal [calculate_max_necklace_length 300 30] \"5\" {Test case 4}\nassert_equal [calculate_max_necklace_length 2000 200] \"5\" {Test case 5}\n}\n\n# Call the check procedure\ncheck calculate_max_necklace_length", "entry_point": "calculate_max_necklace_length", "signature": "proc calculate_max_necklace_length {totalVolume lossPerBead} {", "docstring": "This function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\nThe diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\nThe function returns the maximum length of the necklace by determining the optimal number of beads.\nIt returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n\nExample usage:\n>>> calculate_max_necklace_length 100 10\nResult: 5", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\nThe diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\nThe function returns the maximum length of the necklace by determining the optimal number of beads.\nIt returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n\nExample usage:\n>>> calculate_max_necklace_length 100 10\nResult: 5\n\n* Incomplete Code:\nproc calculate_max_necklace_length {totalVolume lossPerBead} {\nset maxLen 0\nset numOfBeads 0\n\nfor {set i 1} {$i * $lossPerBead < $totalVolume} {incr i} {\nset volumePerBead [expr {$totalVolume / double($i)}]\nif {$volumePerBead <= $lossPerBead} break\n\n[MASK]\n[MASK]\n[MASK]\nset maxLen $length\nset numOfBeads $i\n}\n}\n\nif {$numOfBeads == 0 || $maxLen == [expr {0.3 * sqrt($totalVolume - $lossPerBead) * 2}]} {\nreturn 0\n} else {\n[MASK]\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set maxLen 0\nset numOfBeads 0\n\nfor {set i 1} {$i * $lossPerBead < $totalVolume} {incr i} {\nset volumePerBead [expr {$totalVolume / double($i)}]\nif {$volumePerBead <= $lossPerBead} break\n\n[MASK]\n[MASK]\n[MASK]\nset maxLen $length\nset numOfBeads $i\n}\n}\n\nif {$numOfBeads == 0 || $maxLen == [expr {0.3 * sqrt($totalVolume - $lossPerBead) * 2}]} {\nreturn 0\n} else {\n[MASK]\n}\n}"}
{"task_id": "Tcl/29-0-multi", "prompt": "proc calculate_consistent_pairs {k rankings} {\n# Calculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\n# A pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n#\n# Args:\n# k: The number of training sessions (integer).\n# rankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n#\n# Returns:\n# The number of consistent pairs of cows.\n#\n# Example usage:\n# >>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n# 2", "canonical_solution": "# Helper function to check if a pair is consistent\nproc is_consistent {pair rankings} {\nforeach session $rankings {\nif {[lsearch -exact $session [lindex $pair 0]] > [lsearch -exact $session [lindex $pair 1]]} {\nreturn 0\n}\n}\nreturn 1\n}\n\n\nset consistent_count 0\n\n# Assume N is the number of cows, which should be the length of the first ranking list\nset N [llength [lindex $rankings 0]]\n\n# Generate all pairs of cows\nfor {set i 1} {$i < $N} {incr i} {\nfor {set j [expr {$i + 1}]} {$j <= $N} {incr j} {\nset pair [list $i $j]\nif {[is_consistent $pair $rankings]} {\nincr consistent_count\n}\n}\n}\n\n\nreturn $consistent_count\n}", "test": "proc check {calculate_consistent_pairs} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}] 2 \"Test case 1\"\nassert_equal [calculate_consistent_pairs 3 {{3 2 1} {1 3 2} {2 1 3}}] 0 \"Test case 2\"\nassert_equal [calculate_consistent_pairs 3 {{1 2 3 4} {2 3 4 1} {3 4 1 2}}] 1 \"Test case 3\"\nassert_equal [calculate_consistent_pairs 4 {{1 2 3 4} {4 3 2 1} {1 4 2 3} {3 1 4 2}}] 0 \"Test case 4\"\n}\n\n# Call the check procedure\ncheck calculate_consistent_pairs", "entry_point": "calculate_consistent_pairs", "signature": "proc calculate_consistent_pairs {k rankings} {", "docstring": "Calculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\nA pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n\nArgs:\nk: The number of training sessions (integer).\nrankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n\nReturns:\nThe number of consistent pairs of cows.\n\nExample usage:\n>>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n2", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\nA pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n\nArgs:\nk: The number of training sessions (integer).\nrankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n\nReturns:\nThe number of consistent pairs of cows.\n\nExample usage:\n>>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n2\n\n* Incomplete Code:\nproc calculate_consistent_pairs {k rankings} {\n# Helper function to check if a pair is consistent\nproc is_consistent {pair rankings} {\nforeach session $rankings {\n[MASK]\nreturn 0\n}\n}\nreturn 1\n}\n\n\n[MASK]\n\n# Assume N is the number of cows, which should be the length of the first ranking list\n[MASK]\n\n# Generate all pairs of cows\nfor {set i 1} {$i < $N} {incr i} {\nfor {set j [expr {$i + 1}]} {$j <= $N} {incr j} {\nset pair [list $i $j]\nif {[is_consistent $pair $rankings]} {\nincr consistent_count\n}\n}\n}\n\n\nreturn $consistent_count\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "# Helper function to check if a pair is consistent\nproc is_consistent {pair rankings} {\nforeach session $rankings {\n[MASK]\nreturn 0\n}\n}\nreturn 1\n}\n\n\n[MASK]\n\n# Assume N is the number of cows, which should be the length of the first ranking list\n[MASK]\n\n# Generate all pairs of cows\nfor {set i 1} {$i < $N} {incr i} {\nfor {set j [expr {$i + 1}]} {$j <= $N} {incr j} {\nset pair [list $i $j]\nif {[is_consistent $pair $rankings]} {\nincr consistent_count\n}\n}\n}\n\n\nreturn $consistent_count\n}"}
{"task_id": "Tcl/29-1-multi", "prompt": "proc calculate_consistent_pairs {k rankings} {\n# Calculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\n# A pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n#\n# Args:\n# k: The number of training sessions (integer).\n# rankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n#\n# Returns:\n# The number of consistent pairs of cows.\n#\n# Example usage:\n# >>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n# 2", "canonical_solution": "# Helper function to check if a pair is consistent\nproc is_consistent {pair rankings} {\nforeach session $rankings {\nif {[lsearch -exact $session [lindex $pair 0]] > [lsearch -exact $session [lindex $pair 1]]} {\nreturn 0\n}\n}\nreturn 1\n}\n\n\nset consistent_count 0\n\n# Assume N is the number of cows, which should be the length of the first ranking list\nset N [llength [lindex $rankings 0]]\n\n# Generate all pairs of cows\nfor {set i 1} {$i < $N} {incr i} {\nfor {set j [expr {$i + 1}]} {$j <= $N} {incr j} {\nset pair [list $i $j]\nif {[is_consistent $pair $rankings]} {\nincr consistent_count\n}\n}\n}\n\n\nreturn $consistent_count\n}", "test": "proc check {calculate_consistent_pairs} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}] 2 \"Test case 1\"\nassert_equal [calculate_consistent_pairs 3 {{3 2 1} {1 3 2} {2 1 3}}] 0 \"Test case 2\"\nassert_equal [calculate_consistent_pairs 3 {{1 2 3 4} {2 3 4 1} {3 4 1 2}}] 1 \"Test case 3\"\nassert_equal [calculate_consistent_pairs 4 {{1 2 3 4} {4 3 2 1} {1 4 2 3} {3 1 4 2}}] 0 \"Test case 4\"\n}\n\n# Call the check procedure\ncheck calculate_consistent_pairs", "entry_point": "calculate_consistent_pairs", "signature": "proc calculate_consistent_pairs {k rankings} {", "docstring": "Calculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\nA pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n\nArgs:\nk: The number of training sessions (integer).\nrankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n\nReturns:\nThe number of consistent pairs of cows.\n\nExample usage:\n>>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n2", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\nA pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n\nArgs:\nk: The number of training sessions (integer).\nrankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n\nReturns:\nThe number of consistent pairs of cows.\n\nExample usage:\n>>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n2\n\n* Incomplete Code:\nproc calculate_consistent_pairs {k rankings} {\n# Helper function to check if a pair is consistent\nproc is_consistent {pair rankings} {\nforeach session $rankings {\nif {[lsearch -exact $session [lindex $pair 0]] > [lsearch -exact $session [lindex $pair 1]]} {\nreturn 0\n}\n}\nreturn 1\n}\n\n\nset consistent_count 0\n\n# Assume N is the number of cows, which should be the length of the first ranking list\n[MASK]\n\n# Generate all pairs of cows\nfor {set i 1} {$i < $N} {incr i} {\n[MASK]\nset pair [list $i $j]\nif {[is_consistent $pair $rankings]} {\n[MASK]\n}\n}\n}\n\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "# Helper function to check if a pair is consistent\nproc is_consistent {pair rankings} {\nforeach session $rankings {\nif {[lsearch -exact $session [lindex $pair 0]] > [lsearch -exact $session [lindex $pair 1]]} {\nreturn 0\n}\n}\nreturn 1\n}\n\n\nset consistent_count 0\n\n# Assume N is the number of cows, which should be the length of the first ranking list\n[MASK]\n\n# Generate all pairs of cows\nfor {set i 1} {$i < $N} {incr i} {\n[MASK]\nset pair [list $i $j]\nif {[is_consistent $pair $rankings]} {\n[MASK]\n}\n}\n}\n\n\n[MASK]\n}"}
{"task_id": "Tcl/30-0-multi", "prompt": "proc find_min_unique_sequence_length {mailbox_sequence} {\n# This function finds the minimum length of a unique sequence of characters\n# in a given string representing a series of colored mailboxes along a road.\n# Each character in the string is an uppercase letter from A to Z, representing\n# the color of a mailbox. The function returns the smallest integer K such that\n# any sequence of K consecutive characters in the string is unique within the string.\n#\n# Example usage:\n# >>> find_min_unique_sequence_length \"AABCAA\"\n# 3\n# >>> find_min_unique_sequence_length \"XYZXYZ\"\n# 4", "canonical_solution": "set n [string length $mailbox_sequence]\nfor {set k 1} {$k <= $n} {incr k} {\nset unique 1\n# Initialize seen_sequences as an array\narray set seen_sequences {}\nfor {set i 0} {$i <= $n - $k} {incr i} {\nset seq [string range $mailbox_sequence $i [expr {$i + $k - 1}]]\nif {[info exists seen_sequences($seq)]} {\nset unique 0\nbreak\n} else {\nset seen_sequences($seq) 1\n}\n}\nif {$unique} {\nreturn $k\n}\n}\n}", "test": "proc check {find_min_unique_sequence_length} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [find_min_unique_sequence_length \"AABCAA\"] 3 \"Test case 1\"\nassert_equal [find_min_unique_sequence_length \"XYZXYZ\"] 4 \"Test case 2\"\nassert_equal [find_min_unique_sequence_length \"BBBBB\"] 5 \"Test case 3\"\nassert_equal [find_min_unique_sequence_length \"ABCDEFA\"] 2 \"Test case 4\"\nassert_equal [find_min_unique_sequence_length \"GHIJKLGH\"] 3 \"Test case 5\"\nassert_equal [find_min_unique_sequence_length \"RSTUVWXYZRST\"] 4 \"Test case 6\"\n}\n\n# Call the check procedure\ncheck find_min_unique_sequence_length", "entry_point": "find_min_unique_sequence_length", "signature": "proc find_min_unique_sequence_length {mailbox_sequence} {", "docstring": "This function finds the minimum length of a unique sequence of characters\nin a given string representing a series of colored mailboxes along a road.\nEach character in the string is an uppercase letter from A to Z, representing\nthe color of a mailbox. The function returns the smallest integer K such that\nany sequence of K consecutive characters in the string is unique within the string.\n\nExample usage:\n>>> find_min_unique_sequence_length \"AABCAA\"\n3\n>>> find_min_unique_sequence_length \"XYZXYZ\"\n4", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function finds the minimum length of a unique sequence of characters\nin a given string representing a series of colored mailboxes along a road.\nEach character in the string is an uppercase letter from A to Z, representing\nthe color of a mailbox. The function returns the smallest integer K such that\nany sequence of K consecutive characters in the string is unique within the string.\n\nExample usage:\n>>> find_min_unique_sequence_length \"AABCAA\"\n3\n>>> find_min_unique_sequence_length \"XYZXYZ\"\n4\n\n* Incomplete Code:\nproc find_min_unique_sequence_length {mailbox_sequence} {\nset n [string length $mailbox_sequence]\nfor {set k 1} {$k <= $n} {incr k} {\nset unique 1\n# Initialize seen_sequences as an array\n[MASK]\nfor {set i 0} {$i <= $n - $k} {incr i} {\n[MASK]\n[MASK]\nset unique 0\n[MASK]\n} else {\nset seen_sequences($seq) 1\n}\n}\nif {$unique} {\n[MASK]\n}\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set n [string length $mailbox_sequence]\nfor {set k 1} {$k <= $n} {incr k} {\nset unique 1\n# Initialize seen_sequences as an array\n[MASK]\nfor {set i 0} {$i <= $n - $k} {incr i} {\n[MASK]\n[MASK]\nset unique 0\n[MASK]\n} else {\nset seen_sequences($seq) 1\n}\n}\nif {$unique} {\n[MASK]\n}\n}\n}"}
{"task_id": "Tcl/30-1-multi", "prompt": "proc find_min_unique_sequence_length {mailbox_sequence} {\n# This function finds the minimum length of a unique sequence of characters\n# in a given string representing a series of colored mailboxes along a road.\n# Each character in the string is an uppercase letter from A to Z, representing\n# the color of a mailbox. The function returns the smallest integer K such that\n# any sequence of K consecutive characters in the string is unique within the string.\n#\n# Example usage:\n# >>> find_min_unique_sequence_length \"AABCAA\"\n# 3\n# >>> find_min_unique_sequence_length \"XYZXYZ\"\n# 4", "canonical_solution": "set n [string length $mailbox_sequence]\nfor {set k 1} {$k <= $n} {incr k} {\nset unique 1\n# Initialize seen_sequences as an array\narray set seen_sequences {}\nfor {set i 0} {$i <= $n - $k} {incr i} {\nset seq [string range $mailbox_sequence $i [expr {$i + $k - 1}]]\nif {[info exists seen_sequences($seq)]} {\nset unique 0\nbreak\n} else {\nset seen_sequences($seq) 1\n}\n}\nif {$unique} {\nreturn $k\n}\n}\n}", "test": "proc check {find_min_unique_sequence_length} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [find_min_unique_sequence_length \"AABCAA\"] 3 \"Test case 1\"\nassert_equal [find_min_unique_sequence_length \"XYZXYZ\"] 4 \"Test case 2\"\nassert_equal [find_min_unique_sequence_length \"BBBBB\"] 5 \"Test case 3\"\nassert_equal [find_min_unique_sequence_length \"ABCDEFA\"] 2 \"Test case 4\"\nassert_equal [find_min_unique_sequence_length \"GHIJKLGH\"] 3 \"Test case 5\"\nassert_equal [find_min_unique_sequence_length \"RSTUVWXYZRST\"] 4 \"Test case 6\"\n}\n\n# Call the check procedure\ncheck find_min_unique_sequence_length", "entry_point": "find_min_unique_sequence_length", "signature": "proc find_min_unique_sequence_length {mailbox_sequence} {", "docstring": "This function finds the minimum length of a unique sequence of characters\nin a given string representing a series of colored mailboxes along a road.\nEach character in the string is an uppercase letter from A to Z, representing\nthe color of a mailbox. The function returns the smallest integer K such that\nany sequence of K consecutive characters in the string is unique within the string.\n\nExample usage:\n>>> find_min_unique_sequence_length \"AABCAA\"\n3\n>>> find_min_unique_sequence_length \"XYZXYZ\"\n4", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function finds the minimum length of a unique sequence of characters\nin a given string representing a series of colored mailboxes along a road.\nEach character in the string is an uppercase letter from A to Z, representing\nthe color of a mailbox. The function returns the smallest integer K such that\nany sequence of K consecutive characters in the string is unique within the string.\n\nExample usage:\n>>> find_min_unique_sequence_length \"AABCAA\"\n3\n>>> find_min_unique_sequence_length \"XYZXYZ\"\n4\n\n* Incomplete Code:\nproc find_min_unique_sequence_length {mailbox_sequence} {\nset n [string length $mailbox_sequence]\nfor {set k 1} {$k <= $n} {incr k} {\n[MASK]\n# Initialize seen_sequences as an array\narray set seen_sequences {}\nfor {set i 0} {$i <= $n - $k} {incr i} {\nset seq [string range $mailbox_sequence $i [expr {$i + $k - 1}]]\n[MASK]\nset unique 0\nbreak\n} else {\nset seen_sequences($seq) 1\n}\n}\nif {$unique} {\nreturn $k\n}\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set n [string length $mailbox_sequence]\nfor {set k 1} {$k <= $n} {incr k} {\n[MASK]\n# Initialize seen_sequences as an array\narray set seen_sequences {}\nfor {set i 0} {$i <= $n - $k} {incr i} {\nset seq [string range $mailbox_sequence $i [expr {$i + $k - 1}]]\n[MASK]\nset unique 0\nbreak\n} else {\nset seen_sequences($seq) 1\n}\n}\nif {$unique} {\nreturn $k\n}\n}\n}"}
{"task_id": "Tcl/32-0-multi", "prompt": "proc calculate_minimal_dissatisfaction {schoolScores studentScores} {\n# This function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\n# It takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\n# The function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n#\n# Example usage:\n# >>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n# 25\n# >>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n# 40", "canonical_solution": "set totalDissatisfaction 0\n\nforeach studentScore $studentScores {\nset minDissatisfaction 1000000\n\nforeach schoolScore $schoolScores {\nset difference [expr {abs($studentScore - $schoolScore)}]\n\nif {$difference < $minDissatisfaction} {\nset minDissatisfaction $difference\n}\n}\n\nset totalDissatisfaction [expr {$totalDissatisfaction + $minDissatisfaction}]\n}\n\nreturn $totalDissatisfaction\n}", "test": "proc check {calculate_minimal_dissatisfaction} {\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\nassert_equal [calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}] 25 \"Test case 1\"\nassert_equal [calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}] 40 \"Test case 2\"\nassert_equal [calculate_minimal_dissatisfaction {520 580 640} {500 630 550}] 60 \"Test case 3\"\nassert_equal [calculate_minimal_dissatisfaction {530 560 590 620} {550 570 540}] 30 \"Test case 4\"\nassert_equal [calculate_minimal_dissatisfaction {500 530 560 590} {510 540 570}] 30 \"Test case 5\"\n}\n\ncheck calculate_minimal_dissatisfaction", "entry_point": "calculate_minimal_dissatisfaction", "signature": "proc calculate_minimal_dissatisfaction {schoolScores studentScores} {", "docstring": "This function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\nIt takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\nThe function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n\nExample usage:\n>>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n25\n>>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n40", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\nIt takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\nThe function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n\nExample usage:\n>>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n25\n>>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n40\n\n* Incomplete Code:\nproc calculate_minimal_dissatisfaction {schoolScores studentScores} {\nset totalDissatisfaction 0\n\nforeach studentScore $studentScores {\nset minDissatisfaction 1000000\n\nforeach schoolScore $schoolScores {\n[MASK]\n\nif {$difference < $minDissatisfaction} {\n[MASK]\n}\n}\n\nset totalDissatisfaction [expr {$totalDissatisfaction + $minDissatisfaction}]\n}\n\nreturn $totalDissatisfaction\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set totalDissatisfaction 0\n\nforeach studentScore $studentScores {\nset minDissatisfaction 1000000\n\nforeach schoolScore $schoolScores {\n[MASK]\n\nif {$difference < $minDissatisfaction} {\n[MASK]\n}\n}\n\nset totalDissatisfaction [expr {$totalDissatisfaction + $minDissatisfaction}]\n}\n\nreturn $totalDissatisfaction\n}"}
{"task_id": "Tcl/32-1-multi", "prompt": "proc calculate_minimal_dissatisfaction {schoolScores studentScores} {\n# This function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\n# It takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\n# The function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n#\n# Example usage:\n# >>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n# 25\n# >>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n# 40", "canonical_solution": "set totalDissatisfaction 0\n\nforeach studentScore $studentScores {\nset minDissatisfaction 1000000\n\nforeach schoolScore $schoolScores {\nset difference [expr {abs($studentScore - $schoolScore)}]\n\nif {$difference < $minDissatisfaction} {\nset minDissatisfaction $difference\n}\n}\n\nset totalDissatisfaction [expr {$totalDissatisfaction + $minDissatisfaction}]\n}\n\nreturn $totalDissatisfaction\n}", "test": "proc check {calculate_minimal_dissatisfaction} {\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\nassert_equal [calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}] 25 \"Test case 1\"\nassert_equal [calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}] 40 \"Test case 2\"\nassert_equal [calculate_minimal_dissatisfaction {520 580 640} {500 630 550}] 60 \"Test case 3\"\nassert_equal [calculate_minimal_dissatisfaction {530 560 590 620} {550 570 540}] 30 \"Test case 4\"\nassert_equal [calculate_minimal_dissatisfaction {500 530 560 590} {510 540 570}] 30 \"Test case 5\"\n}\n\ncheck calculate_minimal_dissatisfaction", "entry_point": "calculate_minimal_dissatisfaction", "signature": "proc calculate_minimal_dissatisfaction {schoolScores studentScores} {", "docstring": "This function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\nIt takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\nThe function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n\nExample usage:\n>>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n25\n>>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n40", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\nIt takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\nThe function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n\nExample usage:\n>>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n25\n>>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n40\n\n* Incomplete Code:\nproc calculate_minimal_dissatisfaction {schoolScores studentScores} {\nset totalDissatisfaction 0\n\nforeach studentScore $studentScores {\nset minDissatisfaction 1000000\n\nforeach schoolScore $schoolScores {\nset difference [expr {abs($studentScore - $schoolScore)}]\n\n[MASK]\n[MASK]\n}\n}\n\nset totalDissatisfaction [expr {$totalDissatisfaction + $minDissatisfaction}]\n}\n\nreturn $totalDissatisfaction\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set totalDissatisfaction 0\n\nforeach studentScore $studentScores {\nset minDissatisfaction 1000000\n\nforeach schoolScore $schoolScores {\nset difference [expr {abs($studentScore - $schoolScore)}]\n\n[MASK]\n[MASK]\n}\n}\n\nset totalDissatisfaction [expr {$totalDissatisfaction + $minDissatisfaction}]\n}\n\nreturn $totalDissatisfaction\n}"}
{"task_id": "Tcl/33-0-multi", "prompt": "proc solveEquation {equation} {\n# Solves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\n# The function takes a string input representing the equation. The equation may contain additional spaces.\n# It returns the value of the unknown variable as an integer.\n#\n# Example usage:\n# >>> solveEquation \"1+?=2\"\n# 1\n# >>> solveEquation \"4-3=?\"\n# 1\n# >>> solveEquation \"?-3=2\"\n# 5", "canonical_solution": "set cleanEquation [string map {\" \" \"\"} $equation]\n\n# Split the equation into parts\nregexp {(\\d+|\\?)([+-])(\\d+|\\?)=(\\d+|\\?)} $cleanEquation -> x op y z\n\n# Solve for the unknown\nif {\"?\" in $x} {\nset result [expr {$op eq \"+\" ? $z - $y : $z + $y}]\n} elseif {\"?\" in $y} {\nset result [expr {$op eq \"+\" ? $z - $x : $x - $z}]\n} else {\nset result [expr {$op eq \"+\" ? $x + $y : $x - $y}]\n}\nreturn $result\n}", "test": "proc testSolveEquation {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [solveEquation \"1+?=2\"] 1 \"Test case 1\"\nassert_equal [solveEquation \"4-3=?\"] 1 \"Test case 2\"\nassert_equal [solveEquation \"?-3=2\"] 5 \"Test case 3\"\nassert_equal [solveEquation \"5+?=10\"] 5 \"Test case 4\"\nassert_equal [solveEquation \"?+4=7\"] 3 \"Test case 5\"\nassert_equal [solveEquation \"10-?=5\"] 5 \"Test case 6\"\n}\n\n# Call the test procedure\ntestSolveEquation", "entry_point": "solveEquation", "signature": "proc solveEquation {equation} {", "docstring": "Solves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\nThe function takes a string input representing the equation. The equation may contain additional spaces.\nIt returns the value of the unknown variable as an integer.\n\nExample usage:\n>>> solveEquation \"1+?=2\"\n1\n>>> solveEquation \"4-3=?\"\n1\n>>> solveEquation \"?-3=2\"\n5", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nSolves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\nThe function takes a string input representing the equation. The equation may contain additional spaces.\nIt returns the value of the unknown variable as an integer.\n\nExample usage:\n>>> solveEquation \"1+?=2\"\n1\n>>> solveEquation \"4-3=?\"\n1\n>>> solveEquation \"?-3=2\"\n5\n\n* Incomplete Code:\nproc solveEquation {equation} {\n[MASK]\n\n# Split the equation into parts\nregexp {(\\d+|\\?)([+-])(\\d+|\\?)=(\\d+|\\?)} $cleanEquation -> x op y z\n\n# Solve for the unknown\nif {\"?\" in $x} {\n[MASK]\n[MASK]\n[MASK]\n[MASK]\nset result [expr {$op eq \"+\" ? $x + $y : $x - $y}]\n}\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n\n# Split the equation into parts\nregexp {(\\d+|\\?)([+-])(\\d+|\\?)=(\\d+|\\?)} $cleanEquation -> x op y z\n\n# Solve for the unknown\nif {\"?\" in $x} {\n[MASK]\n[MASK]\n[MASK]\n[MASK]\nset result [expr {$op eq \"+\" ? $x + $y : $x - $y}]\n}\nreturn $result\n}"}
{"task_id": "Tcl/33-1-multi", "prompt": "proc solveEquation {equation} {\n# Solves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\n# The function takes a string input representing the equation. The equation may contain additional spaces.\n# It returns the value of the unknown variable as an integer.\n#\n# Example usage:\n# >>> solveEquation \"1+?=2\"\n# 1\n# >>> solveEquation \"4-3=?\"\n# 1\n# >>> solveEquation \"?-3=2\"\n# 5", "canonical_solution": "set cleanEquation [string map {\" \" \"\"} $equation]\n\n# Split the equation into parts\nregexp {(\\d+|\\?)([+-])(\\d+|\\?)=(\\d+|\\?)} $cleanEquation -> x op y z\n\n# Solve for the unknown\nif {\"?\" in $x} {\nset result [expr {$op eq \"+\" ? $z - $y : $z + $y}]\n} elseif {\"?\" in $y} {\nset result [expr {$op eq \"+\" ? $z - $x : $x - $z}]\n} else {\nset result [expr {$op eq \"+\" ? $x + $y : $x - $y}]\n}\nreturn $result\n}", "test": "proc testSolveEquation {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [solveEquation \"1+?=2\"] 1 \"Test case 1\"\nassert_equal [solveEquation \"4-3=?\"] 1 \"Test case 2\"\nassert_equal [solveEquation \"?-3=2\"] 5 \"Test case 3\"\nassert_equal [solveEquation \"5+?=10\"] 5 \"Test case 4\"\nassert_equal [solveEquation \"?+4=7\"] 3 \"Test case 5\"\nassert_equal [solveEquation \"10-?=5\"] 5 \"Test case 6\"\n}\n\n# Call the test procedure\ntestSolveEquation", "entry_point": "solveEquation", "signature": "proc solveEquation {equation} {", "docstring": "Solves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\nThe function takes a string input representing the equation. The equation may contain additional spaces.\nIt returns the value of the unknown variable as an integer.\n\nExample usage:\n>>> solveEquation \"1+?=2\"\n1\n>>> solveEquation \"4-3=?\"\n1\n>>> solveEquation \"?-3=2\"\n5", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nSolves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\nThe function takes a string input representing the equation. The equation may contain additional spaces.\nIt returns the value of the unknown variable as an integer.\n\nExample usage:\n>>> solveEquation \"1+?=2\"\n1\n>>> solveEquation \"4-3=?\"\n1\n>>> solveEquation \"?-3=2\"\n5\n\n* Incomplete Code:\nproc solveEquation {equation} {\nset cleanEquation [string map {\" \" \"\"} $equation]\n\n# Split the equation into parts\n[MASK]\n\n# Solve for the unknown\nif {\"?\" in $x} {\n[MASK]\n} elseif {\"?\" in $y} {\n[MASK]\n[MASK]\nset result [expr {$op eq \"+\" ? $x + $y : $x - $y}]\n}\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "set cleanEquation [string map {\" \" \"\"} $equation]\n\n# Split the equation into parts\n[MASK]\n\n# Solve for the unknown\nif {\"?\" in $x} {\n[MASK]\n} elseif {\"?\" in $y} {\n[MASK]\n[MASK]\nset result [expr {$op eq \"+\" ? $x + $y : $x - $y}]\n}\nreturn $result\n}"}
{"task_id": "Tcl/34-0-multi", "prompt": "proc generate_bitonic_sequence {numbers} {\n# Generates a bitonic sequence from a list of integers.\n# The sequence starts with the largest number, followed by the smallest,\n# then the second largest, second smallest, and so on until all numbers are used.\n# The numbers are given as a list and are within the range of long integers.\n#\n# Example usage:\n# >>> generate_bitonic_sequence {10 -1 3 3 -9}\n# 10 -9 3 -1 3\n# >>> generate_bitonic_sequence {5 1 9 2 8 3}\n# 9 1 8 2 5 3", "canonical_solution": "set sorted_numbers [lsort -integer $numbers]\nset sequence {}\nset left 0\nset right [expr {[llength $sorted_numbers] - 1}]\n\nwhile {$left <= $right} {\nif {$left != $right} {\nlappend sequence [lindex $sorted_numbers $right]\n}\nlappend sequence [lindex $sorted_numbers $left]\nincr left\nincr right -1\n}\n\nreturn $sequence\n}", "test": "proc check {generate_bitonic_sequence} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [generate_bitonic_sequence {10 -1 3 3 -9}] {10 -9 3 -1 3} \"Test case 1\"\nassert_equal [generate_bitonic_sequence {5 1 9 2 8 3}] {9 1 8 2 5 3} \"Test case 2\"\nassert_equal [generate_bitonic_sequence {-5 -1 -9 -2 -8 -3}] {-1 -9 -2 -8 -3 -5} \"Test case 3\"\nassert_equal [generate_bitonic_sequence {0 0 0 0}] {0 0 0 0} \"Test case 4\"\nassert_equal [generate_bitonic_sequence {1000 500 100 -500}] {1000 -500 500 100} \"Test case 5\"\n}\n\n# Call the check procedure\ncheck generate_bitonic_sequence", "entry_point": "generate_bitonic_sequence", "signature": "proc generate_bitonic_sequence {numbers} {", "docstring": "Generates a bitonic sequence from a list of integers.\nThe sequence starts with the largest number, followed by the smallest,\nthen the second largest, second smallest, and so on until all numbers are used.\nThe numbers are given as a list and are within the range of long integers.\n\nExample usage:\n>>> generate_bitonic_sequence {10 -1 3 3 -9}\n10 -9 3 -1 3\n>>> generate_bitonic_sequence {5 1 9 2 8 3}\n9 1 8 2 5 3", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nGenerates a bitonic sequence from a list of integers.\nThe sequence starts with the largest number, followed by the smallest,\nthen the second largest, second smallest, and so on until all numbers are used.\nThe numbers are given as a list and are within the range of long integers.\n\nExample usage:\n>>> generate_bitonic_sequence {10 -1 3 3 -9}\n10 -9 3 -1 3\n>>> generate_bitonic_sequence {5 1 9 2 8 3}\n9 1 8 2 5 3\n\n* Incomplete Code:\nproc generate_bitonic_sequence {numbers} {\nset sorted_numbers [lsort -integer $numbers]\nset sequence {}\n[MASK]\nset right [expr {[llength $sorted_numbers] - 1}]\n\nwhile {$left <= $right} {\n[MASK]\nlappend sequence [lindex $sorted_numbers $right]\n}\nlappend sequence [lindex $sorted_numbers $left]\n[MASK]\n[MASK]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set sorted_numbers [lsort -integer $numbers]\nset sequence {}\n[MASK]\nset right [expr {[llength $sorted_numbers] - 1}]\n\nwhile {$left <= $right} {\n[MASK]\nlappend sequence [lindex $sorted_numbers $right]\n}\nlappend sequence [lindex $sorted_numbers $left]\n[MASK]\n[MASK]\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/34-1-multi", "prompt": "proc generate_bitonic_sequence {numbers} {\n# Generates a bitonic sequence from a list of integers.\n# The sequence starts with the largest number, followed by the smallest,\n# then the second largest, second smallest, and so on until all numbers are used.\n# The numbers are given as a list and are within the range of long integers.\n#\n# Example usage:\n# >>> generate_bitonic_sequence {10 -1 3 3 -9}\n# 10 -9 3 -1 3\n# >>> generate_bitonic_sequence {5 1 9 2 8 3}\n# 9 1 8 2 5 3", "canonical_solution": "set sorted_numbers [lsort -integer $numbers]\nset sequence {}\nset left 0\nset right [expr {[llength $sorted_numbers] - 1}]\n\nwhile {$left <= $right} {\nif {$left != $right} {\nlappend sequence [lindex $sorted_numbers $right]\n}\nlappend sequence [lindex $sorted_numbers $left]\nincr left\nincr right -1\n}\n\nreturn $sequence\n}", "test": "proc check {generate_bitonic_sequence} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [generate_bitonic_sequence {10 -1 3 3 -9}] {10 -9 3 -1 3} \"Test case 1\"\nassert_equal [generate_bitonic_sequence {5 1 9 2 8 3}] {9 1 8 2 5 3} \"Test case 2\"\nassert_equal [generate_bitonic_sequence {-5 -1 -9 -2 -8 -3}] {-1 -9 -2 -8 -3 -5} \"Test case 3\"\nassert_equal [generate_bitonic_sequence {0 0 0 0}] {0 0 0 0} \"Test case 4\"\nassert_equal [generate_bitonic_sequence {1000 500 100 -500}] {1000 -500 500 100} \"Test case 5\"\n}\n\n# Call the check procedure\ncheck generate_bitonic_sequence", "entry_point": "generate_bitonic_sequence", "signature": "proc generate_bitonic_sequence {numbers} {", "docstring": "Generates a bitonic sequence from a list of integers.\nThe sequence starts with the largest number, followed by the smallest,\nthen the second largest, second smallest, and so on until all numbers are used.\nThe numbers are given as a list and are within the range of long integers.\n\nExample usage:\n>>> generate_bitonic_sequence {10 -1 3 3 -9}\n10 -9 3 -1 3\n>>> generate_bitonic_sequence {5 1 9 2 8 3}\n9 1 8 2 5 3", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nGenerates a bitonic sequence from a list of integers.\nThe sequence starts with the largest number, followed by the smallest,\nthen the second largest, second smallest, and so on until all numbers are used.\nThe numbers are given as a list and are within the range of long integers.\n\nExample usage:\n>>> generate_bitonic_sequence {10 -1 3 3 -9}\n10 -9 3 -1 3\n>>> generate_bitonic_sequence {5 1 9 2 8 3}\n9 1 8 2 5 3\n\n* Incomplete Code:\nproc generate_bitonic_sequence {numbers} {\n[MASK]\nset sequence {}\n[MASK]\n[MASK]\n\n[MASK]\nif {$left != $right} {\n[MASK]\n}\nlappend sequence [lindex $sorted_numbers $left]\nincr left\nincr right -1\n}\n\nreturn $sequence\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset sequence {}\n[MASK]\n[MASK]\n\n[MASK]\nif {$left != $right} {\n[MASK]\n}\nlappend sequence [lindex $sorted_numbers $left]\nincr left\nincr right -1\n}\n\nreturn $sequence\n}"}
{"task_id": "Tcl/35-0-multi", "prompt": "proc maxSubmatrixSum {matrix} {\n# Calculates the maximum sum of a submatrix within a given matrix.\n# The matrix is represented as a list of lists, where each inner list is a row in the matrix.\n# The elements of the matrix are integers in the range [-127, 127].\n# The function returns the maximum sum of any submatrix within the input matrix.\n#\n# Example usage:\n# >>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n# 15\n# >>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n# 9", "canonical_solution": "proc maxSubArray {array} {\nset maxSoFar [lindex $array 0]\nset maxEndingHere [lindex $array 0]\n\nforeach x [lrange $array 1 end] {\nset maxEndingHere [expr {$maxEndingHere > 0 ? $maxEndingHere + $x : $x}]\nset maxSoFar [expr {$maxEndingHere > $maxSoFar ? $maxEndingHere : $maxSoFar}]\n}\n\nreturn $maxSoFar\n}\n\nset maxSum -128\nset rowCount [llength $matrix]\nset colCount [llength [lindex $matrix 0]]\n\nfor {set left 0} {$left < $colCount} {incr left} {\nset temp [lrepeat $rowCount 0]\n\nfor {set right $left} {$right < $colCount} {incr right} {\nfor {set row 0} {$row < $rowCount} {incr row} {\nset tempRow [lindex $matrix $row]\nlset temp $row [expr {[lindex $temp $row] + [lindex $tempRow $right]}]\n}\n\nset tempMax [maxSubArray $temp]\nset maxSum [expr {$tempMax > $maxSum ? $tempMax : $maxSum}]\n}\n}\n\nreturn $maxSum\n}", "test": "proc check {maxSubmatrixSum} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}] \"15\" \"Test case 1\"\nassert_equal [maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}] \"9\" \"Test case 2\"\nassert_equal [maxSubmatrixSum {{1 2 3} {4 5 6} {7 8 9}}] \"45\" \"Test case 3\"\nassert_equal [maxSubmatrixSum {{-1 -2 -3} {-4 -5 -6} {-7 -8 -9}}] \"-1\" \"Test case 4\"\nassert_equal [maxSubmatrixSum {{5 -4 2} {-3 8 -1} {4 -2 6}}] \"15\" \"Test case 5\"\n}\n\n# Call the check procedure\ncheck maxSubmatrixSum", "entry_point": "maxSubmatrixSum", "signature": "proc maxSubmatrixSum {matrix} {", "docstring": "Calculates the maximum sum of a submatrix within a given matrix.\nThe matrix is represented as a list of lists, where each inner list is a row in the matrix.\nThe elements of the matrix are integers in the range [-127, 127].\nThe function returns the maximum sum of any submatrix within the input matrix.\n\nExample usage:\n>>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n15\n>>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n9", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum sum of a submatrix within a given matrix.\nThe matrix is represented as a list of lists, where each inner list is a row in the matrix.\nThe elements of the matrix are integers in the range [-127, 127].\nThe function returns the maximum sum of any submatrix within the input matrix.\n\nExample usage:\n>>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n15\n>>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n9\n\n* Incomplete Code:\nproc maxSubmatrixSum {matrix} {\nproc maxSubArray {array} {\nset maxSoFar [lindex $array 0]\nset maxEndingHere [lindex $array 0]\n\nforeach x [lrange $array 1 end] {\nset maxEndingHere [expr {$maxEndingHere > 0 ? $maxEndingHere + $x : $x}]\nset maxSoFar [expr {$maxEndingHere > $maxSoFar ? $maxEndingHere : $maxSoFar}]\n}\n\nreturn $maxSoFar\n}\n\nset maxSum -128\nset rowCount [llength $matrix]\nset colCount [llength [lindex $matrix 0]]\n\n[MASK]\nset temp [lrepeat $rowCount 0]\n\n[MASK]\n[MASK]\nset tempRow [lindex $matrix $row]\n[MASK]\n}\n\nset tempMax [maxSubArray $temp]\nset maxSum [expr {$tempMax > $maxSum ? $tempMax : $maxSum}]\n}\n}\n\nreturn $maxSum\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "proc maxSubArray {array} {\nset maxSoFar [lindex $array 0]\nset maxEndingHere [lindex $array 0]\n\nforeach x [lrange $array 1 end] {\nset maxEndingHere [expr {$maxEndingHere > 0 ? $maxEndingHere + $x : $x}]\nset maxSoFar [expr {$maxEndingHere > $maxSoFar ? $maxEndingHere : $maxSoFar}]\n}\n\nreturn $maxSoFar\n}\n\nset maxSum -128\nset rowCount [llength $matrix]\nset colCount [llength [lindex $matrix 0]]\n\n[MASK]\nset temp [lrepeat $rowCount 0]\n\n[MASK]\n[MASK]\nset tempRow [lindex $matrix $row]\n[MASK]\n}\n\nset tempMax [maxSubArray $temp]\nset maxSum [expr {$tempMax > $maxSum ? $tempMax : $maxSum}]\n}\n}\n\nreturn $maxSum\n}"}
{"task_id": "Tcl/35-1-multi", "prompt": "proc maxSubmatrixSum {matrix} {\n# Calculates the maximum sum of a submatrix within a given matrix.\n# The matrix is represented as a list of lists, where each inner list is a row in the matrix.\n# The elements of the matrix are integers in the range [-127, 127].\n# The function returns the maximum sum of any submatrix within the input matrix.\n#\n# Example usage:\n# >>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n# 15\n# >>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n# 9", "canonical_solution": "proc maxSubArray {array} {\nset maxSoFar [lindex $array 0]\nset maxEndingHere [lindex $array 0]\n\nforeach x [lrange $array 1 end] {\nset maxEndingHere [expr {$maxEndingHere > 0 ? $maxEndingHere + $x : $x}]\nset maxSoFar [expr {$maxEndingHere > $maxSoFar ? $maxEndingHere : $maxSoFar}]\n}\n\nreturn $maxSoFar\n}\n\nset maxSum -128\nset rowCount [llength $matrix]\nset colCount [llength [lindex $matrix 0]]\n\nfor {set left 0} {$left < $colCount} {incr left} {\nset temp [lrepeat $rowCount 0]\n\nfor {set right $left} {$right < $colCount} {incr right} {\nfor {set row 0} {$row < $rowCount} {incr row} {\nset tempRow [lindex $matrix $row]\nlset temp $row [expr {[lindex $temp $row] + [lindex $tempRow $right]}]\n}\n\nset tempMax [maxSubArray $temp]\nset maxSum [expr {$tempMax > $maxSum ? $tempMax : $maxSum}]\n}\n}\n\nreturn $maxSum\n}", "test": "proc check {maxSubmatrixSum} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}] \"15\" \"Test case 1\"\nassert_equal [maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}] \"9\" \"Test case 2\"\nassert_equal [maxSubmatrixSum {{1 2 3} {4 5 6} {7 8 9}}] \"45\" \"Test case 3\"\nassert_equal [maxSubmatrixSum {{-1 -2 -3} {-4 -5 -6} {-7 -8 -9}}] \"-1\" \"Test case 4\"\nassert_equal [maxSubmatrixSum {{5 -4 2} {-3 8 -1} {4 -2 6}}] \"15\" \"Test case 5\"\n}\n\n# Call the check procedure\ncheck maxSubmatrixSum", "entry_point": "maxSubmatrixSum", "signature": "proc maxSubmatrixSum {matrix} {", "docstring": "Calculates the maximum sum of a submatrix within a given matrix.\nThe matrix is represented as a list of lists, where each inner list is a row in the matrix.\nThe elements of the matrix are integers in the range [-127, 127].\nThe function returns the maximum sum of any submatrix within the input matrix.\n\nExample usage:\n>>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n15\n>>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n9", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum sum of a submatrix within a given matrix.\nThe matrix is represented as a list of lists, where each inner list is a row in the matrix.\nThe elements of the matrix are integers in the range [-127, 127].\nThe function returns the maximum sum of any submatrix within the input matrix.\n\nExample usage:\n>>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n15\n>>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n9\n\n* Incomplete Code:\nproc maxSubmatrixSum {matrix} {\nproc maxSubArray {array} {\n[MASK]\nset maxEndingHere [lindex $array 0]\n\nforeach x [lrange $array 1 end] {\nset maxEndingHere [expr {$maxEndingHere > 0 ? $maxEndingHere + $x : $x}]\nset maxSoFar [expr {$maxEndingHere > $maxSoFar ? $maxEndingHere : $maxSoFar}]\n}\n\n[MASK]\n}\n\n[MASK]\nset rowCount [llength $matrix]\nset colCount [llength [lindex $matrix 0]]\n\nfor {set left 0} {$left < $colCount} {incr left} {\nset temp [lrepeat $rowCount 0]\n\nfor {set right $left} {$right < $colCount} {incr right} {\n[MASK]\nset tempRow [lindex $matrix $row]\nlset temp $row [expr {[lindex $temp $row] + [lindex $tempRow $right]}]\n}\n\nset tempMax [maxSubArray $temp]\nset maxSum [expr {$tempMax > $maxSum ? $tempMax : $maxSum}]\n}\n}\n\nreturn $maxSum\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "proc maxSubArray {array} {\n[MASK]\nset maxEndingHere [lindex $array 0]\n\nforeach x [lrange $array 1 end] {\nset maxEndingHere [expr {$maxEndingHere > 0 ? $maxEndingHere + $x : $x}]\nset maxSoFar [expr {$maxEndingHere > $maxSoFar ? $maxEndingHere : $maxSoFar}]\n}\n\n[MASK]\n}\n\n[MASK]\nset rowCount [llength $matrix]\nset colCount [llength [lindex $matrix 0]]\n\nfor {set left 0} {$left < $colCount} {incr left} {\nset temp [lrepeat $rowCount 0]\n\nfor {set right $left} {$right < $colCount} {incr right} {\n[MASK]\nset tempRow [lindex $matrix $row]\nlset temp $row [expr {[lindex $temp $row] + [lindex $tempRow $right]}]\n}\n\nset tempMax [maxSubArray $temp]\nset maxSum [expr {$tempMax > $maxSum ? $tempMax : $maxSum}]\n}\n}\n\nreturn $maxSum\n}"}
{"task_id": "Tcl/36-0-multi", "prompt": "proc maximize_herb_value {totalTime numHerbs herbData} {\n# Maximizes the total value of herbs that can be collected within a given time limit.\n# This function takes the total time available for collecting herbs (totalTime),\n# the number of different herbs in the cave (numHerbs), and a list of pairs\n# where each pair consists of the time required to collect a specific herb and its value (herbData).\n# The function returns the maximum total value of herbs that can be collected within the time limit.\n#\n# Example usage:\n# >>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n# 100", "canonical_solution": "# Initialize a list to store the maximum value at each time point\nset dp [list]\nfor {set i 0} {$i <= $totalTime} {incr i} {\nlappend dp 0\n}\n\n# Iterate through each herb\nforeach herb $herbData {\nset time [lindex $herb 0]\nset value [lindex $herb 1]\n\n# Update the dp list for each time point\nfor {set t $totalTime} {$t >= $time} {incr t -1} {\nlset dp $t [expr {max([lindex $dp $t], [expr {[lindex $dp [expr {$t - $time}]] + $value}])}]\n}\n}\n\n# Return the maximum value\nreturn [lindex $dp $totalTime]\n}", "test": "proc check {maximize_herb_value} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}] 100 \"Test case 1\"\nassert_equal [maximize_herb_value 50 4 {{5 10} {10 20} {20 30} {25 40}}] 80 \"Test case 2\"\nassert_equal [maximize_herb_value 30 2 {{15 10} {15 20}}] 30 \"Test case 3\"\nassert_equal [maximize_herb_value 100 5 {{10 10} {20 20} {30 30} {40 40} {50 50}}] 100 \"Test case 4\"\nassert_equal [maximize_herb_value 75 3 {{25 35} {30 40} {20 25}}] 100 \"Test case 5\"\nassert_equal [maximize_herb_value 80 4 {{10 15} {20 25} {30 35} {40 45}}] 95 \"Test case 6\"\n}\n\n# Call the check procedure\ncheck maximize_herb_value", "entry_point": "maximize_herb_value", "signature": "proc maximize_herb_value {totalTime numHerbs herbData} {", "docstring": "Maximizes the total value of herbs that can be collected within a given time limit.\nThis function takes the total time available for collecting herbs (totalTime),\nthe number of different herbs in the cave (numHerbs), and a list of pairs\nwhere each pair consists of the time required to collect a specific herb and its value (herbData).\nThe function returns the maximum total value of herbs that can be collected within the time limit.\n\nExample usage:\n>>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n100", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nMaximizes the total value of herbs that can be collected within a given time limit.\nThis function takes the total time available for collecting herbs (totalTime),\nthe number of different herbs in the cave (numHerbs), and a list of pairs\nwhere each pair consists of the time required to collect a specific herb and its value (herbData).\nThe function returns the maximum total value of herbs that can be collected within the time limit.\n\nExample usage:\n>>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n100\n\n* Incomplete Code:\nproc maximize_herb_value {totalTime numHerbs herbData} {\n# Initialize a list to store the maximum value at each time point\nset dp [list]\nfor {set i 0} {$i <= $totalTime} {incr i} {\nlappend dp 0\n}\n\n# Iterate through each herb\nforeach herb $herbData {\n[MASK]\n[MASK]\n\n# Update the dp list for each time point\n[MASK]\nlset dp $t [expr {max([lindex $dp $t], [expr {[lindex $dp [expr {$t - $time}]] + $value}])}]\n}\n}\n\n# Return the maximum value\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "# Initialize a list to store the maximum value at each time point\nset dp [list]\nfor {set i 0} {$i <= $totalTime} {incr i} {\nlappend dp 0\n}\n\n# Iterate through each herb\nforeach herb $herbData {\n[MASK]\n[MASK]\n\n# Update the dp list for each time point\n[MASK]\nlset dp $t [expr {max([lindex $dp $t], [expr {[lindex $dp [expr {$t - $time}]] + $value}])}]\n}\n}\n\n# Return the maximum value\n[MASK]\n}"}
{"task_id": "Tcl/36-1-multi", "prompt": "proc maximize_herb_value {totalTime numHerbs herbData} {\n# Maximizes the total value of herbs that can be collected within a given time limit.\n# This function takes the total time available for collecting herbs (totalTime),\n# the number of different herbs in the cave (numHerbs), and a list of pairs\n# where each pair consists of the time required to collect a specific herb and its value (herbData).\n# The function returns the maximum total value of herbs that can be collected within the time limit.\n#\n# Example usage:\n# >>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n# 100", "canonical_solution": "# Initialize a list to store the maximum value at each time point\nset dp [list]\nfor {set i 0} {$i <= $totalTime} {incr i} {\nlappend dp 0\n}\n\n# Iterate through each herb\nforeach herb $herbData {\nset time [lindex $herb 0]\nset value [lindex $herb 1]\n\n# Update the dp list for each time point\nfor {set t $totalTime} {$t >= $time} {incr t -1} {\nlset dp $t [expr {max([lindex $dp $t], [expr {[lindex $dp [expr {$t - $time}]] + $value}])}]\n}\n}\n\n# Return the maximum value\nreturn [lindex $dp $totalTime]\n}", "test": "proc check {maximize_herb_value} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}] 100 \"Test case 1\"\nassert_equal [maximize_herb_value 50 4 {{5 10} {10 20} {20 30} {25 40}}] 80 \"Test case 2\"\nassert_equal [maximize_herb_value 30 2 {{15 10} {15 20}}] 30 \"Test case 3\"\nassert_equal [maximize_herb_value 100 5 {{10 10} {20 20} {30 30} {40 40} {50 50}}] 100 \"Test case 4\"\nassert_equal [maximize_herb_value 75 3 {{25 35} {30 40} {20 25}}] 100 \"Test case 5\"\nassert_equal [maximize_herb_value 80 4 {{10 15} {20 25} {30 35} {40 45}}] 95 \"Test case 6\"\n}\n\n# Call the check procedure\ncheck maximize_herb_value", "entry_point": "maximize_herb_value", "signature": "proc maximize_herb_value {totalTime numHerbs herbData} {", "docstring": "Maximizes the total value of herbs that can be collected within a given time limit.\nThis function takes the total time available for collecting herbs (totalTime),\nthe number of different herbs in the cave (numHerbs), and a list of pairs\nwhere each pair consists of the time required to collect a specific herb and its value (herbData).\nThe function returns the maximum total value of herbs that can be collected within the time limit.\n\nExample usage:\n>>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n100", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nMaximizes the total value of herbs that can be collected within a given time limit.\nThis function takes the total time available for collecting herbs (totalTime),\nthe number of different herbs in the cave (numHerbs), and a list of pairs\nwhere each pair consists of the time required to collect a specific herb and its value (herbData).\nThe function returns the maximum total value of herbs that can be collected within the time limit.\n\nExample usage:\n>>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n100\n\n* Incomplete Code:\nproc maximize_herb_value {totalTime numHerbs herbData} {\n# Initialize a list to store the maximum value at each time point\nset dp [list]\nfor {set i 0} {$i <= $totalTime} {incr i} {\n[MASK]\n}\n\n# Iterate through each herb\n[MASK]\nset time [lindex $herb 0]\nset value [lindex $herb 1]\n\n# Update the dp list for each time point\n[MASK]\n[MASK]\n}\n}\n\n# Return the maximum value\nreturn [lindex $dp $totalTime]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "# Initialize a list to store the maximum value at each time point\nset dp [list]\nfor {set i 0} {$i <= $totalTime} {incr i} {\n[MASK]\n}\n\n# Iterate through each herb\n[MASK]\nset time [lindex $herb 0]\nset value [lindex $herb 1]\n\n# Update the dp list for each time point\n[MASK]\n[MASK]\n}\n}\n\n# Return the maximum value\nreturn [lindex $dp $totalTime]\n}"}
{"task_id": "Tcl/37-0-multi", "prompt": "proc count_prime_sums {n k numbers} {\n# This function counts the number of ways to select k integers from a list of n integers\n# such that their sum is a prime number.\n# The inputs are the total number of integers (n), the number of integers to be selected (k),\n# and a list of integers (numbers).\n# The function returns the count of combinations whose sum is a prime number.\n#\n# Example usage:\n# >>> count_prime_sums 5 3 {2 3 5 7 11}\n# 2\n# >>> count_prime_sums 4 2 {4 6 8 9}\n# 2", "canonical_solution": "set count 0\nforeach combination [combine $numbers $k] {\nset sum [expr [join $combination +]]\nif {[is_prime $sum]} {incr count}\n}\nreturn $count\n}\nproc is_prime {num} {\nif {$num <= 1} {return 0}\nset limit [expr {int(sqrt($num))}]\nfor {set i 2} {$i <= $limit} {incr i} {\nif {$num % $i == 0} {return 0}\n}\nreturn 1\n}\n\nproc combine {lst k} {\nif {$k == 0} {return {{}}}\nif {[llength $lst] == 0} {return {}}\nset result {}\nforeach x $lst {\nforeach y [combine [lreplace $lst 0 0] [expr {$k - 1}]] {\nlappend result [concat $x $y]\n}\nset lst [lrange $lst 1 end]\n}\nreturn $result\n}", "test": "proc check {count_prime_sums} {\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\nassert_equal [count_prime_sums 5 3 {2 3 5 7 11}] 2 \"Test case 1\"\nassert_equal [count_prime_sums 4 2 {4 6 8 9}] 2 \"Test case 2\"\nassert_equal [count_prime_sums 6 4 {1 3 5 7 9 11}] 0 \"Test case 3\"\nassert_equal [count_prime_sums 3 2 {2 5 6}] 2 \"Test case 4\"\nassert_equal [count_prime_sums 4 3 {10 12 14 15}] 2 \"Test case 5\"\n}\n\ncheck count_prime_sums", "entry_point": "count_prime_sums", "signature": "proc count_prime_sums {n k numbers} {", "docstring": "This function counts the number of ways to select k integers from a list of n integers\nsuch that their sum is a prime number.\nThe inputs are the total number of integers (n), the number of integers to be selected (k),\nand a list of integers (numbers).\nThe function returns the count of combinations whose sum is a prime number.\n\nExample usage:\n>>> count_prime_sums 5 3 {2 3 5 7 11}\n2\n>>> count_prime_sums 4 2 {4 6 8 9}\n2", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function counts the number of ways to select k integers from a list of n integers\nsuch that their sum is a prime number.\nThe inputs are the total number of integers (n), the number of integers to be selected (k),\nand a list of integers (numbers).\nThe function returns the count of combinations whose sum is a prime number.\n\nExample usage:\n>>> count_prime_sums 5 3 {2 3 5 7 11}\n2\n>>> count_prime_sums 4 2 {4 6 8 9}\n2\n\n* Incomplete Code:\nproc count_prime_sums {n k numbers} {\nset count 0\n[MASK]\nset sum [expr [join $combination +]]\nif {[is_prime $sum]} {incr count}\n}\n[MASK]\n}\nproc is_prime {num} {\nif {$num <= 1} {return 0}\nset limit [expr {int(sqrt($num))}]\nfor {set i 2} {$i <= $limit} {incr i} {\n[MASK]\n}\n[MASK]\n}\n\nproc combine {lst k} {\nif {$k == 0} {return {{}}}\nif {[llength $lst] == 0} {return {}}\nset result {}\nforeach x $lst {\nforeach y [combine [lreplace $lst 0 0] [expr {$k - 1}]] {\nlappend result [concat $x $y]\n}\nset lst [lrange $lst 1 end]\n}\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "set count 0\n[MASK]\nset sum [expr [join $combination +]]\nif {[is_prime $sum]} {incr count}\n}\n[MASK]\n}\nproc is_prime {num} {\nif {$num <= 1} {return 0}\nset limit [expr {int(sqrt($num))}]\nfor {set i 2} {$i <= $limit} {incr i} {\n[MASK]\n}\n[MASK]\n}\n\nproc combine {lst k} {\nif {$k == 0} {return {{}}}\nif {[llength $lst] == 0} {return {}}\nset result {}\nforeach x $lst {\nforeach y [combine [lreplace $lst 0 0] [expr {$k - 1}]] {\nlappend result [concat $x $y]\n}\nset lst [lrange $lst 1 end]\n}\nreturn $result\n}"}
{"task_id": "Tcl/37-1-multi", "prompt": "proc count_prime_sums {n k numbers} {\n# This function counts the number of ways to select k integers from a list of n integers\n# such that their sum is a prime number.\n# The inputs are the total number of integers (n), the number of integers to be selected (k),\n# and a list of integers (numbers).\n# The function returns the count of combinations whose sum is a prime number.\n#\n# Example usage:\n# >>> count_prime_sums 5 3 {2 3 5 7 11}\n# 2\n# >>> count_prime_sums 4 2 {4 6 8 9}\n# 2", "canonical_solution": "set count 0\nforeach combination [combine $numbers $k] {\nset sum [expr [join $combination +]]\nif {[is_prime $sum]} {incr count}\n}\nreturn $count\n}\nproc is_prime {num} {\nif {$num <= 1} {return 0}\nset limit [expr {int(sqrt($num))}]\nfor {set i 2} {$i <= $limit} {incr i} {\nif {$num % $i == 0} {return 0}\n}\nreturn 1\n}\n\nproc combine {lst k} {\nif {$k == 0} {return {{}}}\nif {[llength $lst] == 0} {return {}}\nset result {}\nforeach x $lst {\nforeach y [combine [lreplace $lst 0 0] [expr {$k - 1}]] {\nlappend result [concat $x $y]\n}\nset lst [lrange $lst 1 end]\n}\nreturn $result\n}", "test": "proc check {count_prime_sums} {\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\nassert_equal [count_prime_sums 5 3 {2 3 5 7 11}] 2 \"Test case 1\"\nassert_equal [count_prime_sums 4 2 {4 6 8 9}] 2 \"Test case 2\"\nassert_equal [count_prime_sums 6 4 {1 3 5 7 9 11}] 0 \"Test case 3\"\nassert_equal [count_prime_sums 3 2 {2 5 6}] 2 \"Test case 4\"\nassert_equal [count_prime_sums 4 3 {10 12 14 15}] 2 \"Test case 5\"\n}\n\ncheck count_prime_sums", "entry_point": "count_prime_sums", "signature": "proc count_prime_sums {n k numbers} {", "docstring": "This function counts the number of ways to select k integers from a list of n integers\nsuch that their sum is a prime number.\nThe inputs are the total number of integers (n), the number of integers to be selected (k),\nand a list of integers (numbers).\nThe function returns the count of combinations whose sum is a prime number.\n\nExample usage:\n>>> count_prime_sums 5 3 {2 3 5 7 11}\n2\n>>> count_prime_sums 4 2 {4 6 8 9}\n2", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function counts the number of ways to select k integers from a list of n integers\nsuch that their sum is a prime number.\nThe inputs are the total number of integers (n), the number of integers to be selected (k),\nand a list of integers (numbers).\nThe function returns the count of combinations whose sum is a prime number.\n\nExample usage:\n>>> count_prime_sums 5 3 {2 3 5 7 11}\n2\n>>> count_prime_sums 4 2 {4 6 8 9}\n2\n\n* Incomplete Code:\nproc count_prime_sums {n k numbers} {\nset count 0\nforeach combination [combine $numbers $k] {\nset sum [expr [join $combination +]]\nif {[is_prime $sum]} {incr count}\n}\nreturn $count\n}\nproc is_prime {num} {\n[MASK]\nset limit [expr {int(sqrt($num))}]\n[MASK]\nif {$num % $i == 0} {return 0}\n}\nreturn 1\n}\n\nproc combine {lst k} {\nif {$k == 0} {return {{}}}\nif {[llength $lst] == 0} {return {}}\nset result {}\nforeach x $lst {\n[MASK]\nlappend result [concat $x $y]\n}\n[MASK]\n}\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "set count 0\nforeach combination [combine $numbers $k] {\nset sum [expr [join $combination +]]\nif {[is_prime $sum]} {incr count}\n}\nreturn $count\n}\nproc is_prime {num} {\n[MASK]\nset limit [expr {int(sqrt($num))}]\n[MASK]\nif {$num % $i == 0} {return 0}\n}\nreturn 1\n}\n\nproc combine {lst k} {\nif {$k == 0} {return {{}}}\nif {[llength $lst] == 0} {return {}}\nset result {}\nforeach x $lst {\n[MASK]\nlappend result [concat $x $y]\n}\n[MASK]\n}\nreturn $result\n}"}
{"task_id": "Tcl/39-0-multi", "prompt": "proc maximize_value {n m item_list} {\n# This function calculates the maximum value achievable within a given budget when purchasing a set of items,\n# each with its own price and importance. The value of an item is its price multiplied by its importance.\n# The function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n# \n# Args:\n# n (int): The total money available.\n# m (int): The number of items available for purchase.\n# item_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n#\n# Returns:\n# int: The maximum total value of the items that can be purchased without exceeding the budget.\n#\n# Example usage:\n# >>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n# 3900", "canonical_solution": "set dp [list]\nfor {set i 0} {$i <= $n} {incr i} {\nlappend dp 0\n}\n\n# Iterate over each item\nforeach item $item_list {\nset price [lindex $item 0]\nset importance [lindex $item 1]\n\n# Update the dp list in reverse to avoid overwriting needed values\nfor {set j $n} {$j >= $price} {incr j -1} {\n# Calculate the new value if this item is included\nset newValue [expr {[lindex $dp [expr {$j - $price}]] + $price * $importance}]\n\n# Update the dp value if newValue is better\nif {$newValue > [lindex $dp $j]} {\nlset dp $j $newValue\n}\n}\n}\n\nreturn [lindex $dp $n]\n}", "test": "proc check_maximize_value {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}] 3900 \"Test case 1\"\nassert_equal [maximize_value 500 3 {{300 4} {200 3} {100 2}}] 1800 \"Test case 2\"\nassert_equal [maximize_value 200 2 {{100 1} {50 2}}] 200 \"Test case 3\"\nassert_equal [maximize_value 700 4 {{350 3} {200 2} {100 5} {50 2}}] 2050 \"Test case 4\"\nassert_equal [maximize_value 1500 6 {{500 5} {400 4} {300 3} {200 2} {100 1} {50 1}}] 5500 \"Test case 5\"\n}\n\n# Call the check procedure\ncheck_maximize_value", "entry_point": "maximize_value", "signature": "proc maximize_value {n m item_list} {", "docstring": "This function calculates the maximum value achievable within a given budget when purchasing a set of items,\neach with its own price and importance. The value of an item is its price multiplied by its importance.\nThe function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n\nArgs:\nn (int): The total money available.\nm (int): The number of items available for purchase.\nitem_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n\nReturns:\nint: The maximum total value of the items that can be purchased without exceeding the budget.\n\nExample usage:\n>>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n3900", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the maximum value achievable within a given budget when purchasing a set of items,\neach with its own price and importance. The value of an item is its price multiplied by its importance.\nThe function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n\nArgs:\nn (int): The total money available.\nm (int): The number of items available for purchase.\nitem_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n\nReturns:\nint: The maximum total value of the items that can be purchased without exceeding the budget.\n\nExample usage:\n>>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n3900\n\n* Incomplete Code:\nproc maximize_value {n m item_list} {\nset dp [list]\n[MASK]\nlappend dp 0\n}\n\n# Iterate over each item\n[MASK]\nset price [lindex $item 0]\n[MASK]\n\n# Update the dp list in reverse to avoid overwriting needed values\nfor {set j $n} {$j >= $price} {incr j -1} {\n# Calculate the new value if this item is included\nset newValue [expr {[lindex $dp [expr {$j - $price}]] + $price * $importance}]\n\n# Update the dp value if newValue is better\n[MASK]\n[MASK]\n}\n}\n}\n\nreturn [lindex $dp $n]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "set dp [list]\n[MASK]\nlappend dp 0\n}\n\n# Iterate over each item\n[MASK]\nset price [lindex $item 0]\n[MASK]\n\n# Update the dp list in reverse to avoid overwriting needed values\nfor {set j $n} {$j >= $price} {incr j -1} {\n# Calculate the new value if this item is included\nset newValue [expr {[lindex $dp [expr {$j - $price}]] + $price * $importance}]\n\n# Update the dp value if newValue is better\n[MASK]\n[MASK]\n}\n}\n}\n\nreturn [lindex $dp $n]\n}"}
{"task_id": "Tcl/39-1-multi", "prompt": "proc maximize_value {n m item_list} {\n# This function calculates the maximum value achievable within a given budget when purchasing a set of items,\n# each with its own price and importance. The value of an item is its price multiplied by its importance.\n# The function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n# \n# Args:\n# n (int): The total money available.\n# m (int): The number of items available for purchase.\n# item_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n#\n# Returns:\n# int: The maximum total value of the items that can be purchased without exceeding the budget.\n#\n# Example usage:\n# >>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n# 3900", "canonical_solution": "set dp [list]\nfor {set i 0} {$i <= $n} {incr i} {\nlappend dp 0\n}\n\n# Iterate over each item\nforeach item $item_list {\nset price [lindex $item 0]\nset importance [lindex $item 1]\n\n# Update the dp list in reverse to avoid overwriting needed values\nfor {set j $n} {$j >= $price} {incr j -1} {\n# Calculate the new value if this item is included\nset newValue [expr {[lindex $dp [expr {$j - $price}]] + $price * $importance}]\n\n# Update the dp value if newValue is better\nif {$newValue > [lindex $dp $j]} {\nlset dp $j $newValue\n}\n}\n}\n\nreturn [lindex $dp $n]\n}", "test": "proc check_maximize_value {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}] 3900 \"Test case 1\"\nassert_equal [maximize_value 500 3 {{300 4} {200 3} {100 2}}] 1800 \"Test case 2\"\nassert_equal [maximize_value 200 2 {{100 1} {50 2}}] 200 \"Test case 3\"\nassert_equal [maximize_value 700 4 {{350 3} {200 2} {100 5} {50 2}}] 2050 \"Test case 4\"\nassert_equal [maximize_value 1500 6 {{500 5} {400 4} {300 3} {200 2} {100 1} {50 1}}] 5500 \"Test case 5\"\n}\n\n# Call the check procedure\ncheck_maximize_value", "entry_point": "maximize_value", "signature": "proc maximize_value {n m item_list} {", "docstring": "This function calculates the maximum value achievable within a given budget when purchasing a set of items,\neach with its own price and importance. The value of an item is its price multiplied by its importance.\nThe function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n\nArgs:\nn (int): The total money available.\nm (int): The number of items available for purchase.\nitem_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n\nReturns:\nint: The maximum total value of the items that can be purchased without exceeding the budget.\n\nExample usage:\n>>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n3900", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the maximum value achievable within a given budget when purchasing a set of items,\neach with its own price and importance. The value of an item is its price multiplied by its importance.\nThe function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n\nArgs:\nn (int): The total money available.\nm (int): The number of items available for purchase.\nitem_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n\nReturns:\nint: The maximum total value of the items that can be purchased without exceeding the budget.\n\nExample usage:\n>>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n3900\n\n* Incomplete Code:\nproc maximize_value {n m item_list} {\nset dp [list]\nfor {set i 0} {$i <= $n} {incr i} {\n[MASK]\n}\n\n# Iterate over each item\nforeach item $item_list {\nset price [lindex $item 0]\nset importance [lindex $item 1]\n\n# Update the dp list in reverse to avoid overwriting needed values\nfor {set j $n} {$j >= $price} {incr j -1} {\n# Calculate the new value if this item is included\n[MASK]\n\n# Update the dp value if newValue is better\nif {$newValue > [lindex $dp $j]} {\n[MASK]\n}\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "set dp [list]\nfor {set i 0} {$i <= $n} {incr i} {\n[MASK]\n}\n\n# Iterate over each item\nforeach item $item_list {\nset price [lindex $item 0]\nset importance [lindex $item 1]\n\n# Update the dp list in reverse to avoid overwriting needed values\nfor {set j $n} {$j >= $price} {incr j -1} {\n# Calculate the new value if this item is included\n[MASK]\n\n# Update the dp value if newValue is better\nif {$newValue > [lindex $dp $j]} {\n[MASK]\n}\n}\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/40-0-multi", "prompt": "proc max_subsequence_sum {sequence} {\n# Calculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\n# The input is a list of integers, which can include both positive and negative values.\n# The function returns the maximum sum of any such subsequence.\n#\n# Example usage:\n# >>> max_subsequence_sum {2 -1 3 4 -2}\n# 8\n# >>> max_subsequence_sum {-3 -2 -1 -4}\n# -1", "canonical_solution": "set max_so_far [lindex $sequence 0]\nset max_ending_here 0\n\nforeach i $sequence {\nset max_ending_here [expr {$max_ending_here + $i}]\nif {$max_so_far < $max_ending_here} {\nset max_so_far $max_ending_here\n}\nif {$max_ending_here < 0} {\nset max_ending_here 0\n}\n}\n\nreturn $max_so_far\n}", "test": "proc check {max_subsequence_sum} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [max_subsequence_sum {2 -1 3 4 -2}] \"8\" \"Test case 1\"\nassert_equal [max_subsequence_sum {-3 -2 -1 -4}] \"-1\" \"Test case 2\"\nassert_equal [max_subsequence_sum {1 -2 3 10 -4 7 -2 5}] \"19\" \"Test case 3\"\nassert_equal [max_subsequence_sum {-1 -2 -3 -4}] \"-1\" \"Test case 4\"\nassert_equal [max_subsequence_sum {1 2 3 4 5 -10 5 4 3 2 1}] \"20\" \"Test case 5\"\n}\n\n# Call the check procedure\ncheck max_subsequence_sum", "entry_point": "max_subsequence_sum", "signature": "proc max_subsequence_sum {sequence} {", "docstring": "Calculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\nThe input is a list of integers, which can include both positive and negative values.\nThe function returns the maximum sum of any such subsequence.\n\nExample usage:\n>>> max_subsequence_sum {2 -1 3 4 -2}\n8\n>>> max_subsequence_sum {-3 -2 -1 -4}\n-1", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\nThe input is a list of integers, which can include both positive and negative values.\nThe function returns the maximum sum of any such subsequence.\n\nExample usage:\n>>> max_subsequence_sum {2 -1 3 4 -2}\n8\n>>> max_subsequence_sum {-3 -2 -1 -4}\n-1\n\n* Incomplete Code:\nproc max_subsequence_sum {sequence} {\nset max_so_far [lindex $sequence 0]\nset max_ending_here 0\n\n[MASK]\nset max_ending_here [expr {$max_ending_here + $i}]\nif {$max_so_far < $max_ending_here} {\n[MASK]\n}\n[MASK]\nset max_ending_here 0\n}\n}\n\nreturn $max_so_far\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "set max_so_far [lindex $sequence 0]\nset max_ending_here 0\n\n[MASK]\nset max_ending_here [expr {$max_ending_here + $i}]\nif {$max_so_far < $max_ending_here} {\n[MASK]\n}\n[MASK]\nset max_ending_here 0\n}\n}\n\nreturn $max_so_far\n}"}
{"task_id": "Tcl/40-1-multi", "prompt": "proc max_subsequence_sum {sequence} {\n# Calculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\n# The input is a list of integers, which can include both positive and negative values.\n# The function returns the maximum sum of any such subsequence.\n#\n# Example usage:\n# >>> max_subsequence_sum {2 -1 3 4 -2}\n# 8\n# >>> max_subsequence_sum {-3 -2 -1 -4}\n# -1", "canonical_solution": "set max_so_far [lindex $sequence 0]\nset max_ending_here 0\n\nforeach i $sequence {\nset max_ending_here [expr {$max_ending_here + $i}]\nif {$max_so_far < $max_ending_here} {\nset max_so_far $max_ending_here\n}\nif {$max_ending_here < 0} {\nset max_ending_here 0\n}\n}\n\nreturn $max_so_far\n}", "test": "proc check {max_subsequence_sum} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [max_subsequence_sum {2 -1 3 4 -2}] \"8\" \"Test case 1\"\nassert_equal [max_subsequence_sum {-3 -2 -1 -4}] \"-1\" \"Test case 2\"\nassert_equal [max_subsequence_sum {1 -2 3 10 -4 7 -2 5}] \"19\" \"Test case 3\"\nassert_equal [max_subsequence_sum {-1 -2 -3 -4}] \"-1\" \"Test case 4\"\nassert_equal [max_subsequence_sum {1 2 3 4 5 -10 5 4 3 2 1}] \"20\" \"Test case 5\"\n}\n\n# Call the check procedure\ncheck max_subsequence_sum", "entry_point": "max_subsequence_sum", "signature": "proc max_subsequence_sum {sequence} {", "docstring": "Calculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\nThe input is a list of integers, which can include both positive and negative values.\nThe function returns the maximum sum of any such subsequence.\n\nExample usage:\n>>> max_subsequence_sum {2 -1 3 4 -2}\n8\n>>> max_subsequence_sum {-3 -2 -1 -4}\n-1", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\nThe input is a list of integers, which can include both positive and negative values.\nThe function returns the maximum sum of any such subsequence.\n\nExample usage:\n>>> max_subsequence_sum {2 -1 3 4 -2}\n8\n>>> max_subsequence_sum {-3 -2 -1 -4}\n-1\n\n* Incomplete Code:\nproc max_subsequence_sum {sequence} {\n[MASK]\nset max_ending_here 0\n\nforeach i $sequence {\nset max_ending_here [expr {$max_ending_here + $i}]\nif {$max_so_far < $max_ending_here} {\nset max_so_far $max_ending_here\n}\nif {$max_ending_here < 0} {\n[MASK]\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nset max_ending_here 0\n\nforeach i $sequence {\nset max_ending_here [expr {$max_ending_here + $i}]\nif {$max_so_far < $max_ending_here} {\nset max_so_far $max_ending_here\n}\nif {$max_ending_here < 0} {\n[MASK]\n}\n}\n\n[MASK]\n}"}
{"task_id": "Tcl/49-0-multi", "prompt": "proc determine_sign {N} {\n    # Determines the sign of a given integer N.\n    # This function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\n    # It uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    #\n    # Args:\n    #   N (int): The integer whose sign is to be determined.\n    #\n    # Returns:\n    #   string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    #\n    # Example usage:\n    # >>> determine_sign 95\n    # 'positive'\n    # >>> determine_sign 0\n    # 'zero'\n    # >>> determine_sign -10\n    # 'negative'", "canonical_solution": "    if {$N > 0} {\n        return \"positive\"\n    } elseif {$N == 0} {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}", "test": "proc check_determine_sign {} {\n    proc assert_equal {actual expected message} {\n        if {$actual ne $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [determine_sign 95] \"positive\" \"Test case 1: Determining sign for 95\"\n    assert_equal [determine_sign 0] \"zero\" \"Test case 2: Determining sign for 0\"\n    assert_equal [determine_sign -10] \"negative\" \"Test case 3: Determining sign for -10\"\n    assert_equal [determine_sign 1] \"positive\" \"Test case 4: Determining sign for 1\"\n    assert_equal [determine_sign -1] \"negative\" \"Test case 5: Determining sign for -1\"\n}\n\ncheck_determine_sign", "entry_point": "determine_sign", "signature": "proc determine_sign {N} {", "docstring": " Determines the sign of a given integer N.\nThis function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\nIt uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    \nArgs:\n  N (int): The integer whose sign is to be determined.\n    \nReturns:\n  string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    \nExample usage:\n>>> determine_sign 95\n'positive'\n>>> determine_sign 0\n'zero'\n>>> determine_sign -10\n'negative'", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \n Determines the sign of a given integer N.\nThis function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\nIt uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    \nArgs:\n  N (int): The integer whose sign is to be determined.\n    \nReturns:\n  string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    \nExample usage:\n>>> determine_sign 95\n'positive'\n>>> determine_sign 0\n'zero'\n>>> determine_sign -10\n'negative'\n\n* Incomplete Code:\nproc determine_sign {N} {\n    if {$N > 0} {\n[MASK]\n    } elseif {$N == 0} {\n[MASK]\n[MASK]\n[MASK]\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if {$N > 0} {\n[MASK]\n    } elseif {$N == 0} {\n[MASK]\n[MASK]\n[MASK]\n    }\n}"}
{"task_id": "Tcl/49-1-multi", "prompt": "proc determine_sign {N} {\n    # Determines the sign of a given integer N.\n    # This function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\n    # It uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    #\n    # Args:\n    #   N (int): The integer whose sign is to be determined.\n    #\n    # Returns:\n    #   string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    #\n    # Example usage:\n    # >>> determine_sign 95\n    # 'positive'\n    # >>> determine_sign 0\n    # 'zero'\n    # >>> determine_sign -10\n    # 'negative'", "canonical_solution": "    if {$N > 0} {\n        return \"positive\"\n    } elseif {$N == 0} {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}", "test": "proc check_determine_sign {} {\n    proc assert_equal {actual expected message} {\n        if {$actual ne $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [determine_sign 95] \"positive\" \"Test case 1: Determining sign for 95\"\n    assert_equal [determine_sign 0] \"zero\" \"Test case 2: Determining sign for 0\"\n    assert_equal [determine_sign -10] \"negative\" \"Test case 3: Determining sign for -10\"\n    assert_equal [determine_sign 1] \"positive\" \"Test case 4: Determining sign for 1\"\n    assert_equal [determine_sign -1] \"negative\" \"Test case 5: Determining sign for -1\"\n}\n\ncheck_determine_sign", "entry_point": "determine_sign", "signature": "proc determine_sign {N} {", "docstring": " Determines the sign of a given integer N.\nThis function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\nIt uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    \nArgs:\n  N (int): The integer whose sign is to be determined.\n    \nReturns:\n  string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    \nExample usage:\n>>> determine_sign 95\n'positive'\n>>> determine_sign 0\n'zero'\n>>> determine_sign -10\n'negative'", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \n Determines the sign of a given integer N.\nThis function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\nIt uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    \nArgs:\n  N (int): The integer whose sign is to be determined.\n    \nReturns:\n  string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    \nExample usage:\n>>> determine_sign 95\n'positive'\n>>> determine_sign 0\n'zero'\n>>> determine_sign -10\n'negative'\n\n* Incomplete Code:\nproc determine_sign {N} {\n    if {$N > 0} {\n[MASK]\n    } elseif {$N == 0} {\n        return \"zero\"\n[MASK]\n[MASK]\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if {$N > 0} {\n[MASK]\n    } elseif {$N == 0} {\n        return \"zero\"\n[MASK]\n[MASK]\n    }\n}"}
{"task_id": "Tcl/50-0-multi", "prompt": "proc calculate_absolute_value {n} {\n    # Calculates the absolute value of an integer n.\n    # This function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\n    # The absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    #\n    # Args:\n    #   n (int): An integer whose absolute value is to be calculated.\n    #\n    # Returns:\n    #   int: The absolute value of n.\n    #\n    # Example usage:\n    # >>> calculate_absolute_value -3\n    # 3\n    # >>> calculate_absolute_value 5\n    # 5\n    # >>> calculate_absolute_value 0\n    # 0", "canonical_solution": "    if {$n < 0} {\n        return [expr {-$n}]\n    } else {\n        return $n\n    }\n}", "test": "proc check_calculate_absolute_value {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [calculate_absolute_value -3] 3 \"Test case 1: Absolute value of -3\"\n    assert_equal [calculate_absolute_value 5] 5 \"Test case 2: Absolute value of 5\"\n    assert_equal [calculate_absolute_value 0] 0 \"Test case 3: Absolute value of 0\"\n    assert_equal [calculate_absolute_value -10000] 10000 \"Test case 4: Absolute value of -10000\"\n    assert_equal [calculate_absolute_value 10000] 10000 \"Test case 5: Absolute value of 10000\"\n}\n\ncheck_calculate_absolute_value", "entry_point": "calculate_absolute_value", "signature": "proc calculate_absolute_value {n} {", "docstring": " Calculates the absolute value of an integer n.\nThis function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\nThe absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    \nArgs:\n  n (int): An integer whose absolute value is to be calculated.\n    \nReturns:\n  int: The absolute value of n.\n    \nExample usage:\n>>> calculate_absolute_value -3\n3\n>>> calculate_absolute_value 5\n5\n>>> calculate_absolute_value 0\n0", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \n Calculates the absolute value of an integer n.\nThis function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\nThe absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    \nArgs:\n  n (int): An integer whose absolute value is to be calculated.\n    \nReturns:\n  int: The absolute value of n.\n    \nExample usage:\n>>> calculate_absolute_value -3\n3\n>>> calculate_absolute_value 5\n5\n>>> calculate_absolute_value 0\n0\n\n* Incomplete Code:\nproc calculate_absolute_value {n} {\n[MASK]\n[MASK]\n    } else {\n        return $n\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n    } else {\n        return $n\n    }\n}"}
{"task_id": "Tcl/50-1-multi", "prompt": "proc calculate_absolute_value {n} {\n    # Calculates the absolute value of an integer n.\n    # This function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\n    # The absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    #\n    # Args:\n    #   n (int): An integer whose absolute value is to be calculated.\n    #\n    # Returns:\n    #   int: The absolute value of n.\n    #\n    # Example usage:\n    # >>> calculate_absolute_value -3\n    # 3\n    # >>> calculate_absolute_value 5\n    # 5\n    # >>> calculate_absolute_value 0\n    # 0", "canonical_solution": "    if {$n < 0} {\n        return [expr {-$n}]\n    } else {\n        return $n\n    }\n}", "test": "proc check_calculate_absolute_value {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [calculate_absolute_value -3] 3 \"Test case 1: Absolute value of -3\"\n    assert_equal [calculate_absolute_value 5] 5 \"Test case 2: Absolute value of 5\"\n    assert_equal [calculate_absolute_value 0] 0 \"Test case 3: Absolute value of 0\"\n    assert_equal [calculate_absolute_value -10000] 10000 \"Test case 4: Absolute value of -10000\"\n    assert_equal [calculate_absolute_value 10000] 10000 \"Test case 5: Absolute value of 10000\"\n}\n\ncheck_calculate_absolute_value", "entry_point": "calculate_absolute_value", "signature": "proc calculate_absolute_value {n} {", "docstring": " Calculates the absolute value of an integer n.\nThis function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\nThe absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    \nArgs:\n  n (int): An integer whose absolute value is to be calculated.\n    \nReturns:\n  int: The absolute value of n.\n    \nExample usage:\n>>> calculate_absolute_value -3\n3\n>>> calculate_absolute_value 5\n5\n>>> calculate_absolute_value 0\n0", "instruction": "Below is a explanation of Tcl code and incomplete code implementation.\n\n* Docstring: \n Calculates the absolute value of an integer n.\nThis function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\nThe absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    \nArgs:\n  n (int): An integer whose absolute value is to be calculated.\n    \nReturns:\n  int: The absolute value of n.\n    \nExample usage:\n>>> calculate_absolute_value -3\n3\n>>> calculate_absolute_value 5\n5\n>>> calculate_absolute_value 0\n0\n\n* Incomplete Code:\nproc calculate_absolute_value {n} {\n    if {$n < 0} {\n[MASK]\n    } else {\n[MASK]\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if {$n < 0} {\n[MASK]\n    } else {\n[MASK]\n    }\n}"}
