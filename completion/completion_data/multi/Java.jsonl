{"task_id": "Java/1-0-multi", "prompt": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculate the average account balance based on the closing balances from the past twelve months.\n         *\n         * @param closingBalances A list of closing balances from the past twelve months.\n         * @return The average account balance.\n         *\n         * Example:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)", "canonical_solution": "    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75)) - 1581.42) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0)) - 650.0) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) - 6.5) < 0.01;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "calculateAverageBalance", "signature": "public static double calculateAverageBalance(List<Double> closingBalances)", "docstring": "Calculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42\n\n* Incomplete Code:\npublic static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n[MASK]\n            sum += balance;\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        double sum = 0.0;\n[MASK]\n            sum += balance;\n        }\n[MASK]\n    }"}
{"task_id": "Java/1-1-multi", "prompt": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculate the average account balance based on the closing balances from the past twelve months.\n         *\n         * @param closingBalances A list of closing balances from the past twelve months.\n         * @return The average account balance.\n         *\n         * Example:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)", "canonical_solution": "    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75)) - 1581.42) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0)) - 650.0) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) - 6.5) < 0.01;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "calculateAverageBalance", "signature": "public static double calculateAverageBalance(List<Double> closingBalances)", "docstring": "Calculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42\n\n* Incomplete Code:\npublic static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n[MASK]\n[MASK]\n        }\n        return sum / closingBalances.size();\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        double sum = 0.0;\n[MASK]\n[MASK]\n        }\n        return sum / closingBalances.size();\n    }"}
{"task_id": "Java/2-0-multi", "prompt": "class Solution {\n    /**\n     * Given a positive integer Y indicating the start year, and a positive integer N,\n     * this function finds the Nth leap year after the start year Y.\n     *\n     * @param Y The start year.\n     * @param N The position of the leap year to find.\n     * @return The Nth leap year after the start year Y.\n     *\n     * Example:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ", "canonical_solution": "    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert findNthLeapYear(2000, 4) == 2012;\n        assert findNthLeapYear(1996, 10) == 2032;\n        assert findNthLeapYear(2000, 1) == 2000;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "findNthLeapYear", "signature": "public static int findNthLeapYear(int Y, int N)", "docstring": "Given a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032\n\n* Incomplete Code:\npublic static int findNthLeapYear(int Y, int N)\n    {\n    \n[MASK]\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n[MASK]\n                }\n            }\n[MASK]\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n    \n[MASK]\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n[MASK]\n                }\n            }\n[MASK]\n        }\n    }"}
{"task_id": "Java/2-1-multi", "prompt": "class Solution {\n    /**\n     * Given a positive integer Y indicating the start year, and a positive integer N,\n     * this function finds the Nth leap year after the start year Y.\n     *\n     * @param Y The start year.\n     * @param N The position of the leap year to find.\n     * @return The Nth leap year after the start year Y.\n     *\n     * Example:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ", "canonical_solution": "    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert findNthLeapYear(2000, 4) == 2012;\n        assert findNthLeapYear(1996, 10) == 2032;\n        assert findNthLeapYear(2000, 1) == 2000;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "findNthLeapYear", "signature": "public static int findNthLeapYear(int Y, int N)", "docstring": "Given a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032\n\n* Incomplete Code:\npublic static int findNthLeapYear(int Y, int N)\n    {\n    \n[MASK]\n[MASK]\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n[MASK]\n[MASK]\n                }\n            }\n            Y++;\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n    \n[MASK]\n[MASK]\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n[MASK]\n[MASK]\n                }\n            }\n            Y++;\n        }\n    }"}
{"task_id": "Java/4-0-multi", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Given an array of distinct integers, return all possible permutations of the array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ", "canonical_solution": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }", "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution\n      .permute(new int[] { 4, 5, 6 })\n      .equals(\n        Arrays.asList(\n          Arrays.asList(4, 5, 6),\n          Arrays.asList(4, 6, 5),\n          Arrays.asList(5, 4, 6),\n          Arrays.asList(5, 6, 4),\n          Arrays.asList(6, 4, 5),\n          Arrays.asList(6, 5, 4)\n        )\n      );\n    assert solution\n      .permute(new int[] { 7, 8 })\n      .equals(Arrays.asList(Arrays.asList(7, 8), Arrays.asList(8, 7)));\n    assert solution\n      .permute(new int[] { 9 })\n      .equals(Collections.singletonList(Collections.singletonList(9)));\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "permute", "signature": "public List<List<Integer>> permute(int[] nums)", "docstring": "Given an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]\n\n* Incomplete Code:\npublic List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n[MASK]\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n[MASK]\n            }\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n[MASK]\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n[MASK]\n            }\n        }\n    }"}
{"task_id": "Java/4-1-multi", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Given an array of distinct integers, return all possible permutations of the array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ", "canonical_solution": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }", "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution\n      .permute(new int[] { 4, 5, 6 })\n      .equals(\n        Arrays.asList(\n          Arrays.asList(4, 5, 6),\n          Arrays.asList(4, 6, 5),\n          Arrays.asList(5, 4, 6),\n          Arrays.asList(5, 6, 4),\n          Arrays.asList(6, 4, 5),\n          Arrays.asList(6, 5, 4)\n        )\n      );\n    assert solution\n      .permute(new int[] { 7, 8 })\n      .equals(Arrays.asList(Arrays.asList(7, 8), Arrays.asList(8, 7)));\n    assert solution\n      .permute(new int[] { 9 })\n      .equals(Collections.singletonList(Collections.singletonList(9)));\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "permute", "signature": "public List<List<Integer>> permute(int[] nums)", "docstring": "Given an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]\n\n* Incomplete Code:\npublic List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n[MASK]\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n[MASK]\n[MASK]\n            for(int i = 0; i < nums.length; i++){\n[MASK]\n[MASK]\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n[MASK]\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n[MASK]\n[MASK]\n            for(int i = 0; i < nums.length; i++){\n[MASK]\n[MASK]\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }"}
{"task_id": "Java/5-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n     * \n     * Example:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ", "canonical_solution": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"rose\", \"orchid\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"hello\", \"world\")) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "findLargestSubstring", "signature": "public int findLargestSubstring(List<String> strings)", "docstring": "Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2\n\n* Incomplete Code:\npublic int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n[MASK]\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n[MASK]\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n[MASK]\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n[MASK]\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n[MASK]\n    }"}
{"task_id": "Java/5-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n     * \n     * Example:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ", "canonical_solution": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"rose\", \"orchid\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"hello\", \"world\")) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "findLargestSubstring", "signature": "public int findLargestSubstring(List<String> strings)", "docstring": "Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2\n\n* Incomplete Code:\npublic int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n[MASK]\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n[MASK]\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n[MASK]\n    }"}
{"task_id": "Java/6-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n     * \n     * Parameters:\n     *     grid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n     * \n     * Returns:\n     *     int: The number of distinct oil deposits in the grid.\n     * \n     * Example:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ", "canonical_solution": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countOilDeposits(new char[][] {{'@', '@', '@'}, {'@', '*', '@'}, {'@', '@', '@'}}) == 1;\n        assert countOilDeposits(new char[][] {{'@', '*', '@'}, {'*', '*', '*'}, {'@', '*', '@'}}) == 4;\n        assert countOilDeposits(new char[][] {{'*', '*', '*', '*', '*'}, {'*', '@', '@', '@', '*'}, {'*', '@', '*', '@', '*'}, {'*', '@', '@', '@', '*'}, {'*', '*', '*', '*', '*'}}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countOilDeposits", "signature": "public static int countOilDeposits(char[][] grid)", "docstring": "Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2\n\n* Incomplete Code:\npublic static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n[MASK]\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n[MASK]\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n[MASK]\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n[MASK]\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }"}
{"task_id": "Java/6-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n     * \n     * Parameters:\n     *     grid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n     * \n     * Returns:\n     *     int: The number of distinct oil deposits in the grid.\n     * \n     * Example:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ", "canonical_solution": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countOilDeposits(new char[][] {{'@', '@', '@'}, {'@', '*', '@'}, {'@', '@', '@'}}) == 1;\n        assert countOilDeposits(new char[][] {{'@', '*', '@'}, {'*', '*', '*'}, {'@', '*', '@'}}) == 4;\n        assert countOilDeposits(new char[][] {{'*', '*', '*', '*', '*'}, {'*', '@', '@', '@', '*'}, {'*', '@', '*', '@', '*'}, {'*', '@', '@', '@', '*'}, {'*', '*', '*', '*', '*'}}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countOilDeposits", "signature": "public static int countOilDeposits(char[][] grid)", "docstring": "Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2\n\n* Incomplete Code:\npublic static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n[MASK]\n[MASK]\n                    dfs(grid, i, j);\n[MASK]\n                }\n            }\n        }\n        return count;\n    }\n\n[MASK]\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n[MASK]\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n[MASK]\n[MASK]\n                    dfs(grid, i, j);\n[MASK]\n                }\n            }\n        }\n        return count;\n    }\n\n[MASK]\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n[MASK]\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }"}
{"task_id": "Java/8-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Count the number of words in the given word list that have the given prefix.\n     * \n     * @param wordList: a list of words\n     * @param prefix: the prefix string\n     * @return the number of words with the given prefix\n     * \n     * Example:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ", "canonical_solution": "    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countPrefixWords(Arrays.asList(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3;\n        assert countPrefixWords(Arrays.asList(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4;\n        assert countPrefixWords(Arrays.asList(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countPrefixWords", "signature": "public static int countPrefixWords(List<String> wordList, String prefix)", "docstring": "Count the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCount the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1\n\n* Incomplete Code:\npublic static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n[MASK]\n[MASK]\n                count++;\n            }\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int count = 0;\n[MASK]\n[MASK]\n                count++;\n            }\n        }\n[MASK]\n    }"}
{"task_id": "Java/8-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Count the number of words in the given word list that have the given prefix.\n     * \n     * @param wordList: a list of words\n     * @param prefix: the prefix string\n     * @return the number of words with the given prefix\n     * \n     * Example:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ", "canonical_solution": "    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countPrefixWords(Arrays.asList(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3;\n        assert countPrefixWords(Arrays.asList(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4;\n        assert countPrefixWords(Arrays.asList(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countPrefixWords", "signature": "public static int countPrefixWords(List<String> wordList, String prefix)", "docstring": "Count the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCount the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1\n\n* Incomplete Code:\npublic static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n[MASK]\n[MASK]\n[MASK]\n            }\n        }\n        return count;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int count = 0;\n[MASK]\n[MASK]\n[MASK]\n            }\n        }\n        return count;\n    }"}
{"task_id": "Java/9-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n   /**\n     * Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n     * \n     * Example:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ", "canonical_solution": "    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countDoubles(new int[]{1, 2, 4, 8, 16}) == 4;\n        assert countDoubles(new int[]{5, 10, 20, 40, 80}) == 4;\n        assert countDoubles(new int[]{3, 6, 12, 24, 48}) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countDoubles", "signature": "public static int countDoubles(int[] numbers)", "docstring": "Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0\n\n* Incomplete Code:\npublic static int countDoubles(int[] numbers)\n    {\n     \n[MASK]\n[MASK]\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n[MASK]\n            }\n[MASK]\n        }\n        return count;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n     \n[MASK]\n[MASK]\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n[MASK]\n            }\n[MASK]\n        }\n        return count;\n    }"}
{"task_id": "Java/9-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n   /**\n     * Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n     * \n     * Example:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ", "canonical_solution": "    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countDoubles(new int[]{1, 2, 4, 8, 16}) == 4;\n        assert countDoubles(new int[]{5, 10, 20, 40, 80}) == 4;\n        assert countDoubles(new int[]{3, 6, 12, 24, 48}) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countDoubles", "signature": "public static int countDoubles(int[] numbers)", "docstring": "Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0\n\n* Incomplete Code:\npublic static int countDoubles(int[] numbers)\n    {\n     \n[MASK]\n        int count = 0;\n        for (int num : numbers) {\n[MASK]\n[MASK]\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n     \n[MASK]\n        int count = 0;\n        for (int num : numbers) {\n[MASK]\n[MASK]\n            }\n            set.add(num);\n        }\n        return count;\n    }"}
{"task_id": "Java/10-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n     * \n     * Parameters:\n     * - n: the size of the n-teresting space\n     * - start: the starting n-tersection coordinates\n     * - end: the ending n-tersection coordinates\n     * - paths: paths between adjacent n-tersections in the n-teresting space\n     * \n     * Output:\n     * - If travel is possible, return \"can be travelled\"\n     * - If travel is not possible, return \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ", "canonical_solution": "    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 2}, {1, 2, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}, {2, 1, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}}).equals(\"cannot be travelled\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "canTravelMaze", "signature": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)", "docstring": "Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"\n\n* Incomplete Code:\npublic static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n[MASK]\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n[MASK]\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n[MASK]\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n[MASK]\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }"}
{"task_id": "Java/10-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n     * \n     * Parameters:\n     * - n: the size of the n-teresting space\n     * - start: the starting n-tersection coordinates\n     * - end: the ending n-tersection coordinates\n     * - paths: paths between adjacent n-tersections in the n-teresting space\n     * \n     * Output:\n     * - If travel is possible, return \"can be travelled\"\n     * - If travel is not possible, return \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ", "canonical_solution": "    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 2}, {1, 2, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}, {2, 1, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}}).equals(\"cannot be travelled\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "canTravelMaze", "signature": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)", "docstring": "Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"\n\n* Incomplete Code:\npublic static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n[MASK]\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n[MASK]\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n[MASK]\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n[MASK]\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n[MASK]\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n[MASK]\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }"}
{"task_id": "Java/11-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * The approximate value is calculated by counting the number of common letters\n     * and dividing it by the sum of the lengths of the two words.\n     *\n     * @param word1 The first word.\n     * @param word2 The second word.\n     * @return The approximate value as a reduced fraction.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ", "canonical_solution": "    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert appx(\"DOG\", \"CAT\").equals(\"appx(DOG, CAT) = 0/6\");\n        assert appx(\"HELLO\", \"WORLD\").equals(\"appx(HELLO, WORLD) = 3/10\");\n        assert appx(\"JAVA\", \"PYTHON\").equals(\"appx(JAVA, PYTHON) = 0/10\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "appx", "signature": "public static String appx(String word1, String word2)", "docstring": "The approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nThe approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"\n\n* Incomplete Code:\npublic static String appx(String word1, String word2)\n    {\n     \n[MASK]\n        for (char c : word1.toCharArray()) {\n[MASK]\n[MASK]\n            }\n        }\n        int total = word1.length() + word2.length();\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n     \n[MASK]\n        for (char c : word1.toCharArray()) {\n[MASK]\n[MASK]\n            }\n        }\n        int total = word1.length() + word2.length();\n[MASK]\n    }"}
{"task_id": "Java/11-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * The approximate value is calculated by counting the number of common letters\n     * and dividing it by the sum of the lengths of the two words.\n     *\n     * @param word1 The first word.\n     * @param word2 The second word.\n     * @return The approximate value as a reduced fraction.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ", "canonical_solution": "    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert appx(\"DOG\", \"CAT\").equals(\"appx(DOG, CAT) = 0/6\");\n        assert appx(\"HELLO\", \"WORLD\").equals(\"appx(HELLO, WORLD) = 3/10\");\n        assert appx(\"JAVA\", \"PYTHON\").equals(\"appx(JAVA, PYTHON) = 0/10\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "appx", "signature": "public static String appx(String word1, String word2)", "docstring": "The approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nThe approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"\n\n* Incomplete Code:\npublic static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n[MASK]\n[MASK]\n[MASK]\n            }\n        }\n        int total = word1.length() + word2.length();\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n     \n        int common = 0;\n[MASK]\n[MASK]\n[MASK]\n            }\n        }\n        int total = word1.length() + word2.length();\n[MASK]\n    }"}
{"task_id": "Java/12-0-multi", "prompt": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n     * \n     * Example:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ", "canonical_solution": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert convertDatesToWeekdays(\"02 05 2024\").equals(\"February 5, 2024 is a Monday\");\n        assert convertDatesToWeekdays(\"01 12 2023\").equals(\"January 12, 2023 is a Thursday\");\n        assert convertDatesToWeekdays(\"09 14 2013\").equals(\"September 14, 2013 is a Saturday\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "convertDatesToWeekdays", "signature": "public static String convertDatesToWeekdays(String date)", "docstring": "Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"\n\n* Incomplete Code:\npublic static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n[MASK]\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n[MASK]\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n[MASK]\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n[MASK]\n[MASK]\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n[MASK]\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n[MASK]\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n[MASK]\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n[MASK]\n[MASK]\n        }\n    }"}
{"task_id": "Java/12-1-multi", "prompt": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n     * \n     * Example:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ", "canonical_solution": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert convertDatesToWeekdays(\"02 05 2024\").equals(\"February 5, 2024 is a Monday\");\n        assert convertDatesToWeekdays(\"01 12 2023\").equals(\"January 12, 2023 is a Thursday\");\n        assert convertDatesToWeekdays(\"09 14 2013\").equals(\"September 14, 2013 is a Saturday\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "convertDatesToWeekdays", "signature": "public static String convertDatesToWeekdays(String date)", "docstring": "Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"\n\n* Incomplete Code:\npublic static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n[MASK]\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n[MASK]\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n[MASK]\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n[MASK]\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n[MASK]\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n[MASK]\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }"}
{"task_id": "Java/13-0-multi", "prompt": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Given an array of integers nums and an integer target,\n     * find two numbers such that they add up to target and return their indices.\n     * You may assume that each input would have exactly one solution,\n     * and you may not use the same element twice.\n     * You can return the answer in any order.\n     *\n     * Example 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     *\n     * Example 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Example 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ", "canonical_solution": "  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 3, 7, 9, 2 }, 11),\n      new int[] { 3, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 5, 3, 7, 8 }, 9),\n      new int[] { 0, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 10, 20, 30, 40, 50 }, 90),\n      new int[] { 3, 4 }\n    );\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "twoSum", "signature": "public int[] twoSum(int[] nums, int target)", "docstring": "Given an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n* Incomplete Code:\npublic int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n[MASK]\n[MASK]\n      }\n      map.put(nums[i], i);\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n[MASK]\n[MASK]\n      }\n      map.put(nums[i], i);\n    }\n[MASK]\n  }"}
{"task_id": "Java/13-1-multi", "prompt": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Given an array of integers nums and an integer target,\n     * find two numbers such that they add up to target and return their indices.\n     * You may assume that each input would have exactly one solution,\n     * and you may not use the same element twice.\n     * You can return the answer in any order.\n     *\n     * Example 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     *\n     * Example 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Example 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ", "canonical_solution": "  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 3, 7, 9, 2 }, 11),\n      new int[] { 3, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 5, 3, 7, 8 }, 9),\n      new int[] { 0, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 10, 20, 30, 40, 50 }, 90),\n      new int[] { 3, 4 }\n    );\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "twoSum", "signature": "public int[] twoSum(int[] nums, int target)", "docstring": "Given an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n* Incomplete Code:\npublic int[] twoSum(int[] nums, int target)\n  {\n\n[MASK]\n[MASK]\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n[MASK]\n      }\n[MASK]\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n[MASK]\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n[MASK]\n      }\n[MASK]\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }"}
{"task_id": "Java/14-0-multi", "prompt": "class Solution {\n    /**\n     * Search for the target value in the rotated sorted array.\n     * If the target value exists, return its index; otherwise, return -1.\n     * The array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\n     * The time complexity of the algorithm must be O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ", "canonical_solution": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 6) == 2;\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 7) == 3;\n        assert solution.search(new int[]{1, 3}, 3) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "search", "signature": "public int search(int[] nums, int target)", "docstring": "Search for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nSearch for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1\n\n* Incomplete Code:\npublic int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n[MASK]\n[MASK]\n            else if (nums[mid] >= nums[start]) {\n[MASK]\n                else start = mid + 1;\n            }\n            else {\n[MASK]\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n[MASK]\n[MASK]\n            else if (nums[mid] >= nums[start]) {\n[MASK]\n                else start = mid + 1;\n            }\n            else {\n[MASK]\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }"}
{"task_id": "Java/14-1-multi", "prompt": "class Solution {\n    /**\n     * Search for the target value in the rotated sorted array.\n     * If the target value exists, return its index; otherwise, return -1.\n     * The array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\n     * The time complexity of the algorithm must be O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ", "canonical_solution": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 6) == 2;\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 7) == 3;\n        assert solution.search(new int[]{1, 3}, 3) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "search", "signature": "public int search(int[] nums, int target)", "docstring": "Search for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nSearch for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1\n\n* Incomplete Code:\npublic int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n[MASK]\n[MASK]\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n[MASK]\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n[MASK]\n            }\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n[MASK]\n[MASK]\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n[MASK]\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n[MASK]\n            }\n        }\n[MASK]\n    }"}
{"task_id": "Java/15-0-multi", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\n     * Return the mean with an error within 10^-5.\n     *\n     * Example 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Example 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Example 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Example 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Example 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ", "canonical_solution": "  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }) - 5.5\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }) -\n      55.0\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }) - 1.0\n    ) <\n    1e-5;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "trimMean", "signature": "public double trimMean(int[] arr)", "docstring": "Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167\n\n* Incomplete Code:\npublic double trimMean(int[] arr)\n  {\n\n[MASK]\n    int n = arr.length;\n[MASK]\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    int n = arr.length;\n[MASK]\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n[MASK]\n  }"}
{"task_id": "Java/15-1-multi", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\n     * Return the mean with an error within 10^-5.\n     *\n     * Example 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Example 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Example 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Example 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Example 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ", "canonical_solution": "  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }) - 5.5\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }) -\n      55.0\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }) - 1.0\n    ) <\n    1e-5;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "trimMean", "signature": "public double trimMean(int[] arr)", "docstring": "Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167\n\n* Incomplete Code:\npublic double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n[MASK]\n[MASK]\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n[MASK]\n[MASK]\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n[MASK]\n  }"}
{"task_id": "Java/16-0-multi", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n     *\n     * @param arr the input integer array\n     * @param k the divisor\n     * @return true if it is possible, false otherwise\n     *\n     * Example:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n     */\n  public boolean canArrange(int[] arr, int k) ", "canonical_solution": "  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.canArrange(new int[]{1,2,3,4,5,10,6,7,8,9}, 5) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 7) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 10) == false;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "canArrange", "signature": "public boolean canArrange(int[] arr, int k)", "docstring": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCheck if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n\n* Incomplete Code:\npublic boolean canArrange(int[] arr, int k)\n  {\n\n[MASK]\n[MASK]\n      remainder[(num % k + k) % k]++;\n    }\n[MASK]\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n[MASK]\n      }\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n[MASK]\n      remainder[(num % k + k) % k]++;\n    }\n[MASK]\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n[MASK]\n      }\n    }\n[MASK]\n  }"}
{"task_id": "Java/16-1-multi", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n     *\n     * @param arr the input integer array\n     * @param k the divisor\n     * @return true if it is possible, false otherwise\n     *\n     * Example:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n     */\n  public boolean canArrange(int[] arr, int k) ", "canonical_solution": "  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.canArrange(new int[]{1,2,3,4,5,10,6,7,8,9}, 5) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 7) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 10) == false;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "canArrange", "signature": "public boolean canArrange(int[] arr, int k)", "docstring": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCheck if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n\n* Incomplete Code:\npublic boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n[MASK]\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n[MASK]\n        return false;\n      }\n    }\n    return true;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n[MASK]\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n[MASK]\n        return false;\n      }\n    }\n    return true;\n  }"}
{"task_id": "Java/17-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\n   * Starting from node 0, return the minimum time required to collect all the apples and return to node 0.\n   *\n   * Example:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ", "canonical_solution": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, false, true, false, true, true, false }\n    ) ==\n    8;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, true, true, true, true, true, true }\n    ) ==\n    12;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,true,false,false,true,false }\n    ) ==\n    6;\n\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,false,false,false,false,false }\n    ) ==\n    0;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minTime", "signature": "public int minTime(int n, int[][] edges, boolean[] hasApple)", "docstring": "Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0\n\n* Incomplete Code:\npublic int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n[MASK]\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n[MASK]\n    if (res[node] >= 0) return res[node];\n[MASK]\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n[MASK]\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n[MASK]\n    if (res[node] >= 0) return res[node];\n[MASK]\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n"}
{"task_id": "Java/17-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\n   * Starting from node 0, return the minimum time required to collect all the apples and return to node 0.\n   *\n   * Example:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ", "canonical_solution": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, false, true, false, true, true, false }\n    ) ==\n    8;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, true, true, true, true, true, true }\n    ) ==\n    12;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,true,false,false,true,false }\n    ) ==\n    6;\n\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,false,false,false,false,false }\n    ) ==\n    0;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minTime", "signature": "public int minTime(int n, int[][] edges, boolean[] hasApple)", "docstring": "Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0\n\n* Incomplete Code:\npublic int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n[MASK]\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n[MASK]\n[MASK]\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n[MASK]\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n[MASK]\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n[MASK]\n[MASK]\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n[MASK]\n  }\n"}
{"task_id": "Java/18-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s)", "canonical_solution": "    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "sortString", "signature": "public String sortString(String s)", "docstring": "Given a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.\n\n* Incomplete Code:\npublic String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n[MASK]\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n[MASK]\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n[MASK]\n[MASK]\n            }\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n[MASK]\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n[MASK]\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n[MASK]\n[MASK]\n            }\n        }\n    }"}
{"task_id": "Java/18-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s)", "canonical_solution": "    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "sortString", "signature": "public String sortString(String s)", "docstring": "Given a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.\n\n* Incomplete Code:\npublic String sortString(String s)\n    {\n\n[MASK]\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n[MASK]\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n[MASK]\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n[MASK]\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n[MASK]\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n[MASK]\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }"}
{"task_id": "Java/19-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to split the given integer array into two non-empty arrays\n     * with the same average.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ", "canonical_solution": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }", "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 9}) == false;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 10}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == true;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "splitArraySameAverage", "signature": "public boolean splitArraySameAverage(int[] nums)", "docstring": "Check if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCheck if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse\n\n* Incomplete Code:\npublic boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n[MASK]\n[MASK]\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n[MASK]\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n[MASK]\n[MASK]\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n[MASK]\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }"}
{"task_id": "Java/19-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to split the given integer array into two non-empty arrays\n     * with the same average.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ", "canonical_solution": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }", "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 9}) == false;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 10}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == true;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "splitArraySameAverage", "signature": "public boolean splitArraySameAverage(int[] nums)", "docstring": "Check if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCheck if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse\n\n* Incomplete Code:\npublic boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n[MASK]\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n[MASK]\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n[MASK]\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n[MASK]\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }"}
{"task_id": "Java/20-0-multi", "prompt": "class Solution {\n    /**\n     * Given an integer array cost where cost[i] is the cost of ith step on a staircase,\n     * return the minimum cost to reach the top of the floor.\n     * You can either start from the step with index 0 or the step with index 1.\n     *\n     * Example:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explanation: You will start at index 1.\n     * - Pay 15 and climb two steps to reach the top.\n     * The total cost is 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explanation: You will start at index 0.\n     * - Pay 1 and climb two steps to reach index 2.\n     * - Pay 1 and climb two steps to reach index 4.\n     * - Pay 1 and climb two steps to reach index 6.\n     * - Pay 1 and climb one step to reach index 7.\n     * - Pay 1 and climb two steps to reach index 9.\n     * - Pay 1 and climb one step to reach the top.\n     * The total cost is 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ", "canonical_solution": "  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minCostClimbingStairs(new int[] { 10, 15, 20 }) == 15;\n    assert solution.minCostClimbingStairs(\n      new int[] { 1, 100, 1, 1, 1, 100, 1, 1, 100, 1 }\n    ) ==\n    6;\n    assert solution.minCostClimbingStairs(new int[] { 0, 0, 0, 1 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "minCostClimbingStairs", "signature": "public int minCostClimbingStairs(int[] cost)", "docstring": "Given an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n* Incomplete Code:\npublic int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n[MASK]\n    for (int i = 2; i <= n; i++) {\n[MASK]\n    }\n    return dp[n];\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    int n = cost.length;\n[MASK]\n    for (int i = 2; i <= n; i++) {\n[MASK]\n    }\n    return dp[n];\n  }"}
{"task_id": "Java/20-1-multi", "prompt": "class Solution {\n    /**\n     * Given an integer array cost where cost[i] is the cost of ith step on a staircase,\n     * return the minimum cost to reach the top of the floor.\n     * You can either start from the step with index 0 or the step with index 1.\n     *\n     * Example:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explanation: You will start at index 1.\n     * - Pay 15 and climb two steps to reach the top.\n     * The total cost is 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explanation: You will start at index 0.\n     * - Pay 1 and climb two steps to reach index 2.\n     * - Pay 1 and climb two steps to reach index 4.\n     * - Pay 1 and climb two steps to reach index 6.\n     * - Pay 1 and climb one step to reach index 7.\n     * - Pay 1 and climb two steps to reach index 9.\n     * - Pay 1 and climb one step to reach the top.\n     * The total cost is 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ", "canonical_solution": "  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minCostClimbingStairs(new int[] { 10, 15, 20 }) == 15;\n    assert solution.minCostClimbingStairs(\n      new int[] { 1, 100, 1, 1, 1, 100, 1, 1, 100, 1 }\n    ) ==\n    6;\n    assert solution.minCostClimbingStairs(new int[] { 0, 0, 0, 1 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "minCostClimbingStairs", "signature": "public int minCostClimbingStairs(int[] cost)", "docstring": "Given an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n* Incomplete Code:\npublic int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n[MASK]\n[MASK]\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n[MASK]\n[MASK]\n    }\n[MASK]\n  }"}
{"task_id": "Java/21-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\n     * return the number of different transformations among all words.\n     *\n     * Example:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ", "canonical_solution": "    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.uniqueMorseRepresentations(new String[]{\"hello\", \"world\", \"hello\"}) == 2;\n        assert solution.uniqueMorseRepresentations(new String[]{\"abc\", \"def\", \"ghi\"}) == 3;\n        assert solution.uniqueMorseRepresentations(new String[]{\"aaa\", \"aaa\", \"aaa\"}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "uniqueMorseRepresentations", "signature": "public int uniqueMorseRepresentations(String[] words)", "docstring": "Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1\n\n* Incomplete Code:\npublic int uniqueMorseRepresentations(String[] words)\n    {\n\n[MASK]\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n[MASK]\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n[MASK]\n        }\n\n        return seen.size();\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n[MASK]\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n[MASK]\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n[MASK]\n        }\n\n        return seen.size();\n    }"}
{"task_id": "Java/21-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\n     * return the number of different transformations among all words.\n     *\n     * Example:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ", "canonical_solution": "    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.uniqueMorseRepresentations(new String[]{\"hello\", \"world\", \"hello\"}) == 2;\n        assert solution.uniqueMorseRepresentations(new String[]{\"abc\", \"def\", \"ghi\"}) == 3;\n        assert solution.uniqueMorseRepresentations(new String[]{\"aaa\", \"aaa\", \"aaa\"}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "uniqueMorseRepresentations", "signature": "public int uniqueMorseRepresentations(String[] words)", "docstring": "Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1\n\n* Incomplete Code:\npublic int uniqueMorseRepresentations(String[] words)\n    {\n\n[MASK]\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n[MASK]\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n[MASK]\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n[MASK]\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }"}
{"task_id": "Java/22-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n     *\n     * Example 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Explanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n     *\n     * Example 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Explanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n     *\n     * Example 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Explanation: The binary string \"00\" is not a substring of s.\n     */\n  public boolean hasAllCodes(String s, int k) ", "canonical_solution": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.hasAllCodes(\"00110110\", 3) == false;\n    assert solution.hasAllCodes(\"00110110\", 2) == true;\n    assert solution.hasAllCodes(\n      \"1111111111111111111111111111111111111111111111111111111111111111\",\n      1\n    ) ==\n    false;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "hasAllCodes", "signature": "public boolean hasAllCodes(String s, int k)", "docstring": "Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.\n\n* Incomplete Code:\npublic boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n[MASK]\n      }\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n[MASK]\n      }\n    }\n[MASK]\n  }"}
{"task_id": "Java/22-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n     *\n     * Example 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Explanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n     *\n     * Example 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Explanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n     *\n     * Example 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Explanation: The binary string \"00\" is not a substring of s.\n     */\n  public boolean hasAllCodes(String s, int k) ", "canonical_solution": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.hasAllCodes(\"00110110\", 3) == false;\n    assert solution.hasAllCodes(\"00110110\", 2) == true;\n    assert solution.hasAllCodes(\n      \"1111111111111111111111111111111111111111111111111111111111111111\",\n      1\n    ) ==\n    false;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "hasAllCodes", "signature": "public boolean hasAllCodes(String s, int k)", "docstring": "Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.\n\n* Incomplete Code:\npublic boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n[MASK]\n[MASK]\n        return true;\n      }\n    }\n    return false;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n[MASK]\n[MASK]\n        return true;\n      }\n    }\n    return false;\n  }"}
{"task_id": "Java/23-0-multi", "prompt": "class Solution {\n    /**\n    * Check if the searchWord is a prefix of any word in the sentence.\n    * If searchWord is a prefix of multiple words, return the index of the first matching word.\n    * If searchWord is not a prefix of any word, return -1.\n    * \n    * Example:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ", "canonical_solution": "  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }", "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.isPrefixOfWord(\"hello world\", \"wor\") == 2;\n      assert solution.isPrefixOfWord(\"hello world\", \"hell\") == 1;\n      assert solution.isPrefixOfWord(\"hello world\", \"foo\") == -1;\n      System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isPrefixOfWord", "signature": "public int isPrefixOfWord(String sentence, String searchWord)", "docstring": "Check if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCheck if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1\n\n* Incomplete Code:\npublic int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n[MASK]\n          if (words[i].startsWith(searchWord)) {\n[MASK]\n          }\n      }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      String[] words = sentence.split(\" \");\n[MASK]\n          if (words[i].startsWith(searchWord)) {\n[MASK]\n          }\n      }\n[MASK]\n  }"}
{"task_id": "Java/23-1-multi", "prompt": "class Solution {\n    /**\n    * Check if the searchWord is a prefix of any word in the sentence.\n    * If searchWord is a prefix of multiple words, return the index of the first matching word.\n    * If searchWord is not a prefix of any word, return -1.\n    * \n    * Example:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ", "canonical_solution": "  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }", "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.isPrefixOfWord(\"hello world\", \"wor\") == 2;\n      assert solution.isPrefixOfWord(\"hello world\", \"hell\") == 1;\n      assert solution.isPrefixOfWord(\"hello world\", \"foo\") == -1;\n      System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isPrefixOfWord", "signature": "public int isPrefixOfWord(String sentence, String searchWord)", "docstring": "Check if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCheck if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1\n\n* Incomplete Code:\npublic int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n[MASK]\n[MASK]\n          }\n      }\n      return -1;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n[MASK]\n[MASK]\n          }\n      }\n      return -1;\n  }"}
{"task_id": "Java/24-0-multi", "prompt": "class Solution {\n    /**\n    * Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n    *\n    * Example 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\n    * Example 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s consists of '(' and ')' only.\n    */\n public int minInsertions(String s) ", "canonical_solution": " {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.minInsertions(\"((()))\") == 0;\n        assert solution.minInsertions(\"()()()\") == 0;\n        assert solution.minInsertions(\"(()))(()\") == 2;\n        assert solution.minInsertions(\"))())(((\") == 6;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "minInsertions", "signature": "public int minInsertions(String s)", "docstring": "Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.\n\n* Incomplete Code:\npublic int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n[MASK]\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n[MASK]\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n[MASK]\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n        int insertions = 0; // Count of insertions needed\n[MASK]\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n[MASK]\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n[MASK]\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }"}
{"task_id": "Java/24-1-multi", "prompt": "class Solution {\n    /**\n    * Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n    *\n    * Example 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\n    * Example 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s consists of '(' and ')' only.\n    */\n public int minInsertions(String s) ", "canonical_solution": " {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.minInsertions(\"((()))\") == 0;\n        assert solution.minInsertions(\"()()()\") == 0;\n        assert solution.minInsertions(\"(()))(()\") == 2;\n        assert solution.minInsertions(\"))())(((\") == 6;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "minInsertions", "signature": "public int minInsertions(String s)", "docstring": "Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.\n\n* Incomplete Code:\npublic int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n[MASK]\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n[MASK]\n[MASK]\n                // Decrease balance for every ')' found\n[MASK]\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n[MASK]\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n[MASK]\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n[MASK]\n[MASK]\n                // Decrease balance for every ')' found\n[MASK]\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n[MASK]\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }"}
{"task_id": "Java/26-0-multi", "prompt": "class Solution {\n    /**\n     * Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n     *\n     * Example:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n     *\n     * Constraints:\n     * - The length of the `gain` array is between 1 and 100, inclusive.\n     * - Each element in the `gain` array is between -100 and 100, inclusive.\n     */\n    public int highestAltitude(int[] gain) ", "canonical_solution": "    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.highestAltitude(new int[]{-5,1,5,0,-7}) == 1;\n        assert solution.highestAltitude(new int[]{-4,-3,-2,-1,4,3,2}) == 0;\n        assert solution.highestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2, 1}) == 0;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "highestAltitude", "signature": "public int highestAltitude(int[] gain)", "docstring": "Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.\n\n* Incomplete Code:\npublic int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n[MASK]\n            altitude += i;\n[MASK]\n        }\n        return highest;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int altitude = 0, highest = 0;\n[MASK]\n            altitude += i;\n[MASK]\n        }\n        return highest;\n    }"}
{"task_id": "Java/26-1-multi", "prompt": "class Solution {\n    /**\n     * Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n     *\n     * Example:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n     *\n     * Constraints:\n     * - The length of the `gain` array is between 1 and 100, inclusive.\n     * - Each element in the `gain` array is between -100 and 100, inclusive.\n     */\n    public int highestAltitude(int[] gain) ", "canonical_solution": "    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.highestAltitude(new int[]{-5,1,5,0,-7}) == 1;\n        assert solution.highestAltitude(new int[]{-4,-3,-2,-1,4,3,2}) == 0;\n        assert solution.highestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2, 1}) == 0;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "highestAltitude", "signature": "public int highestAltitude(int[] gain)", "docstring": "Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.\n\n* Incomplete Code:\npublic int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n[MASK]\n[MASK]\n[MASK]\n        }\n        return highest;\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int altitude = 0, highest = 0;\n[MASK]\n[MASK]\n[MASK]\n        }\n        return highest;\n    }"}
{"task_id": "Java/27-0-multi", "prompt": "class Solution {\n    /**\n     * Given an integer array nums, return the maximum absolute sum of any subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ", "canonical_solution": "    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }", "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.maxAbsoluteSum(new int[]{1,-3,2,3,-4}) == 5;\n        assert solution.maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2}) == 8;\n        assert solution.maxAbsoluteSum(new int[]{-2, -3, 4, -1, -2, 1, 5, -3}) == 7;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "maxAbsoluteSum", "signature": "public int maxAbsoluteSum(int[] nums)", "docstring": "Given an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8\n\n* Incomplete Code:\npublic int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n[MASK]\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n[MASK]\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n[MASK]\n    }"}
{"task_id": "Java/27-1-multi", "prompt": "class Solution {\n    /**\n     * Given an integer array nums, return the maximum absolute sum of any subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ", "canonical_solution": "    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }", "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.maxAbsoluteSum(new int[]{1,-3,2,3,-4}) == 5;\n        assert solution.maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2}) == 8;\n        assert solution.maxAbsoluteSum(new int[]{-2, -3, 4, -1, -2, 1, 5, -3}) == 7;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "maxAbsoluteSum", "signature": "public int maxAbsoluteSum(int[] nums)", "docstring": "Given an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8\n\n* Incomplete Code:\npublic int maxAbsoluteSum(int[] nums)\n    {\n\n[MASK]\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n[MASK]\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n[MASK]\n    }"}
{"task_id": "Java/28-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\n     * Fibonacci numbers are defined as follows:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, for n > 2.\n     * It is guaranteed that there is at least one valid solution for the given k.\n     *\n     * Example 1:\n     * Input: k = 7\n     * Output: 2\n     * Explanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\n     * For k = 7, we can get 2 + 5 = 7.\n     *\n     * Example 2:\n     * Input: k = 10\n     * Output: 2\n     * Explanation: For k = 10, we can get 2 + 8 = 10.\n     *\n     * Example 3:\n     * Input: k = 19\n     * Output: 3\n     * Explanation: For k = 19, we can get 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ", "canonical_solution": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.findMinFibonacciNumbers(7) == 2;\n    assert solution.findMinFibonacciNumbers(10) == 2;\n    assert solution.findMinFibonacciNumbers(13) == 1;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "findMinFibonacciNumbers", "signature": "public int findMinFibonacciNumbers(int k)", "docstring": "Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.\n\n* Incomplete Code:\npublic int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n[MASK]\n[MASK]\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n[MASK]\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n[MASK]\n[MASK]\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n[MASK]\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }"}
{"task_id": "Java/28-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\n     * Fibonacci numbers are defined as follows:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, for n > 2.\n     * It is guaranteed that there is at least one valid solution for the given k.\n     *\n     * Example 1:\n     * Input: k = 7\n     * Output: 2\n     * Explanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\n     * For k = 7, we can get 2 + 5 = 7.\n     *\n     * Example 2:\n     * Input: k = 10\n     * Output: 2\n     * Explanation: For k = 10, we can get 2 + 8 = 10.\n     *\n     * Example 3:\n     * Input: k = 19\n     * Output: 3\n     * Explanation: For k = 19, we can get 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ", "canonical_solution": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.findMinFibonacciNumbers(7) == 2;\n    assert solution.findMinFibonacciNumbers(10) == 2;\n    assert solution.findMinFibonacciNumbers(13) == 1;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "findMinFibonacciNumbers", "signature": "public int findMinFibonacciNumbers(int k)", "docstring": "Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.\n\n* Incomplete Code:\npublic int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n[MASK]\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n      }\n    }\n    return count;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n[MASK]\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n      }\n    }\n    return count;\n  }"}
{"task_id": "Java/29-0-multi", "prompt": "class Solution {\n    /**\n     * Given two positive integers n and k, find the kth factor of n.\n     * A factor of n is a positive integer that divides n evenly.\n     * Return the kth factor in ascending order. If n has less than k factors, return -1.\n     *\n     * Example 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Explanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n     *\n     * Example 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Explanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n     *\n     * Example 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Explanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n     */\n    public int kthFactor(int n, int k) ", "canonical_solution": "    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.kthFactor(100, 3) == 4;\n        assert solution.kthFactor(15, 4) == 15;\n        assert solution.kthFactor(30, 18) == -1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "kthFactor", "signature": "public int kthFactor(int n, int k)", "docstring": "Given two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n\n* Incomplete Code:\npublic int kthFactor(int n, int k)\n    {\n\n[MASK]\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n[MASK]\n[MASK]\n                    return i;\n                }\n            }\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n[MASK]\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n[MASK]\n[MASK]\n                    return i;\n                }\n            }\n        }\n[MASK]\n    }"}
{"task_id": "Java/29-1-multi", "prompt": "class Solution {\n    /**\n     * Given two positive integers n and k, find the kth factor of n.\n     * A factor of n is a positive integer that divides n evenly.\n     * Return the kth factor in ascending order. If n has less than k factors, return -1.\n     *\n     * Example 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Explanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n     *\n     * Example 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Explanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n     *\n     * Example 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Explanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n     */\n    public int kthFactor(int n, int k) ", "canonical_solution": "    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.kthFactor(100, 3) == 4;\n        assert solution.kthFactor(15, 4) == 15;\n        assert solution.kthFactor(30, 18) == -1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "kthFactor", "signature": "public int kthFactor(int n, int k)", "docstring": "Given two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n\n* Incomplete Code:\npublic int kthFactor(int n, int k)\n    {\n\n[MASK]\n[MASK]\n[MASK]\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n\n[MASK]\n[MASK]\n[MASK]\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n[MASK]\n    }"}
{"task_id": "Java/30-0-multi", "prompt": "class Solution {\n    /**\n     * Given a string s consisting of lowercase and uppercase English letters,\n     * you need to make the string \"good\".\n     * A string is considered \"good\" if there are no adjacent characters such that\n     * one is a lowercase letter and the other is the corresponding uppercase letter.\n     * You can choose any adjacent characters in the string and remove them until the string is \"good\".\n     * Return the final \"good\" string.\n     *\n     * Example 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Explanation: You can remove \"Ee\" to make \"leetcode\".\n     *\n     * Example 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Explanation: There are multiple possible solutions, such as:\n     * - Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n     * - Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\n     *   then remove \"aA\" to make \"\".\n     * No matter the choices, the result is an empty string.\n     *\n     * Example 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Explanation: The string is already \"good\".\n     */\n  public String makeGood(String s) ", "canonical_solution": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }", "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.makeGood(\"aAbBcC\").equals(\"\");\n    assert solution.makeGood(\"AaBbCc\").equals(\"\");\n    assert solution.makeGood(\"abcABC\").equals(\"abcABC\");\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "makeGood", "signature": "public String makeGood(String s)", "docstring": "Given a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".\n\n* Incomplete Code:\npublic String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n[MASK]\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n[MASK]\n      }\n    }\n    return sb.toString();\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n[MASK]\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n[MASK]\n      }\n    }\n    return sb.toString();\n  }"}
{"task_id": "Java/30-1-multi", "prompt": "class Solution {\n    /**\n     * Given a string s consisting of lowercase and uppercase English letters,\n     * you need to make the string \"good\".\n     * A string is considered \"good\" if there are no adjacent characters such that\n     * one is a lowercase letter and the other is the corresponding uppercase letter.\n     * You can choose any adjacent characters in the string and remove them until the string is \"good\".\n     * Return the final \"good\" string.\n     *\n     * Example 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Explanation: You can remove \"Ee\" to make \"leetcode\".\n     *\n     * Example 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Explanation: There are multiple possible solutions, such as:\n     * - Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n     * - Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\n     *   then remove \"aA\" to make \"\".\n     * No matter the choices, the result is an empty string.\n     *\n     * Example 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Explanation: The string is already \"good\".\n     */\n  public String makeGood(String s) ", "canonical_solution": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }", "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.makeGood(\"aAbBcC\").equals(\"\");\n    assert solution.makeGood(\"AaBbCc\").equals(\"\");\n    assert solution.makeGood(\"abcABC\").equals(\"abcABC\");\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "makeGood", "signature": "public String makeGood(String s)", "docstring": "Given a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".\n\n* Incomplete Code:\npublic String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n[MASK]\n[MASK]\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n[MASK]\n      } else {\n[MASK]\n      }\n    }\n    return sb.toString();\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n[MASK]\n[MASK]\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n[MASK]\n      } else {\n[MASK]\n      }\n    }\n    return sb.toString();\n  }"}
{"task_id": "Java/31-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a string s, split the string and return the maximum number of unique substrings.\n   * The split substrings should be able to reconstruct the original string, and each substring must be unique.\n   *\n   * Example:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Explanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\n   *              Splitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n   *\n   * Note:\n   * - The length of s is between 1 and 16.\n   * - s only contains lowercase English letters.\n   */\n  public int maxUniqueSplit(String s) ", "canonical_solution": "  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.maxUniqueSplit(\"ababccc\") == 5;\n    assert solution.maxUniqueSplit(\"abcabcabc\") == 6;\n    assert solution.maxUniqueSplit(\"abcdefg\") == 7;\n    assert solution.maxUniqueSplit(\"aaaaaaa\") == 3;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "maxUniqueSplit", "signature": "public int maxUniqueSplit(String s)", "docstring": "Given a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.\n\n* Incomplete Code:\npublic int maxUniqueSplit(String s)\n  {\n[MASK]\n  }\n\n[MASK]\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n  }\n\n[MASK]\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n"}
{"task_id": "Java/31-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a string s, split the string and return the maximum number of unique substrings.\n   * The split substrings should be able to reconstruct the original string, and each substring must be unique.\n   *\n   * Example:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Explanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\n   *              Splitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n   *\n   * Note:\n   * - The length of s is between 1 and 16.\n   * - s only contains lowercase English letters.\n   */\n  public int maxUniqueSplit(String s) ", "canonical_solution": "  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.maxUniqueSplit(\"ababccc\") == 5;\n    assert solution.maxUniqueSplit(\"abcabcabc\") == 6;\n    assert solution.maxUniqueSplit(\"abcdefg\") == 7;\n    assert solution.maxUniqueSplit(\"aaaaaaa\") == 3;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "maxUniqueSplit", "signature": "public int maxUniqueSplit(String s)", "docstring": "Given a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.\n\n* Incomplete Code:\npublic int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n[MASK]\n    if (start == s.length()) {\n      return seen.size();\n    }\n[MASK]\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n[MASK]\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n[MASK]\n    if (start == s.length()) {\n      return seen.size();\n    }\n[MASK]\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n[MASK]\n  }\n"}
{"task_id": "Java/32-0-multi", "prompt": "class Solution {\n    /**\n     * Given a list of logs representing folder operations,\n     * return the minimum number of steps required to return to the main folder.\n     *\n     * Example:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explanation: Perform the \"../\" operation twice to return to the main folder.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ", "canonical_solution": "  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"../\", \"d21/\", \"./\", \"../\" }\n    ) ==\n    1;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"./\", \"d3/\", \"../\", \"d31/\", \"../\" }\n    ) ==\n    2;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"../\", \"../\", \"../\", \"d2/\" }\n    ) ==\n    1;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minOperations", "signature": "public int minOperations(String[] logs)", "docstring": "Given a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0\n\n* Incomplete Code:\npublic int minOperations(String[] logs)\n  {\n[MASK]\n    for (String log : logs) {\n[MASK]\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n[MASK]\n      }\n    }\n    return depth;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (String log : logs) {\n[MASK]\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n[MASK]\n      }\n    }\n    return depth;\n  }"}
{"task_id": "Java/32-1-multi", "prompt": "class Solution {\n    /**\n     * Given a list of logs representing folder operations,\n     * return the minimum number of steps required to return to the main folder.\n     *\n     * Example:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explanation: Perform the \"../\" operation twice to return to the main folder.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ", "canonical_solution": "  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"../\", \"d21/\", \"./\", \"../\" }\n    ) ==\n    1;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"./\", \"d3/\", \"../\", \"d31/\", \"../\" }\n    ) ==\n    2;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"../\", \"../\", \"../\", \"d2/\" }\n    ) ==\n    1;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minOperations", "signature": "public int minOperations(String[] logs)", "docstring": "Given a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0\n\n* Incomplete Code:\npublic int minOperations(String[] logs)\n  {\n    int depth = 0;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n        }\n      } else if (!log.equals(\"./\")) {\n[MASK]\n      }\n    }\n    return depth;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    int depth = 0;\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n        }\n      } else if (!log.equals(\"./\")) {\n[MASK]\n      }\n    }\n    return depth;\n  }"}
{"task_id": "Java/33-0-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the lexicographically smallest string of length n and value k.\n     * The value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\n     * Example:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ", "canonical_solution": "    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }", "test": "\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.getSmallestString(3, 27).equals(\"aay\");\n        assert solution.getSmallestString(5, 73).equals(\"aaszz\");\n        assert solution.getSmallestString(3, 30).equals(\"acz\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "getSmallestString", "signature": "public String getSmallestString(int n, int k)", "docstring": "Return the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReturn the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"\n\n* Incomplete Code:\npublic String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n[MASK]\n[MASK]\n        while (k > 0) {\n[MASK]\n[MASK]\n        }\n        return String.valueOf(res);\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        char[] res = new char[n];\n[MASK]\n[MASK]\n        while (k > 0) {\n[MASK]\n[MASK]\n        }\n        return String.valueOf(res);\n    }"}
{"task_id": "Java/33-1-multi", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the lexicographically smallest string of length n and value k.\n     * The value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\n     * Example:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ", "canonical_solution": "    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }", "test": "\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.getSmallestString(3, 27).equals(\"aay\");\n        assert solution.getSmallestString(5, 73).equals(\"aaszz\");\n        assert solution.getSmallestString(3, 30).equals(\"acz\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "getSmallestString", "signature": "public String getSmallestString(int n, int k)", "docstring": "Return the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReturn the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"\n\n* Incomplete Code:\npublic String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n[MASK]\n        k -= n;\n        while (k > 0) {\n[MASK]\n            k -= Math.min(25, k);\n        }\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    {\n        char[] res = new char[n];\n[MASK]\n        k -= n;\n        while (k > 0) {\n[MASK]\n            k -= Math.min(25, k);\n        }\n[MASK]\n    }"}
{"task_id": "Java/35-0-multi", "prompt": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n   *\n   * @param nums An integer array where every element appears three times except for one.\n   * @return The element that appears only once.\n   *\n   * Example:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Example:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ", "canonical_solution": "  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }", "test": "  public static void main(String[] args) {\n    assert singleNumber(new int[] { 6, 1, 6, 6 }) == 1 : \"Test case 1 failed\";\n    assert singleNumber(new int[] { 22, 22, 22, 11, 11, 11, 55 }) ==\n    55 : \"Test case 2 failed\";\n    assert singleNumber(new int[] { -1, 3, -1, 3, -1, 3, 99 }) ==\n    99 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "singleNumber", "signature": "public static int singleNumber(int[] nums)", "docstring": "Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99\n\n* Incomplete Code:\npublic static int singleNumber(int[] nums)\n  {\n[MASK]\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n[MASK]\n[MASK]\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n[MASK]\n[MASK]\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n[MASK]\n  }"}
{"task_id": "Java/35-1-multi", "prompt": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n   *\n   * @param nums An integer array where every element appears three times except for one.\n   * @return The element that appears only once.\n   *\n   * Example:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Example:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ", "canonical_solution": "  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }", "test": "  public static void main(String[] args) {\n    assert singleNumber(new int[] { 6, 1, 6, 6 }) == 1 : \"Test case 1 failed\";\n    assert singleNumber(new int[] { 22, 22, 22, 11, 11, 11, 55 }) ==\n    55 : \"Test case 2 failed\";\n    assert singleNumber(new int[] { -1, 3, -1, 3, -1, 3, 99 }) ==\n    99 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "singleNumber", "signature": "public static int singleNumber(int[] nums)", "docstring": "Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99\n\n* Incomplete Code:\npublic static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n[MASK]\n[MASK]\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n[MASK]\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n[MASK]\n[MASK]\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n[MASK]\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }"}
{"task_id": "Java/36-0-multi", "prompt": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n   *\n   * @param low The lower bound of the range.\n   * @param high The upper bound of the range.\n   * @return A list of stepping numbers within the range [low, high] sorted in ascending order.\n   *\n   * Example:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ", "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }", "test": "  public static void main(String[] args) {\n    assert findSteppingNumbers(0, 21)\n      .equals(\n        new ArrayList<>(List.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21))\n      );\n    assert findSteppingNumbers(10, 15).equals(new ArrayList<>(List.of(10, 12)));\n    assert findSteppingNumbers(50, 55).equals(List.of(54));\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "findSteppingNumbers", "signature": "public static List<Integer> findSteppingNumbers(int low, int high)", "docstring": "Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nFind all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n\n* Incomplete Code:\npublic static List<Integer> findSteppingNumbers(int low, int high)\n  {\n[MASK]\n    for (int i = low; i <= high; i++) {\n[MASK]\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n[MASK]\n[MASK]\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n[MASK]\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (int i = low; i <= high; i++) {\n[MASK]\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n[MASK]\n[MASK]\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n[MASK]\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }"}
{"task_id": "Java/36-1-multi", "prompt": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n   *\n   * @param low The lower bound of the range.\n   * @param high The upper bound of the range.\n   * @return A list of stepping numbers within the range [low, high] sorted in ascending order.\n   *\n   * Example:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ", "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }", "test": "  public static void main(String[] args) {\n    assert findSteppingNumbers(0, 21)\n      .equals(\n        new ArrayList<>(List.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21))\n      );\n    assert findSteppingNumbers(10, 15).equals(new ArrayList<>(List.of(10, 12)));\n    assert findSteppingNumbers(50, 55).equals(List.of(54));\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "findSteppingNumbers", "signature": "public static List<Integer> findSteppingNumbers(int low, int high)", "docstring": "Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nFind all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n\n* Incomplete Code:\npublic static List<Integer> findSteppingNumbers(int low, int high)\n  {\n[MASK]\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n[MASK]\n    String strNum = String.valueOf(num);\n[MASK]\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n[MASK]\n    String strNum = String.valueOf(num);\n[MASK]\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }"}
{"task_id": "Java/37-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   *\n   * @param n An integer representing the upper limit.\n   * @return The number of times the digit 1 appears.\n   *\n   * Example:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Example:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ", "canonical_solution": "  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }", "test": "  public static void main(String[] args) {\n    assert countDigitOne(20) == 12 : \"Test case 1 failed\";\n    assert countDigitOne(55) == 16 : \"Test case 2 failed\";\n    assert countDigitOne(99) == 20 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "countDigitOne", "signature": "public static int countDigitOne(int n)", "docstring": "Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0\n\n* Incomplete Code:\npublic static int countDigitOne(int n)\n  {\n    int count = 0;\n[MASK]\n      long divider = k * 10;\n[MASK]\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    int count = 0;\n[MASK]\n      long divider = k * 10;\n[MASK]\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n[MASK]\n  }"}
{"task_id": "Java/37-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   *\n   * @param n An integer representing the upper limit.\n   * @return The number of times the digit 1 appears.\n   *\n   * Example:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Example:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ", "canonical_solution": "  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }", "test": "  public static void main(String[] args) {\n    assert countDigitOne(20) == 12 : \"Test case 1 failed\";\n    assert countDigitOne(55) == 16 : \"Test case 2 failed\";\n    assert countDigitOne(99) == 20 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "countDigitOne", "signature": "public static int countDigitOne(int n)", "docstring": "Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0\n\n* Incomplete Code:\npublic static int countDigitOne(int n)\n  {\n    int count = 0;\n[MASK]\n[MASK]\n      count +=\n[MASK]\n    }\n    return count;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    int count = 0;\n[MASK]\n[MASK]\n      count +=\n[MASK]\n    }\n    return count;\n  }"}
{"task_id": "Java/38-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, determine if it is a power of two.\n   * If it is, return true; otherwise, return false.\n   * A number n is a power of two if there exists an integer x such that n == 2^x.\n   *\n   * @param n The integer to be checked.\n   * @return True if n is a power of two, false otherwise.\n   *\n   * Example:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Example:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ", "canonical_solution": "  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert isPowerOfTwo(1024) == true; // 1024 is 2^10\n    assert isPowerOfTwo(65536) == true; // 65536 is 2^16\n    assert isPowerOfTwo(14) == false; // 14 is not a power of two\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isPowerOfTwo", "signature": "public static boolean isPowerOfTwo(int n)", "docstring": "Given an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false\n\n* Incomplete Code:\npublic static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n[MASK]\n    }\n[MASK]\n[MASK]\n    }\n    return n == 1;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (n <= 0) {\n[MASK]\n    }\n[MASK]\n[MASK]\n    }\n    return n == 1;\n  }"}
{"task_id": "Java/38-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, determine if it is a power of two.\n   * If it is, return true; otherwise, return false.\n   * A number n is a power of two if there exists an integer x such that n == 2^x.\n   *\n   * @param n The integer to be checked.\n   * @return True if n is a power of two, false otherwise.\n   *\n   * Example:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Example:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ", "canonical_solution": "  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert isPowerOfTwo(1024) == true; // 1024 is 2^10\n    assert isPowerOfTwo(65536) == true; // 65536 is 2^16\n    assert isPowerOfTwo(14) == false; // 14 is not a power of two\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isPowerOfTwo", "signature": "public static boolean isPowerOfTwo(int n)", "docstring": "Given an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false\n\n* Incomplete Code:\npublic static boolean isPowerOfTwo(int n)\n  {\n[MASK]\n      return false;\n    }\n[MASK]\n      n /= 2;\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n      return false;\n    }\n[MASK]\n      n /= 2;\n    }\n[MASK]\n  }"}
{"task_id": "Java/39-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n   *\n   * @param num The non-negative integer to perform the operation on.\n   * @return The single digit result after repeatedly adding all digits.\n   *\n   * Example:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ", "canonical_solution": "  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }", "test": "  public static void main(String[] args) {\n    assert addDigits(123) == 6 : \"Test case 1 failed\";\n    assert addDigits(59) == 5 : \"Test case 2 failed\";\n    assert addDigits(0) == 0 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "addDigits", "signature": "public static int addDigits(int num)", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2\n\n* Incomplete Code:\npublic static int addDigits(int num)\n  {\n[MASK]\n[MASK]\n    }\n[MASK]\n  }\n\n[MASK]\n    int sum = 0;\n    while (num > 0) {\n[MASK]\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n[MASK]\n    }\n[MASK]\n  }\n\n[MASK]\n    int sum = 0;\n    while (num > 0) {\n[MASK]\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }"}
{"task_id": "Java/39-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n   *\n   * @param num The non-negative integer to perform the operation on.\n   * @return The single digit result after repeatedly adding all digits.\n   *\n   * Example:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ", "canonical_solution": "  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }", "test": "  public static void main(String[] args) {\n    assert addDigits(123) == 6 : \"Test case 1 failed\";\n    assert addDigits(59) == 5 : \"Test case 2 failed\";\n    assert addDigits(0) == 0 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "addDigits", "signature": "public static int addDigits(int num)", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2\n\n* Incomplete Code:\npublic static int addDigits(int num)\n  {\n    while (num >= 10) {\n[MASK]\n    }\n[MASK]\n  }\n\n[MASK]\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    while (num >= 10) {\n[MASK]\n    }\n[MASK]\n  }\n\n[MASK]\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }"}
{"task_id": "Java/40-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n   * The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   *\n   * @param mat The binary matrix.\n   * @return The length of the longest continuous line of 1s.\n   *\n   * Example:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ", "canonical_solution": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }", "test": "  public static void main(String[] args) {\n    assert longestLine(\n      new int[][] {\n        { 1, 1, 0, 0 },\n        { 0, 1, 1, 0 },\n        { 0, 0, 0, 1 },\n        { 1, 0, 0, 0 },\n      }\n    ) ==\n    3;\n    assert longestLine(\n      new int[][] {\n        { 1, 0, 0, 1 },\n        { 0, 1, 1, 0 },\n        { 1, 1, 0, 0 },\n        { 1, 0, 1, 1 },\n      }\n    ) ==\n    4;\n    assert longestLine(new int[][] { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } }) ==\n    1;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "longestLine", "signature": "public static int longestLine(int[][] mat)", "docstring": "Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3\n\n* Incomplete Code:\npublic static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n[MASK]\n    }\n\n[MASK]\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n[MASK]\n[MASK]\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n[MASK]\n    }\n\n[MASK]\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n[MASK]\n[MASK]\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }"}
{"task_id": "Java/40-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n   * The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   *\n   * @param mat The binary matrix.\n   * @return The length of the longest continuous line of 1s.\n   *\n   * Example:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ", "canonical_solution": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }", "test": "  public static void main(String[] args) {\n    assert longestLine(\n      new int[][] {\n        { 1, 1, 0, 0 },\n        { 0, 1, 1, 0 },\n        { 0, 0, 0, 1 },\n        { 1, 0, 0, 0 },\n      }\n    ) ==\n    3;\n    assert longestLine(\n      new int[][] {\n        { 1, 0, 0, 1 },\n        { 0, 1, 1, 0 },\n        { 1, 1, 0, 0 },\n        { 1, 0, 1, 1 },\n      }\n    ) ==\n    4;\n    assert longestLine(new int[][] { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } }) ==\n    1;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "longestLine", "signature": "public static int longestLine(int[][] mat)", "docstring": "Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3\n\n* Incomplete Code:\npublic static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n[MASK]\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n[MASK]\n[MASK]\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n[MASK]\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n[MASK]\n[MASK]\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }"}
{"task_id": "Java/41-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   *\n   * @param n The integer to add thousand separators to.\n   * @return The string with thousand separators added.\n   *\n   * Example:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Example:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Example:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Example:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ", "canonical_solution": "  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }", "test": "  public static void main(String[] args) {\n    assert \"2.147.483.647\".equals(\n        addThousandSeparator(2147483647)\n      ) : \"Test case 1 failed\";\n    assert \"10.000\".equals(addThousandSeparator(10000)) : \"Test case 2 failed\";\n    assert \"999\".equals(addThousandSeparator(999)) : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "addThousandSeparator", "signature": "public static String addThousandSeparator(int n)", "docstring": "Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"\n\n* Incomplete Code:\npublic static String addThousandSeparator(int n)\n  {\n[MASK]\n    String numberString = Integer.toString(n);\n[MASK]\n    int counter = 0;\n\n[MASK]\n[MASK]\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n[MASK]\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    String numberString = Integer.toString(n);\n[MASK]\n    int counter = 0;\n\n[MASK]\n[MASK]\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n[MASK]\n      }\n    }\n\n    return result.reverse().toString();\n  }"}
{"task_id": "Java/41-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   *\n   * @param n The integer to add thousand separators to.\n   * @return The string with thousand separators added.\n   *\n   * Example:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Example:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Example:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Example:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ", "canonical_solution": "  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }", "test": "  public static void main(String[] args) {\n    assert \"2.147.483.647\".equals(\n        addThousandSeparator(2147483647)\n      ) : \"Test case 1 failed\";\n    assert \"10.000\".equals(addThousandSeparator(10000)) : \"Test case 2 failed\";\n    assert \"999\".equals(addThousandSeparator(999)) : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "addThousandSeparator", "signature": "public static String addThousandSeparator(int n)", "docstring": "Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"\n\n* Incomplete Code:\npublic static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n[MASK]\n[MASK]\n[MASK]\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n[MASK]\n      if (counter == 3 && i != 0) {\n[MASK]\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    StringBuilder result = new StringBuilder();\n[MASK]\n[MASK]\n[MASK]\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n[MASK]\n      if (counter == 3 && i != 0) {\n[MASK]\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }"}
{"task_id": "Java/42-0-multi", "prompt": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n   * Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   *\n   * @param A The input non-negative integer array.\n   * @return The number of square permutations of A.\n   *\n   * Example:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Example:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ", "canonical_solution": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }", "test": "  public static void main(String[] args) {\n    assert squarePermutations(new int[] { 1, 8, 27 }) == 0;\n    assert squarePermutations(new int[] { 1, 8, 17 }) == 2;\n    assert squarePermutations(new int[] { 4, 1, 3, 0, 2 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "squarePermutations", "signature": "public static int squarePermutations(int[] A)", "docstring": "Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1\n\n* Incomplete Code:\npublic static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n[MASK]\n[MASK]\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n[MASK]\n[MASK]\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n[MASK]\n    }\n    return sb.toString();\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n[MASK]\n[MASK]\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n[MASK]\n[MASK]\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n[MASK]\n    }\n    return sb.toString();\n  }"}
{"task_id": "Java/42-1-multi", "prompt": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n   * Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   *\n   * @param A The input non-negative integer array.\n   * @return The number of square permutations of A.\n   *\n   * Example:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Example:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ", "canonical_solution": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }", "test": "  public static void main(String[] args) {\n    assert squarePermutations(new int[] { 1, 8, 27 }) == 0;\n    assert squarePermutations(new int[] { 1, 8, 17 }) == 2;\n    assert squarePermutations(new int[] { 4, 1, 3, 0, 2 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "squarePermutations", "signature": "public static int squarePermutations(int[] A)", "docstring": "Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1\n\n* Incomplete Code:\npublic static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n[MASK]\n    arr[i] = arr[j];\n[MASK]\n  }\n\n  private static String arrayToString(int[] arr) {\n[MASK]\n    for (int num : arr) {\n[MASK]\n    }\n    return sb.toString();\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n[MASK]\n    arr[i] = arr[j];\n[MASK]\n  }\n\n  private static String arrayToString(int[] arr) {\n[MASK]\n    for (int num : arr) {\n[MASK]\n    }\n    return sb.toString();\n  }"}
{"task_id": "Java/43-0-multi", "prompt": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Given n non-negative integers representing the heights of bars in a bar chart.\n   * Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   *\n   * @param heights An array of integers representing the heights of bars.\n   * @return The maximum area of the rectangle that can be formed.\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ", "canonical_solution": "  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }", "test": "  public static void main(String[] args) {\n    assert largestRectangleArea(new int[] { 1, 2, 3, 4, 5, 3, 3, 2 }) == 15;\n    assert largestRectangleArea(new int[] { 6, 2, 5, 4, 5, 1, 6 }) == 12;\n    assert largestRectangleArea(new int[] { 2, 1, 2, 3, 1 }) == 5;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "largestRectangleArea", "signature": "public static int largestRectangleArea(int[] heights)", "docstring": "Given n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4\n\n* Incomplete Code:\npublic static int largestRectangleArea(int[] heights)\n  {\n[MASK]\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n[MASK]\n[MASK]\n        stack.push(i);\n        i++;\n[MASK]\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n[MASK]\n      }\n    }\n    return maxArea;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n[MASK]\n[MASK]\n        stack.push(i);\n        i++;\n[MASK]\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n[MASK]\n      }\n    }\n    return maxArea;\n  }"}
{"task_id": "Java/43-1-multi", "prompt": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Given n non-negative integers representing the heights of bars in a bar chart.\n   * Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   *\n   * @param heights An array of integers representing the heights of bars.\n   * @return The maximum area of the rectangle that can be formed.\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ", "canonical_solution": "  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }", "test": "  public static void main(String[] args) {\n    assert largestRectangleArea(new int[] { 1, 2, 3, 4, 5, 3, 3, 2 }) == 15;\n    assert largestRectangleArea(new int[] { 6, 2, 5, 4, 5, 1, 6 }) == 12;\n    assert largestRectangleArea(new int[] { 2, 1, 2, 3, 1 }) == 5;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "largestRectangleArea", "signature": "public static int largestRectangleArea(int[] heights)", "docstring": "Given n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4\n\n* Incomplete Code:\npublic static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n[MASK]\n[MASK]\n    while (i <= heights.length) {\n[MASK]\n[MASK]\n        stack.push(i);\n[MASK]\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    int maxArea = 0;\n[MASK]\n[MASK]\n    while (i <= heights.length) {\n[MASK]\n[MASK]\n        stack.push(i);\n[MASK]\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }"}
{"task_id": "Java/44-0-multi", "prompt": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Return all elements in the matrix in diagonal order.\n   *\n   * @param mat The input matrix.\n   * @return An array containing all elements in diagonal order.\n   *\n   * Example:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ", "canonical_solution": "  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }", "test": "  public static void main(String[] args) {\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1, 2 }, { 3, 4 } }),\n      new int[] { 1, 2, 3, 4 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(\n        new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }\n      ),\n      new int[] { 1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1 }, { 2 }, { 3 } }),\n      new int[] { 1, 2, 3 }\n    );\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "diagonalOrder", "signature": "public static int[] diagonalOrder(int[][] mat)", "docstring": "Return all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReturn all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]\n\n* Incomplete Code:\npublic static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n[MASK]\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n[MASK]\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n[MASK]\n        } else {\n[MASK]\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n[MASK]\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n[MASK]\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n[MASK]\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n[MASK]\n        } else {\n[MASK]\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n[MASK]\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }"}
{"task_id": "Java/44-1-multi", "prompt": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Return all elements in the matrix in diagonal order.\n   *\n   * @param mat The input matrix.\n   * @return An array containing all elements in diagonal order.\n   *\n   * Example:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ", "canonical_solution": "  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }", "test": "  public static void main(String[] args) {\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1, 2 }, { 3, 4 } }),\n      new int[] { 1, 2, 3, 4 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(\n        new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }\n      ),\n      new int[] { 1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1 }, { 2 }, { 3 } }),\n      new int[] { 1, 2, 3 }\n    );\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "diagonalOrder", "signature": "public static int[] diagonalOrder(int[][] mat)", "docstring": "Return all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReturn all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]\n\n* Incomplete Code:\npublic static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n[MASK]\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n[MASK]\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n[MASK]\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (mat == null || mat.length == 0) {\n[MASK]\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n[MASK]\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n[MASK]\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n[MASK]\n  }"}
{"task_id": "Java/45-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n   *\n   * @param n The input positive integer.\n   * @return The smallest rearranged integer greater than n, or -1 if not possible.\n   *\n   * Example:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ", "canonical_solution": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n", "test": "  public static void main(String[] args) {\n    assert findSmallestInteger(123) == 132;\n    assert findSmallestInteger(531) == -1;\n    assert findSmallestInteger(2071) == 2107;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "findSmallestInteger", "signature": "public static int findSmallestInteger(int n)", "docstring": "Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nFind the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21\n\n* Incomplete Code:\npublic static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n[MASK]\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n[MASK]\n    }\n\n    // Swap the digits at indices i and j\n[MASK]\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n[MASK]\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n[MASK]\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n[MASK]\n    }\n\n    // Swap the digits at indices i and j\n[MASK]\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n[MASK]\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n"}
{"task_id": "Java/45-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n   *\n   * @param n The input positive integer.\n   * @return The smallest rearranged integer greater than n, or -1 if not possible.\n   *\n   * Example:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ", "canonical_solution": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n", "test": "  public static void main(String[] args) {\n    assert findSmallestInteger(123) == 132;\n    assert findSmallestInteger(531) == -1;\n    assert findSmallestInteger(2071) == 2107;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "findSmallestInteger", "signature": "public static int findSmallestInteger(int n)", "docstring": "Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nFind the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21\n\n* Incomplete Code:\npublic static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n[MASK]\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n[MASK]\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n[MASK]\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n[MASK]\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n[MASK]\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n[MASK]\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n[MASK]\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n[MASK]\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n"}
{"task_id": "Java/46-0-multi", "prompt": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Given an integer n, return all the center symmetric numbers of length n.\n   *\n   * @param n The length of the center symmetric numbers.\n   * @return A list of center symmetric numbers.\n   *\n   * Example:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ", "canonical_solution": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }", "test": "  private static void assertArrays(String[] expected, List<String> actual) {\n    if (actual == null || actual.size() != expected.length) {\n      throw new AssertionError(\"Test case failed\");\n    }\n    for (String str : expected) {\n      if (!actual.contains(str)) {\n        throw new AssertionError(\"Test case failed\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    assertArrays(\n      new String[] { \"11\", \"69\", \"88\", \"96\" },\n      centerSymmetricNumbers(2)\n    );\n    assertArrays(new String[] { \"0\", \"1\", \"8\" }, centerSymmetricNumbers(1));\n    assertArrays(\n      new String[] {\n        \"101\",\n        \"111\",\n        \"181\",\n        \"609\",\n        \"619\",\n        \"689\",\n        \"808\",\n        \"818\",\n        \"888\",\n        \"906\",\n        \"916\",\n        \"986\",\n      },\n      centerSymmetricNumbers(3)\n    );\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "centerSymmetricNumbers", "signature": "public static List<String> centerSymmetricNumbers(int n)", "docstring": "Given an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]\n\n* Incomplete Code:\npublic static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n[MASK]\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n[MASK]\n    }\n\n    return resultList;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n[MASK]\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n[MASK]\n    }\n\n    return resultList;\n  }"}
{"task_id": "Java/46-1-multi", "prompt": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Given an integer n, return all the center symmetric numbers of length n.\n   *\n   * @param n The length of the center symmetric numbers.\n   * @return A list of center symmetric numbers.\n   *\n   * Example:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ", "canonical_solution": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }", "test": "  private static void assertArrays(String[] expected, List<String> actual) {\n    if (actual == null || actual.size() != expected.length) {\n      throw new AssertionError(\"Test case failed\");\n    }\n    for (String str : expected) {\n      if (!actual.contains(str)) {\n        throw new AssertionError(\"Test case failed\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    assertArrays(\n      new String[] { \"11\", \"69\", \"88\", \"96\" },\n      centerSymmetricNumbers(2)\n    );\n    assertArrays(new String[] { \"0\", \"1\", \"8\" }, centerSymmetricNumbers(1));\n    assertArrays(\n      new String[] {\n        \"101\",\n        \"111\",\n        \"181\",\n        \"609\",\n        \"619\",\n        \"689\",\n        \"808\",\n        \"818\",\n        \"888\",\n        \"906\",\n        \"916\",\n        \"986\",\n      },\n      centerSymmetricNumbers(3)\n    );\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "centerSymmetricNumbers", "signature": "public static List<String> centerSymmetricNumbers(int n)", "docstring": "Given an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]\n\n* Incomplete Code:\npublic static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n[MASK]\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n[MASK]\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n[MASK]\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n[MASK]\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n[MASK]\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n[MASK]\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }"}
{"task_id": "Java/47-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Determine if the given points form a boomerang on the X-Y plane.\n   *\n   * @param points An array of points where points[i] = [xi, yi].\n   * @return True if the points form a boomerang, false otherwise.\n   *\n   * Example:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ", "canonical_solution": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }", "test": "  public static void main(String[] args) {\n    assert isBoomerang(new int[][] { { 0, 0 }, { 2, 2 }, { 1, 1 } }) ==\n    false : \"Test case 1 failed\";\n    assert isBoomerang(new int[][] { { 1, 1 }, { 2, 4 }, { 3, 1 } }) ==\n    true : \"Test case 2 failed\";\n    assert isBoomerang(new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 } }) ==\n    true : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isBoomerang", "signature": "public static boolean isBoomerang(int[][] points)", "docstring": "Determine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nDetermine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true\n\n* Incomplete Code:\npublic static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n[MASK]\n[MASK]\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n[MASK]\n\n    // The points form a boomerang if the slopes are not equal.\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n[MASK]\n[MASK]\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n[MASK]\n\n    // The points form a boomerang if the slopes are not equal.\n[MASK]\n  }"}
{"task_id": "Java/47-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Determine if the given points form a boomerang on the X-Y plane.\n   *\n   * @param points An array of points where points[i] = [xi, yi].\n   * @return True if the points form a boomerang, false otherwise.\n   *\n   * Example:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ", "canonical_solution": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }", "test": "  public static void main(String[] args) {\n    assert isBoomerang(new int[][] { { 0, 0 }, { 2, 2 }, { 1, 1 } }) ==\n    false : \"Test case 1 failed\";\n    assert isBoomerang(new int[][] { { 1, 1 }, { 2, 4 }, { 3, 1 } }) ==\n    true : \"Test case 2 failed\";\n    assert isBoomerang(new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 } }) ==\n    true : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isBoomerang", "signature": "public static boolean isBoomerang(int[][] points)", "docstring": "Determine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nDetermine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true\n\n* Incomplete Code:\npublic static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n[MASK]\n    int x2 = points[1][0], y2 = points[1][1];\n[MASK]\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n[MASK]\n[MASK]\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n[MASK]\n    int x2 = points[1][0], y2 = points[1][1];\n[MASK]\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n[MASK]\n[MASK]\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }"}
{"task_id": "Java/48-0-multi", "prompt": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Find and return the nth ugly number.\n   *\n   * @param n The index of the ugly number to find.\n   * @return The nth ugly number.\n   *\n   * Example:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ", "canonical_solution": "  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n", "test": "  public static void main(String[] args) {\n    assert findNthUglyNumber(1) == 1 : \"Test case 1 failed\";\n    assert findNthUglyNumber(7) == 8 : \"Test case 2 failed\";\n    assert findNthUglyNumber(15) == 24 : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "findNthUglyNumber", "signature": "public static int findNthUglyNumber(int n)", "docstring": "Find and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nFind and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12\n\n* Incomplete Code:\npublic static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n[MASK]\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n[MASK]\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n[MASK]\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n[MASK]\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n[MASK]\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n[MASK]\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n"}
{"task_id": "Java/48-1-multi", "prompt": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Find and return the nth ugly number.\n   *\n   * @param n The index of the ugly number to find.\n   * @return The nth ugly number.\n   *\n   * Example:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ", "canonical_solution": "  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n", "test": "  public static void main(String[] args) {\n    assert findNthUglyNumber(1) == 1 : \"Test case 1 failed\";\n    assert findNthUglyNumber(7) == 8 : \"Test case 2 failed\";\n    assert findNthUglyNumber(15) == 24 : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "findNthUglyNumber", "signature": "public static int findNthUglyNumber(int n)", "docstring": "Find and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nFind and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12\n\n* Incomplete Code:\npublic static int findNthUglyNumber(int n)\n  {\n[MASK]\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n[MASK]\n\n[MASK]\n[MASK]\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n[MASK]\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n[MASK]\n\n[MASK]\n[MASK]\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n[MASK]\n  }\n"}
{"task_id": "Java/49-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   *\n   * @param s The input string.\n   * @return The energy of the string.\n   *\n   * Example:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ", "canonical_solution": "  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert calculateEnergy(\"aabbccdd\") == 2 : \"Test case 1 failed\"; // Contains two characters 'aa', 'bb', 'cc', 'dd'\n    assert calculateEnergy(\"horizon\") == 1 : \"Test case 2 failed\"; // All characters are unique\n    assert calculateEnergy(\"success\") == 2 : \"Test case 3 failed\"; // Contains three characters 'ccc'\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "calculateEnergy", "signature": "public static int calculateEnergy(String s)", "docstring": "Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2\n\n* Incomplete Code:\npublic static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n[MASK]\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n[MASK]\n[MASK]\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n[MASK]\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n[MASK]\n[MASK]\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }"}
{"task_id": "Java/49-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   *\n   * @param s The input string.\n   * @return The energy of the string.\n   *\n   * Example:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ", "canonical_solution": "  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert calculateEnergy(\"aabbccdd\") == 2 : \"Test case 1 failed\"; // Contains two characters 'aa', 'bb', 'cc', 'dd'\n    assert calculateEnergy(\"horizon\") == 1 : \"Test case 2 failed\"; // All characters are unique\n    assert calculateEnergy(\"success\") == 2 : \"Test case 3 failed\"; // Contains three characters 'ccc'\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "calculateEnergy", "signature": "public static int calculateEnergy(String s)", "docstring": "Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2\n\n* Incomplete Code:\npublic static int calculateEnergy(String s)\n  {\n[MASK]\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n[MASK]\n        // Increment the energy of the current substring\n        currentEnergy++;\n[MASK]\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n[MASK]\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n[MASK]\n        // Increment the energy of the current substring\n        currentEnergy++;\n[MASK]\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n[MASK]\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }"}
{"task_id": "Java/50-0-multi", "prompt": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Return all integers in the range [1, n] in lexicographical order.\n   *\n   * @param n The upper limit of the range.\n   * @return List of integers in lexicographical order.\n   *\n   * Example:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ", "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert lexicalOrder(13)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(2);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 1 failed\";\n\n    assert lexicalOrder(20)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(14);\n            add(15);\n            add(16);\n            add(17);\n            add(18);\n            add(19);\n            add(2);\n            add(20);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 2 failed\";\n\n    assert lexicalOrder(2)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(2);\n          }\n        }\n      ) : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "lexicalOrder", "signature": "public static List<Integer> lexicalOrder(int n)", "docstring": "Return all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReturn all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n\n* Incomplete Code:\npublic static List<Integer> lexicalOrder(int n)\n  {\n[MASK]\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n[MASK]\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n[MASK]\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n[MASK]\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n[MASK]\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n[MASK]\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n[MASK]\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }"}
{"task_id": "Java/50-1-multi", "prompt": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Return all integers in the range [1, n] in lexicographical order.\n   *\n   * @param n The upper limit of the range.\n   * @return List of integers in lexicographical order.\n   *\n   * Example:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ", "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert lexicalOrder(13)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(2);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 1 failed\";\n\n    assert lexicalOrder(20)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(14);\n            add(15);\n            add(16);\n            add(17);\n            add(18);\n            add(19);\n            add(2);\n            add(20);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 2 failed\";\n\n    assert lexicalOrder(2)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(2);\n          }\n        }\n      ) : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "lexicalOrder", "signature": "public static List<Integer> lexicalOrder(int n)", "docstring": "Return all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReturn all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n\n* Incomplete Code:\npublic static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n[MASK]\n[MASK]\n    }\n[MASK]\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n[MASK]\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n[MASK]\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    List<Integer> result = new ArrayList<>();\n[MASK]\n[MASK]\n    }\n[MASK]\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n[MASK]\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n[MASK]\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }"}
{"task_id": "Java/51-0-multi", "prompt": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculate the sum of unique elements in the given integer array.\n   *\n   * @param nums An array of integers.\n   * @return The sum of unique elements.\n   *\n   * Example:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ", "canonical_solution": "  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }", "test": "  public static void main(String[] args) {\n    assert calculateUniqueSum(new int[] { 1, 4, 5, 1, 2, 4 }) == 7; // Test Case 1\n    assert calculateUniqueSum(new int[] { 0, 0, 0, 0 }) == 0; // Test Case 2\n    assert calculateUniqueSum(new int[] { -1, -2, -3, -2 }) == -4; // Test Case 3\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "calculateUniqueSum", "signature": "public static int calculateUniqueSum(int[] nums)", "docstring": "Calculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4\n\n* Incomplete Code:\npublic static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n[MASK]\n[MASK]\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n[MASK]\n[MASK]\n      }\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n[MASK]\n[MASK]\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n[MASK]\n[MASK]\n      }\n    }\n\n[MASK]\n  }"}
{"task_id": "Java/51-1-multi", "prompt": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculate the sum of unique elements in the given integer array.\n   *\n   * @param nums An array of integers.\n   * @return The sum of unique elements.\n   *\n   * Example:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ", "canonical_solution": "  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }", "test": "  public static void main(String[] args) {\n    assert calculateUniqueSum(new int[] { 1, 4, 5, 1, 2, 4 }) == 7; // Test Case 1\n    assert calculateUniqueSum(new int[] { 0, 0, 0, 0 }) == 0; // Test Case 2\n    assert calculateUniqueSum(new int[] { -1, -2, -3, -2 }) == -4; // Test Case 3\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "calculateUniqueSum", "signature": "public static int calculateUniqueSum(int[] nums)", "docstring": "Calculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4\n\n* Incomplete Code:\npublic static int calculateUniqueSum(int[] nums)\n  {\n[MASK]\n    for (int num : nums) {\n[MASK]\n    }\n\n[MASK]\n[MASK]\n[MASK]\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (int num : nums) {\n[MASK]\n    }\n\n[MASK]\n[MASK]\n[MASK]\n        sum += key;\n      }\n    }\n\n    return sum;\n  }"}
{"task_id": "Java/52-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ", "canonical_solution": "  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }", "test": "  public static void main(String[] args) {\n    assert minPerfectSquareSum(26) == 2 : \"Test case 1 failed\";\n    assert minPerfectSquareSum(17) == 2 : \"Test case 2 failed\";\n    assert minPerfectSquareSum(99) == 3 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "public static int minPerfectSquareSum(int n)", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2\n\n* Incomplete Code:\npublic static int minPerfectSquareSum(int n)\n  {\n[MASK]\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n[MASK]\n  }"}
{"task_id": "Java/52-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ", "canonical_solution": "  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }", "test": "  public static void main(String[] args) {\n    assert minPerfectSquareSum(26) == 2 : \"Test case 1 failed\";\n    assert minPerfectSquareSum(17) == 2 : \"Test case 2 failed\";\n    assert minPerfectSquareSum(99) == 3 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "public static int minPerfectSquareSum(int n)", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2\n\n* Incomplete Code:\npublic static int minPerfectSquareSum(int n)\n  {\n[MASK]\n    for (int i = 1; i <= n; i++) {\n[MASK]\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (int i = 1; i <= n; i++) {\n[MASK]\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n[MASK]\n  }"}
{"task_id": "Java/53-0-multi", "prompt": "public class Solution {\n\n  /**\n   * Reverse the characters of each word in the given string while maintaining the original word order.\n   *\n   * @param s The input string containing words separated by spaces.\n   * @return The string with characters of each word reversed.\n   *\n   * Example:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ", "canonical_solution": "  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }", "test": "  public static void main(String[] args) {\n    testReverseWords(\"The quick brown fox\", \"ehT kciuq nworb xof\");\n    testReverseWords(\"Hello World\", \"olleH dlroW\");\n    testReverseWords(\"a b c d e f\", \"a b c d e f\");\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "reverseWords", "signature": "public static String reverseWords(String s)", "docstring": "Reverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"\n\n* Incomplete Code:\npublic static String reverseWords(String s)\n  {\n[MASK]\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n[MASK]\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n[MASK]\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n[MASK]\n  }"}
{"task_id": "Java/53-1-multi", "prompt": "public class Solution {\n\n  /**\n   * Reverse the characters of each word in the given string while maintaining the original word order.\n   *\n   * @param s The input string containing words separated by spaces.\n   * @return The string with characters of each word reversed.\n   *\n   * Example:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ", "canonical_solution": "  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }", "test": "  public static void main(String[] args) {\n    testReverseWords(\"The quick brown fox\", \"ehT kciuq nworb xof\");\n    testReverseWords(\"Hello World\", \"olleH dlroW\");\n    testReverseWords(\"a b c d e f\", \"a b c d e f\");\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "reverseWords", "signature": "public static String reverseWords(String s)", "docstring": "Reverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"", "instruction": "Below is a explanation of Java code and incomplete code implementation.\n\n* Docstring: \nReverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"\n\n* Incomplete Code:\npublic static String reverseWords(String s)\n  {\n[MASK]\n[MASK]\n    for (String word : words) {\n[MASK]\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n[MASK]\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n[MASK]\n    for (String word : words) {\n[MASK]\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n[MASK]\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }"}
