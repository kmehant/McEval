{"task_id": "Common Lisp/1-0-multi", "prompt": "(defun has-close-elements (numbers threshold)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t", "canonical_solution": "(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "test": "(defun check-has-close-elements ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)", "entry_point": "has-close-elements", "signature": "(defun has-close-elements (numbers threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'\n\n* Incomplete Code:\n(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\n[MASK]\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(loop for i from 0 below (length numbers)\n[MASK]\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/1-1-multi", "prompt": "(defun has-close-elements (numbers threshold)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t", "canonical_solution": "(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "test": "(defun check-has-close-elements ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)", "entry_point": "has-close-elements", "signature": "(defun has-close-elements (numbers threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'\n\n* Incomplete Code:\n(defun has-close-elements (numbers threshold)\n[MASK]\ndo (loop for j from 0 below (length numbers)\n[MASK]\n[MASK]\n(return-from has-close-elements t))))\nnil)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\ndo (loop for j from 0 below (length numbers)\n[MASK]\n[MASK]\n(return-from has-close-elements t))))\nnil)"}
{"task_id": "Common Lisp/2-0-multi", "prompt": "(defun bin-search (obj vec)\n;; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.\n;; Example:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t", "canonical_solution": "(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "test": "(defun check-bin-search ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check-bin-search)", "entry_point": "bin-search", "signature": "(defun bin-search (obj vec)", "docstring": "Binary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nBinary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt\n\n* Incomplete Code:\n(defun bin-search (obj vec)\n[MASK]\n(high (1- (length vec))))\n(loop while (<= low high)\n[MASK]\n[MASK]\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n(high (1- (length vec))))\n(loop while (<= low high)\n[MASK]\n[MASK]\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))"}
{"task_id": "Common Lisp/2-1-multi", "prompt": "(defun bin-search (obj vec)\n;; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.\n;; Example:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t", "canonical_solution": "(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "test": "(defun check-bin-search ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check-bin-search)", "entry_point": "bin-search", "signature": "(defun bin-search (obj vec)", "docstring": "Binary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nBinary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt\n\n* Incomplete Code:\n(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n[MASK]\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\n[MASK]\n[MASK]\n((> obj mid-val) (setf low (1+ mid)))))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let ((low 0)\n(high (1- (length vec))))\n[MASK]\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\n[MASK]\n[MASK]\n((> obj mid-val) (setf low (1+ mid)))))\n[MASK]"}
{"task_id": "Common Lisp/3-0-multi", "prompt": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n;; Example:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980", "canonical_solution": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "test": "(defun check-parse-date ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check-parse-date)", "entry_point": "parse-date", "signature": "(defun parse-date (date-str)", "docstring": "\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980\n\n* Incomplete Code:\n(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n[MASK]\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n[MASK]\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n[MASK]\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n[MASK]\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n[MASK]\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n[MASK]\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))"}
{"task_id": "Common Lisp/3-1-multi", "prompt": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n;; Example:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980", "canonical_solution": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "test": "(defun check-parse-date ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check-parse-date)", "entry_point": "parse-date", "signature": "(defun parse-date (date-str)", "docstring": "\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980\n\n* Incomplete Code:\n(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n[MASK]\n(not (funcall test c)))\n[MASK]\n(cons (subseq str p1 p2)\n[MASK]\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n[MASK]\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n[MASK]\n(error \"Invalid month string: ~A\" str))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n[MASK]\n(not (funcall test c)))\n[MASK]\n(cons (subseq str p1 p2)\n[MASK]\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n[MASK]\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n[MASK]\n(error \"Invalid month string: ~A\" str))))"}
{"task_id": "Common Lisp/6-0-multi", "prompt": "(defun ordered-union (list1 list2)\n;; Write a version of union that preserves the order of the elements in the original lists:\n;; Example:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6", "canonical_solution": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))", "test": "(defun check-ordered-union ()\n(assert (equal (ordered-union '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))\n(assert (equal (ordered-union '(1 2 3) '(3 4 5)) '(1 2 3 4 5)))\n(assert (equal (ordered-union '(a b c) '(b c d)) '(a b c d)))\n(assert (equal (ordered-union '() '(1 2 3)) '(1 2 3)))\n(assert (equal (ordered-union '(1 2 3) '()) '(1 2 3))))\n\n(check-ordered-union)", "entry_point": "ordered-union", "signature": "(defun ordered-union (list1 list2)", "docstring": "Write a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nWrite a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6\n\n* Incomplete Code:\n(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n[MASK]\n[MASK]\n(nreverse result)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n[MASK]\n[MASK]\n(nreverse result)))"}
{"task_id": "Common Lisp/6-1-multi", "prompt": "(defun ordered-union (list1 list2)\n;; Write a version of union that preserves the order of the elements in the original lists:\n;; Example:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6", "canonical_solution": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))", "test": "(defun check-ordered-union ()\n(assert (equal (ordered-union '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))\n(assert (equal (ordered-union '(1 2 3) '(3 4 5)) '(1 2 3 4 5)))\n(assert (equal (ordered-union '(a b c) '(b c d)) '(a b c d)))\n(assert (equal (ordered-union '() '(1 2 3)) '(1 2 3)))\n(assert (equal (ordered-union '(1 2 3) '()) '(1 2 3))))\n\n(check-ordered-union)", "entry_point": "ordered-union", "signature": "(defun ordered-union (list1 list2)", "docstring": "Write a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nWrite a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6\n\n* Incomplete Code:\n(defun ordered-union (list1 list2)\n[MASK]\n[MASK]\n[MASK]\ndo (push item result))\n[MASK]\ndo (push item result))\n(nreverse result)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n[MASK]\ndo (push item result))\n[MASK]\ndo (push item result))\n(nreverse result)))"}
{"task_id": "Common Lisp/7-0-multi", "prompt": "(defun occurrences (lst)\n;; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\n;; Example:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)", "canonical_solution": "(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "test": "(defun check-occurrences ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check-occurrences)", "entry_point": "occurrences", "signature": "(defun occurrences (lst)", "docstring": "takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \ntakes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)\n\n* Incomplete Code:\n(defun occurrences (lst)\n[MASK]\n(dolist (obj lst)\n(if (null (assoc obj result))\n[MASK]\n[MASK]\n))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(dolist (obj lst)\n(if (null (assoc obj result))\n[MASK]\n[MASK]\n))\n[MASK]"}
{"task_id": "Common Lisp/7-1-multi", "prompt": "(defun occurrences (lst)\n;; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\n;; Example:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)", "canonical_solution": "(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "test": "(defun check-occurrences ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check-occurrences)", "entry_point": "occurrences", "signature": "(defun occurrences (lst)", "docstring": "takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \ntakes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)\n\n* Incomplete Code:\n(defun occurrences (lst)\n[MASK]\n[MASK]\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n[MASK]\n))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n[MASK]\n))\n[MASK]"}
{"task_id": "Common Lisp/10-0-multi", "prompt": "(defun index-of-element (element lst)\n;; Returns the index of the element in the list, or nil if the element is not in the list.\n;; Example:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0", "canonical_solution": "(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))", "test": "(defun check-index-of-element ()\n;; 测试 'index-of-element' 函数。\n(assert (equal (index-of-element 'a '(a b c d e)) 0))\n(assert (equal (index-of-element 'c '(a b c d e)) 2))\n(assert (equal (index-of-element 'e '(a b c d e)) 4))\n(assert (equal (index-of-element 'f '(a b c d e)) nil))\n(assert (equal (index-of-element 3 '(1 2 3 4 5)) 2)))\n\n(check-index-of-element)", "entry_point": "index-of-element", "signature": "(defun index-of-element (element lst)", "docstring": "Returns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nReturns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0\n\n* Incomplete Code:\n(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(loop for item in lst\nfor index from 0\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/10-1-multi", "prompt": "(defun index-of-element (element lst)\n;; Returns the index of the element in the list, or nil if the element is not in the list.\n;; Example:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0", "canonical_solution": "(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))", "test": "(defun check-index-of-element ()\n;; 测试 'index-of-element' 函数。\n(assert (equal (index-of-element 'a '(a b c d e)) 0))\n(assert (equal (index-of-element 'c '(a b c d e)) 2))\n(assert (equal (index-of-element 'e '(a b c d e)) 4))\n(assert (equal (index-of-element 'f '(a b c d e)) nil))\n(assert (equal (index-of-element 3 '(1 2 3 4 5)) 2)))\n\n(check-index-of-element)", "entry_point": "index-of-element", "signature": "(defun index-of-element (element lst)", "docstring": "Returns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nReturns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0\n\n* Incomplete Code:\n(defun index-of-element (element lst)\n[MASK]\nfor index from 0\n[MASK]\ndo (return index)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nfor index from 0\n[MASK]\ndo (return index)))"}
{"task_id": "Common Lisp/14-0-multi", "prompt": "(defun lines-from-file (filename)\n;; Read each line from the file and return them as a string list.", "canonical_solution": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))", "test": "(defun check-lines-from-file ()\n(let ((lines (lines-from-file \"data/Common Lisp/file.txt\")))\n(assert (equal (first lines) \"First line of the file\"))\n(assert (equal (second lines) \"Second line of the file\"))))\n\n(check-lines-from-file)", "entry_point": "lines-from-file", "signature": "(defun lines-from-file (filename)", "docstring": "Read each line from the file and return them as a string list.", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nRead each line from the file and return them as a string list.\n\n* Incomplete Code:\n(defun lines-from-file (filename)\n[MASK]\n(loop for line = (read-line stream nil nil)\nwhile line\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(loop for line = (read-line stream nil nil)\nwhile line\n[MASK]"}
{"task_id": "Common Lisp/14-1-multi", "prompt": "(defun lines-from-file (filename)\n;; Read each line from the file and return them as a string list.", "canonical_solution": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))", "test": "(defun check-lines-from-file ()\n(let ((lines (lines-from-file \"data/Common Lisp/file.txt\")))\n(assert (equal (first lines) \"First line of the file\"))\n(assert (equal (second lines) \"Second line of the file\"))))\n\n(check-lines-from-file)", "entry_point": "lines-from-file", "signature": "(defun lines-from-file (filename)", "docstring": "Read each line from the file and return them as a string list.", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nRead each line from the file and return them as a string list.\n\n* Incomplete Code:\n(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/16-0-multi", "prompt": "(defun make-change (cents)\n;; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\n;; Example:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3", "canonical_solution": "(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "test": "(defun check-make-change ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check-make-change)", "entry_point": "make-change", "signature": "(defun make-change (cents)", "docstring": "Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nDefine a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3\n\n* Incomplete Code:\n(defun make-change (cents)\n[MASK]\n[MASK]\n(let ((dimes (floor remaining-after-quarters 10))\n[MASK]\n(let ((nickels (floor remaining-after-dimes 5))\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n(let ((dimes (floor remaining-after-quarters 10))\n[MASK]\n(let ((nickels (floor remaining-after-dimes 5))\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/16-1-multi", "prompt": "(defun make-change (cents)\n;; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\n;; Example:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3", "canonical_solution": "(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "test": "(defun check-make-change ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check-make-change)", "entry_point": "make-change", "signature": "(defun make-change (cents)", "docstring": "Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nDefine a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3\n\n* Incomplete Code:\n(defun make-change (cents)\n[MASK]\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n[MASK]\n(let ((nickels (floor remaining-after-dimes 5))\n[MASK]\n(values quarters dimes nickels pennies)))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n[MASK]\n(let ((nickels (floor remaining-after-dimes 5))\n[MASK]\n(values quarters dimes nickels pennies)))))"}
{"task_id": "Common Lisp/17-0-multi", "prompt": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\n;; Example:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5", "canonical_solution": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "test": "(defun check-segments-intersect? ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check-segments-intersect?)", "entry_point": "segments-intersect?", "signature": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)", "docstring": "Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nDefine a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5\n\n* Incomplete Code:\n(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n[MASK]\n[MASK]\n[MASK]\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n[MASK]\n[MASK]\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n[MASK]\n[MASK]\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n[MASK]\n[MASK]\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))"}
{"task_id": "Common Lisp/17-1-multi", "prompt": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\n;; Example:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5", "canonical_solution": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "test": "(defun check-segments-intersect? ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check-segments-intersect?)", "entry_point": "segments-intersect?", "signature": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)", "docstring": "Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nDefine a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5\n\n* Incomplete Code:\n(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n[MASK]\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n[MASK]\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n[MASK]\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n[MASK]\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n[MASK]"}
{"task_id": "Common Lisp/18-0-multi", "prompt": "(defun quicksort (list)\n;; Quickly sort the list\n;; Example:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9", "canonical_solution": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "test": "(defun check-quicksort ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check-quicksort)", "entry_point": "quicksort", "signature": "(defun quicksort (list)", "docstring": "Quickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nQuickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9\n\n* Incomplete Code:\n(defun quicksort (list)\n(if (null list)\nnil\n[MASK]\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(if (null list)\nnil\n[MASK]\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n[MASK]"}
{"task_id": "Common Lisp/18-1-multi", "prompt": "(defun quicksort (list)\n;; Quickly sort the list\n;; Example:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9", "canonical_solution": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "test": "(defun check-quicksort ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check-quicksort)", "entry_point": "quicksort", "signature": "(defun quicksort (list)", "docstring": "Quickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nQuickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9\n\n* Incomplete Code:\n(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n[MASK]\n[MASK]\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n[MASK]\n[MASK]\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))"}
{"task_id": "Common Lisp/20-0-multi", "prompt": "(defun move-first-instance-to-front (object queue)\n;; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\n;; Example:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d", "canonical_solution": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "test": "(defun check-move-first-instance-to-front ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check-move-first-instance-to-front)", "entry_point": "move-first-instance-to-front", "signature": "(defun move-first-instance-to-front (object queue)", "docstring": "Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nDefine a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d\n\n* Incomplete Code:\n(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n[MASK]\n(t \n(let ((prev nil)\n[MASK]\n(loop while (and current (not (eql (first current) object)))\n[MASK]\n[MASK]\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(cond ((null queue) nil) \n[MASK]\n(t \n(let ((prev nil)\n[MASK]\n(loop while (and current (not (eql (first current) object)))\n[MASK]\n[MASK]\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \n[MASK]"}
{"task_id": "Common Lisp/20-1-multi", "prompt": "(defun move-first-instance-to-front (object queue)\n;; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\n;; Example:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d", "canonical_solution": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "test": "(defun check-move-first-instance-to-front ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check-move-first-instance-to-front)", "entry_point": "move-first-instance-to-front", "signature": "(defun move-first-instance-to-front (object queue)", "docstring": "Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nDefine a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d\n\n* Incomplete Code:\n(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n[MASK]\n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n[MASK]\n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \n[MASK]"}
{"task_id": "Common Lisp/21-0-multi", "prompt": "(defun find-substring-index (haystack needle)\n;; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.\n;; Example:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Returns 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Returns -1", "canonical_solution": "(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))", "test": "(defun test-find-substring-index ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(test-find-substring-index)", "entry_point": "find-substring-index", "signature": "(defun find-substring-index (haystack needle)", "docstring": "Finds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nFinds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1\n\n* Incomplete Code:\n(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n[MASK]\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n[MASK]\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let ((hay-len (length haystack))\n[MASK]\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n[MASK]\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\n[MASK]"}
{"task_id": "Common Lisp/21-1-multi", "prompt": "(defun find-substring-index (haystack needle)\n;; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.\n;; Example:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Returns 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Returns -1", "canonical_solution": "(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))", "test": "(defun test-find-substring-index ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(test-find-substring-index)", "entry_point": "find-substring-index", "signature": "(defun find-substring-index (haystack needle)", "docstring": "Finds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nFinds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1\n\n* Incomplete Code:\n(defun find-substring-index (haystack needle)\n[MASK]\n[MASK]\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))"}
{"task_id": "Common Lisp/22-0-multi", "prompt": "(defun min-n-for-sum-greater-than-k (k)\n;; Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; is greater than a given integer k.\n;; The function returns the smallest such n.\n;; Example:\n;; (min-n-for-sum-greater-than-k 2) ;; Returns 4\n;; (min-n-for-sum-greater-than-k 3) ;; Returns 11", "canonical_solution": "(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))", "test": "(defun test-min-n-for-sum-greater-than-k ()\n(assert (equal (min-n-for-sum-greater-than-k 1) 2))\n(assert (equal (min-n-for-sum-greater-than-k 2) 4))\n(assert (equal (min-n-for-sum-greater-than-k 3) 11))\n(assert (equal (min-n-for-sum-greater-than-k 4) 31))\n(assert (equal (min-n-for-sum-greater-than-k 5) 83))\n(assert (equal (min-n-for-sum-greater-than-k 0) 1)))\n\n(test-min-n-for-sum-greater-than-k)", "entry_point": "min-n-for-sum-greater-than-k", "signature": "(defun min-n-for-sum-greater-than-k (k)", "docstring": "Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCalculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11\n\n* Incomplete Code:\n(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n[MASK]\n[MASK]\n[MASK]\n(when (> sum k)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let ((sum 0.0) (n 0))\n[MASK]\n[MASK]\n[MASK]\n(when (> sum k)\n[MASK]"}
{"task_id": "Common Lisp/22-1-multi", "prompt": "(defun min-n-for-sum-greater-than-k (k)\n;; Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; is greater than a given integer k.\n;; The function returns the smallest such n.\n;; Example:\n;; (min-n-for-sum-greater-than-k 2) ;; Returns 4\n;; (min-n-for-sum-greater-than-k 3) ;; Returns 11", "canonical_solution": "(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))", "test": "(defun test-min-n-for-sum-greater-than-k ()\n(assert (equal (min-n-for-sum-greater-than-k 1) 2))\n(assert (equal (min-n-for-sum-greater-than-k 2) 4))\n(assert (equal (min-n-for-sum-greater-than-k 3) 11))\n(assert (equal (min-n-for-sum-greater-than-k 4) 31))\n(assert (equal (min-n-for-sum-greater-than-k 5) 83))\n(assert (equal (min-n-for-sum-greater-than-k 0) 1)))\n\n(test-min-n-for-sum-greater-than-k)", "entry_point": "min-n-for-sum-greater-than-k", "signature": "(defun min-n-for-sum-greater-than-k (k)", "docstring": "Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCalculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11\n\n* Incomplete Code:\n(defun min-n-for-sum-greater-than-k (k)\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n(when (> sum k)\n(return n)))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n[MASK]\n[MASK]\n(when (> sum k)\n(return n)))))"}
{"task_id": "Common Lisp/24-0-multi", "prompt": "(defun count-remaining-trees (road-length regions)\n;; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.\n;; Example:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Returns 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Returns 7", "canonical_solution": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "test": "(defun test-count-remaining-trees ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(test-count-remaining-trees)", "entry_point": "count-remaining-trees", "signature": "(defun count-remaining-trees (road-length regions)", "docstring": "Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCounts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7\n\n* Incomplete Code:\n(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n[MASK]\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n[MASK]\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n[MASK]"}
{"task_id": "Common Lisp/24-1-multi", "prompt": "(defun count-remaining-trees (road-length regions)\n;; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.\n;; Example:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Returns 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Returns 7", "canonical_solution": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "test": "(defun test-count-remaining-trees ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(test-count-remaining-trees)", "entry_point": "count-remaining-trees", "signature": "(defun count-remaining-trees (road-length regions)", "docstring": "Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCounts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7\n\n* Incomplete Code:\n(defun count-remaining-trees (road-length regions)\n[MASK]\n[MASK]\n(loop for i from (first region) to (second region)\n[MASK]\n(count t tree-map)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n(loop for i from (first region) to (second region)\n[MASK]\n(count t tree-map)))"}
{"task_id": "Common Lisp/25-0-multi", "prompt": "(defun larger-prime-factor (n)\n;; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.\n;; Example:\n;; (larger-prime-factor 15) ;; Returns 5\n;; (larger-prime-factor 33) ;; Returns 11", "canonical_solution": "(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "test": "(defun test-larger-prime-factor ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(test-larger-prime-factor)", "entry_point": "larger-prime-factor", "signature": "(defun larger-prime-factor (n)", "docstring": "Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nFinds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11\n\n* Incomplete Code:\n(defun larger-prime-factor (n)\n[MASK]\n(loop while (> n factor)\n[MASK]\n[MASK]\nelse\ndo (incf factor))\nn))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(loop while (> n factor)\n[MASK]\n[MASK]\nelse\ndo (incf factor))\nn))"}
{"task_id": "Common Lisp/25-1-multi", "prompt": "(defun larger-prime-factor (n)\n;; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.\n;; Example:\n;; (larger-prime-factor 15) ;; Returns 5\n;; (larger-prime-factor 33) ;; Returns 11", "canonical_solution": "(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "test": "(defun test-larger-prime-factor ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(test-larger-prime-factor)", "entry_point": "larger-prime-factor", "signature": "(defun larger-prime-factor (n)", "docstring": "Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nFinds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11\n\n* Incomplete Code:\n(defun larger-prime-factor (n)\n[MASK]\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\n[MASK]\nn))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\n[MASK]\nn))"}
{"task_id": "Common Lisp/26-0-multi", "prompt": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n;; 'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\n;; The function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\n;; Example:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Returns 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Returns 0", "canonical_solution": "(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))", "test": "(defun test-day-of-max-unhappiness ()\n(assert (equal (day-of-max-unhappiness '((5 3) (6 2) (7 2) (5 3) (5 4) (0 4) (0 6))) 3))\n(assert (equal (day-of-max-unhappiness '((4 4) (4 4) (4 4) (4 4) (4 4) (4 4) (4 4))) 0))\n(assert (equal (day-of-max-unhappiness '((3 3) (3 3) (3 3) (3 3) (3 3) (3 3) (3 3))) 0))\n(assert (equal (day-of-max-unhappiness '((2 6) (3 5) (4 4) (5 3) (6 2) (7 1) (1 7))) 0))\n(assert (equal (day-of-max-unhappiness '((5 0) (0 5) (6 3) (3 6) (2 7) (7 2) (4 4))) 3)))\n(test-day-of-max-unhappiness)", "entry_point": "day-of-max-unhappiness", "signature": "(defun day-of-max-unhappiness (weekly-schedule)", "docstring": "Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nAnalyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0\n\n* Incomplete Code:\n(defun day-of-max-unhappiness (weekly-schedule)\n[MASK]\n[MASK]\n(loop for day from 1 to 7\n[MASK]\ndo (let ((total-hours (+ (first hours) (second hours))))\n[MASK]\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n(loop for day from 1 to 7\n[MASK]\ndo (let ((total-hours (+ (first hours) (second hours))))\n[MASK]\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))"}
{"task_id": "Common Lisp/26-1-multi", "prompt": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n;; 'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\n;; The function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\n;; Example:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Returns 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Returns 0", "canonical_solution": "(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))", "test": "(defun test-day-of-max-unhappiness ()\n(assert (equal (day-of-max-unhappiness '((5 3) (6 2) (7 2) (5 3) (5 4) (0 4) (0 6))) 3))\n(assert (equal (day-of-max-unhappiness '((4 4) (4 4) (4 4) (4 4) (4 4) (4 4) (4 4))) 0))\n(assert (equal (day-of-max-unhappiness '((3 3) (3 3) (3 3) (3 3) (3 3) (3 3) (3 3))) 0))\n(assert (equal (day-of-max-unhappiness '((2 6) (3 5) (4 4) (5 3) (6 2) (7 1) (1 7))) 0))\n(assert (equal (day-of-max-unhappiness '((5 0) (0 5) (6 3) (3 6) (2 7) (7 2) (4 4))) 3)))\n(test-day-of-max-unhappiness)", "entry_point": "day-of-max-unhappiness", "signature": "(defun day-of-max-unhappiness (weekly-schedule)", "docstring": "Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nAnalyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0\n\n* Incomplete Code:\n(defun day-of-max-unhappiness (weekly-schedule)\n[MASK]\n[MASK]\n(loop for day from 1 to 7\n[MASK]\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n[MASK]\n[MASK]\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n(loop for day from 1 to 7\n[MASK]\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n[MASK]\n[MASK]\n(if (> max-unhappiness 8) most-unhappy-day 0)))"}
{"task_id": "Common Lisp/27-0-multi", "prompt": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7", "canonical_solution": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "test": "(defun test-calculate-year-end-amount ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(test-calculate-year-end-amount)", "entry_point": "calculate-year-end-amount", "signature": "(defun calculate-year-end-amount (monthly-budgets)", "docstring": "Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCalculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7\n\n* Incomplete Code:\n(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n[MASK]\n(decf current-amount (* 100 savings))\n[MASK]\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n[MASK]\n(decf current-amount (* 100 savings))\n[MASK]\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest"}
{"task_id": "Common Lisp/27-1-multi", "prompt": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7", "canonical_solution": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "test": "(defun test-calculate-year-end-amount ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(test-calculate-year-end-amount)", "entry_point": "calculate-year-end-amount", "signature": "(defun calculate-year-end-amount (monthly-budgets)", "docstring": "Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCalculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7\n\n* Incomplete Code:\n(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n[MASK]\nfor budget in monthly-budgets\ndo (progn\n[MASK]\n(decf current-amount budget) ;; Subtract monthly budget\n[MASK]\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n[MASK]\n[MASK]\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((current-amount 0)\n(total-saved 0))\n[MASK]\nfor budget in monthly-budgets\ndo (progn\n[MASK]\n(decf current-amount budget) ;; Subtract monthly budget\n[MASK]\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n[MASK]\n[MASK]\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest"}
{"task_id": "Common Lisp/28-0-multi", "prompt": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.\n;; Example:\n;; (total-cigarettes-smoked 4 3) ;; Returns 5\n;; (total-cigarettes-smoked 10 4) ;; Returns 13", "canonical_solution": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "test": "(defun test-total-cigarettes-smoked ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(test-total-cigarettes-smoked)", "entry_point": "total-cigarettes-smoked", "signature": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)", "docstring": "Calculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCalculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13\n\n* Incomplete Code:\n(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n[MASK]\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\n[MASK]\n(incf total-smoked new-cigarettes)\n[MASK]\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\n[MASK]\n(incf total-smoked new-cigarettes)\n[MASK]\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/28-1-multi", "prompt": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.\n;; Example:\n;; (total-cigarettes-smoked 4 3) ;; Returns 5\n;; (total-cigarettes-smoked 10 4) ;; Returns 13", "canonical_solution": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "test": "(defun test-total-cigarettes-smoked ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(test-total-cigarettes-smoked)", "entry_point": "total-cigarettes-smoked", "signature": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)", "docstring": "Calculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nCalculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13\n\n* Incomplete Code:\n(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n[MASK]\n[MASK]\ntotal-smoked))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n[MASK]\n[MASK]\ntotal-smoked))"}
{"task_id": "Common Lisp/29-0-multi", "prompt": "(defun divisible-five-digit-numbers (k)\n;; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.\n;; Example:\n;; (divisible-five-digit-numbers 15) ;; Returns (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Returns a list of numbers or 'No' if no such numbers exist", "canonical_solution": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "test": "(defun test-divisible-five-digit-numbers ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(test-divisible-five-digit-numbers)", "entry_point": "divisible-five-digit-numbers", "signature": "(defun divisible-five-digit-numbers (k)", "docstring": "Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nFinds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist\n\n* Incomplete Code:\n(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n[MASK]\n[MASK]\n'No\n(nreverse results))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n[MASK]\n[MASK]\n'No\n(nreverse results))))"}
{"task_id": "Common Lisp/29-1-multi", "prompt": "(defun divisible-five-digit-numbers (k)\n;; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.\n;; Example:\n;; (divisible-five-digit-numbers 15) ;; Returns (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Returns a list of numbers or 'No' if no such numbers exist", "canonical_solution": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "test": "(defun test-divisible-five-digit-numbers ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(test-divisible-five-digit-numbers)", "entry_point": "divisible-five-digit-numbers", "signature": "(defun divisible-five-digit-numbers (k)", "docstring": "Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nFinds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist\n\n* Incomplete Code:\n(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n[MASK]\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n[MASK]\n(if (null results)\n'No\n(nreverse results))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n[MASK]\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n[MASK]\n(if (null results)\n'No\n(nreverse results))))"}
{"task_id": "Common Lisp/30-0-multi", "prompt": "(defun count-digit-two (L R)\n;; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.\n;; Example:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9", "canonical_solution": "(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "test": "(defun test-count-digit-two ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(test-count-digit-two)", "entry_point": "count-digit-two", "signature": "(defun count-digit-two (L R)", "docstring": "This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9\n\n* Incomplete Code:\n(defun count-digit-two (L R)\n(let ((count 0))\n[MASK]\n[MASK]\n(when (char= char #\\2) (incf count))))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let ((count 0))\n[MASK]\n[MASK]\n(when (char= char #\\2) (incf count))))\n[MASK]"}
{"task_id": "Common Lisp/30-1-multi", "prompt": "(defun count-digit-two (L R)\n;; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.\n;; Example:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9", "canonical_solution": "(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "test": "(defun test-count-digit-two ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(test-count-digit-two)", "entry_point": "count-digit-two", "signature": "(defun count-digit-two (L R)", "docstring": "This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9\n\n* Incomplete Code:\n(defun count-digit-two (L R)\n[MASK]\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/31-0-multi", "prompt": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"", "canonical_solution": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "test": "(defun test-represent-as-powers-of-two ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(test-represent-as-powers-of-two)", "entry_point": "represent-as-powers-of-two", "signature": "(defun represent-as-powers-of-two (n)", "docstring": "This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"\n\n* Incomplete Code:\n(defun represent-as-powers-of-two (n)\n[MASK]\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n[MASK]\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n[MASK]\n(when list\n[MASK]\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n[MASK]\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n[MASK]\n(when list\n[MASK]\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))"}
{"task_id": "Common Lisp/31-1-multi", "prompt": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"", "canonical_solution": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "test": "(defun test-represent-as-powers-of-two ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(test-represent-as-powers-of-two)", "entry_point": "represent-as-powers-of-two", "signature": "(defun represent-as-powers-of-two (n)", "docstring": "This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"\n\n* Incomplete Code:\n(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n[MASK]\n(with-output-to-string (stream)\n(when list\n[MASK]\n[MASK]\n(write-string separator stream)\n(write-string item stream)))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n[MASK]\n(with-output-to-string (stream)\n(when list\n[MASK]\n[MASK]\n(write-string separator stream)\n(write-string item stream)))))"}
{"task_id": "Common Lisp/32-0-multi", "prompt": "(defun create-largest-number (numbers)\n;; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\n;; Example:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"", "canonical_solution": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "test": "(defun test-create-largest-number ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(test-create-largest-number)", "entry_point": "create-largest-number", "signature": "(defun create-largest-number (numbers)", "docstring": "This function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"\n\n* Incomplete Code:\n(defun create-largest-number (numbers)\n[MASK]\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n[MASK]\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n[MASK]\n\n[MASK]\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n[MASK]\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n[MASK]\n\n[MASK]\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))"}
{"task_id": "Common Lisp/32-1-multi", "prompt": "(defun create-largest-number (numbers)\n;; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\n;; Example:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"", "canonical_solution": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "test": "(defun test-create-largest-number ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(test-create-largest-number)", "entry_point": "create-largest-number", "signature": "(defun create-largest-number (numbers)", "docstring": "This function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"\n\n* Incomplete Code:\n(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n[MASK]\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n[MASK]\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n[MASK]"}
{"task_id": "Common Lisp/35-0-multi", "prompt": "(defun construct-preorder (inorder postorder)\n;; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.\n;; Example:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"", "canonical_solution": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "test": "(defun test-construct-preorder ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(test-construct-preorder)", "entry_point": "construct-preorder", "signature": "(defun construct-preorder (inorder postorder)", "docstring": "This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"\n\n* Incomplete Code:\n(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n[MASK]\n(root-pos (position root inorder)))\n(concatenate 'string\n[MASK]\n[MASK]\n(subseq postorder 0 root-pos))\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(when (and inorder postorder (not (zerop (length postorder))))\n[MASK]\n(root-pos (position root inorder)))\n(concatenate 'string\n[MASK]\n[MASK]\n(subseq postorder 0 root-pos))\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/35-1-multi", "prompt": "(defun construct-preorder (inorder postorder)\n;; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.\n;; Example:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"", "canonical_solution": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "test": "(defun test-construct-preorder ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(test-construct-preorder)", "entry_point": "construct-preorder", "signature": "(defun construct-preorder (inorder postorder)", "docstring": "This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"\n\n* Incomplete Code:\n(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n[MASK]\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n[MASK]\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n[MASK]"}
{"task_id": "Common Lisp/36-0-multi", "prompt": "(defun count-prime-sums (numbers k)\n;; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\n;; Example:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) and (3+4) are prime\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Only (1+2+5) is prime", "canonical_solution": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "test": "(defun test-count-prime-sums ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(test-count-prime-sums)", "entry_point": "count-prime-sums", "signature": "(defun count-prime-sums (numbers k)", "docstring": "This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime\n\n* Incomplete Code:\n(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n[MASK]\n((= n 2) t)\n[MASK]\n\n[MASK]\n(if (= k 0)\n'(())\n[MASK]\n[MASK]\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n[MASK]\n((= n 2) t)\n[MASK]\n\n[MASK]\n(if (= k 0)\n'(())\n[MASK]\n[MASK]\n(sum-combinations (subseq lst (1+ i)) (1- k))))))"}
{"task_id": "Common Lisp/36-1-multi", "prompt": "(defun count-prime-sums (numbers k)\n;; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\n;; Example:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) and (3+4) are prime\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Only (1+2+5) is prime", "canonical_solution": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "test": "(defun test-count-prime-sums ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(test-count-prime-sums)", "entry_point": "count-prime-sums", "signature": "(defun count-prime-sums (numbers k)", "docstring": "This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime\n\n* Incomplete Code:\n(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n[MASK]\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n[MASK]\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n[MASK]\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n[MASK]\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))"}
{"task_id": "Common Lisp/37-0-multi", "prompt": "(defun calculate-table-tennis-scores (record)\n;; This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \n;; and calculates the scores under 11-point and 21-point systems.\n;; 'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\n;; The function returns two lists: the first list contains the scores under the 11-point system, \n;; and the second list contains the scores under the 21-point system.\n;; Example:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))", "canonical_solution": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))", "test": "(defun test-calculate-table-tennis-scores ()\n(assert (equal (calculate-table-tennis-scores \"WWLLWE\") '((\"3:2\") (\"3:2\"))))\n(assert (equal (calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\") '((\"11:0\" \"2:1\") (\"13:1\"))))\n(assert (equal (calculate-table-tennis-scores \"WLWLWLWLWLE\") '((\"5:5\") (\"5:5\"))))\n(assert (equal (calculate-table-tennis-scores \"LWE\") '((\"1:1\") (\"1:1\")))))\n\n(test-calculate-table-tennis-scores)", "entry_point": "calculate-table-tennis-scores", "signature": "(defun calculate-table-tennis-scores (record)", "docstring": "This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))\n\n* Incomplete Code:\n(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n[MASK]\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n[MASK]\n(setf score-11 (cons 0 0)))\n[MASK]\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n[MASK]\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n[MASK]\n(setf score-11 (cons 0 0)))\n[MASK]\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))"}
{"task_id": "Common Lisp/37-1-multi", "prompt": "(defun calculate-table-tennis-scores (record)\n;; This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \n;; and calculates the scores under 11-point and 21-point systems.\n;; 'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\n;; The function returns two lists: the first list contains the scores under the 11-point system, \n;; and the second list contains the scores under the 21-point system.\n;; Example:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))", "canonical_solution": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))", "test": "(defun test-calculate-table-tennis-scores ()\n(assert (equal (calculate-table-tennis-scores \"WWLLWE\") '((\"3:2\") (\"3:2\"))))\n(assert (equal (calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\") '((\"11:0\" \"2:1\") (\"13:1\"))))\n(assert (equal (calculate-table-tennis-scores \"WLWLWLWLWLE\") '((\"5:5\") (\"5:5\"))))\n(assert (equal (calculate-table-tennis-scores \"LWE\") '((\"1:1\") (\"1:1\")))))\n\n(test-calculate-table-tennis-scores)", "entry_point": "calculate-table-tennis-scores", "signature": "(defun calculate-table-tennis-scores (record)", "docstring": "This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))\n\n* Incomplete Code:\n(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n[MASK]\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n[MASK]\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n[MASK]\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n[MASK]\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n[MASK]\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n[MASK]\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))"}
{"task_id": "Common Lisp/38-0-multi", "prompt": "(defun count-output-sequences (n)\n;; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\n;; Example:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14", "canonical_solution": "(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "test": "(defun test-count-output-sequences ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(test-count-output-sequences)", "entry_point": "count-output-sequences", "signature": "(defun count-output-sequences (n)", "docstring": "This function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14\n\n* Incomplete Code:\n(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n[MASK]\n(loop for i from 1 to n do\n[MASK]\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let ((dp (make-array (1+ n) :initial-element 0)))\n[MASK]\n(loop for i from 1 to n do\n[MASK]\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/38-1-multi", "prompt": "(defun count-output-sequences (n)\n;; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\n;; Example:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14", "canonical_solution": "(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "test": "(defun test-count-output-sequences ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(test-count-output-sequences)", "entry_point": "count-output-sequences", "signature": "(defun count-output-sequences (n)", "docstring": "This function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14\n\n* Incomplete Code:\n(defun count-output-sequences (n)\n[MASK]\n[MASK]\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n[MASK]"}
{"task_id": "Common Lisp/39-0-multi", "prompt": "(defun max-herb-value (time-limit herb-info)\n;; This function calculates the maximum total value of herbs that can be collected within a given time limit.\n;; 'time-limit' is the total time available for collecting herbs.\n;; 'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\n;; The function uses a dynamic programming approach to determine the maximum value that can be obtained.\n;; Example:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14", "canonical_solution": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))", "test": "(defun test-max-herb-value ()\n(assert (equal (max-herb-value 70 '((71 100) (69 1) (1 2))) 3))\n(assert (equal (max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))) 14))\n(assert (equal (max-herb-value 15 '((5 10) (10 15) (20 25))) 25))\n(assert (equal (max-herb-value 100 '((50 60) (50 70))) 130))\n(assert (equal (max-herb-value 5 '((2 3) (2 4) (1 1))) 8)))\n\n(test-max-herb-value)", "entry_point": "max-herb-value", "signature": "(defun max-herb-value (time-limit herb-info)", "docstring": "This function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14\n\n* Incomplete Code:\n(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n[MASK]\n[MASK]\n(aref dp time-limit)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n[MASK]\n[MASK]\n(aref dp time-limit)))"}
{"task_id": "Common Lisp/39-1-multi", "prompt": "(defun max-herb-value (time-limit herb-info)\n;; This function calculates the maximum total value of herbs that can be collected within a given time limit.\n;; 'time-limit' is the total time available for collecting herbs.\n;; 'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\n;; The function uses a dynamic programming approach to determine the maximum value that can be obtained.\n;; Example:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14", "canonical_solution": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))", "test": "(defun test-max-herb-value ()\n(assert (equal (max-herb-value 70 '((71 100) (69 1) (1 2))) 3))\n(assert (equal (max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))) 14))\n(assert (equal (max-herb-value 15 '((5 10) (10 15) (20 25))) 25))\n(assert (equal (max-herb-value 100 '((50 60) (50 70))) 130))\n(assert (equal (max-herb-value 5 '((2 3) (2 4) (1 1))) 8)))\n\n(test-max-herb-value)", "entry_point": "max-herb-value", "signature": "(defun max-herb-value (time-limit herb-info)", "docstring": "This function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14\n\n* Incomplete Code:\n(defun max-herb-value (time-limit herb-info)\n[MASK]\n[MASK]\n[MASK]\n(setf (aref dp current-time) \n[MASK]\n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n[MASK]\n(setf (aref dp current-time) \n[MASK]\n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))"}
{"task_id": "Common Lisp/40-0-multi", "prompt": "(defun min-box-space (box-capacity item-volumes)\n;; This function calculates the minimum remaining space in a box after optimally packing a given set of items.\n;; Each item has a specific volume, and the box has a fixed capacity.\n;; The function returns the smallest possible remaining space in the box.\n;; Example:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0", "canonical_solution": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))", "test": "(defun test-min-box-space ()\n(assert (equal (min-box-space 20 '(5 5 10 6)) 0))\n(assert (equal (min-box-space 25 '(7 8 5 10)) 0))\n(assert (equal (min-box-space 12 '(3 2 2 5)) 0))\n(assert (equal (min-box-space 30 '(10 10 12)) 8))\n(assert (equal (min-box-space 8 '(1 2 3 4)) 0))\n(assert (equal (min-box-space 18 '(2 5 6 8)) 2))\n(assert (equal (min-box-space 11 '(1 2 3)) 5)))\n\n(test-min-box-space)", "entry_point": "min-box-space", "signature": "(defun min-box-space (box-capacity item-volumes)", "docstring": "This function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0\n\n* Incomplete Code:\n(defun min-box-space (box-capacity item-volumes)\n[MASK]\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n[MASK]\n[MASK]"}
{"task_id": "Common Lisp/40-1-multi", "prompt": "(defun min-box-space (box-capacity item-volumes)\n;; This function calculates the minimum remaining space in a box after optimally packing a given set of items.\n;; Each item has a specific volume, and the box has a fixed capacity.\n;; The function returns the smallest possible remaining space in the box.\n;; Example:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0", "canonical_solution": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))", "test": "(defun test-min-box-space ()\n(assert (equal (min-box-space 20 '(5 5 10 6)) 0))\n(assert (equal (min-box-space 25 '(7 8 5 10)) 0))\n(assert (equal (min-box-space 12 '(3 2 2 5)) 0))\n(assert (equal (min-box-space 30 '(10 10 12)) 8))\n(assert (equal (min-box-space 8 '(1 2 3 4)) 0))\n(assert (equal (min-box-space 18 '(2 5 6 8)) 2))\n(assert (equal (min-box-space 11 '(1 2 3)) 5)))\n\n(test-min-box-space)", "entry_point": "min-box-space", "signature": "(defun min-box-space (box-capacity item-volumes)", "docstring": "This function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0", "instruction": "Below is a explanation of Common Lisp code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0\n\n* Incomplete Code:\n(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n[MASK]\n(loop for v from box-capacity downto item do\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n[MASK]\n(loop for v from box-capacity downto item do\n[MASK]\n[MASK]"}
