{"task_id": "Erlang/1-0-multi", "prompt": "-module(has_close_elements).\n-export([has_close_elements/2, test/0]).\n\n%Check if in given list of numbers, are any two numbers closer to each other than\n%given threshold.\n%>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n%False\n%>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n%True\nhas_close_elements(Numbers, Threshold) ->", "canonical_solution": "has_close_elements_helper(Numbers, Threshold, []).\n\nhas_close_elements_helper([], _, _) -> false;\nhas_close_elements_helper([H|T], Threshold, Checked) ->\ncase check_distance(H, Checked, Threshold) of\ntrue -> true;\nfalse -> has_close_elements_helper(T, Threshold, [H|Checked])\nend.\n\ncheck_distance(_, [], _) -> false;\ncheck_distance(Number, [H|T], Threshold) ->\nDistance = abs(Number - H),\nif\nDistance < Threshold -> true;\ntrue -> check_distance(Number, T, Threshold)\nend.", "test": "test() ->\ntrue = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),\nfalse = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),\ntrue = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\nfalse = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),\ntrue = has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),\ntrue = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\nfalse = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\nok.", "module": "has_close_elements", "entry_point": "has_close_elements", "signature": "has_close_elements(Numbers, Threshold) ->", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nhas_close_elements(Numbers, Threshold) ->\nhas_close_elements_helper(Numbers, Threshold, []).\n\n[MASK]\n[MASK]\ncase check_distance(H, Checked, Threshold) of\ntrue -> true;\n[MASK]\nend.\n\ncheck_distance(_, [], _) -> false;\ncheck_distance(Number, [H|T], Threshold) ->\nDistance = abs(Number - H),\nif\n[MASK]\ntrue -> check_distance(Number, T, Threshold)\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "has_close_elements_helper(Numbers, Threshold, []).\n\n[MASK]\n[MASK]\ncase check_distance(H, Checked, Threshold) of\ntrue -> true;\n[MASK]\nend.\n\ncheck_distance(_, [], _) -> false;\ncheck_distance(Number, [H|T], Threshold) ->\nDistance = abs(Number - H),\nif\n[MASK]\ntrue -> check_distance(Number, T, Threshold)\nend."}
{"task_id": "Erlang/1-1-multi", "prompt": "-module(has_close_elements).\n-export([has_close_elements/2, test/0]).\n\n%Check if in given list of numbers, are any two numbers closer to each other than\n%given threshold.\n%>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n%False\n%>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n%True\nhas_close_elements(Numbers, Threshold) ->", "canonical_solution": "has_close_elements_helper(Numbers, Threshold, []).\n\nhas_close_elements_helper([], _, _) -> false;\nhas_close_elements_helper([H|T], Threshold, Checked) ->\ncase check_distance(H, Checked, Threshold) of\ntrue -> true;\nfalse -> has_close_elements_helper(T, Threshold, [H|Checked])\nend.\n\ncheck_distance(_, [], _) -> false;\ncheck_distance(Number, [H|T], Threshold) ->\nDistance = abs(Number - H),\nif\nDistance < Threshold -> true;\ntrue -> check_distance(Number, T, Threshold)\nend.", "test": "test() ->\ntrue = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),\nfalse = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),\ntrue = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\nfalse = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),\ntrue = has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),\ntrue = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\nfalse = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\nok.", "module": "has_close_elements", "entry_point": "has_close_elements", "signature": "has_close_elements(Numbers, Threshold) ->", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nhas_close_elements(Numbers, Threshold) ->\nhas_close_elements_helper(Numbers, Threshold, []).\n\nhas_close_elements_helper([], _, _) -> false;\nhas_close_elements_helper([H|T], Threshold, Checked) ->\ncase check_distance(H, Checked, Threshold) of\n[MASK]\nfalse -> has_close_elements_helper(T, Threshold, [H|Checked])\nend.\n\ncheck_distance(_, [], _) -> false;\ncheck_distance(Number, [H|T], Threshold) ->\n[MASK]\nif\n[MASK]\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "has_close_elements_helper(Numbers, Threshold, []).\n\nhas_close_elements_helper([], _, _) -> false;\nhas_close_elements_helper([H|T], Threshold, Checked) ->\ncase check_distance(H, Checked, Threshold) of\n[MASK]\nfalse -> has_close_elements_helper(T, Threshold, [H|Checked])\nend.\n\ncheck_distance(_, [], _) -> false;\ncheck_distance(Number, [H|T], Threshold) ->\n[MASK]\nif\n[MASK]\n[MASK]\nend."}
{"task_id": "Erlang/4-0-multi", "prompt": "-module(automorphic_numbers).\n-export([automorphic_numbers_up_to/1, test/0]).\n\nautomorphic_numbers_up_to(N) ->\n\n% This function calculates all automorphic numbers from 1 up to a given number N.\n% An automorphic number is a number whose square ends in the same digits as the number itself.\n% For example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\n% The function takes an integer N and returns a list of all automorphic numbers up to N.\n%\n% Example:\n% automorphic_numbers_up_to(10) returns [1, 5, 6]\n% automorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]", "canonical_solution": "lists:filter(fun(X) -> is_automorphic(X) end, lists:seq(1, N)).\n\nis_automorphic(X) ->\nSqr = X * X,\nSuffix = integer_to_list(X),\nlists:suffix(Suffix, integer_to_list(Sqr)).", "test": "test() ->\n[1, 5, 6] = automorphic_numbers_up_to(10),\n[1, 5, 6, 25, 76] = automorphic_numbers_up_to(100),\n[] = automorphic_numbers_up_to(0),\n[1] = automorphic_numbers_up_to(1),\n[1, 5, 6, 25, 76, 376, 625] = automorphic_numbers_up_to(1000),\nok.", "module": "automorphic_numbers", "entry_point": "automorphic_numbers_up_to", "signature": "automorphic_numbers_up_to/1, test/0]).automorphic_numbers_up_to(N) ->", "docstring": "This function calculates all automorphic numbers from 1 up to a given number N.\nAn automorphic number is a number whose square ends in the same digits as the number itself.\nFor example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\nThe function takes an integer N and returns a list of all automorphic numbers up to N.\n\nExample:\nautomorphic_numbers_up_to(10) returns [1, 5, 6]\nautomorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates all automorphic numbers from 1 up to a given number N.\nAn automorphic number is a number whose square ends in the same digits as the number itself.\nFor example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\nThe function takes an integer N and returns a list of all automorphic numbers up to N.\n\nExample:\nautomorphic_numbers_up_to(10) returns [1, 5, 6]\nautomorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]\n\n* Incomplete Code:\nautomorphic_numbers_up_to/1, test/0]).automorphic_numbers_up_to(N) ->\n[MASK]\n\nis_automorphic(X) ->\nSqr = X * X,\nSuffix = integer_to_list(X),\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n\nis_automorphic(X) ->\nSqr = X * X,\nSuffix = integer_to_list(X),\n[MASK]"}
{"task_id": "Erlang/4-1-multi", "prompt": "-module(automorphic_numbers).\n-export([automorphic_numbers_up_to/1, test/0]).\n\nautomorphic_numbers_up_to(N) ->\n\n% This function calculates all automorphic numbers from 1 up to a given number N.\n% An automorphic number is a number whose square ends in the same digits as the number itself.\n% For example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\n% The function takes an integer N and returns a list of all automorphic numbers up to N.\n%\n% Example:\n% automorphic_numbers_up_to(10) returns [1, 5, 6]\n% automorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]", "canonical_solution": "lists:filter(fun(X) -> is_automorphic(X) end, lists:seq(1, N)).\n\nis_automorphic(X) ->\nSqr = X * X,\nSuffix = integer_to_list(X),\nlists:suffix(Suffix, integer_to_list(Sqr)).", "test": "test() ->\n[1, 5, 6] = automorphic_numbers_up_to(10),\n[1, 5, 6, 25, 76] = automorphic_numbers_up_to(100),\n[] = automorphic_numbers_up_to(0),\n[1] = automorphic_numbers_up_to(1),\n[1, 5, 6, 25, 76, 376, 625] = automorphic_numbers_up_to(1000),\nok.", "module": "automorphic_numbers", "entry_point": "automorphic_numbers_up_to", "signature": "automorphic_numbers_up_to/1, test/0]).automorphic_numbers_up_to(N) ->", "docstring": "This function calculates all automorphic numbers from 1 up to a given number N.\nAn automorphic number is a number whose square ends in the same digits as the number itself.\nFor example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\nThe function takes an integer N and returns a list of all automorphic numbers up to N.\n\nExample:\nautomorphic_numbers_up_to(10) returns [1, 5, 6]\nautomorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates all automorphic numbers from 1 up to a given number N.\nAn automorphic number is a number whose square ends in the same digits as the number itself.\nFor example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\nThe function takes an integer N and returns a list of all automorphic numbers up to N.\n\nExample:\nautomorphic_numbers_up_to(10) returns [1, 5, 6]\nautomorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]\n\n* Incomplete Code:\nautomorphic_numbers_up_to/1, test/0]).automorphic_numbers_up_to(N) ->\nlists:filter(fun(X) -> is_automorphic(X) end, lists:seq(1, N)).\n\nis_automorphic(X) ->\n[MASK]\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "lists:filter(fun(X) -> is_automorphic(X) end, lists:seq(1, N)).\n\nis_automorphic(X) ->\n[MASK]\n[MASK]\n[MASK]"}
{"task_id": "Erlang/8-0-multi", "prompt": "-module(convert_and_concat).\n-export([convert_and_concat/1, test/0]).\n\n% Convert integers, floats, and atoms in a list to strings and concatenate them.\n% >>> convert_and_concat([1, 2.5, hello, 3])\n% \"12.5hello3\"\n% >>> convert_and_concat([apple, 42, 3.1415])\n% \"apple423.1415\"\nconvert_and_concat(List) ->", "canonical_solution": "StringList = lists:map(fun convert_to_string/1, List),\nlists:flatten(StringList).\n\nconvert_to_string(Item) when is_integer(Item); is_float(Item) ->\nio_lib:format(\"~p\", [Item]);\nconvert_to_string(Item) when is_atom(Item) ->\natom_to_list(Item).", "test": "test() ->\n\"12.5hello3\" = convert_and_concat([1, 2.5, hello, 3]),\n\"apple423.1415\" = convert_and_concat([apple, 42, 3.1415]),\n\"\" = convert_and_concat([]),\n\"42\" = convert_and_concat([42]),\nok.", "module": "convert_and_concat", "entry_point": "convert_and_concat", "signature": "convert_and_concat(List) ->", "docstring": "Convert integers, floats, and atoms in a list to strings and concatenate them.\n>>> convert_and_concat([1, 2.5, hello, 3])\n\"12.5hello3\"\n>>> convert_and_concat([apple, 42, 3.1415])\n\"apple423.1415\"\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nConvert integers, floats, and atoms in a list to strings and concatenate them.\n>>> convert_and_concat([1, 2.5, hello, 3])\n\"12.5hello3\"\n>>> convert_and_concat([apple, 42, 3.1415])\n\"apple423.1415\"\n\n\n* Incomplete Code:\nconvert_and_concat(List) ->\n[MASK]\n[MASK]\n\nconvert_to_string(Item) when is_integer(Item); is_float(Item) ->\n[MASK]\nconvert_to_string(Item) when is_atom(Item) ->\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n\nconvert_to_string(Item) when is_integer(Item); is_float(Item) ->\n[MASK]\nconvert_to_string(Item) when is_atom(Item) ->\n[MASK]"}
{"task_id": "Erlang/8-1-multi", "prompt": "-module(convert_and_concat).\n-export([convert_and_concat/1, test/0]).\n\n% Convert integers, floats, and atoms in a list to strings and concatenate them.\n% >>> convert_and_concat([1, 2.5, hello, 3])\n% \"12.5hello3\"\n% >>> convert_and_concat([apple, 42, 3.1415])\n% \"apple423.1415\"\nconvert_and_concat(List) ->", "canonical_solution": "StringList = lists:map(fun convert_to_string/1, List),\nlists:flatten(StringList).\n\nconvert_to_string(Item) when is_integer(Item); is_float(Item) ->\nio_lib:format(\"~p\", [Item]);\nconvert_to_string(Item) when is_atom(Item) ->\natom_to_list(Item).", "test": "test() ->\n\"12.5hello3\" = convert_and_concat([1, 2.5, hello, 3]),\n\"apple423.1415\" = convert_and_concat([apple, 42, 3.1415]),\n\"\" = convert_and_concat([]),\n\"42\" = convert_and_concat([42]),\nok.", "module": "convert_and_concat", "entry_point": "convert_and_concat", "signature": "convert_and_concat(List) ->", "docstring": "Convert integers, floats, and atoms in a list to strings and concatenate them.\n>>> convert_and_concat([1, 2.5, hello, 3])\n\"12.5hello3\"\n>>> convert_and_concat([apple, 42, 3.1415])\n\"apple423.1415\"\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nConvert integers, floats, and atoms in a list to strings and concatenate them.\n>>> convert_and_concat([1, 2.5, hello, 3])\n\"12.5hello3\"\n>>> convert_and_concat([apple, 42, 3.1415])\n\"apple423.1415\"\n\n\n* Incomplete Code:\nconvert_and_concat(List) ->\nStringList = lists:map(fun convert_to_string/1, List),\n[MASK]\n\nconvert_to_string(Item) when is_integer(Item); is_float(Item) ->\nio_lib:format(\"~p\", [Item]);\n[MASK]\natom_to_list(Item).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "StringList = lists:map(fun convert_to_string/1, List),\n[MASK]\n\nconvert_to_string(Item) when is_integer(Item); is_float(Item) ->\nio_lib:format(\"~p\", [Item]);\n[MASK]\natom_to_list(Item)."}
{"task_id": "Erlang/10-0-multi", "prompt": "-module(extract_numbers).\n-export([extract_numbers/1, test/0]).\n\nextract_numbers(String) ->\n% This function extracts all the numbers from a given string.\n% The numbers in the string are assumed to be non-negative integers separated by non-digit characters.\n% The function returns a list of integers found in the string.\n% If there are no numbers in the string, it returns an empty list.\n%\n% Example:\n% extract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\n% extract_numbers(\"no numbers\") returns []", "canonical_solution": "extract_numbers(String, [], []).\n\nextract_numbers([], CurrentNumber, Acc) when CurrentNumber =/= [] ->\nlists:reverse([list_to_integer(lists:reverse(CurrentNumber)) | Acc]);\nextract_numbers([], [], Acc) ->\nlists:reverse(Acc);\nextract_numbers([Char|Rest], CurrentNumber, Acc) when Char >= $0, Char =< $9 ->\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\nextract_numbers(Rest, [], Acc);\nextract_numbers([_|Rest], CurrentNumber, Acc) ->\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc]).", "test": "test() ->\n[123, 45, 6] = extract_numbers(\"abc123def45ghi6\"),\n[] = extract_numbers(\"no numbers\"),\n[2023] = extract_numbers(\"year2023\"),\n[1, 2, 3] = extract_numbers(\"1a2b3c\"),\n[] = extract_numbers(\"\"),\nok.", "module": "extract_numbers", "entry_point": "extract_numbers", "signature": "extract_numbers).-export([extract_numbers/1, test/0]).extract_numbers(String) ->", "docstring": "This function extracts all the numbers from a given string.\nThe numbers in the string are assumed to be non-negative integers separated by non-digit characters.\nThe function returns a list of integers found in the string.\nIf there are no numbers in the string, it returns an empty list.\n\nExample:\nextract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\nextract_numbers(\"no numbers\") returns []", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function extracts all the numbers from a given string.\nThe numbers in the string are assumed to be non-negative integers separated by non-digit characters.\nThe function returns a list of integers found in the string.\nIf there are no numbers in the string, it returns an empty list.\n\nExample:\nextract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\nextract_numbers(\"no numbers\") returns []\n\n* Incomplete Code:\nextract_numbers).-export([extract_numbers/1, test/0]).extract_numbers(String) ->\n[MASK]\n\nextract_numbers([], CurrentNumber, Acc) when CurrentNumber =/= [] ->\n[MASK]\n[MASK]\nlists:reverse(Acc);\n[MASK]\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\nextract_numbers(Rest, [], Acc);\nextract_numbers([_|Rest], CurrentNumber, Acc) ->\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc]).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n\nextract_numbers([], CurrentNumber, Acc) when CurrentNumber =/= [] ->\n[MASK]\n[MASK]\nlists:reverse(Acc);\n[MASK]\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\nextract_numbers(Rest, [], Acc);\nextract_numbers([_|Rest], CurrentNumber, Acc) ->\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc])."}
{"task_id": "Erlang/10-1-multi", "prompt": "-module(extract_numbers).\n-export([extract_numbers/1, test/0]).\n\nextract_numbers(String) ->\n% This function extracts all the numbers from a given string.\n% The numbers in the string are assumed to be non-negative integers separated by non-digit characters.\n% The function returns a list of integers found in the string.\n% If there are no numbers in the string, it returns an empty list.\n%\n% Example:\n% extract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\n% extract_numbers(\"no numbers\") returns []", "canonical_solution": "extract_numbers(String, [], []).\n\nextract_numbers([], CurrentNumber, Acc) when CurrentNumber =/= [] ->\nlists:reverse([list_to_integer(lists:reverse(CurrentNumber)) | Acc]);\nextract_numbers([], [], Acc) ->\nlists:reverse(Acc);\nextract_numbers([Char|Rest], CurrentNumber, Acc) when Char >= $0, Char =< $9 ->\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\nextract_numbers(Rest, [], Acc);\nextract_numbers([_|Rest], CurrentNumber, Acc) ->\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc]).", "test": "test() ->\n[123, 45, 6] = extract_numbers(\"abc123def45ghi6\"),\n[] = extract_numbers(\"no numbers\"),\n[2023] = extract_numbers(\"year2023\"),\n[1, 2, 3] = extract_numbers(\"1a2b3c\"),\n[] = extract_numbers(\"\"),\nok.", "module": "extract_numbers", "entry_point": "extract_numbers", "signature": "extract_numbers).-export([extract_numbers/1, test/0]).extract_numbers(String) ->", "docstring": "This function extracts all the numbers from a given string.\nThe numbers in the string are assumed to be non-negative integers separated by non-digit characters.\nThe function returns a list of integers found in the string.\nIf there are no numbers in the string, it returns an empty list.\n\nExample:\nextract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\nextract_numbers(\"no numbers\") returns []", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function extracts all the numbers from a given string.\nThe numbers in the string are assumed to be non-negative integers separated by non-digit characters.\nThe function returns a list of integers found in the string.\nIf there are no numbers in the string, it returns an empty list.\n\nExample:\nextract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\nextract_numbers(\"no numbers\") returns []\n\n* Incomplete Code:\nextract_numbers).-export([extract_numbers/1, test/0]).extract_numbers(String) ->\n[MASK]\n\nextract_numbers([], CurrentNumber, Acc) when CurrentNumber =/= [] ->\nlists:reverse([list_to_integer(lists:reverse(CurrentNumber)) | Acc]);\n[MASK]\nlists:reverse(Acc);\nextract_numbers([Char|Rest], CurrentNumber, Acc) when Char >= $0, Char =< $9 ->\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\n[MASK]\n[MASK]\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc]).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n\nextract_numbers([], CurrentNumber, Acc) when CurrentNumber =/= [] ->\nlists:reverse([list_to_integer(lists:reverse(CurrentNumber)) | Acc]);\n[MASK]\nlists:reverse(Acc);\nextract_numbers([Char|Rest], CurrentNumber, Acc) when Char >= $0, Char =< $9 ->\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\n[MASK]\n[MASK]\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc])."}
{"task_id": "Erlang/11-0-multi", "prompt": "-module(fibonacci).\n-export([fib/1, test/0]).\n\n% This function computes the Nth term of the Fibonacci sequence.\n% The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\n% usually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\n% This function takes an integer N and returns the Nth term of the Fibonacci sequence.\n%\n% Example:\n% fib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\n% fib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)", "canonical_solution": "fib(0) -> 0;\nfib(1) -> 1;\nfib(N) when N > 1 ->\nfib(N - 1) + fib(N - 2).", "test": "test() ->\n0 = fib(0),\n1 = fib(1),\n1 = fib(2),\n2 = fib(3),\n3 = fib(4),\n5 = fib(5),\n8 = fib(6),\n13 = fib(7),\n21 = fib(8),\n34 = fib(9),\n55 = fib(10),\nok.", "module": "fibonacci", "entry_point": "fib", "signature": "fib(n)->", "docstring": "This function computes the Nth term of the Fibonacci sequence.\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\nusually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\nThis function takes an integer N and returns the Nth term of the Fibonacci sequence.\n\nExample:\nfib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\nfib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function computes the Nth term of the Fibonacci sequence.\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\nusually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\nThis function takes an integer N and returns the Nth term of the Fibonacci sequence.\n\nExample:\nfib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\nfib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)\n\n* Incomplete Code:\nfib(n)->\n[MASK]\nfib(1) -> 1;\nfib(N) when N > 1 ->\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nfib(1) -> 1;\nfib(N) when N > 1 ->\n[MASK]"}
{"task_id": "Erlang/11-1-multi", "prompt": "-module(fibonacci).\n-export([fib/1, test/0]).\n\n% This function computes the Nth term of the Fibonacci sequence.\n% The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\n% usually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\n% This function takes an integer N and returns the Nth term of the Fibonacci sequence.\n%\n% Example:\n% fib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\n% fib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)", "canonical_solution": "fib(0) -> 0;\nfib(1) -> 1;\nfib(N) when N > 1 ->\nfib(N - 1) + fib(N - 2).", "test": "test() ->\n0 = fib(0),\n1 = fib(1),\n1 = fib(2),\n2 = fib(3),\n3 = fib(4),\n5 = fib(5),\n8 = fib(6),\n13 = fib(7),\n21 = fib(8),\n34 = fib(9),\n55 = fib(10),\nok.", "module": "fibonacci", "entry_point": "fib", "signature": "fib(n)->", "docstring": "This function computes the Nth term of the Fibonacci sequence.\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\nusually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\nThis function takes an integer N and returns the Nth term of the Fibonacci sequence.\n\nExample:\nfib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\nfib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function computes the Nth term of the Fibonacci sequence.\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\nusually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\nThis function takes an integer N and returns the Nth term of the Fibonacci sequence.\n\nExample:\nfib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\nfib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)\n\n* Incomplete Code:\nfib(n)->\nfib(0) -> 0;\nfib(1) -> 1;\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "fib(0) -> 0;\nfib(1) -> 1;\n[MASK]\n[MASK]"}
{"task_id": "Erlang/13-0-multi", "prompt": "-module(find_duplicates).\n-export([sorted_duplicates_in_list/1, test/0]).\n\n% Find all duplicate elements in a list and sort them in dictionary order.\n% >>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n% [1, 2]\n% >>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n% [\"apple\"]\nsorted_duplicates_in_list(List) ->", "canonical_solution": "Duplicates = duplicates_in_list_helper(List, []),\nlists:sort(Duplicates).\n\nduplicates_in_list_helper([], _) -> [];\nduplicates_in_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\nfalse -> duplicates_in_list_helper(T, [H|Checked])\nend.", "test": "test() ->\n[1, 2] = sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1]),\n[\"apple\"] = sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"]),\n[] = sorted_duplicates_in_list([1, 2, 3, 4, 5]),\nok.", "module": "find_duplicates", "entry_point": "sorted_duplicates_in_list", "signature": "sorted_duplicates_in_list(List) ->", "docstring": "Find all duplicate elements in a list and sort them in dictionary order.\n>>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n[1, 2]\n>>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n[\"apple\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind all duplicate elements in a list and sort them in dictionary order.\n>>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n[1, 2]\n>>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n[\"apple\"]\n\n\n* Incomplete Code:\nsorted_duplicates_in_list(List) ->\nDuplicates = duplicates_in_list_helper(List, []),\n[MASK]\n\nduplicates_in_list_helper([], _) -> [];\n[MASK]\n[MASK]\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "Duplicates = duplicates_in_list_helper(List, []),\n[MASK]\n\nduplicates_in_list_helper([], _) -> [];\n[MASK]\n[MASK]\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\n[MASK]\nend."}
{"task_id": "Erlang/13-1-multi", "prompt": "-module(find_duplicates).\n-export([sorted_duplicates_in_list/1, test/0]).\n\n% Find all duplicate elements in a list and sort them in dictionary order.\n% >>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n% [1, 2]\n% >>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n% [\"apple\"]\nsorted_duplicates_in_list(List) ->", "canonical_solution": "Duplicates = duplicates_in_list_helper(List, []),\nlists:sort(Duplicates).\n\nduplicates_in_list_helper([], _) -> [];\nduplicates_in_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\nfalse -> duplicates_in_list_helper(T, [H|Checked])\nend.", "test": "test() ->\n[1, 2] = sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1]),\n[\"apple\"] = sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"]),\n[] = sorted_duplicates_in_list([1, 2, 3, 4, 5]),\nok.", "module": "find_duplicates", "entry_point": "sorted_duplicates_in_list", "signature": "sorted_duplicates_in_list(List) ->", "docstring": "Find all duplicate elements in a list and sort them in dictionary order.\n>>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n[1, 2]\n>>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n[\"apple\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind all duplicate elements in a list and sort them in dictionary order.\n>>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n[1, 2]\n>>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n[\"apple\"]\n\n\n* Incomplete Code:\nsorted_duplicates_in_list(List) ->\nDuplicates = duplicates_in_list_helper(List, []),\nlists:sort(Duplicates).\n\nduplicates_in_list_helper([], _) -> [];\nduplicates_in_list_helper([H|T], Checked) ->\n[MASK]\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "Duplicates = duplicates_in_list_helper(List, []),\nlists:sort(Duplicates).\n\nduplicates_in_list_helper([], _) -> [];\nduplicates_in_list_helper([H|T], Checked) ->\n[MASK]\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\n[MASK]\nend."}
{"task_id": "Erlang/15-0-multi", "prompt": "-module(is_prefix).\n-export([is_prefix/2, test/0]).\n\n% Check if List1 is a prefix of List2.\n% >>> is_prefix([1, 2], [1, 2, 3, 4])\n% true\n% >>> is_prefix([1, 3], [1, 2, 3, 4])\n% false", "canonical_solution": "is_prefix([], _) -> true;\nis_prefix(_, []) -> false;\nis_prefix([H1|T1], [H2|T2]) ->\nH1 == H2 andalso is_prefix(T1, T2).", "test": "test() ->\ntrue = is_prefix([1, 2], [1, 2, 3, 4]),\nfalse = is_prefix([1, 3], [1, 2, 3, 4]),\ntrue = is_prefix([], [1, 2, 3, 4]),\nfalse = is_prefix([1, 2, 3, 4], [1, 2]),\ntrue = is_prefix([], []),\nfalse = is_prefix([1], []),\nok.", "module": "is_prefix", "entry_point": "is_prefix", "signature": "is_prefix()->", "docstring": "Check if List1 is a prefix of List2.\n>>> is_prefix([1, 2], [1, 2, 3, 4])\ntrue\n>>> is_prefix([1, 3], [1, 2, 3, 4])\nfalse", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if List1 is a prefix of List2.\n>>> is_prefix([1, 2], [1, 2, 3, 4])\ntrue\n>>> is_prefix([1, 3], [1, 2, 3, 4])\nfalse\n\n* Incomplete Code:\nis_prefix()->\nis_prefix([], _) -> true;\n[MASK]\n[MASK]\nH1 == H2 andalso is_prefix(T1, T2).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "is_prefix([], _) -> true;\n[MASK]\n[MASK]\nH1 == H2 andalso is_prefix(T1, T2)."}
{"task_id": "Erlang/15-1-multi", "prompt": "-module(is_prefix).\n-export([is_prefix/2, test/0]).\n\n% Check if List1 is a prefix of List2.\n% >>> is_prefix([1, 2], [1, 2, 3, 4])\n% true\n% >>> is_prefix([1, 3], [1, 2, 3, 4])\n% false", "canonical_solution": "is_prefix([], _) -> true;\nis_prefix(_, []) -> false;\nis_prefix([H1|T1], [H2|T2]) ->\nH1 == H2 andalso is_prefix(T1, T2).", "test": "test() ->\ntrue = is_prefix([1, 2], [1, 2, 3, 4]),\nfalse = is_prefix([1, 3], [1, 2, 3, 4]),\ntrue = is_prefix([], [1, 2, 3, 4]),\nfalse = is_prefix([1, 2, 3, 4], [1, 2]),\ntrue = is_prefix([], []),\nfalse = is_prefix([1], []),\nok.", "module": "is_prefix", "entry_point": "is_prefix", "signature": "is_prefix()->", "docstring": "Check if List1 is a prefix of List2.\n>>> is_prefix([1, 2], [1, 2, 3, 4])\ntrue\n>>> is_prefix([1, 3], [1, 2, 3, 4])\nfalse", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if List1 is a prefix of List2.\n>>> is_prefix([1, 2], [1, 2, 3, 4])\ntrue\n>>> is_prefix([1, 3], [1, 2, 3, 4])\nfalse\n\n* Incomplete Code:\nis_prefix()->\nis_prefix([], _) -> true;\n[MASK]\nis_prefix([H1|T1], [H2|T2]) ->\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "is_prefix([], _) -> true;\n[MASK]\nis_prefix([H1|T1], [H2|T2]) ->\n[MASK]"}
{"task_id": "Erlang/17-0-multi", "prompt": "-module(list_occurrence).\n-export([find_list_in_list/2, test/0]).\n\n% Check if list A appears in list B. If yes, return the starting position of A in B (0-based).\n% If not, return -1.\n% >>> find_list_in_list([2, 3], [1, 2, 3, 4])\n% 1\n% >>> find_list_in_list([3, 4, 5], [1, 2, 3])\n% -1\nfind_list_in_list(A, B) ->", "canonical_solution": "find_list_in_list_helper(A, B, 0).\n\nfind_list_in_list_helper(_, [], _) -> -1;\nfind_list_in_list_helper(A, B, Index) ->\ncase lists:prefix(A, B) of\ntrue -> Index;\nfalse -> find_list_in_list_helper(A, tl(B), Index + 1)\nend.", "test": "test() ->\n1 = find_list_in_list([2, 3], [1, 2, 3, 4]),\n-1 = find_list_in_list([3, 4, 5], [1, 2, 3]),\n-1 = find_list_in_list([1, 2, 3], []),\n0 = find_list_in_list([], [1, 2, 3]),\n-1 = find_list_in_list([1, 2, 3], [4, 5, 6]),\nok.", "module": "list_occurrence", "entry_point": "find_list_in_list", "signature": "find_list_in_list(A, B) ->", "docstring": "Check if list A appears in list B. If yes, return the starting position of A in B (0-based).\nIf not, return -1.\n>>> find_list_in_list([2, 3], [1, 2, 3, 4])\n1\n>>> find_list_in_list([3, 4, 5], [1, 2, 3])\n-1\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if list A appears in list B. If yes, return the starting position of A in B (0-based).\nIf not, return -1.\n>>> find_list_in_list([2, 3], [1, 2, 3, 4])\n1\n>>> find_list_in_list([3, 4, 5], [1, 2, 3])\n-1\n\n\n* Incomplete Code:\nfind_list_in_list(A, B) ->\n[MASK]\n\n[MASK]\nfind_list_in_list_helper(A, B, Index) ->\ncase lists:prefix(A, B) of\n[MASK]\nfalse -> find_list_in_list_helper(A, tl(B), Index + 1)\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n\n[MASK]\nfind_list_in_list_helper(A, B, Index) ->\ncase lists:prefix(A, B) of\n[MASK]\nfalse -> find_list_in_list_helper(A, tl(B), Index + 1)\nend."}
{"task_id": "Erlang/17-1-multi", "prompt": "-module(list_occurrence).\n-export([find_list_in_list/2, test/0]).\n\n% Check if list A appears in list B. If yes, return the starting position of A in B (0-based).\n% If not, return -1.\n% >>> find_list_in_list([2, 3], [1, 2, 3, 4])\n% 1\n% >>> find_list_in_list([3, 4, 5], [1, 2, 3])\n% -1\nfind_list_in_list(A, B) ->", "canonical_solution": "find_list_in_list_helper(A, B, 0).\n\nfind_list_in_list_helper(_, [], _) -> -1;\nfind_list_in_list_helper(A, B, Index) ->\ncase lists:prefix(A, B) of\ntrue -> Index;\nfalse -> find_list_in_list_helper(A, tl(B), Index + 1)\nend.", "test": "test() ->\n1 = find_list_in_list([2, 3], [1, 2, 3, 4]),\n-1 = find_list_in_list([3, 4, 5], [1, 2, 3]),\n-1 = find_list_in_list([1, 2, 3], []),\n0 = find_list_in_list([], [1, 2, 3]),\n-1 = find_list_in_list([1, 2, 3], [4, 5, 6]),\nok.", "module": "list_occurrence", "entry_point": "find_list_in_list", "signature": "find_list_in_list(A, B) ->", "docstring": "Check if list A appears in list B. If yes, return the starting position of A in B (0-based).\nIf not, return -1.\n>>> find_list_in_list([2, 3], [1, 2, 3, 4])\n1\n>>> find_list_in_list([3, 4, 5], [1, 2, 3])\n-1\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if list A appears in list B. If yes, return the starting position of A in B (0-based).\nIf not, return -1.\n>>> find_list_in_list([2, 3], [1, 2, 3, 4])\n1\n>>> find_list_in_list([3, 4, 5], [1, 2, 3])\n-1\n\n\n* Incomplete Code:\nfind_list_in_list(A, B) ->\nfind_list_in_list_helper(A, B, 0).\n\nfind_list_in_list_helper(_, [], _) -> -1;\n[MASK]\ncase lists:prefix(A, B) of\n[MASK]\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "find_list_in_list_helper(A, B, 0).\n\nfind_list_in_list_helper(_, [], _) -> -1;\n[MASK]\ncase lists:prefix(A, B) of\n[MASK]\n[MASK]\nend."}
{"task_id": "Erlang/20-0-multi", "prompt": "-module(prime_numbers).\n-export([get_prime/1, test/0]).\n\nget_prime(N) ->\n% This function calculates the number of prime numbers from 1 up to a given number N( excluding N).\n% A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n% The function takes an integer N and returns the number of prime numbers from 1 to N.\n%\n% Example:\n% primes_up_to(10) returns 4\n% primes_up_to(20) returns 8", "canonical_solution": "length(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \nRec =:= null ->\nget_prime(Seq + 1, N, List);\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\nfor_prime(Seq) ->\nSqrtValue = trunc(math:sqrt(Seq)),\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\nnull;\n\nfor_prime(Seq, [], _) ->\nSeq;\n\nfor_prime(_Seq, _, 0) ->\nnull;\n\nfor_prime(Seq, [Num | List], _) ->\nfor_prime(Seq, List, Seq rem Num).\n", "test": "test() ->\n0 = get_prime(2),\n1 = get_prime(3),\n4 = get_prime(10),\n8 = get_prime(20),\nok.", "module": "prime_numbers", "entry_point": "get_prime", "signature": "get_prime/1, test/0]).get_prime(N) ->", "docstring": "This function calculates the number of prime numbers from 1 up to a given number N( excluding N).\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\nThe function takes an integer N and returns the number of prime numbers from 1 to N.\n\nExample:\nprimes_up_to(10) returns 4\nprimes_up_to(20) returns 8", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of prime numbers from 1 up to a given number N( excluding N).\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\nThe function takes an integer N and returns the number of prime numbers from 1 to N.\n\nExample:\nprimes_up_to(10) returns 4\nprimes_up_to(20) returns 8\n\n* Incomplete Code:\nget_prime/1, test/0]).get_prime(N) ->\nlength(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \nRec =:= null ->\nget_prime(Seq + 1, N, List);\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\n[MASK]\n[MASK]\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\nnull;\n\nfor_prime(Seq, [], _) ->\nSeq;\n\nfor_prime(_Seq, _, 0) ->\nnull;\n\nfor_prime(Seq, [Num | List], _) ->\nfor_prime(Seq, List, Seq rem Num).\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "length(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \nRec =:= null ->\nget_prime(Seq + 1, N, List);\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\n[MASK]\n[MASK]\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\nnull;\n\nfor_prime(Seq, [], _) ->\nSeq;\n\nfor_prime(_Seq, _, 0) ->\nnull;\n\nfor_prime(Seq, [Num | List], _) ->\nfor_prime(Seq, List, Seq rem Num).\n"}
{"task_id": "Erlang/20-1-multi", "prompt": "-module(prime_numbers).\n-export([get_prime/1, test/0]).\n\nget_prime(N) ->\n% This function calculates the number of prime numbers from 1 up to a given number N( excluding N).\n% A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n% The function takes an integer N and returns the number of prime numbers from 1 to N.\n%\n% Example:\n% primes_up_to(10) returns 4\n% primes_up_to(20) returns 8", "canonical_solution": "length(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \nRec =:= null ->\nget_prime(Seq + 1, N, List);\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\nfor_prime(Seq) ->\nSqrtValue = trunc(math:sqrt(Seq)),\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\nnull;\n\nfor_prime(Seq, [], _) ->\nSeq;\n\nfor_prime(_Seq, _, 0) ->\nnull;\n\nfor_prime(Seq, [Num | List], _) ->\nfor_prime(Seq, List, Seq rem Num).\n", "test": "test() ->\n0 = get_prime(2),\n1 = get_prime(3),\n4 = get_prime(10),\n8 = get_prime(20),\nok.", "module": "prime_numbers", "entry_point": "get_prime", "signature": "get_prime/1, test/0]).get_prime(N) ->", "docstring": "This function calculates the number of prime numbers from 1 up to a given number N( excluding N).\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\nThe function takes an integer N and returns the number of prime numbers from 1 to N.\n\nExample:\nprimes_up_to(10) returns 4\nprimes_up_to(20) returns 8", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of prime numbers from 1 up to a given number N( excluding N).\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\nThe function takes an integer N and returns the number of prime numbers from 1 to N.\n\nExample:\nprimes_up_to(10) returns 4\nprimes_up_to(20) returns 8\n\n* Incomplete Code:\nget_prime/1, test/0]).get_prime(N) ->\nlength(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \n[MASK]\n[MASK]\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\n[MASK]\n[MASK]\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\nnull;\n\nfor_prime(Seq, [], _) ->\nSeq;\n\nfor_prime(_Seq, _, 0) ->\nnull;\n\nfor_prime(Seq, [Num | List], _) ->\nfor_prime(Seq, List, Seq rem Num).\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "length(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \n[MASK]\n[MASK]\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\n[MASK]\n[MASK]\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\nnull;\n\nfor_prime(Seq, [], _) ->\nSeq;\n\nfor_prime(_Seq, _, 0) ->\nnull;\n\nfor_prime(Seq, [Num | List], _) ->\nfor_prime(Seq, List, Seq rem Num).\n"}
{"task_id": "Erlang/21-0-multi", "prompt": "-module(quick_sort).\n-export([quick_sort/1, test/0]).\n\n% This function implements the Quick Sort algorithm to sort a list of integers.\n% Quick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\n% and partitions the other elements into two sub-arrays, according to whether they are less than\n% or greater than the pivot. The sub-arrays are then sorted recursively.\n% This function takes a list of integers and returns a sorted list.\n%\n% Example:\n% quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n% quick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]", "canonical_solution": "quick_sort([]) -> [];\nquick_sort([Pivot|Rest]) ->\n{Smaller, Greater} = partition(Rest, Pivot, [], []),\nquick_sort(Smaller) ++ [Pivot] ++ quick_sort(Greater).\n\npartition([], _, Smaller, Greater) -> {Smaller, Greater};\npartition([H|T], Pivot, Smaller, Greater) ->\nif\nH =< Pivot -> partition(T, Pivot, [H|Smaller], Greater);\nH > Pivot -> partition(T, Pivot, Smaller, [H|Greater])\nend.", "test": "test() ->\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] = quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]),\n[1, 2, 3, 4, 5] = quick_sort([5, 4, 3, 2, 1]),\n[] = quick_sort([]),\n[1] = quick_sort([1]),\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = quick_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]),\nok.", "module": "quick_sort", "entry_point": "quick_sort", "signature": "quick_sort() ->", "docstring": "This function implements the Quick Sort algorithm to sort a list of integers.\nQuick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\nand partitions the other elements into two sub-arrays, according to whether they are less than\nor greater than the pivot. The sub-arrays are then sorted recursively.\nThis function takes a list of integers and returns a sorted list.\n\nExample:\nquick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nquick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function implements the Quick Sort algorithm to sort a list of integers.\nQuick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\nand partitions the other elements into two sub-arrays, according to whether they are less than\nor greater than the pivot. The sub-arrays are then sorted recursively.\nThis function takes a list of integers and returns a sorted list.\n\nExample:\nquick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nquick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]\n\n* Incomplete Code:\nquick_sort() ->\n[MASK]\nquick_sort([Pivot|Rest]) ->\n{Smaller, Greater} = partition(Rest, Pivot, [], []),\n[MASK]\n\npartition([], _, Smaller, Greater) -> {Smaller, Greater};\npartition([H|T], Pivot, Smaller, Greater) ->\nif\n[MASK]\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\nquick_sort([Pivot|Rest]) ->\n{Smaller, Greater} = partition(Rest, Pivot, [], []),\n[MASK]\n\npartition([], _, Smaller, Greater) -> {Smaller, Greater};\npartition([H|T], Pivot, Smaller, Greater) ->\nif\n[MASK]\n[MASK]\nend."}
{"task_id": "Erlang/21-1-multi", "prompt": "-module(quick_sort).\n-export([quick_sort/1, test/0]).\n\n% This function implements the Quick Sort algorithm to sort a list of integers.\n% Quick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\n% and partitions the other elements into two sub-arrays, according to whether they are less than\n% or greater than the pivot. The sub-arrays are then sorted recursively.\n% This function takes a list of integers and returns a sorted list.\n%\n% Example:\n% quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n% quick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]", "canonical_solution": "quick_sort([]) -> [];\nquick_sort([Pivot|Rest]) ->\n{Smaller, Greater} = partition(Rest, Pivot, [], []),\nquick_sort(Smaller) ++ [Pivot] ++ quick_sort(Greater).\n\npartition([], _, Smaller, Greater) -> {Smaller, Greater};\npartition([H|T], Pivot, Smaller, Greater) ->\nif\nH =< Pivot -> partition(T, Pivot, [H|Smaller], Greater);\nH > Pivot -> partition(T, Pivot, Smaller, [H|Greater])\nend.", "test": "test() ->\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] = quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]),\n[1, 2, 3, 4, 5] = quick_sort([5, 4, 3, 2, 1]),\n[] = quick_sort([]),\n[1] = quick_sort([1]),\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = quick_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]),\nok.", "module": "quick_sort", "entry_point": "quick_sort", "signature": "quick_sort() ->", "docstring": "This function implements the Quick Sort algorithm to sort a list of integers.\nQuick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\nand partitions the other elements into two sub-arrays, according to whether they are less than\nor greater than the pivot. The sub-arrays are then sorted recursively.\nThis function takes a list of integers and returns a sorted list.\n\nExample:\nquick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nquick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function implements the Quick Sort algorithm to sort a list of integers.\nQuick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\nand partitions the other elements into two sub-arrays, according to whether they are less than\nor greater than the pivot. The sub-arrays are then sorted recursively.\nThis function takes a list of integers and returns a sorted list.\n\nExample:\nquick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nquick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]\n\n* Incomplete Code:\nquick_sort() ->\nquick_sort([]) -> [];\n[MASK]\n[MASK]\nquick_sort(Smaller) ++ [Pivot] ++ quick_sort(Greater).\n\n[MASK]\npartition([H|T], Pivot, Smaller, Greater) ->\nif\nH =< Pivot -> partition(T, Pivot, [H|Smaller], Greater);\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "quick_sort([]) -> [];\n[MASK]\n[MASK]\nquick_sort(Smaller) ++ [Pivot] ++ quick_sort(Greater).\n\n[MASK]\npartition([H|T], Pivot, Smaller, Greater) ->\nif\nH =< Pivot -> partition(T, Pivot, [H|Smaller], Greater);\n[MASK]\nend."}
{"task_id": "Erlang/23-0-multi", "prompt": "-module(remove_duplicates).\n-export([remove_duplicates_list/1, remove_duplicates_tuple/1, test/0]).\n\n% Remove all duplicate elements from a list.\n% >>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n% [1,2,3, 4, 5]\n% >>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n% [\"apple\",\"banana\", \"cherry\"]\nremove_duplicates_list(List) ->", "canonical_solution": "remove_duplicates_list_helper(List, []).\n\nremove_duplicates_list_helper([], _) -> [];\nremove_duplicates_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> remove_duplicates_list_helper(T, Checked);\nfalse -> [H | remove_duplicates_list_helper(T, [H|Checked])]\nend.\n\nremove_duplicates_tuple(Tuple) ->\nlist_to_tuple(remove_duplicates_list(tuple_to_list(Tuple))).", "test": "test() ->\n[1,2,3, 4, 5] = remove_duplicates_list([1, 2, 3, 2, 4, 5, 1]),\n[\"apple\",\"banana\", \"cherry\"] = remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"]),\n[] = remove_duplicates_list([]),\n{1,2,3, 4, 5} = remove_duplicates_tuple({1, 2, 3, 2, 4, 5, 1}),\n{\"apple\",\"banana\", \"cherry\"} = remove_duplicates_tuple({\"apple\", \"banana\", \"apple\", \"cherry\"}),\n{} = remove_duplicates_tuple({}),\nok.", "module": "remove_duplicates", "entry_point": "remove_duplicates_list", "signature": "remove_duplicates_list(List) ->", "docstring": "Remove all duplicate elements from a list.\n>>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n[1,2,3, 4, 5]\n>>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n[\"apple\",\"banana\", \"cherry\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nRemove all duplicate elements from a list.\n>>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n[1,2,3, 4, 5]\n>>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n[\"apple\",\"banana\", \"cherry\"]\n\n\n* Incomplete Code:\nremove_duplicates_list(List) ->\nremove_duplicates_list_helper(List, []).\n\nremove_duplicates_list_helper([], _) -> [];\n[MASK]\ncase lists:member(H, Checked) of\n[MASK]\nfalse -> [H | remove_duplicates_list_helper(T, [H|Checked])]\nend.\n\nremove_duplicates_tuple(Tuple) ->\nlist_to_tuple(remove_duplicates_list(tuple_to_list(Tuple))).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "remove_duplicates_list_helper(List, []).\n\nremove_duplicates_list_helper([], _) -> [];\n[MASK]\ncase lists:member(H, Checked) of\n[MASK]\nfalse -> [H | remove_duplicates_list_helper(T, [H|Checked])]\nend.\n\nremove_duplicates_tuple(Tuple) ->\nlist_to_tuple(remove_duplicates_list(tuple_to_list(Tuple)))."}
{"task_id": "Erlang/23-1-multi", "prompt": "-module(remove_duplicates).\n-export([remove_duplicates_list/1, remove_duplicates_tuple/1, test/0]).\n\n% Remove all duplicate elements from a list.\n% >>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n% [1,2,3, 4, 5]\n% >>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n% [\"apple\",\"banana\", \"cherry\"]\nremove_duplicates_list(List) ->", "canonical_solution": "remove_duplicates_list_helper(List, []).\n\nremove_duplicates_list_helper([], _) -> [];\nremove_duplicates_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> remove_duplicates_list_helper(T, Checked);\nfalse -> [H | remove_duplicates_list_helper(T, [H|Checked])]\nend.\n\nremove_duplicates_tuple(Tuple) ->\nlist_to_tuple(remove_duplicates_list(tuple_to_list(Tuple))).", "test": "test() ->\n[1,2,3, 4, 5] = remove_duplicates_list([1, 2, 3, 2, 4, 5, 1]),\n[\"apple\",\"banana\", \"cherry\"] = remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"]),\n[] = remove_duplicates_list([]),\n{1,2,3, 4, 5} = remove_duplicates_tuple({1, 2, 3, 2, 4, 5, 1}),\n{\"apple\",\"banana\", \"cherry\"} = remove_duplicates_tuple({\"apple\", \"banana\", \"apple\", \"cherry\"}),\n{} = remove_duplicates_tuple({}),\nok.", "module": "remove_duplicates", "entry_point": "remove_duplicates_list", "signature": "remove_duplicates_list(List) ->", "docstring": "Remove all duplicate elements from a list.\n>>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n[1,2,3, 4, 5]\n>>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n[\"apple\",\"banana\", \"cherry\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nRemove all duplicate elements from a list.\n>>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n[1,2,3, 4, 5]\n>>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n[\"apple\",\"banana\", \"cherry\"]\n\n\n* Incomplete Code:\nremove_duplicates_list(List) ->\nremove_duplicates_list_helper(List, []).\n\n[MASK]\nremove_duplicates_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> remove_duplicates_list_helper(T, Checked);\n[MASK]\nend.\n\nremove_duplicates_tuple(Tuple) ->\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "remove_duplicates_list_helper(List, []).\n\n[MASK]\nremove_duplicates_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> remove_duplicates_list_helper(T, Checked);\n[MASK]\nend.\n\nremove_duplicates_tuple(Tuple) ->\n[MASK]"}
{"task_id": "Erlang/28-0-multi", "prompt": "-module(sum_values_by_key).\n-export([sum_values_and_sort_keys/1, test/0]).\n\n% Sum the values of identical keys in a list of key-value pairs and sort the keys.\n% >>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n% [{a, 4}, {b, 2}]\n% >>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n% [{bar, 20}, {baz, 40}, {foo, 40}]\nsum_values_and_sort_keys(List) ->", "canonical_solution": "SortedDict = lists:foldl(fun({K, V}, Acc) ->\ndict:update(K, fun(OldV) -> OldV + V end, V, Acc)\nend, dict:new(), List),\nSortedList = dict:to_list(SortedDict),\nlists:sort(fun({K1, _}, {K2, _}) -> K1 < K2 end, SortedList).", "test": "test() ->\n[{a, 4}, {b, 2}] = sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}]),\n[{bar, 20}, {baz, 40}, {foo, 40}] = sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}]),\n[] = sum_values_and_sort_keys([]),\n[{x, 1}] = sum_values_and_sort_keys([{x, 1}]),\nok.", "module": "sum_values_by_key", "entry_point": "sum_values_and_sort_keys", "signature": "sum_values_and_sort_keys(List) ->", "docstring": "Sum the values of identical keys in a list of key-value pairs and sort the keys.\n>>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n[{a, 4}, {b, 2}]\n>>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n[{bar, 20}, {baz, 40}, {foo, 40}]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nSum the values of identical keys in a list of key-value pairs and sort the keys.\n>>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n[{a, 4}, {b, 2}]\n>>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n[{bar, 20}, {baz, 40}, {foo, 40}]\n\n\n* Incomplete Code:\nsum_values_and_sort_keys(List) ->\nSortedDict = lists:foldl(fun({K, V}, Acc) ->\n[MASK]\nend, dict:new(), List),\nSortedList = dict:to_list(SortedDict),\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "SortedDict = lists:foldl(fun({K, V}, Acc) ->\n[MASK]\nend, dict:new(), List),\nSortedList = dict:to_list(SortedDict),\n[MASK]"}
{"task_id": "Erlang/28-1-multi", "prompt": "-module(sum_values_by_key).\n-export([sum_values_and_sort_keys/1, test/0]).\n\n% Sum the values of identical keys in a list of key-value pairs and sort the keys.\n% >>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n% [{a, 4}, {b, 2}]\n% >>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n% [{bar, 20}, {baz, 40}, {foo, 40}]\nsum_values_and_sort_keys(List) ->", "canonical_solution": "SortedDict = lists:foldl(fun({K, V}, Acc) ->\ndict:update(K, fun(OldV) -> OldV + V end, V, Acc)\nend, dict:new(), List),\nSortedList = dict:to_list(SortedDict),\nlists:sort(fun({K1, _}, {K2, _}) -> K1 < K2 end, SortedList).", "test": "test() ->\n[{a, 4}, {b, 2}] = sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}]),\n[{bar, 20}, {baz, 40}, {foo, 40}] = sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}]),\n[] = sum_values_and_sort_keys([]),\n[{x, 1}] = sum_values_and_sort_keys([{x, 1}]),\nok.", "module": "sum_values_by_key", "entry_point": "sum_values_and_sort_keys", "signature": "sum_values_and_sort_keys(List) ->", "docstring": "Sum the values of identical keys in a list of key-value pairs and sort the keys.\n>>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n[{a, 4}, {b, 2}]\n>>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n[{bar, 20}, {baz, 40}, {foo, 40}]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nSum the values of identical keys in a list of key-value pairs and sort the keys.\n>>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n[{a, 4}, {b, 2}]\n>>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n[{bar, 20}, {baz, 40}, {foo, 40}]\n\n\n* Incomplete Code:\nsum_values_and_sort_keys(List) ->\n[MASK]\n[MASK]\nend, dict:new(), List),\nSortedList = dict:to_list(SortedDict),\nlists:sort(fun({K1, _}, {K2, _}) -> K1 < K2 end, SortedList).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\nend, dict:new(), List),\nSortedList = dict:to_list(SortedDict),\nlists:sort(fun({K1, _}, {K2, _}) -> K1 < K2 end, SortedList)."}
{"task_id": "Erlang/29-0-multi", "prompt": "-module(third_largest).\n-export([find_third_largest/1, test/0]).\n\n% Find the third largest number in a non-empty array.\n% If the third largest number does not exist, return the largest number.\n% >>> find_third_largest([2, 3, 1])\n% 1\n% >>> find_third_largest([9, 2, 3, 6])\n% 3\nfind_third_largest(Numbers) ->", "canonical_solution": "Sorted = lists:usort(Numbers),\ncase length(Sorted) of\nL when L >= 3 -> lists:nth(L - 2, Sorted);\n_ -> lists:last(Sorted)\nend.", "test": "test() ->\n1 = find_third_largest([2, 3, 1]),\n3 = find_third_largest([9, 2, 3, 6]),\n5 = find_third_largest([5]),\n7 = find_third_largest([7, 7, 7]),\nok.", "module": "third_largest", "entry_point": "find_third_largest", "signature": "find_third_largest(Numbers) ->", "docstring": "Find the third largest number in a non-empty array.\nIf the third largest number does not exist, return the largest number.\n>>> find_third_largest([2, 3, 1])\n1\n>>> find_third_largest([9, 2, 3, 6])\n3\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind the third largest number in a non-empty array.\nIf the third largest number does not exist, return the largest number.\n>>> find_third_largest([2, 3, 1])\n1\n>>> find_third_largest([9, 2, 3, 6])\n3\n\n\n* Incomplete Code:\nfind_third_largest(Numbers) ->\nSorted = lists:usort(Numbers),\ncase length(Sorted) of\n[MASK]\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Sorted = lists:usort(Numbers),\ncase length(Sorted) of\n[MASK]\n[MASK]\nend."}
{"task_id": "Erlang/29-1-multi", "prompt": "-module(third_largest).\n-export([find_third_largest/1, test/0]).\n\n% Find the third largest number in a non-empty array.\n% If the third largest number does not exist, return the largest number.\n% >>> find_third_largest([2, 3, 1])\n% 1\n% >>> find_third_largest([9, 2, 3, 6])\n% 3\nfind_third_largest(Numbers) ->", "canonical_solution": "Sorted = lists:usort(Numbers),\ncase length(Sorted) of\nL when L >= 3 -> lists:nth(L - 2, Sorted);\n_ -> lists:last(Sorted)\nend.", "test": "test() ->\n1 = find_third_largest([2, 3, 1]),\n3 = find_third_largest([9, 2, 3, 6]),\n5 = find_third_largest([5]),\n7 = find_third_largest([7, 7, 7]),\nok.", "module": "third_largest", "entry_point": "find_third_largest", "signature": "find_third_largest(Numbers) ->", "docstring": "Find the third largest number in a non-empty array.\nIf the third largest number does not exist, return the largest number.\n>>> find_third_largest([2, 3, 1])\n1\n>>> find_third_largest([9, 2, 3, 6])\n3\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind the third largest number in a non-empty array.\nIf the third largest number does not exist, return the largest number.\n>>> find_third_largest([2, 3, 1])\n1\n>>> find_third_largest([9, 2, 3, 6])\n3\n\n\n* Incomplete Code:\nfind_third_largest(Numbers) ->\n[MASK]\ncase length(Sorted) of\nL when L >= 3 -> lists:nth(L - 2, Sorted);\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\ncase length(Sorted) of\nL when L >= 3 -> lists:nth(L - 2, Sorted);\n[MASK]\nend."}
{"task_id": "Erlang/30-0-multi", "prompt": "-module(two_sum).\n-export([find_two_sum/2, test/0]).\n\n% Find two integers in the array nums that add up to the target value.\n% Returns the indices of the two numbers.\n% >>> find_two_sum([2, 7, 11, 15], 9)\n% {0, 1}\n% >>> find_two_sum([3, 2, 4], 6)\n% {1, 2}\nfind_two_sum(Nums, Target) ->", "canonical_solution": "find_two_sum_helper(Nums, Target, 0, dict:new()).\n\nfind_two_sum_helper([], _, _, _) -> not_found;\nfind_two_sum_helper([H|T], Target, Index, Dict) ->\ncase dict:find(Target - H, Dict) of\n{ok, OtherIndex} -> {OtherIndex, Index};\nerror -> find_two_sum_helper(T, Target, Index + 1, dict:store(H, Index, Dict))\nend.", "test": "test() ->\n{0, 1} = find_two_sum([2, 7, 11, 15], 9),\n{1, 2} = find_two_sum([3, 2, 4], 6),\nnot_found = find_two_sum([1, 2, 3], 7),\nok.", "module": "two_sum", "entry_point": "find_two_sum", "signature": "find_two_sum(Nums, Target) ->", "docstring": "Find two integers in the array nums that add up to the target value.\nReturns the indices of the two numbers.\n>>> find_two_sum([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_two_sum([3, 2, 4], 6)\n{1, 2}\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind two integers in the array nums that add up to the target value.\nReturns the indices of the two numbers.\n>>> find_two_sum([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_two_sum([3, 2, 4], 6)\n{1, 2}\n\n\n* Incomplete Code:\nfind_two_sum(Nums, Target) ->\n[MASK]\n\n[MASK]\nfind_two_sum_helper([H|T], Target, Index, Dict) ->\n[MASK]\n{ok, OtherIndex} -> {OtherIndex, Index};\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n\n[MASK]\nfind_two_sum_helper([H|T], Target, Index, Dict) ->\n[MASK]\n{ok, OtherIndex} -> {OtherIndex, Index};\n[MASK]\nend."}
{"task_id": "Erlang/30-1-multi", "prompt": "-module(two_sum).\n-export([find_two_sum/2, test/0]).\n\n% Find two integers in the array nums that add up to the target value.\n% Returns the indices of the two numbers.\n% >>> find_two_sum([2, 7, 11, 15], 9)\n% {0, 1}\n% >>> find_two_sum([3, 2, 4], 6)\n% {1, 2}\nfind_two_sum(Nums, Target) ->", "canonical_solution": "find_two_sum_helper(Nums, Target, 0, dict:new()).\n\nfind_two_sum_helper([], _, _, _) -> not_found;\nfind_two_sum_helper([H|T], Target, Index, Dict) ->\ncase dict:find(Target - H, Dict) of\n{ok, OtherIndex} -> {OtherIndex, Index};\nerror -> find_two_sum_helper(T, Target, Index + 1, dict:store(H, Index, Dict))\nend.", "test": "test() ->\n{0, 1} = find_two_sum([2, 7, 11, 15], 9),\n{1, 2} = find_two_sum([3, 2, 4], 6),\nnot_found = find_two_sum([1, 2, 3], 7),\nok.", "module": "two_sum", "entry_point": "find_two_sum", "signature": "find_two_sum(Nums, Target) ->", "docstring": "Find two integers in the array nums that add up to the target value.\nReturns the indices of the two numbers.\n>>> find_two_sum([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_two_sum([3, 2, 4], 6)\n{1, 2}\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind two integers in the array nums that add up to the target value.\nReturns the indices of the two numbers.\n>>> find_two_sum([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_two_sum([3, 2, 4], 6)\n{1, 2}\n\n\n* Incomplete Code:\nfind_two_sum(Nums, Target) ->\n[MASK]\n\nfind_two_sum_helper([], _, _, _) -> not_found;\n[MASK]\ncase dict:find(Target - H, Dict) of\n[MASK]\n[MASK]\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n\nfind_two_sum_helper([], _, _, _) -> not_found;\n[MASK]\ncase dict:find(Target - H, Dict) of\n[MASK]\n[MASK]\nend."}
{"task_id": "Erlang/34-0-multi", "prompt": "-module(binary_search).\n-export([search/2, test/0]).\n\nsearch(List, Target) ->\n% This function performs a binary search to find a target element within a sorted list.\n% The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n% until it finds the target or concludes the target is not in the list.\n%\n% Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n% Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n% or 'not_found' if the target is not in the list.\n%\n% Examples:\n% search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n% search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n% search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)", "canonical_solution": "    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n    not_found;\nsearch(List, Target, Start, End) ->\n    Mid = Start + ((End - Start) div 2),\n    MidValue = lists:nth(Mid, List),\n    case Target of\n        MidValue -> {found, Mid};\n        _ when Target < MidValue -> search(List, Target, Start, Mid - 1);\n        _ when Target > MidValue -> search(List, Target, Mid + 1, End)\n    end.", "test": "test() ->\n    {found, 3} = search([1, 2, 3, 4, 5], 3),\n    not_found = search([1, 2, 4, 5, 6], 3),\n    {found, 4} = search([10, 20, 30, 40, 50], 40),\n    {found, 1} = search([100], 100),\n    not_found = search([], 1),\n    ok.", "entry_point": "search", "signature": "search).-export([search/2, test/0]).search(List, Target) ->", "docstring": " This function performs a binary search to find a target element within a sorted list.\n The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n until it finds the target or concludes the target is not in the list.\n\n Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n or 'not_found' if the target is not in the list.\n\n Examples:\n search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)", "module": "binary_search", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function performs a binary search to find a target element within a sorted list.\n The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n until it finds the target or concludes the target is not in the list.\n\n Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n or 'not_found' if the target is not in the list.\n\n Examples:\n search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)\n\n* Incomplete Code:\nsearch).-export([search/2, test/0]).search(List, Target) ->\n    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n[MASK]\nsearch(List, Target, Start, End) ->\n[MASK]\n[MASK]\n    case Target of\n        MidValue -> {found, Mid};\n[MASK]\n        _ when Target > MidValue -> search(List, Target, Mid + 1, End)\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n[MASK]\nsearch(List, Target, Start, End) ->\n[MASK]\n[MASK]\n    case Target of\n        MidValue -> {found, Mid};\n[MASK]\n        _ when Target > MidValue -> search(List, Target, Mid + 1, End)\n    end."}
{"task_id": "Erlang/34-1-multi", "prompt": "-module(binary_search).\n-export([search/2, test/0]).\n\nsearch(List, Target) ->\n% This function performs a binary search to find a target element within a sorted list.\n% The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n% until it finds the target or concludes the target is not in the list.\n%\n% Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n% Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n% or 'not_found' if the target is not in the list.\n%\n% Examples:\n% search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n% search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n% search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)", "canonical_solution": "    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n    not_found;\nsearch(List, Target, Start, End) ->\n    Mid = Start + ((End - Start) div 2),\n    MidValue = lists:nth(Mid, List),\n    case Target of\n        MidValue -> {found, Mid};\n        _ when Target < MidValue -> search(List, Target, Start, Mid - 1);\n        _ when Target > MidValue -> search(List, Target, Mid + 1, End)\n    end.", "test": "test() ->\n    {found, 3} = search([1, 2, 3, 4, 5], 3),\n    not_found = search([1, 2, 4, 5, 6], 3),\n    {found, 4} = search([10, 20, 30, 40, 50], 40),\n    {found, 1} = search([100], 100),\n    not_found = search([], 1),\n    ok.", "entry_point": "search", "signature": "search).-export([search/2, test/0]).search(List, Target) ->", "docstring": " This function performs a binary search to find a target element within a sorted list.\n The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n until it finds the target or concludes the target is not in the list.\n\n Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n or 'not_found' if the target is not in the list.\n\n Examples:\n search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)", "module": "binary_search", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function performs a binary search to find a target element within a sorted list.\n The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n until it finds the target or concludes the target is not in the list.\n\n Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n or 'not_found' if the target is not in the list.\n\n Examples:\n search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)\n\n* Incomplete Code:\nsearch).-export([search/2, test/0]).search(List, Target) ->\n    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n    not_found;\nsearch(List, Target, Start, End) ->\n    Mid = Start + ((End - Start) div 2),\n[MASK]\n    case Target of\n[MASK]\n        _ when Target < MidValue -> search(List, Target, Start, Mid - 1);\n[MASK]\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n    not_found;\nsearch(List, Target, Start, End) ->\n    Mid = Start + ((End - Start) div 2),\n[MASK]\n    case Target of\n[MASK]\n        _ when Target < MidValue -> search(List, Target, Start, Mid - 1);\n[MASK]\n    end."}
{"task_id": "Erlang/37-0-multi", "prompt": "-module(fish_danger).\n-export([is_danger/2, test/0]).\n\nis_danger(S, X) ->\n% This function determines whether a fish swimming with an initial speed of 7 meters per second,\n% with its speed decreasing to 98% of its speed in the previous second, will be in danger.\n% The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n% to both sides) and not being able to exit that range within the next second.\n%\n% Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n% extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n%\n% Examples:\n% is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n% is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)", "canonical_solution": "    Danger_Start = S - X,\n    Danger_End = S + X,\n    check_danger(7, 0, Danger_Start, Danger_End).\n\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position >= Danger_Start, Position + Speed < Danger_End ->\n    'y';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position > Danger_End ->\n    'n';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) ->\n    NewSpeed = Speed * 0.98,\n    NewPosition = Position + Speed,\n    check_danger(NewSpeed, NewPosition, Danger_Start, Danger_End).", "test": "test() ->\n    'n' = is_danger(14, 1),\n    'n' = is_danger(20, 2),\n    'n' = is_danger(10, 1),\n    'n' = is_danger(14, 0.5),\n    'n' = is_danger(30, 3),\n    ok.", "entry_point": "is_danger", "signature": "is_danger/2, test/0]).is_danger(S, X) ->", "docstring": " This function determines whether a fish swimming with an initial speed of 7 meters per second,\n with its speed decreasing to 98 of its speed in the previous second, will be in danger.\n The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n to both sides) and not being able to exit that range within the next second.\n\n Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n\n Examples:\n is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)", "module": "fish_danger", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function determines whether a fish swimming with an initial speed of 7 meters per second,\n with its speed decreasing to 98 of its speed in the previous second, will be in danger.\n The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n to both sides) and not being able to exit that range within the next second.\n\n Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n\n Examples:\n is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)\n\n* Incomplete Code:\nis_danger/2, test/0]).is_danger(S, X) ->\n    Danger_Start = S - X,\n    Danger_End = S + X,\n[MASK]\n\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position >= Danger_Start, Position + Speed < Danger_End ->\n    'y';\n[MASK]\n    'n';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) ->\n[MASK]\n[MASK]\n    check_danger(NewSpeed, NewPosition, Danger_Start, Danger_End).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    Danger_Start = S - X,\n    Danger_End = S + X,\n[MASK]\n\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position >= Danger_Start, Position + Speed < Danger_End ->\n    'y';\n[MASK]\n    'n';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) ->\n[MASK]\n[MASK]\n    check_danger(NewSpeed, NewPosition, Danger_Start, Danger_End)."}
{"task_id": "Erlang/37-1-multi", "prompt": "-module(fish_danger).\n-export([is_danger/2, test/0]).\n\nis_danger(S, X) ->\n% This function determines whether a fish swimming with an initial speed of 7 meters per second,\n% with its speed decreasing to 98% of its speed in the previous second, will be in danger.\n% The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n% to both sides) and not being able to exit that range within the next second.\n%\n% Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n% extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n%\n% Examples:\n% is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n% is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)", "canonical_solution": "    Danger_Start = S - X,\n    Danger_End = S + X,\n    check_danger(7, 0, Danger_Start, Danger_End).\n\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position >= Danger_Start, Position + Speed < Danger_End ->\n    'y';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position > Danger_End ->\n    'n';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) ->\n    NewSpeed = Speed * 0.98,\n    NewPosition = Position + Speed,\n    check_danger(NewSpeed, NewPosition, Danger_Start, Danger_End).", "test": "test() ->\n    'n' = is_danger(14, 1),\n    'n' = is_danger(20, 2),\n    'n' = is_danger(10, 1),\n    'n' = is_danger(14, 0.5),\n    'n' = is_danger(30, 3),\n    ok.", "entry_point": "is_danger", "signature": "is_danger/2, test/0]).is_danger(S, X) ->", "docstring": " This function determines whether a fish swimming with an initial speed of 7 meters per second,\n with its speed decreasing to 98 of its speed in the previous second, will be in danger.\n The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n to both sides) and not being able to exit that range within the next second.\n\n Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n\n Examples:\n is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)", "module": "fish_danger", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function determines whether a fish swimming with an initial speed of 7 meters per second,\n with its speed decreasing to 98 of its speed in the previous second, will be in danger.\n The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n to both sides) and not being able to exit that range within the next second.\n\n Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n\n Examples:\n is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)\n\n* Incomplete Code:\nis_danger/2, test/0]).is_danger(S, X) ->\n[MASK]\n    Danger_End = S + X,\n[MASK]\n\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position >= Danger_Start, Position + Speed < Danger_End ->\n    'y';\n[MASK]\n    'n';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) ->\n[MASK]\n    NewPosition = Position + Speed,\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n    Danger_End = S + X,\n[MASK]\n\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position >= Danger_Start, Position + Speed < Danger_End ->\n    'y';\n[MASK]\n    'n';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) ->\n[MASK]\n    NewPosition = Position + Speed,\n[MASK]"}
{"task_id": "Erlang/39-0-multi", "prompt": "-module(int_bool_conversion).\n-export([convert/1, test/0]).\n\nconvert(Int) ->\n% This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n% In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n% Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n% and converting 0 will result in 0 (for false).\n%\n% Examples:\n% convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n% convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n% convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n% convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)", "canonical_solution": "    Bool = Int /= 0, % Convert integer to boolean\n    case Bool of\n        true -> 1;\n        false -> 0\n    end.", "test": "test() ->\n    1 = convert(3),\n    0 = convert(0),\n    1 = convert(-5),\n    1 = convert(100),\n    1 = convert(2),\n    ok.", "entry_point": "convert", "signature": "convert/1, test/0]).convert(Int) ->", "docstring": " This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n and converting 0 will result in 0 (for false).\n\n Examples:\n convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)", "module": "int_bool_conversion", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n and converting 0 will result in 0 (for false).\n\n Examples:\n convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)\n\n* Incomplete Code:\nconvert/1, test/0]).convert(Int) ->\n[MASK]\n[MASK]\n        true -> 1;\n        false -> 0\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n        true -> 1;\n        false -> 0\n    end."}
{"task_id": "Erlang/39-1-multi", "prompt": "-module(int_bool_conversion).\n-export([convert/1, test/0]).\n\nconvert(Int) ->\n% This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n% In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n% Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n% and converting 0 will result in 0 (for false).\n%\n% Examples:\n% convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n% convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n% convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n% convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)", "canonical_solution": "    Bool = Int /= 0, % Convert integer to boolean\n    case Bool of\n        true -> 1;\n        false -> 0\n    end.", "test": "test() ->\n    1 = convert(3),\n    0 = convert(0),\n    1 = convert(-5),\n    1 = convert(100),\n    1 = convert(2),\n    ok.", "entry_point": "convert", "signature": "convert/1, test/0]).convert(Int) ->", "docstring": " This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n and converting 0 will result in 0 (for false).\n\n Examples:\n convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)", "module": "int_bool_conversion", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n and converting 0 will result in 0 (for false).\n\n Examples:\n convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)\n\n* Incomplete Code:\nconvert/1, test/0]).convert(Int) ->\n[MASK]\n    case Bool of\n[MASK]\n        false -> 0\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n    case Bool of\n[MASK]\n        false -> 0\n    end."}
{"task_id": "Erlang/40-0-multi", "prompt": "-module(median_without_extremes).\n-export([median/1, test/0]).\n\nmedian(List) ->\n% This function calculates the median of a list after removing the maximum and minimum values.\n% It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n% If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n% If the list has an odd number of elements, the median is the middle element.\n%\n% Examples:\n% median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n% median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n% median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)", "canonical_solution": "    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(Sorted)),\n    Length = length(Trimmed),\n    case Length rem 2 of\n        0 -> % Even number of elements\n            Middle1 = lists:nth(Length div 2, Trimmed),\n            Middle2 = lists:nth((Length div 2) + 1, Trimmed),\n            (Middle1 + Middle2) / 2;\n        1 -> % Odd number of elements\n            lists:nth((Length div 2) + 1, Trimmed)\n    end.", "test": "test() ->\n    6 = median([10, 5, 1, 8, 7, 6, 2]),\n    3 = median([1, 2, 3, 4, 5]),\n    3.5 = median([10, 10, 5, 2, 2, 1]),\n    2 = median([1, 2, 3]),\n    4.5 = median([1, 2, 3, 4, 5, 6, 7, 8]),\n    ok.", "entry_point": "median", "signature": "median_without_extremes).-export([median/1, test/0]).median(List) ->", "docstring": " This function calculates the median of a list after removing the maximum and minimum values.\n It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n If the list has an odd number of elements, the median is the middle element.\n\n Examples:\n median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)", "module": "median_without_extremes", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the median of a list after removing the maximum and minimum values.\n It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n If the list has an odd number of elements, the median is the middle element.\n\n Examples:\n median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)\n\n* Incomplete Code:\nmedian_without_extremes).-export([median/1, test/0]).median(List) ->\n    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(Sorted)),\n    Length = length(Trimmed),\n[MASK]\n        0 -> % Even number of elements\n            Middle1 = lists:nth(Length div 2, Trimmed),\n[MASK]\n            (Middle1 + Middle2) / 2;\n[MASK]\n[MASK]\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(Sorted)),\n    Length = length(Trimmed),\n[MASK]\n        0 -> % Even number of elements\n            Middle1 = lists:nth(Length div 2, Trimmed),\n[MASK]\n            (Middle1 + Middle2) / 2;\n[MASK]\n[MASK]\n    end."}
{"task_id": "Erlang/40-1-multi", "prompt": "-module(median_without_extremes).\n-export([median/1, test/0]).\n\nmedian(List) ->\n% This function calculates the median of a list after removing the maximum and minimum values.\n% It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n% If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n% If the list has an odd number of elements, the median is the middle element.\n%\n% Examples:\n% median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n% median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n% median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)", "canonical_solution": "    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(Sorted)),\n    Length = length(Trimmed),\n    case Length rem 2 of\n        0 -> % Even number of elements\n            Middle1 = lists:nth(Length div 2, Trimmed),\n            Middle2 = lists:nth((Length div 2) + 1, Trimmed),\n            (Middle1 + Middle2) / 2;\n        1 -> % Odd number of elements\n            lists:nth((Length div 2) + 1, Trimmed)\n    end.", "test": "test() ->\n    6 = median([10, 5, 1, 8, 7, 6, 2]),\n    3 = median([1, 2, 3, 4, 5]),\n    3.5 = median([10, 10, 5, 2, 2, 1]),\n    2 = median([1, 2, 3]),\n    4.5 = median([1, 2, 3, 4, 5, 6, 7, 8]),\n    ok.", "entry_point": "median", "signature": "median_without_extremes).-export([median/1, test/0]).median(List) ->", "docstring": " This function calculates the median of a list after removing the maximum and minimum values.\n It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n If the list has an odd number of elements, the median is the middle element.\n\n Examples:\n median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)", "module": "median_without_extremes", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the median of a list after removing the maximum and minimum values.\n It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n If the list has an odd number of elements, the median is the middle element.\n\n Examples:\n median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)\n\n* Incomplete Code:\nmedian_without_extremes).-export([median/1, test/0]).median(List) ->\n    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(Sorted)),\n    Length = length(Trimmed),\n    case Length rem 2 of\n[MASK]\n[MASK]\n            Middle2 = lists:nth((Length div 2) + 1, Trimmed),\n[MASK]\n        1 -> % Odd number of elements\n            lists:nth((Length div 2) + 1, Trimmed)\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(Sorted)),\n    Length = length(Trimmed),\n    case Length rem 2 of\n[MASK]\n[MASK]\n            Middle2 = lists:nth((Length div 2) + 1, Trimmed),\n[MASK]\n        1 -> % Odd number of elements\n            lists:nth((Length div 2) + 1, Trimmed)\n    end."}
{"task_id": "Erlang/41-0-multi", "prompt": "-module(minimum_n).\n-export([find_min_n/1, test/0]).\n\nfind_min_n(K) ->\n% This function calculates the minimum value of n for which the sum\n% S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n% It iteratively adds terms of the harmonic series until the sum exceeds k.\n%\n% The input is a positive integer k, and the output is the minimum n\n% such that the sum of the harmonic series up to 1/n is greater than k.\n%\n% Examples:\n% find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n% find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n% find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n% find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)", "canonical_solution": "    find_min_n(1, 0, K).\n\nfind_min_n(N, Sum, K) when Sum > K ->\n    N-1;\nfind_min_n(N, Sum, K) ->\n    find_min_n(N + 1, Sum + 1/N, K).", "test": "test() ->\n    2 = find_min_n(1),\n    4 = find_min_n(2),\n    11 = find_min_n(3),\n    31 = find_min_n(4),\n    83 = find_min_n(5),\n    ok.", "entry_point": "find_min_n", "signature": "find_min_n/1, test/0]).find_min_n(K) ->", "docstring": " This function calculates the minimum value of n for which the sum\n S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n It iteratively adds terms of the harmonic series until the sum exceeds k.\n\n The input is a positive integer k, and the output is the minimum n\n such that the sum of the harmonic series up to 1/n is greater than k.\n\n Examples:\n find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)", "module": "minimum_n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the minimum value of n for which the sum\n S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n It iteratively adds terms of the harmonic series until the sum exceeds k.\n\n The input is a positive integer k, and the output is the minimum n\n such that the sum of the harmonic series up to 1/n is greater than k.\n\n Examples:\n find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)\n\n* Incomplete Code:\nfind_min_n/1, test/0]).find_min_n(K) ->\n[MASK]\n\n[MASK]\n    N-1;\n[MASK]\n    find_min_n(N + 1, Sum + 1/N, K).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n\n[MASK]\n    N-1;\n[MASK]\n    find_min_n(N + 1, Sum + 1/N, K)."}
{"task_id": "Erlang/41-1-multi", "prompt": "-module(minimum_n).\n-export([find_min_n/1, test/0]).\n\nfind_min_n(K) ->\n% This function calculates the minimum value of n for which the sum\n% S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n% It iteratively adds terms of the harmonic series until the sum exceeds k.\n%\n% The input is a positive integer k, and the output is the minimum n\n% such that the sum of the harmonic series up to 1/n is greater than k.\n%\n% Examples:\n% find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n% find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n% find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n% find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)", "canonical_solution": "    find_min_n(1, 0, K).\n\nfind_min_n(N, Sum, K) when Sum > K ->\n    N-1;\nfind_min_n(N, Sum, K) ->\n    find_min_n(N + 1, Sum + 1/N, K).", "test": "test() ->\n    2 = find_min_n(1),\n    4 = find_min_n(2),\n    11 = find_min_n(3),\n    31 = find_min_n(4),\n    83 = find_min_n(5),\n    ok.", "entry_point": "find_min_n", "signature": "find_min_n/1, test/0]).find_min_n(K) ->", "docstring": " This function calculates the minimum value of n for which the sum\n S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n It iteratively adds terms of the harmonic series until the sum exceeds k.\n\n The input is a positive integer k, and the output is the minimum n\n such that the sum of the harmonic series up to 1/n is greater than k.\n\n Examples:\n find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)", "module": "minimum_n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the minimum value of n for which the sum\n S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n It iteratively adds terms of the harmonic series until the sum exceeds k.\n\n The input is a positive integer k, and the output is the minimum n\n such that the sum of the harmonic series up to 1/n is greater than k.\n\n Examples:\n find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)\n\n* Incomplete Code:\nfind_min_n/1, test/0]).find_min_n(K) ->\n    find_min_n(1, 0, K).\n\n[MASK]\n    N-1;\n[MASK]\n    find_min_n(N + 1, Sum + 1/N, K).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    find_min_n(1, 0, K).\n\n[MASK]\n    N-1;\n[MASK]\n    find_min_n(N + 1, Sum + 1/N, K)."}
{"task_id": "Erlang/42-0-multi", "prompt": "-module(monotonic_list).\n-export([is_monotonic/1, test/0]).\n\n% This function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n% The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n%\n% Input: A list of integers.\n% Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n%\n% Examples:\n% is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n% is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n% is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n% is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)", "canonical_solution": "is_monotonic([]) -> true;\nis_monotonic([_]) -> true;\nis_monotonic([First, Second | Tail]) ->\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\ncheck_non_decreasing([_]) -> true;\ncheck_non_decreasing([First, Second | Tail]) ->\n    First =< Second andalso check_non_decreasing([Second | Tail]).\n\ncheck_non_increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\ncheck_non_increasing([First, Second | Tail]) ->\n    First >= Second andalso check_non_increasing([Second | Tail]).", "test": "test() ->\n    true = is_monotonic([1, 2, 2, 3]),\n    true = is_monotonic([3, 2, 1]),\n    false = is_monotonic([1, 3, 2]),\n    true = is_monotonic([10, 10, 10]),\n    true = is_monotonic([5]),\n    true = is_monotonic([]),\n    false = is_monotonic([1, 2, 3, 2, 4]),\n    ok.", "entry_point": "is_monotonic", "signature": "is_monotonic() ->", "docstring": "This function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n\n Input: A list of integers.\n Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n\n Examples:\n is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)", "module": "monotonic_list", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n\n Input: A list of integers.\n Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n\n Examples:\n is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)\n\n* Incomplete Code:\nis_monotonic() ->\nis_monotonic([]) -> true;\nis_monotonic([_]) -> true;\n[MASK]\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\n[MASK]\n[MASK]\n    First =< Second andalso check_non_decreasing([Second | Tail]).\n\ncheck_non_increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\ncheck_non_increasing([First, Second | Tail]) ->\n    First >= Second andalso check_non_increasing([Second | Tail]).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "is_monotonic([]) -> true;\nis_monotonic([_]) -> true;\n[MASK]\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\n[MASK]\n[MASK]\n    First =< Second andalso check_non_decreasing([Second | Tail]).\n\ncheck_non_increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\ncheck_non_increasing([First, Second | Tail]) ->\n    First >= Second andalso check_non_increasing([Second | Tail])."}
{"task_id": "Erlang/42-1-multi", "prompt": "-module(monotonic_list).\n-export([is_monotonic/1, test/0]).\n\n% This function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n% The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n%\n% Input: A list of integers.\n% Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n%\n% Examples:\n% is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n% is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n% is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n% is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)", "canonical_solution": "is_monotonic([]) -> true;\nis_monotonic([_]) -> true;\nis_monotonic([First, Second | Tail]) ->\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\ncheck_non_decreasing([_]) -> true;\ncheck_non_decreasing([First, Second | Tail]) ->\n    First =< Second andalso check_non_decreasing([Second | Tail]).\n\ncheck_non_increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\ncheck_non_increasing([First, Second | Tail]) ->\n    First >= Second andalso check_non_increasing([Second | Tail]).", "test": "test() ->\n    true = is_monotonic([1, 2, 2, 3]),\n    true = is_monotonic([3, 2, 1]),\n    false = is_monotonic([1, 3, 2]),\n    true = is_monotonic([10, 10, 10]),\n    true = is_monotonic([5]),\n    true = is_monotonic([]),\n    false = is_monotonic([1, 2, 3, 2, 4]),\n    ok.", "entry_point": "is_monotonic", "signature": "is_monotonic() ->", "docstring": "This function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n\n Input: A list of integers.\n Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n\n Examples:\n is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)", "module": "monotonic_list", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n\n Input: A list of integers.\n Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n\n Examples:\n is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)\n\n* Incomplete Code:\nis_monotonic() ->\nis_monotonic([]) -> true;\nis_monotonic([_]) -> true;\nis_monotonic([First, Second | Tail]) ->\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\ncheck_non_decreasing([_]) -> true;\ncheck_non_decreasing([First, Second | Tail]) ->\n[MASK]\n\ncheck_non_increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "is_monotonic([]) -> true;\nis_monotonic([_]) -> true;\nis_monotonic([First, Second | Tail]) ->\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\ncheck_non_decreasing([_]) -> true;\ncheck_non_decreasing([First, Second | Tail]) ->\n[MASK]\n\ncheck_non_increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\n[MASK]\n[MASK]"}
{"task_id": "Erlang/47-0-multi", "prompt": "-module(reverse_number).\n-export([reverse/1, test/0]).\n\nreverse(N) ->\n% This function reverses a three-digit number.\n% It takes a three-digit number N as input and returns its reverse.\n% The function handles numbers with leading zeros by ensuring the output is properly formatted\n% as a three-digit number, including those zeros.\n%\n% Examples:\n% reverse(123) returns 321\n% reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n% reverse(205) returns 502\n% reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n% reverse(050) returns 5 (as 050 -> 5 in integer format)", "canonical_solution": "    Hundreds = N div 100,\n    Tens = (N div 10) rem 10,\n    Ones = N rem 10,\n    Ones * 100 + Tens * 10 + Hundreds.", "test": "test() ->\n    321 = reverse(123),\n    1 = reverse(100), % Note: Erlang integers do not preserve leading zeros\n    502 = reverse(205),\n    98 = reverse(890), % Note: Erlang integers do not preserve leading zeros\n    50 = reverse(050), % Note: Erlang integers do not preserve leading zeros, 050 is equivalent to 50 in Erlang\n    ok.", "entry_point": "reverse", "signature": "reverse_number).-export([reverse/1, test/0]).reverse(N) ->", "docstring": " This function reverses a three-digit number.\n It takes a three-digit number N as input and returns its reverse.\n The function handles numbers with leading zeros by ensuring the output is properly formatted\n as a three-digit number, including those zeros.\n\n Examples:\n reverse(123) returns 321\n reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(205) returns 502\n reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(050) returns 5 (as 050 -> 5 in integer format)", "module": "reverse_number", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function reverses a three-digit number.\n It takes a three-digit number N as input and returns its reverse.\n The function handles numbers with leading zeros by ensuring the output is properly formatted\n as a three-digit number, including those zeros.\n\n Examples:\n reverse(123) returns 321\n reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(205) returns 502\n reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(050) returns 5 (as 050 -> 5 in integer format)\n\n* Incomplete Code:\nreverse_number).-export([reverse/1, test/0]).reverse(N) ->\n    Hundreds = N div 100,\n[MASK]\n    Ones = N rem 10,\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    Hundreds = N div 100,\n[MASK]\n    Ones = N rem 10,\n[MASK]"}
{"task_id": "Erlang/47-1-multi", "prompt": "-module(reverse_number).\n-export([reverse/1, test/0]).\n\nreverse(N) ->\n% This function reverses a three-digit number.\n% It takes a three-digit number N as input and returns its reverse.\n% The function handles numbers with leading zeros by ensuring the output is properly formatted\n% as a three-digit number, including those zeros.\n%\n% Examples:\n% reverse(123) returns 321\n% reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n% reverse(205) returns 502\n% reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n% reverse(050) returns 5 (as 050 -> 5 in integer format)", "canonical_solution": "    Hundreds = N div 100,\n    Tens = (N div 10) rem 10,\n    Ones = N rem 10,\n    Ones * 100 + Tens * 10 + Hundreds.", "test": "test() ->\n    321 = reverse(123),\n    1 = reverse(100), % Note: Erlang integers do not preserve leading zeros\n    502 = reverse(205),\n    98 = reverse(890), % Note: Erlang integers do not preserve leading zeros\n    50 = reverse(050), % Note: Erlang integers do not preserve leading zeros, 050 is equivalent to 50 in Erlang\n    ok.", "entry_point": "reverse", "signature": "reverse_number).-export([reverse/1, test/0]).reverse(N) ->", "docstring": " This function reverses a three-digit number.\n It takes a three-digit number N as input and returns its reverse.\n The function handles numbers with leading zeros by ensuring the output is properly formatted\n as a three-digit number, including those zeros.\n\n Examples:\n reverse(123) returns 321\n reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(205) returns 502\n reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(050) returns 5 (as 050 -> 5 in integer format)", "module": "reverse_number", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function reverses a three-digit number.\n It takes a three-digit number N as input and returns its reverse.\n The function handles numbers with leading zeros by ensuring the output is properly formatted\n as a three-digit number, including those zeros.\n\n Examples:\n reverse(123) returns 321\n reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(205) returns 502\n reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(050) returns 5 (as 050 -> 5 in integer format)\n\n* Incomplete Code:\nreverse_number).-export([reverse/1, test/0]).reverse(N) ->\n[MASK]\n    Tens = (N div 10) rem 10,\n    Ones = N rem 10,\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n    Tens = (N div 10) rem 10,\n    Ones = N rem 10,\n[MASK]"}
{"task_id": "Erlang/48-0-multi", "prompt": "-module(swimming_distance).\n-export([total_swim_distance/2, test/0]).\n\ntotal_swim_distance(X, N) ->\n% This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n% Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n% it returns the cumulative distance swum by the fish.\n%\n% The fish does not swim on weekends (Saturday and Sunday).\n%\n% Examples:\n% total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n% total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n% total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n% total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)", "canonical_solution": "    DaysSwum = lists:foldl(fun(Day, Acc) ->\n                               case (Day rem 7) of\n                                   6 -> Acc; % Saturday\n                                   0 -> Acc; % Sunday\n                                   _ -> Acc + 1\n                               end\n                           end, 0, lists:seq(X, X + N - 1)),\n    DaysSwum * 250.", "test": "test() ->\n    2000 = total_swim_distance(3, 10),\n    1250 = total_swim_distance(6, 7),\n    2500 = total_swim_distance(1, 14),\n    500 = total_swim_distance(7, 3),\n    1000 = total_swim_distance(5, 5),\n    ok.", "entry_point": "total_swim_distance", "signature": "total_swim_distance/2, test/0]).total_swim_distance(X, N) ->", "docstring": " This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n it returns the cumulative distance swum by the fish.\n\n The fish does not swim on weekends (Saturday and Sunday).\n\n Examples:\n total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)", "module": "swimming_distance", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n it returns the cumulative distance swum by the fish.\n\n The fish does not swim on weekends (Saturday and Sunday).\n\n Examples:\n total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)\n\n* Incomplete Code:\ntotal_swim_distance/2, test/0]).total_swim_distance(X, N) ->\n    DaysSwum = lists:foldl(fun(Day, Acc) ->\n                               case (Day rem 7) of\n[MASK]\n[MASK]\n[MASK]\n                               end\n                           end, 0, lists:seq(X, X + N - 1)),\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    DaysSwum = lists:foldl(fun(Day, Acc) ->\n                               case (Day rem 7) of\n[MASK]\n[MASK]\n[MASK]\n                               end\n                           end, 0, lists:seq(X, X + N - 1)),\n[MASK]"}
{"task_id": "Erlang/48-1-multi", "prompt": "-module(swimming_distance).\n-export([total_swim_distance/2, test/0]).\n\ntotal_swim_distance(X, N) ->\n% This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n% Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n% it returns the cumulative distance swum by the fish.\n%\n% The fish does not swim on weekends (Saturday and Sunday).\n%\n% Examples:\n% total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n% total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n% total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n% total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)", "canonical_solution": "    DaysSwum = lists:foldl(fun(Day, Acc) ->\n                               case (Day rem 7) of\n                                   6 -> Acc; % Saturday\n                                   0 -> Acc; % Sunday\n                                   _ -> Acc + 1\n                               end\n                           end, 0, lists:seq(X, X + N - 1)),\n    DaysSwum * 250.", "test": "test() ->\n    2000 = total_swim_distance(3, 10),\n    1250 = total_swim_distance(6, 7),\n    2500 = total_swim_distance(1, 14),\n    500 = total_swim_distance(7, 3),\n    1000 = total_swim_distance(5, 5),\n    ok.", "entry_point": "total_swim_distance", "signature": "total_swim_distance/2, test/0]).total_swim_distance(X, N) ->", "docstring": " This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n it returns the cumulative distance swum by the fish.\n\n The fish does not swim on weekends (Saturday and Sunday).\n\n Examples:\n total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)", "module": "swimming_distance", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n it returns the cumulative distance swum by the fish.\n\n The fish does not swim on weekends (Saturday and Sunday).\n\n Examples:\n total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)\n\n* Incomplete Code:\ntotal_swim_distance/2, test/0]).total_swim_distance(X, N) ->\n[MASK]\n[MASK]\n[MASK]\n                                   0 -> Acc; % Sunday\n                                   _ -> Acc + 1\n                               end\n                           end, 0, lists:seq(X, X + N - 1)),\n    DaysSwum * 250.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n[MASK]\n                                   0 -> Acc; % Sunday\n                                   _ -> Acc + 1\n                               end\n                           end, 0, lists:seq(X, X + N - 1)),\n    DaysSwum * 250."}
{"task_id": "Erlang/49-0-multi", "prompt": "-module(swimming_steps).\n-export([calculate_steps/1, test/0]).\n\ncalculate_steps(S) ->\n% This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n% Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98% of the distance of the previous step.\n% The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n% and returns the number of steps required.\n%\n% Examples:\n% calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n% calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).", "canonical_solution": "calculate_steps(Distance, Target, Steps, Speed) when Distance >= Target ->\n    Steps;\ncalculate_steps(Distance, Target, Steps, Speed) ->\n    NextDistance = Speed * 0.98,\n    calculate_steps(Distance + NextDistance, Target, Steps + 1,NextDistance).", "test": "test() ->\n    3 = calculate_steps(4.3),\n    1 = calculate_steps(2.0),\n    4 = calculate_steps(6),\n    ok.", "entry_point": "calculate_steps", "signature": "calculate_steps/1, test/0]).calculate_steps(S) ->", "docstring": " This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98 of the distance of the previous step.\n The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n and returns the number of steps required.\n\n Examples:\n calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).", "module": "swimming_steps", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98 of the distance of the previous step.\n The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n and returns the number of steps required.\n\n Examples:\n calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).\n\n* Incomplete Code:\ncalculate_steps/1, test/0]).calculate_steps(S) ->\n[MASK]\n    Steps;\n[MASK]\n    NextDistance = Speed * 0.98,\n    calculate_steps(Distance + NextDistance, Target, Steps + 1,NextDistance).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n    Steps;\n[MASK]\n    NextDistance = Speed * 0.98,\n    calculate_steps(Distance + NextDistance, Target, Steps + 1,NextDistance)."}
{"task_id": "Erlang/49-1-multi", "prompt": "-module(swimming_steps).\n-export([calculate_steps/1, test/0]).\n\ncalculate_steps(S) ->\n% This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n% Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98% of the distance of the previous step.\n% The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n% and returns the number of steps required.\n%\n% Examples:\n% calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n% calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).", "canonical_solution": "calculate_steps(Distance, Target, Steps, Speed) when Distance >= Target ->\n    Steps;\ncalculate_steps(Distance, Target, Steps, Speed) ->\n    NextDistance = Speed * 0.98,\n    calculate_steps(Distance + NextDistance, Target, Steps + 1,NextDistance).", "test": "test() ->\n    3 = calculate_steps(4.3),\n    1 = calculate_steps(2.0),\n    4 = calculate_steps(6),\n    ok.", "entry_point": "calculate_steps", "signature": "calculate_steps/1, test/0]).calculate_steps(S) ->", "docstring": " This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98 of the distance of the previous step.\n The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n and returns the number of steps required.\n\n Examples:\n calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).", "module": "swimming_steps", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98 of the distance of the previous step.\n The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n and returns the number of steps required.\n\n Examples:\n calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).\n\n* Incomplete Code:\ncalculate_steps/1, test/0]).calculate_steps(S) ->\ncalculate_steps(Distance, Target, Steps, Speed) when Distance >= Target ->\n[MASK]\ncalculate_steps(Distance, Target, Steps, Speed) ->\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "calculate_steps(Distance, Target, Steps, Speed) when Distance >= Target ->\n[MASK]\ncalculate_steps(Distance, Target, Steps, Speed) ->\n[MASK]\n[MASK]"}
{"task_id": "Erlang/50-0-multi", "prompt": "-module(swimming_time).\n-export([calculate_time/4, test/0]).\n\ncalculate_time(A, B, C, D) ->\n% This function calculates the total swimming time for a fish, given the start and end times.\n% The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n% The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n%\n% Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n% The output is the total time spent swimming, formatted as hours and minutes.\n%\n% Examples:\n% calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n% calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n% calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)", "canonical_solution": "    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n    TotalMinutes = EndMinutes - StartMinutes,\n    Hours = TotalMinutes div 60,\n    Minutes = TotalMinutes rem 60,\n    {Hours, Minutes}.", "test": "test() ->\n    {6, 20} = calculate_time(12, 50, 19, 10),\n    {1, 15} = calculate_time(9, 30, 10, 45),\n    {8, 20} = calculate_time(14, 55, 23, 15),\n    {0, 45} = calculate_time(0, 15, 1, 0),\n    {23, 45} = calculate_time(0, 0, 23, 45),\n    ok.", "entry_point": "calculate_time", "signature": "calculate_time/4, test/0]).calculate_time(A, B, C, D) ->", "docstring": " This function calculates the total swimming time for a fish, given the start and end times.\n The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n\n Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n The output is the total time spent swimming, formatted as hours and minutes.\n\n Examples:\n calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)", "module": "swimming_time", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the total swimming time for a fish, given the start and end times.\n The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n\n Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n The output is the total time spent swimming, formatted as hours and minutes.\n\n Examples:\n calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)\n\n* Incomplete Code:\ncalculate_time/4, test/0]).calculate_time(A, B, C, D) ->\n    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n[MASK]\n    Hours = TotalMinutes div 60,\n    Minutes = TotalMinutes rem 60,\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n[MASK]\n    Hours = TotalMinutes div 60,\n    Minutes = TotalMinutes rem 60,\n[MASK]"}
{"task_id": "Erlang/50-1-multi", "prompt": "-module(swimming_time).\n-export([calculate_time/4, test/0]).\n\ncalculate_time(A, B, C, D) ->\n% This function calculates the total swimming time for a fish, given the start and end times.\n% The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n% The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n%\n% Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n% The output is the total time spent swimming, formatted as hours and minutes.\n%\n% Examples:\n% calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n% calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n% calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)", "canonical_solution": "    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n    TotalMinutes = EndMinutes - StartMinutes,\n    Hours = TotalMinutes div 60,\n    Minutes = TotalMinutes rem 60,\n    {Hours, Minutes}.", "test": "test() ->\n    {6, 20} = calculate_time(12, 50, 19, 10),\n    {1, 15} = calculate_time(9, 30, 10, 45),\n    {8, 20} = calculate_time(14, 55, 23, 15),\n    {0, 45} = calculate_time(0, 15, 1, 0),\n    {23, 45} = calculate_time(0, 0, 23, 45),\n    ok.", "entry_point": "calculate_time", "signature": "calculate_time/4, test/0]).calculate_time(A, B, C, D) ->", "docstring": " This function calculates the total swimming time for a fish, given the start and end times.\n The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n\n Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n The output is the total time spent swimming, formatted as hours and minutes.\n\n Examples:\n calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)", "module": "swimming_time", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the total swimming time for a fish, given the start and end times.\n The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n\n Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n The output is the total time spent swimming, formatted as hours and minutes.\n\n Examples:\n calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)\n\n* Incomplete Code:\ncalculate_time/4, test/0]).calculate_time(A, B, C, D) ->\n    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n[MASK]\n    Hours = TotalMinutes div 60,\n[MASK]\n    {Hours, Minutes}.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n[MASK]\n    Hours = TotalMinutes div 60,\n[MASK]\n    {Hours, Minutes}."}
