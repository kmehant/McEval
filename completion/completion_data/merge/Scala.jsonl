{"task_id": "Scala/1-0-single", "prompt": "object Main extends App {\n\n  /**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n  */\n  def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "canonical_solution": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }", "test": "// Test cases\n  def test(): Unit = {\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n  }\n\n  // Run the test\n  test()\n}", "entry_point": "hasCloseElements", "signature": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n\n* Incomplete Code:\ndef hasCloseElements(numbers: List[Double], threshold: Double): Boolean =\n{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n[MASK]\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n[MASK]\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }"}
{"task_id": "Scala/1-1-single", "prompt": "object Main extends App {\n\n  /**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n  */\n  def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "canonical_solution": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }", "test": "// Test cases\n  def test(): Unit = {\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n  }\n\n  // Run the test\n  test()\n}", "entry_point": "hasCloseElements", "signature": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n\n* Incomplete Code:\ndef hasCloseElements(numbers: List[Double], threshold: Double): Boolean =\n{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n[MASK]\n      }\n    }\n    false\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n[MASK]\n      }\n    }\n    false\n  }"}
{"task_id": "Scala/2-0-single", "prompt": "object Solution {\n  /**\n    * Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n    *\n    * A subarray is defined as a contiguous sequence of numbers in an array.\n    *\n    * An ascending subarray is a subarray where the numbers are in strictly increasing order.\n    *\n    * Example:\n    * maxAscendingSum(Array(10,20,30,5,10,50))\n    * Output: 65\n    */\n  def maxAscendingSum(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(maxAscendingSum(Array(1, 2, 3, 4, 5, 6)) == 21)\n    assert(maxAscendingSum(Array(10, 20, 30, 40, 50, 5, 6, 7, 8, 9)) == 150)\n    assert(maxAscendingSum(Array(100, 200, 300, 400, 500, 1, 2, 3, 4, 5)) == 1500)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxAscendingSum", "signature": "def maxAscendingSum(nums: Array[Int]): Int =", "docstring": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65\n\n* Incomplete Code:\ndef maxAscendingSum(nums: Array[Int]): Int =\n  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n[MASK]\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n[MASK]\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }"}
{"task_id": "Scala/2-1-single", "prompt": "object Solution {\n  /**\n    * Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n    *\n    * A subarray is defined as a contiguous sequence of numbers in an array.\n    *\n    * An ascending subarray is a subarray where the numbers are in strictly increasing order.\n    *\n    * Example:\n    * maxAscendingSum(Array(10,20,30,5,10,50))\n    * Output: 65\n    */\n  def maxAscendingSum(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(maxAscendingSum(Array(1, 2, 3, 4, 5, 6)) == 21)\n    assert(maxAscendingSum(Array(10, 20, 30, 40, 50, 5, 6, 7, 8, 9)) == 150)\n    assert(maxAscendingSum(Array(100, 200, 300, 400, 500, 1, 2, 3, 4, 5)) == 1500)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxAscendingSum", "signature": "def maxAscendingSum(nums: Array[Int]): Int =", "docstring": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65\n\n* Incomplete Code:\ndef maxAscendingSum(nums: Array[Int]): Int =\n  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n[MASK]\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n[MASK]\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }"}
{"task_id": "Scala/4-0-single", "prompt": "import scala.collection.mutable.ArrayBuffer\nobject Solution {\n    /**\n    * Find the most competitive subsequence of length k from the given integer array.\n    *\n    * @param nums The integer array.\n    * @param k The length of the subsequence.\n    * @return The most competitive subsequence.\n    *\n    * Example:\n    * mostCompetitive(Array(3, 5, 2, 6), 2)\n    * Output: Array(2, 6)\n    */\n  def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = ", "canonical_solution": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }", "test": "        def main(args: Array[String]): Unit = {\n            assert(mostCompetitive(Array(3, 5, 2, 6), 2).sameElements(Array(2, 6)))\n            assert(mostCompetitive(Array(2, 4, 3, 3, 5, 4, 9, 6), 4).sameElements(Array(2, 3, 3, 4)))\n            assert(mostCompetitive(Array(6, 7, 5, 3, 5, 6, 4, 2), 3).sameElements(Array(3, 4, 2)))\n            println(\"All tests passed\")\n        }\n    }", "entry_point": "mostCompetitive", "signature": "def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =", "docstring": "Find the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)\n\n* Incomplete Code:\ndef mostCompetitive(nums: Array[Int], k: Int): Array[Int] =\n  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n[MASK]\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n[MASK]\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }"}
{"task_id": "Scala/4-1-single", "prompt": "import scala.collection.mutable.ArrayBuffer\nobject Solution {\n    /**\n    * Find the most competitive subsequence of length k from the given integer array.\n    *\n    * @param nums The integer array.\n    * @param k The length of the subsequence.\n    * @return The most competitive subsequence.\n    *\n    * Example:\n    * mostCompetitive(Array(3, 5, 2, 6), 2)\n    * Output: Array(2, 6)\n    */\n  def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = ", "canonical_solution": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }", "test": "        def main(args: Array[String]): Unit = {\n            assert(mostCompetitive(Array(3, 5, 2, 6), 2).sameElements(Array(2, 6)))\n            assert(mostCompetitive(Array(2, 4, 3, 3, 5, 4, 9, 6), 4).sameElements(Array(2, 3, 3, 4)))\n            assert(mostCompetitive(Array(6, 7, 5, 3, 5, 6, 4, 2), 3).sameElements(Array(3, 4, 2)))\n            println(\"All tests passed\")\n        }\n    }", "entry_point": "mostCompetitive", "signature": "def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =", "docstring": "Find the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)\n\n* Incomplete Code:\ndef mostCompetitive(nums: Array[Int], k: Int): Array[Int] =\n  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n[MASK]\n        }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n[MASK]\n        }"}
{"task_id": "Scala/5-0-single", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n    /**\n      * Generate all possible palindrome strings by rearranging the characters in the input string.\n      *\n      * @param s The input string.\n      * @return A list of all possible palindrome strings, without duplicates.\n      *\n      * Example:\n      * generatePalindromes(\"aabb\")\n      * Output: List(\"abba\", \"baab\")\n      */\n  def generatePalindromes(s: String): List[String] = ", "canonical_solution": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val result1 = generatePalindromes(\"aabb\")\n    assert(result1.contains(\"abba\"))\n    assert(result1.contains(\"baab\"))\n    \n    val result2 = generatePalindromes(\"abc\")\n    assert(result2.isEmpty)\n\n    val result3 = generatePalindromes(\"aabbc\")\n    assert(result3.contains(\"abcba\"))\n    assert(result3.contains(\"bacab\"))\n    \n    println(\"All tests passed\")\n}\n    \n}", "entry_point": "generatePalindromes", "signature": "def generatePalindromes(s: String): List[String] =", "docstring": "Generate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")\n\n* Incomplete Code:\ndef generatePalindromes(s: String): List[String] =\n  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n[MASK]\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n[MASK]\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }"}
{"task_id": "Scala/5-1-single", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n    /**\n      * Generate all possible palindrome strings by rearranging the characters in the input string.\n      *\n      * @param s The input string.\n      * @return A list of all possible palindrome strings, without duplicates.\n      *\n      * Example:\n      * generatePalindromes(\"aabb\")\n      * Output: List(\"abba\", \"baab\")\n      */\n  def generatePalindromes(s: String): List[String] = ", "canonical_solution": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val result1 = generatePalindromes(\"aabb\")\n    assert(result1.contains(\"abba\"))\n    assert(result1.contains(\"baab\"))\n    \n    val result2 = generatePalindromes(\"abc\")\n    assert(result2.isEmpty)\n\n    val result3 = generatePalindromes(\"aabbc\")\n    assert(result3.contains(\"abcba\"))\n    assert(result3.contains(\"bacab\"))\n    \n    println(\"All tests passed\")\n}\n    \n}", "entry_point": "generatePalindromes", "signature": "def generatePalindromes(s: String): List[String] =", "docstring": "Generate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")\n\n* Incomplete Code:\ndef generatePalindromes(s: String): List[String] =\n  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n[MASK]\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n[MASK]\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }"}
{"task_id": "Scala/6-0-single", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n    /**\n      * Find the value of the bottom-most left node in a binary tree.\n      *\n      * @param root The root node of the binary tree.\n      * @return The value of the bottom-most left node.\n      *\n      * Example:\n      * findBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\n      * Output: 1\n      *\n      * findBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\n      * Output: 7\n      */\n  def findBottomLeftValue(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2)\n    root1.left = new TreeNode(1)\n    root1.right = new TreeNode(3)\n    assert(findBottomLeftValue(root1) == 1)\n\n    // Test Case 2\n    val root2 = new TreeNode(1)\n    root2.left = new TreeNode(2)\n    root2.left.left = new TreeNode(4)\n    root2.right = new TreeNode(3)\n    root2.right.left = new TreeNode(5)\n    root2.right.left.left = new TreeNode(7)\n    root2.right.left.right = new TreeNode(6)\n    assert(findBottomLeftValue(root2) == 7)\n\n    // Test Case 3\n    val root3 = new TreeNode(5)\n    root3.left = new TreeNode(3)\n    root3.right = new TreeNode(6)\n    root3.left.left = new TreeNode(2)\n    root3.left.right = new TreeNode(4)\n    root3.left.left.left = new TreeNode(1)\n    assert(findBottomLeftValue(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findBottomLeftValue", "signature": "def findBottomLeftValue(root: TreeNode): Int =", "docstring": "Find the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7\n\n* Incomplete Code:\ndef findBottomLeftValue(root: TreeNode): Int =\n  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n[MASK]\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n[MASK]\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }"}
{"task_id": "Scala/6-1-single", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n    /**\n      * Find the value of the bottom-most left node in a binary tree.\n      *\n      * @param root The root node of the binary tree.\n      * @return The value of the bottom-most left node.\n      *\n      * Example:\n      * findBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\n      * Output: 1\n      *\n      * findBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\n      * Output: 7\n      */\n  def findBottomLeftValue(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2)\n    root1.left = new TreeNode(1)\n    root1.right = new TreeNode(3)\n    assert(findBottomLeftValue(root1) == 1)\n\n    // Test Case 2\n    val root2 = new TreeNode(1)\n    root2.left = new TreeNode(2)\n    root2.left.left = new TreeNode(4)\n    root2.right = new TreeNode(3)\n    root2.right.left = new TreeNode(5)\n    root2.right.left.left = new TreeNode(7)\n    root2.right.left.right = new TreeNode(6)\n    assert(findBottomLeftValue(root2) == 7)\n\n    // Test Case 3\n    val root3 = new TreeNode(5)\n    root3.left = new TreeNode(3)\n    root3.right = new TreeNode(6)\n    root3.left.left = new TreeNode(2)\n    root3.left.right = new TreeNode(4)\n    root3.left.left.left = new TreeNode(1)\n    assert(findBottomLeftValue(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findBottomLeftValue", "signature": "def findBottomLeftValue(root: TreeNode): Int =", "docstring": "Find the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7\n\n* Incomplete Code:\ndef findBottomLeftValue(root: TreeNode): Int =\n  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n[MASK]\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n[MASK]\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }"}
{"task_id": "Scala/7-0-single", "prompt": "// Definition for a binary tree node.\ncase class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Determine whether a binary tree is a valid binary search tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a valid binary search tree, false otherwise.\n    *\n    * Example:\n    * isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\n    * isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n    */\n  def isValidBST(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2, new TreeNode(1), new TreeNode(3))\n    assert(isValidBST(root1), \"Test Case 1 Failed\")\n\n    // Test Case 2\n    val root2 = new TreeNode(5, new TreeNode(1), new TreeNode(4, new TreeNode(3), new TreeNode(6)))\n    assert(!isValidBST(root2), \"Test Case 2 Failed\")\n\n    // Test Case 3\n    val root3 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(5))\n    assert(isValidBST(root3), \"Test Case 3 Failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isValidBST", "signature": "def isValidBST(root: TreeNode): Boolean =", "docstring": "Determine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n\n* Incomplete Code:\ndef isValidBST(root: TreeNode): Boolean =\n  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n[MASK]\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n[MASK]\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }"}
{"task_id": "Scala/7-1-single", "prompt": "// Definition for a binary tree node.\ncase class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Determine whether a binary tree is a valid binary search tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a valid binary search tree, false otherwise.\n    *\n    * Example:\n    * isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\n    * isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n    */\n  def isValidBST(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2, new TreeNode(1), new TreeNode(3))\n    assert(isValidBST(root1), \"Test Case 1 Failed\")\n\n    // Test Case 2\n    val root2 = new TreeNode(5, new TreeNode(1), new TreeNode(4, new TreeNode(3), new TreeNode(6)))\n    assert(!isValidBST(root2), \"Test Case 2 Failed\")\n\n    // Test Case 3\n    val root3 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(5))\n    assert(isValidBST(root3), \"Test Case 3 Failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isValidBST", "signature": "def isValidBST(root: TreeNode): Boolean =", "docstring": "Determine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n\n* Incomplete Code:\ndef isValidBST(root: TreeNode): Boolean =\n  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n[MASK]\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n[MASK]\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }"}
{"task_id": "Scala/8-0-single", "prompt": "object Solution {\n    /**\n     * Find all the numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * @param nums An array containing n integers.\n     * @return An array of numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * Example:\n     * findDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\n     * Output: Array(5,6)\n     *\n     * findDisappearedNumbers(Array(1,1))\n     * Output: Array(2)\n     */\n  def findDisappearedNumbers(nums: Array[Int]): List[Int] = ", "canonical_solution": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(4, 3, 2, 7, 8, 2, 3, 1)\n    val result1 = findDisappearedNumbers(nums1)\n    assert(result1.contains(5))\n    assert(result1.contains(6))\n\n    val nums2 = Array(1, 1)\n    val result2 = findDisappearedNumbers(nums2)\n    assert(result2.contains(2))\n\n    val nums3 = Array(2, 2, 2, 2, 2)\n    val result3 = findDisappearedNumbers(nums3)\n    assert(result3.contains(1))\n    assert(result3.contains(3))\n    assert(result3.contains(4))\n    assert(result3.contains(5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findDisappearedNumbers", "signature": "def findDisappearedNumbers(nums: Array[Int]): List[Int] =", "docstring": "Find all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)\n\n* Incomplete Code:\ndef findDisappearedNumbers(nums: Array[Int]): List[Int] =\n  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n[MASK]\n  }"}
{"task_id": "Scala/8-1-single", "prompt": "object Solution {\n    /**\n     * Find all the numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * @param nums An array containing n integers.\n     * @return An array of numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * Example:\n     * findDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\n     * Output: Array(5,6)\n     *\n     * findDisappearedNumbers(Array(1,1))\n     * Output: Array(2)\n     */\n  def findDisappearedNumbers(nums: Array[Int]): List[Int] = ", "canonical_solution": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(4, 3, 2, 7, 8, 2, 3, 1)\n    val result1 = findDisappearedNumbers(nums1)\n    assert(result1.contains(5))\n    assert(result1.contains(6))\n\n    val nums2 = Array(1, 1)\n    val result2 = findDisappearedNumbers(nums2)\n    assert(result2.contains(2))\n\n    val nums3 = Array(2, 2, 2, 2, 2)\n    val result3 = findDisappearedNumbers(nums3)\n    assert(result3.contains(1))\n    assert(result3.contains(3))\n    assert(result3.contains(4))\n    assert(result3.contains(5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findDisappearedNumbers", "signature": "def findDisappearedNumbers(nums: Array[Int]): List[Int] =", "docstring": "Find all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)\n\n* Incomplete Code:\ndef findDisappearedNumbers(nums: Array[Int]): List[Int] =\n  {\n\n[MASK]\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/9-0-single", "prompt": "object Solution {\n  /**\n    * Given an integer n, returns an array consisting of n unique integers that add up to 0.\n    *\n    * @param n The number of integers in the array.\n    * @return An array of n unique integers that add up to 0.\n    *\n    * Example:\n    * sumZero(5)\n    * Output: [-7, -1, 1, 3, 4]\n    *\n    * Note:\n    * Other valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n    */\n  def sumZero(n: Int): Array[Int] = ", "canonical_solution": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }", "test": "  \n  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val result1 = sumZero(4)\n    assert(result1.sameElements(Array(1, 2, 3, -6)))\n    \n    // Test case 2\n    val result2 = sumZero(6)\n    assert(result2.sameElements(Array(1, 2, 3, 4, 5, -15)))\n    \n    // Test case 3\n    val result3 = sumZero(8)\n    assert(result3.sameElements(Array(1, 2, 3, 4, 5, 6, 7, -28)))\n    \n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "sumZero", "signature": "def sumZero(n: Int): Array[Int] =", "docstring": "Given an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n\n* Incomplete Code:\ndef sumZero(n: Int): Array[Int] =\n  {\n\n    // function implementation goes here\n[MASK]\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // function implementation goes here\n[MASK]\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }"}
{"task_id": "Scala/9-1-single", "prompt": "object Solution {\n  /**\n    * Given an integer n, returns an array consisting of n unique integers that add up to 0.\n    *\n    * @param n The number of integers in the array.\n    * @return An array of n unique integers that add up to 0.\n    *\n    * Example:\n    * sumZero(5)\n    * Output: [-7, -1, 1, 3, 4]\n    *\n    * Note:\n    * Other valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n    */\n  def sumZero(n: Int): Array[Int] = ", "canonical_solution": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }", "test": "  \n  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val result1 = sumZero(4)\n    assert(result1.sameElements(Array(1, 2, 3, -6)))\n    \n    // Test case 2\n    val result2 = sumZero(6)\n    assert(result2.sameElements(Array(1, 2, 3, 4, 5, -15)))\n    \n    // Test case 3\n    val result3 = sumZero(8)\n    assert(result3.sameElements(Array(1, 2, 3, 4, 5, 6, 7, -28)))\n    \n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "sumZero", "signature": "def sumZero(n: Int): Array[Int] =", "docstring": "Given an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n\n* Incomplete Code:\ndef sumZero(n: Int): Array[Int] =\n  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n[MASK]\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n[MASK]\n    result\n  }"}
{"task_id": "Scala/11-0-single", "prompt": "\nobject Solution {\n  /**\n    * Calculate the total amount of water that can be trapped between the given heights.\n    *\n    * @param height An array representing the heights of each bar.\n    * @return The total amount of water that can be trapped.\n    *\n    * Example:\n    * trap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\n    * Output: 6\n    *\n    * Explanation:\n    * The heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n    */\n  def trap(height: Array[Int]): Int = ", "canonical_solution": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(trap(Array(1, 0, 2, 0, 1)) == 2)\n    assert(trap(Array(3, 2, 1, 0, 1, 2, 3)) == 9)\n    assert(trap(Array(2, 1, 4, 3, 1, 2)) == 2)\n\n    println(\"All tests passed\")\n  }\n}\n      ", "entry_point": "trap", "signature": "def trap(height: Array[Int]): Int =", "docstring": "Calculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n\n* Incomplete Code:\ndef trap(height: Array[Int]): Int =\n  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n[MASK]\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n[MASK]\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }"}
{"task_id": "Scala/11-1-single", "prompt": "\nobject Solution {\n  /**\n    * Calculate the total amount of water that can be trapped between the given heights.\n    *\n    * @param height An array representing the heights of each bar.\n    * @return The total amount of water that can be trapped.\n    *\n    * Example:\n    * trap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\n    * Output: 6\n    *\n    * Explanation:\n    * The heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n    */\n  def trap(height: Array[Int]): Int = ", "canonical_solution": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(trap(Array(1, 0, 2, 0, 1)) == 2)\n    assert(trap(Array(3, 2, 1, 0, 1, 2, 3)) == 9)\n    assert(trap(Array(2, 1, 4, 3, 1, 2)) == 2)\n\n    println(\"All tests passed\")\n  }\n}\n      ", "entry_point": "trap", "signature": "def trap(height: Array[Int]): Int =", "docstring": "Calculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n\n* Incomplete Code:\ndef trap(height: Array[Int]): Int =\n  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n[MASK]\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n[MASK]\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }"}
{"task_id": "Scala/12-0-single", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n  /**\n    * Remove the minimum number of invalid parentheses from the given string to make it valid.\n    *\n    * @param s The input string containing parentheses and letters.\n    * @return A list of all possible valid strings after removing invalid parentheses.\n    *\n    * Example:\n    * removeInvalidParentheses(\"()())()\")\n    * Output: List(\"(())()\", \"()()()\")\n    */\n  def removeInvalidParentheses(s: String): List[String] = ", "canonical_solution": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test 1\n    val result1 = removeInvalidParentheses(\"()())()\")\n    assert(result1.contains(\"(())()\"))\n    assert(result1.contains(\"()()()\"))\n\n    // Test 2\n    val result2 = removeInvalidParentheses(\"(a)())()\")\n    assert(result2.contains(\"(a())()\"))\n    assert(result2.contains(\"(a)()()\"))\n\n    // Test 3\n    val result3 = removeInvalidParentheses(\")(\")\n    assert(result3.contains(\"\"))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeInvalidParentheses", "signature": "def removeInvalidParentheses(s: String): List[String] =", "docstring": "Remove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")\n\n* Incomplete Code:\ndef removeInvalidParentheses(s: String): List[String] =\n  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n[MASK]\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n[MASK]\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }"}
{"task_id": "Scala/12-1-single", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n  /**\n    * Remove the minimum number of invalid parentheses from the given string to make it valid.\n    *\n    * @param s The input string containing parentheses and letters.\n    * @return A list of all possible valid strings after removing invalid parentheses.\n    *\n    * Example:\n    * removeInvalidParentheses(\"()())()\")\n    * Output: List(\"(())()\", \"()()()\")\n    */\n  def removeInvalidParentheses(s: String): List[String] = ", "canonical_solution": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test 1\n    val result1 = removeInvalidParentheses(\"()())()\")\n    assert(result1.contains(\"(())()\"))\n    assert(result1.contains(\"()()()\"))\n\n    // Test 2\n    val result2 = removeInvalidParentheses(\"(a)())()\")\n    assert(result2.contains(\"(a())()\"))\n    assert(result2.contains(\"(a)()()\"))\n\n    // Test 3\n    val result3 = removeInvalidParentheses(\")(\")\n    assert(result3.contains(\"\"))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeInvalidParentheses", "signature": "def removeInvalidParentheses(s: String): List[String] =", "docstring": "Remove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")\n\n* Incomplete Code:\ndef removeInvalidParentheses(s: String): List[String] =\n  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n[MASK]\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n[MASK]\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }"}
{"task_id": "Scala/13-0-single", "prompt": "case class TreeNode(var value: Int, var left: Option[TreeNode] = None, var right: Option[TreeNode] = None)\nobject Solution {\n\n    /**\n     * Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n     *\n     * @param root The root node of the binary search tree.\n     * @return The minimum difference between any two different nodes values.\n     *\n     * Example:\n     * minDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\n     * Output: 1\n     */\n  def minDiffInBST(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val root = TreeNode(5, Some(TreeNode(3)), Some(TreeNode(7)))\n    root.left.get.left = Some(TreeNode(2))\n    root.left.get.right = Some(TreeNode(4))\n    root.right.get.left = Some(TreeNode(6))\n    root.right.get.right = Some(TreeNode(8))\n\n    assert(minDiffInBST(root) == 1)\n\n    val root2 = TreeNode(8, Some(TreeNode(4)), Some(TreeNode(12)))\n    root2.left.get.left = Some(TreeNode(2))\n    root2.left.get.right = Some(TreeNode(6))\n    root2.right.get.left = Some(TreeNode(10))\n    root2.right.get.right = Some(TreeNode(14))\n\n    assert(minDiffInBST(root2) == 2)\n\n    val root3 = TreeNode(1)\n    root3.right = Some(TreeNode(3))\n    root3.right.get.right = Some(TreeNode(6))\n    root3.right.get.right.get.left = Some(TreeNode(4))\n\n    assert(minDiffInBST(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minDiffInBST", "signature": "def minDiffInBST(root: TreeNode): Int =", "docstring": "Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1\n\n* Incomplete Code:\ndef minDiffInBST(root: TreeNode): Int =\n  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n[MASK]\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n[MASK]\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }"}
{"task_id": "Scala/13-1-single", "prompt": "case class TreeNode(var value: Int, var left: Option[TreeNode] = None, var right: Option[TreeNode] = None)\nobject Solution {\n\n    /**\n     * Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n     *\n     * @param root The root node of the binary search tree.\n     * @return The minimum difference between any two different nodes values.\n     *\n     * Example:\n     * minDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\n     * Output: 1\n     */\n  def minDiffInBST(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val root = TreeNode(5, Some(TreeNode(3)), Some(TreeNode(7)))\n    root.left.get.left = Some(TreeNode(2))\n    root.left.get.right = Some(TreeNode(4))\n    root.right.get.left = Some(TreeNode(6))\n    root.right.get.right = Some(TreeNode(8))\n\n    assert(minDiffInBST(root) == 1)\n\n    val root2 = TreeNode(8, Some(TreeNode(4)), Some(TreeNode(12)))\n    root2.left.get.left = Some(TreeNode(2))\n    root2.left.get.right = Some(TreeNode(6))\n    root2.right.get.left = Some(TreeNode(10))\n    root2.right.get.right = Some(TreeNode(14))\n\n    assert(minDiffInBST(root2) == 2)\n\n    val root3 = TreeNode(1)\n    root3.right = Some(TreeNode(3))\n    root3.right.get.right = Some(TreeNode(6))\n    root3.right.get.right.get.left = Some(TreeNode(4))\n\n    assert(minDiffInBST(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minDiffInBST", "signature": "def minDiffInBST(root: TreeNode): Int =", "docstring": "Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1\n\n* Incomplete Code:\ndef minDiffInBST(root: TreeNode): Int =\n  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n[MASK]\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n[MASK]\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }"}
{"task_id": "Scala/14-0-single", "prompt": "object Solution {\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n  /**\n    * Find the maximum depth of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The maximum depth of the binary tree.\n    *\n    * Example:\n    * maxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: 3\n    */\n  def maxDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    val root1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    val root2 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), null)))\n    val root3 = TreeNode(10, null, null)\n\n    assert(maxDepth(root1) == 3)\n    assert(maxDepth(root2) == 4)\n    assert(maxDepth(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxDepth", "signature": "def maxDepth(root: TreeNode): Int =", "docstring": "Find the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3\n\n* Incomplete Code:\ndef maxDepth(root: TreeNode): Int =\n  {\n\n[MASK]\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n"}
{"task_id": "Scala/14-1-single", "prompt": "object Solution {\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n  /**\n    * Find the maximum depth of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The maximum depth of the binary tree.\n    *\n    * Example:\n    * maxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: 3\n    */\n  def maxDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    val root1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    val root2 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), null)))\n    val root3 = TreeNode(10, null, null)\n\n    assert(maxDepth(root1) == 3)\n    assert(maxDepth(root2) == 4)\n    assert(maxDepth(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxDepth", "signature": "def maxDepth(root: TreeNode): Int =", "docstring": "Find the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3\n\n* Incomplete Code:\ndef maxDepth(root: TreeNode): Int =\n  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n[MASK]\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n[MASK]\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n"}
{"task_id": "Scala/15-0-single", "prompt": "object Solution {\n    /**\n    * Check if a string is a k-palindrome.\n    *\n    * A k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n    *\n    * @param s The input string.\n    * @param k The maximum number of characters that can be removed.\n    * @return True if the string is a k-palindrome, otherwise false.\n    *\n    * Example:\n    * isKPalindrome(\"abcdeca\", 2)\n    * Output: true\n    *\n    * isKPalindrome(\"abbababa\", 1)\n    * Output: true\n    */\n  def isKPalindrome(s: String, k: Int): Boolean = ", "canonical_solution": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(isKPalindrome(\"abcdeca\", 2) == true)\n    assert(isKPalindrome(\"abbababa\", 1) == true)\n    assert(isKPalindrome(\"abcdefg\", 3) == false)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isKPalindrome", "signature": "def isKPalindrome(s: String, k: Int): Boolean =", "docstring": "Check if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true\n\n* Incomplete Code:\ndef isKPalindrome(s: String, k: Int): Boolean =\n  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n[MASK]\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n[MASK]\n    }\n  }"}
{"task_id": "Scala/15-1-single", "prompt": "object Solution {\n    /**\n    * Check if a string is a k-palindrome.\n    *\n    * A k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n    *\n    * @param s The input string.\n    * @param k The maximum number of characters that can be removed.\n    * @return True if the string is a k-palindrome, otherwise false.\n    *\n    * Example:\n    * isKPalindrome(\"abcdeca\", 2)\n    * Output: true\n    *\n    * isKPalindrome(\"abbababa\", 1)\n    * Output: true\n    */\n  def isKPalindrome(s: String, k: Int): Boolean = ", "canonical_solution": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(isKPalindrome(\"abcdeca\", 2) == true)\n    assert(isKPalindrome(\"abbababa\", 1) == true)\n    assert(isKPalindrome(\"abcdefg\", 3) == false)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isKPalindrome", "signature": "def isKPalindrome(s: String, k: Int): Boolean =", "docstring": "Check if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true\n\n* Incomplete Code:\ndef isKPalindrome(s: String, k: Int): Boolean =\n  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n[MASK]\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n[MASK]\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }"}
{"task_id": "Scala/16-0-single", "prompt": "object Solution {\n\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n   /**\n    * Find the diameter of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The length of the longest path between any two nodes in the tree.\n    *\n    * Example:\n    * diameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\n    * Output: 3\n    *\n    * Note:\n    * The diameter of a binary tree is defined as the length of the longest path between any two nodes,\n    * which may or may not pass through the root.\n    * The length of a path is represented by the number of edges between two nodes.\n    * The given tree is guaranteed to have at most 104 nodes,\n    * and the values of the nodes in the tree are in the range [-100, 100].\n    */\n  def diameterOfBinaryTree(root: TreeNode): Int = ", "canonical_solution": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n    assert(diameterOfBinaryTree(root1) == 3)\n\n    // Test case 2\n    val root2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert(diameterOfBinaryTree(root2) == 3)\n\n    // Test case 3\n    val root3 = TreeNode(1, null, TreeNode(2, null, TreeNode(3, null, TreeNode(4))))\n    assert(diameterOfBinaryTree(root3) == 3)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "diameterOfBinaryTree", "signature": "def diameterOfBinaryTree(root: TreeNode): Int =", "docstring": "Find the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].\n\n* Incomplete Code:\ndef diameterOfBinaryTree(root: TreeNode): Int =\n  {\n \n    def height(node: TreeNode): Int = {\n[MASK]\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    def height(node: TreeNode): Int = {\n[MASK]\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }"}
{"task_id": "Scala/16-1-single", "prompt": "object Solution {\n\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n   /**\n    * Find the diameter of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The length of the longest path between any two nodes in the tree.\n    *\n    * Example:\n    * diameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\n    * Output: 3\n    *\n    * Note:\n    * The diameter of a binary tree is defined as the length of the longest path between any two nodes,\n    * which may or may not pass through the root.\n    * The length of a path is represented by the number of edges between two nodes.\n    * The given tree is guaranteed to have at most 104 nodes,\n    * and the values of the nodes in the tree are in the range [-100, 100].\n    */\n  def diameterOfBinaryTree(root: TreeNode): Int = ", "canonical_solution": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n    assert(diameterOfBinaryTree(root1) == 3)\n\n    // Test case 2\n    val root2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert(diameterOfBinaryTree(root2) == 3)\n\n    // Test case 3\n    val root3 = TreeNode(1, null, TreeNode(2, null, TreeNode(3, null, TreeNode(4))))\n    assert(diameterOfBinaryTree(root3) == 3)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "diameterOfBinaryTree", "signature": "def diameterOfBinaryTree(root: TreeNode): Int =", "docstring": "Find the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].\n\n* Incomplete Code:\ndef diameterOfBinaryTree(root: TreeNode): Int =\n  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n[MASK]\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n[MASK]\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }"}
{"task_id": "Scala/17-0-single", "prompt": "object Solution {\n\n    /**\n     * Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n     *\n     * @param date The date in the format \"YYYY-MM-DD\".\n     * @return The day of the year.\n     *\n     * Example:\n     * dayOfYear(\"2019-01-09\")\n     * Output: 9\n     *\n     * dayOfYear(\"2019-02-10\")\n     * Output: 41\n     */\n  def dayOfYear(date: String): Int = ", "canonical_solution": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(dayOfYear(\"2022-03-15\") == 74)\n    assert(dayOfYear(\"2023-11-30\") == 334)\n    assert(dayOfYear(\"2024-07-01\") == 183)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "dayOfYear", "signature": "def dayOfYear(date: String): Int =", "docstring": "Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41\n\n* Incomplete Code:\ndef dayOfYear(date: String): Int =\n  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n[MASK]\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n[MASK]\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }"}
{"task_id": "Scala/17-1-single", "prompt": "object Solution {\n\n    /**\n     * Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n     *\n     * @param date The date in the format \"YYYY-MM-DD\".\n     * @return The day of the year.\n     *\n     * Example:\n     * dayOfYear(\"2019-01-09\")\n     * Output: 9\n     *\n     * dayOfYear(\"2019-02-10\")\n     * Output: 41\n     */\n  def dayOfYear(date: String): Int = ", "canonical_solution": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(dayOfYear(\"2022-03-15\") == 74)\n    assert(dayOfYear(\"2023-11-30\") == 334)\n    assert(dayOfYear(\"2024-07-01\") == 183)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "dayOfYear", "signature": "def dayOfYear(date: String): Int =", "docstring": "Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41\n\n* Incomplete Code:\ndef dayOfYear(date: String): Int =\n  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n[MASK]\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n[MASK]\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }"}
{"task_id": "Scala/18-0-single", "prompt": "\nobject Solution {\n  /**\n    * Convert a non-negative integer to its English representation.\n    *\n    * @param num The number to be converted.\n    * @return The English representation of the number.\n    *\n    * Example:\n    * numberToWords(123)\n    * Output: \"One Hundred Twenty Three\"\n    *\n    * numberToWords(12345)\n    * Output: \"Twelve Thousand Three Hundred Forty Five\"\n    *\n    * numberToWords(1234567)\n    * Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n    */\n  def numberToWords(num: Int): String = ", "canonical_solution": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(numberToWords(567) == \"Five Hundred Sixty Seven\")\n    assert(numberToWords(123456) == \"One Hundred Twenty Three Thousand Four Hundred Fifty Six\")\n    assert(numberToWords(987654321) == \"Nine Hundred Eighty Seven Million Six Hundred Fifty Four Thousand Three Hundred Twenty One\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberToWords", "signature": "def numberToWords(num: Int): String =", "docstring": "Convert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nConvert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n* Incomplete Code:\ndef numberToWords(num: Int): String =\n  {\n\n[MASK]\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n"}
{"task_id": "Scala/18-1-single", "prompt": "\nobject Solution {\n  /**\n    * Convert a non-negative integer to its English representation.\n    *\n    * @param num The number to be converted.\n    * @return The English representation of the number.\n    *\n    * Example:\n    * numberToWords(123)\n    * Output: \"One Hundred Twenty Three\"\n    *\n    * numberToWords(12345)\n    * Output: \"Twelve Thousand Three Hundred Forty Five\"\n    *\n    * numberToWords(1234567)\n    * Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n    */\n  def numberToWords(num: Int): String = ", "canonical_solution": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(numberToWords(567) == \"Five Hundred Sixty Seven\")\n    assert(numberToWords(123456) == \"One Hundred Twenty Three Thousand Four Hundred Fifty Six\")\n    assert(numberToWords(987654321) == \"Nine Hundred Eighty Seven Million Six Hundred Fifty Four Thousand Three Hundred Twenty One\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberToWords", "signature": "def numberToWords(num: Int): String =", "docstring": "Convert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nConvert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n* Incomplete Code:\ndef numberToWords(num: Int): String =\n  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n[MASK]\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n[MASK]\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n"}
{"task_id": "Scala/19-0-single", "prompt": "\nobject Solution {\n  /**\n    * Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\n    * Calculate and return the total number of complete rows that can be formed.\n    *\n    * @param n The total number of coins.\n    * @return The total number of complete rows that can be formed.\n    *\n    * Example:\n    * arrangeCoins(5)\n    * Output: 2\n    * Explanation: The third row is incomplete, so return 2.\n    */\n  def arrangeCoins(n: Int): Int = ", "canonical_solution": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(arrangeCoins(8) == 3)\n    assert(arrangeCoins(15) == 5)\n    assert(arrangeCoins(20) == 5)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "arrangeCoins", "signature": "def arrangeCoins(n: Int): Int =", "docstring": "Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.\n\n* Incomplete Code:\ndef arrangeCoins(n: Int): Int =\n  {\n \n[MASK]\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n[MASK]\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }"}
{"task_id": "Scala/19-1-single", "prompt": "\nobject Solution {\n  /**\n    * Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\n    * Calculate and return the total number of complete rows that can be formed.\n    *\n    * @param n The total number of coins.\n    * @return The total number of complete rows that can be formed.\n    *\n    * Example:\n    * arrangeCoins(5)\n    * Output: 2\n    * Explanation: The third row is incomplete, so return 2.\n    */\n  def arrangeCoins(n: Int): Int = ", "canonical_solution": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(arrangeCoins(8) == 3)\n    assert(arrangeCoins(15) == 5)\n    assert(arrangeCoins(20) == 5)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "arrangeCoins", "signature": "def arrangeCoins(n: Int): Int =", "docstring": "Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.\n\n* Incomplete Code:\ndef arrangeCoins(n: Int): Int =\n  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n[MASK]\n    }\n    row - 1\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n[MASK]\n    }\n    row - 1\n  }"}
{"task_id": "Scala/20-0-single", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\nobject Solution {\n  /**\n   * Calculate the minimum depth of a binary tree.\n   *\n   * The minimum depth is the number of nodes along the shortest path from the root node to\n   * the nearest leaf node.\n   *\n   * @param root The root node of the binary tree.\n   * @return The minimum depth of the tree.\n   *\n   * Examples:\n   * minimumDepth([3,9,20,null,null,15,7])\n   * Output: 2\n   *\n   * minimumDepth([2,null,3,null,4,null,5,null,6])\n   * Output: 5\n   *\n   * Constraints:\n   * - The number of nodes in the tree is in the range [0, 10^5].\n   * - The value of each node is in the range [-1000, 1000].\n   */\n\n  def minimumDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = new TreeNode(3)\n    root1.left = new TreeNode(9)\n    root1.right = new TreeNode(20)\n    root1.right.left = new TreeNode(15)\n    root1.right.right = new TreeNode(7)\n    assert(minimumDepth(root1) == 2)\n    \n    // Test case 2\n    val root2 = new TreeNode(2)\n    root2.right = new TreeNode(3)\n    root2.right.right = new TreeNode(4)\n    root2.right.right.right = new TreeNode(5)\n    root2.right.right.right.right = new TreeNode(6)\n    assert(minimumDepth(root2) == 5)\n    \n    // Test case 3\n    val root3: TreeNode = null\n    assert(minimumDepth(root3) == 0)\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "minimumDepth", "signature": "def minimumDepth(root: TreeNode): Int =", "docstring": "Calculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].\n\n* Incomplete Code:\ndef minimumDepth(root: TreeNode): Int =\n  {\n    if (root == null) {\n      return 0\n    }\n    \n[MASK]\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (root == null) {\n      return 0\n    }\n    \n[MASK]\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  "}
{"task_id": "Scala/20-1-single", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\nobject Solution {\n  /**\n   * Calculate the minimum depth of a binary tree.\n   *\n   * The minimum depth is the number of nodes along the shortest path from the root node to\n   * the nearest leaf node.\n   *\n   * @param root The root node of the binary tree.\n   * @return The minimum depth of the tree.\n   *\n   * Examples:\n   * minimumDepth([3,9,20,null,null,15,7])\n   * Output: 2\n   *\n   * minimumDepth([2,null,3,null,4,null,5,null,6])\n   * Output: 5\n   *\n   * Constraints:\n   * - The number of nodes in the tree is in the range [0, 10^5].\n   * - The value of each node is in the range [-1000, 1000].\n   */\n\n  def minimumDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = new TreeNode(3)\n    root1.left = new TreeNode(9)\n    root1.right = new TreeNode(20)\n    root1.right.left = new TreeNode(15)\n    root1.right.right = new TreeNode(7)\n    assert(minimumDepth(root1) == 2)\n    \n    // Test case 2\n    val root2 = new TreeNode(2)\n    root2.right = new TreeNode(3)\n    root2.right.right = new TreeNode(4)\n    root2.right.right.right = new TreeNode(5)\n    root2.right.right.right.right = new TreeNode(6)\n    assert(minimumDepth(root2) == 5)\n    \n    // Test case 3\n    val root3: TreeNode = null\n    assert(minimumDepth(root3) == 0)\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "minimumDepth", "signature": "def minimumDepth(root: TreeNode): Int =", "docstring": "Calculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].\n\n* Incomplete Code:\ndef minimumDepth(root: TreeNode): Int =\n  {\n[MASK]\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  "}
{"task_id": "Scala/21-0-single", "prompt": "\nobject Solution {\n  /**\n     * Given a string s, you need to split it into some substrings so that each substring is a palindrome.\n     * Return the minimum number of splits required.\n     *\n     * @param s The input string.\n     * @return The minimum number of splits required.\n     *\n     * Example:\n     * minCut(\"aab\")\n     * Output: 1\n     *\n     * Explanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n     *\n     * Constraints:\n     * - 1 <= s.length <= 2000\n     * - s consists only of lowercase English letters.\n     */\n  def minCut(s: String): Int = ", "canonical_solution": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(minCut(\"abcba\") == 0)\n    assert(minCut(\"aabba\") == 1)\n    assert(minCut(\"abbababa\") == 2)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minCut", "signature": "def minCut(s: String): Int =", "docstring": "Given a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.\n\n* Incomplete Code:\ndef minCut(s: String): Int =\n  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n[MASK]\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n[MASK]\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }"}
{"task_id": "Scala/21-1-single", "prompt": "\nobject Solution {\n  /**\n     * Given a string s, you need to split it into some substrings so that each substring is a palindrome.\n     * Return the minimum number of splits required.\n     *\n     * @param s The input string.\n     * @return The minimum number of splits required.\n     *\n     * Example:\n     * minCut(\"aab\")\n     * Output: 1\n     *\n     * Explanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n     *\n     * Constraints:\n     * - 1 <= s.length <= 2000\n     * - s consists only of lowercase English letters.\n     */\n  def minCut(s: String): Int = ", "canonical_solution": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(minCut(\"abcba\") == 0)\n    assert(minCut(\"aabba\") == 1)\n    assert(minCut(\"abbababa\") == 2)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minCut", "signature": "def minCut(s: String): Int =", "docstring": "Given a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.\n\n* Incomplete Code:\ndef minCut(s: String): Int =\n  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n[MASK]\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n[MASK]\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }"}
{"task_id": "Scala/22-0-single", "prompt": "class TreeNode(val value: Int, var left: TreeNode = null, var right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Check if a binary tree is symmetric.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is symmetric, False otherwise.\n    *\n    * Example:\n    * isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\n    * Output: true\n    */\n  def isSymmetric(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }", "test": "def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), new TreeNode(4)\n      ),\n      new TreeNode(2,\n        new TreeNode(4), new TreeNode(3)\n      )\n    )\n    assert(isSymmetric(root1))\n\n    // Test Case 2\n    val root2 = new TreeNode(1,\n      new TreeNode(2,\n        null, new TreeNode(3)\n      ),\n      new TreeNode(2,\n        null, new TreeNode(3)\n      )\n    )\n    assert(!isSymmetric(root2))\n\n    // Test Case 3\n    val root3 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), null\n      ),\n      new TreeNode(2,\n        new TreeNode(3), null\n      )\n    )\n    assert(!isSymmetric(root3))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isSymmetric", "signature": "def isSymmetric(root: TreeNode): Boolean =", "docstring": "Check if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true\n\n* Incomplete Code:\ndef isSymmetric(root: TreeNode): Boolean =\n  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n[MASK]\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n[MASK]\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }"}
{"task_id": "Scala/22-1-single", "prompt": "class TreeNode(val value: Int, var left: TreeNode = null, var right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Check if a binary tree is symmetric.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is symmetric, False otherwise.\n    *\n    * Example:\n    * isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\n    * Output: true\n    */\n  def isSymmetric(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }", "test": "def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), new TreeNode(4)\n      ),\n      new TreeNode(2,\n        new TreeNode(4), new TreeNode(3)\n      )\n    )\n    assert(isSymmetric(root1))\n\n    // Test Case 2\n    val root2 = new TreeNode(1,\n      new TreeNode(2,\n        null, new TreeNode(3)\n      ),\n      new TreeNode(2,\n        null, new TreeNode(3)\n      )\n    )\n    assert(!isSymmetric(root2))\n\n    // Test Case 3\n    val root3 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), null\n      ),\n      new TreeNode(2,\n        new TreeNode(3), null\n      )\n    )\n    assert(!isSymmetric(root3))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isSymmetric", "signature": "def isSymmetric(root: TreeNode): Boolean =", "docstring": "Check if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true\n\n* Incomplete Code:\ndef isSymmetric(root: TreeNode): Boolean =\n  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n[MASK]\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n[MASK]\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }"}
{"task_id": "Scala/23-0-single", "prompt": "object Solution {\n    /**\n     * Find the smallest positive integer b such that the product of all digits of b is equal to a.\n     *\n     * @param a The given integer.\n     * @return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\n     *         is not a 32-bit signed integer, return 0.\n     *\n     * Example:\n     * findSmallestInteger(48)\n     * Output: 68\n     *\n     * Example:\n     * findSmallestInteger(15)\n     * Output: 35\n     */\n  def findSmallestInteger(a: Int): Int = ", "canonical_solution": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(findSmallestInteger(48) == 68)\n    assert(findSmallestInteger(15) == 35)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findSmallestInteger", "signature": "def findSmallestInteger(a: Int): Int =", "docstring": "Find the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35\n\n* Incomplete Code:\ndef findSmallestInteger(a: Int): Int =\n  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n[MASK]\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n[MASK]\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }"}
{"task_id": "Scala/23-1-single", "prompt": "object Solution {\n    /**\n     * Find the smallest positive integer b such that the product of all digits of b is equal to a.\n     *\n     * @param a The given integer.\n     * @return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\n     *         is not a 32-bit signed integer, return 0.\n     *\n     * Example:\n     * findSmallestInteger(48)\n     * Output: 68\n     *\n     * Example:\n     * findSmallestInteger(15)\n     * Output: 35\n     */\n  def findSmallestInteger(a: Int): Int = ", "canonical_solution": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(findSmallestInteger(48) == 68)\n    assert(findSmallestInteger(15) == 35)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findSmallestInteger", "signature": "def findSmallestInteger(a: Int): Int =", "docstring": "Find the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35\n\n* Incomplete Code:\ndef findSmallestInteger(a: Int): Int =\n  {\n\n    def getProductOfDigits(num: Int): Int = {\n[MASK]\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n[MASK]\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }"}
{"task_id": "Scala/24-0-single", "prompt": "object Solution {\n    /**\n     * Calculate the sum of the digits in a number with assigned signs.\n     *\n     * @param n The input number.\n     * @return The sum of the digits with assigned signs.\n     *\n     * Example:\n     * signSum(521)\n     * Output: 4\n     */\n  def signSum(n: Int): Int = ", "canonical_solution": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(signSum(123) == 6)\n    assert(signSum(-456) == -15)\n    assert(signSum(789) == 24)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "signSum", "signature": "def signSum(n: Int): Int =", "docstring": "Calculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4\n\n* Incomplete Code:\ndef signSum(n: Int): Int =\n  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n[MASK]\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n[MASK]\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }"}
{"task_id": "Scala/24-1-single", "prompt": "object Solution {\n    /**\n     * Calculate the sum of the digits in a number with assigned signs.\n     *\n     * @param n The input number.\n     * @return The sum of the digits with assigned signs.\n     *\n     * Example:\n     * signSum(521)\n     * Output: 4\n     */\n  def signSum(n: Int): Int = ", "canonical_solution": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(signSum(123) == 6)\n    assert(signSum(-456) == -15)\n    assert(signSum(789) == 24)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "signSum", "signature": "def signSum(n: Int): Int =", "docstring": "Calculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4\n\n* Incomplete Code:\ndef signSum(n: Int): Int =\n  {\n\n[MASK]\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }"}
{"task_id": "Scala/25-0-single", "prompt": "\nobject Solution {\n    /**\n    * Returns the elements of the matrix in clockwise spiral order.\n    *\n    * @param matrix The input matrix.\n    * @return The elements of the matrix in spiral order.\n    *\n    * Example:\n    * spiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\n    * Output: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n    */\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = ", "canonical_solution": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val matrix1 = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))\n    val result1 = spiralOrder(matrix1)\n    assert(result1 == List(1, 2, 3, 6, 9, 8, 7, 4, 5))\n\n    val matrix2 = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12))\n    val result2 = spiralOrder(matrix2)\n    assert(result2 == List(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7))\n\n    val matrix3 = Array(Array(1, 2, 3, 4, 5), Array(6, 7, 8, 9, 10), Array(11, 12, 13, 14, 15))\n    val result3 = spiralOrder(matrix3)\n    assert(result3 == List(1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "spiralOrder", "signature": "def spiralOrder(matrix: Array[Array[Int]]): List[Int] =", "docstring": "Returns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n\n* Incomplete Code:\ndef spiralOrder(matrix: Array[Array[Int]]): List[Int] =\n  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n[MASK]\n      }\n      left += 1\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n[MASK]\n      }\n      left += 1\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/25-1-single", "prompt": "\nobject Solution {\n    /**\n    * Returns the elements of the matrix in clockwise spiral order.\n    *\n    * @param matrix The input matrix.\n    * @return The elements of the matrix in spiral order.\n    *\n    * Example:\n    * spiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\n    * Output: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n    */\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = ", "canonical_solution": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val matrix1 = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))\n    val result1 = spiralOrder(matrix1)\n    assert(result1 == List(1, 2, 3, 6, 9, 8, 7, 4, 5))\n\n    val matrix2 = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12))\n    val result2 = spiralOrder(matrix2)\n    assert(result2 == List(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7))\n\n    val matrix3 = Array(Array(1, 2, 3, 4, 5), Array(6, 7, 8, 9, 10), Array(11, 12, 13, 14, 15))\n    val result3 = spiralOrder(matrix3)\n    assert(result3 == List(1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "spiralOrder", "signature": "def spiralOrder(matrix: Array[Array[Int]]): List[Int] =", "docstring": "Returns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n\n* Incomplete Code:\ndef spiralOrder(matrix: Array[Array[Int]]): List[Int] =\n  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n[MASK]\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n[MASK]\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/26-0-single", "prompt": "class TreeNode(var value: Int, var left: TreeNode = null, var right: TreeNode = null)\nobject Solution {\n  /**\n    * Determine if a given binary tree is a univalued tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a univalued tree, False otherwise.\n    *\n    * Example:\n    * isUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\n    * Output: true\n    *\n    * isUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\n    * Output: false\n    */\n  def isUnivalTree(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val tree1 = new TreeNode(2)\n    tree1.left = new TreeNode(2)\n    tree1.left.left = new TreeNode(2)\n    tree1.left.left.left = new TreeNode(5)\n    tree1.left.left.right = new TreeNode(2)\n    assert(!isUnivalTree(tree1))  // Output: false\n\n    // Test Case 2\n    val tree2 = new TreeNode(1)\n    tree2.left = new TreeNode(1)\n    tree2.left.left = new TreeNode(1)\n    tree2.left.right = new TreeNode(1)\n    tree2.right = new TreeNode(1)\n    tree2.right.right = new TreeNode(1)\n    assert(isUnivalTree(tree2))  // Output: true\n\n    // Test Case 3\n    val tree3 = new TreeNode(3)\n    tree3.left = new TreeNode(3)\n    tree3.right = new TreeNode(3)\n    assert(isUnivalTree(tree3))  // Output: true\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "isUnivalTree", "signature": "def isUnivalTree(root: TreeNode): Boolean =", "docstring": "Determine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false\n\n* Incomplete Code:\ndef isUnivalTree(root: TreeNode): Boolean =\n  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n[MASK]\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n[MASK]\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }"}
{"task_id": "Scala/26-1-single", "prompt": "class TreeNode(var value: Int, var left: TreeNode = null, var right: TreeNode = null)\nobject Solution {\n  /**\n    * Determine if a given binary tree is a univalued tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a univalued tree, False otherwise.\n    *\n    * Example:\n    * isUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\n    * Output: true\n    *\n    * isUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\n    * Output: false\n    */\n  def isUnivalTree(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val tree1 = new TreeNode(2)\n    tree1.left = new TreeNode(2)\n    tree1.left.left = new TreeNode(2)\n    tree1.left.left.left = new TreeNode(5)\n    tree1.left.left.right = new TreeNode(2)\n    assert(!isUnivalTree(tree1))  // Output: false\n\n    // Test Case 2\n    val tree2 = new TreeNode(1)\n    tree2.left = new TreeNode(1)\n    tree2.left.left = new TreeNode(1)\n    tree2.left.right = new TreeNode(1)\n    tree2.right = new TreeNode(1)\n    tree2.right.right = new TreeNode(1)\n    assert(isUnivalTree(tree2))  // Output: true\n\n    // Test Case 3\n    val tree3 = new TreeNode(3)\n    tree3.left = new TreeNode(3)\n    tree3.right = new TreeNode(3)\n    assert(isUnivalTree(tree3))  // Output: true\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "isUnivalTree", "signature": "def isUnivalTree(root: TreeNode): Boolean =", "docstring": "Determine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false\n\n* Incomplete Code:\ndef isUnivalTree(root: TreeNode): Boolean =\n  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n[MASK]\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n[MASK]\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }"}
{"task_id": "Scala/27-0-single", "prompt": "object Solution {\n    /**\n     * Remove the trailing zeros from a given integer represented as a string.\n     *\n     * @param num The string representation of the integer.\n     * @return The integer with trailing zeros removed represented as a string.\n     *\n     * Example:\n     * removeTrailingZeros(\"51230100\")\n     * Output: \"512301\"\n     *\n     * removeTrailingZeros(\"123\")\n     * Output: \"123\"\n     */\n  def removeTrailingZeros(num: String): String = ", "canonical_solution": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(removeTrailingZeros(\"51230100\") == \"512301\")\n    assert(removeTrailingZeros(\"123\") == \"123\")\n    assert(removeTrailingZeros(\"1000010\") == \"100001\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeTrailingZeros", "signature": "def removeTrailingZeros(num: String): String =", "docstring": "Remove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"\n\n* Incomplete Code:\ndef removeTrailingZeros(num: String): String =\n  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n[MASK]\n  }"}
{"task_id": "Scala/27-1-single", "prompt": "object Solution {\n    /**\n     * Remove the trailing zeros from a given integer represented as a string.\n     *\n     * @param num The string representation of the integer.\n     * @return The integer with trailing zeros removed represented as a string.\n     *\n     * Example:\n     * removeTrailingZeros(\"51230100\")\n     * Output: \"512301\"\n     *\n     * removeTrailingZeros(\"123\")\n     * Output: \"123\"\n     */\n  def removeTrailingZeros(num: String): String = ", "canonical_solution": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(removeTrailingZeros(\"51230100\") == \"512301\")\n    assert(removeTrailingZeros(\"123\") == \"123\")\n    assert(removeTrailingZeros(\"1000010\") == \"100001\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeTrailingZeros", "signature": "def removeTrailingZeros(num: String): String =", "docstring": "Remove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"\n\n* Incomplete Code:\ndef removeTrailingZeros(num: String): String =\n  {\n\n    var index = num.length - 1\n[MASK]\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var index = num.length - 1\n[MASK]\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }"}
{"task_id": "Scala/28-0-single", "prompt": "object Solution {\n  /**\n    * Check if the binary string contains at most one segment of consecutive '1's.\n    *\n    * @param s The input binary string.\n    * @return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n    *\n    * Example:\n    * checkOnesSegment(\"1001\")\n    * Output: false\n    *\n    * Example:\n    * checkOnesSegment(\"110\")\n    * Output: true\n    */\n  def checkOnesSegment(s: String): Boolean = ", "canonical_solution": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(checkOnesSegment(\"10101\") == true)\n    assert(checkOnesSegment(\"111000\") == false)\n    assert(checkOnesSegment(\"100111000\") == false)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "checkOnesSegment", "signature": "def checkOnesSegment(s: String): Boolean =", "docstring": "Check if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true\n\n* Incomplete Code:\ndef checkOnesSegment(s: String): Boolean =\n  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n[MASK]\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n[MASK]\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }"}
{"task_id": "Scala/28-1-single", "prompt": "object Solution {\n  /**\n    * Check if the binary string contains at most one segment of consecutive '1's.\n    *\n    * @param s The input binary string.\n    * @return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n    *\n    * Example:\n    * checkOnesSegment(\"1001\")\n    * Output: false\n    *\n    * Example:\n    * checkOnesSegment(\"110\")\n    * Output: true\n    */\n  def checkOnesSegment(s: String): Boolean = ", "canonical_solution": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(checkOnesSegment(\"10101\") == true)\n    assert(checkOnesSegment(\"111000\") == false)\n    assert(checkOnesSegment(\"100111000\") == false)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "checkOnesSegment", "signature": "def checkOnesSegment(s: String): Boolean =", "docstring": "Check if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true\n\n* Incomplete Code:\ndef checkOnesSegment(s: String): Boolean =\n  {\n    var count = 0\n    for (i <- 0 until s.length) {\n[MASK]\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n[MASK]\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }"}
{"task_id": "Scala/29-0-single", "prompt": "object Solution {\n/**\n * Computes the minimum cost of merging N piles of sand into one pile. \n * The cost of merging two adjacent piles is the sum of their sizes. \n * The function aims to find a merge strategy that minimizes the total cost.\n *\n * @param sandPiles An array of integers representing the sizes of each sand pile.\n * @return The minimum total cost of merging all piles into one.\n *\n * Example:\n * minMergeCost(Array(1, 3, 5, 2))\n * Output: 22\n * \n * Explanation:\n * Merging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9), \n * and finally merging the last two piles (cost = 11), results in a total cost of 22.\n */\n\ndef minMergeCost(sandPiles: Array[Int]): Int = ", "canonical_solution": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}", "test": "  def main(args: Array[String]): Unit = {\n    assert(minMergeCost(Array(1, 3, 5, 2)) == 22)\n    assert(minMergeCost(Array(4, 3, 3)) == 16)\n    assert(minMergeCost(Array(10, 20, 30)) == 90)\n    assert(minMergeCost(Array(3, 4, 3, 9, 6, 7, 8, 10 )) == 147)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minMergeCost", "signature": "def minMergeCost(sandPiles: Array[Int]): Int =", "docstring": "Computes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nComputes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.\n\n* Incomplete Code:\ndef minMergeCost(sandPiles: Array[Int]): Int =\n{\n[MASK]\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n[MASK]\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}"}
{"task_id": "Scala/29-1-single", "prompt": "object Solution {\n/**\n * Computes the minimum cost of merging N piles of sand into one pile. \n * The cost of merging two adjacent piles is the sum of their sizes. \n * The function aims to find a merge strategy that minimizes the total cost.\n *\n * @param sandPiles An array of integers representing the sizes of each sand pile.\n * @return The minimum total cost of merging all piles into one.\n *\n * Example:\n * minMergeCost(Array(1, 3, 5, 2))\n * Output: 22\n * \n * Explanation:\n * Merging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9), \n * and finally merging the last two piles (cost = 11), results in a total cost of 22.\n */\n\ndef minMergeCost(sandPiles: Array[Int]): Int = ", "canonical_solution": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}", "test": "  def main(args: Array[String]): Unit = {\n    assert(minMergeCost(Array(1, 3, 5, 2)) == 22)\n    assert(minMergeCost(Array(4, 3, 3)) == 16)\n    assert(minMergeCost(Array(10, 20, 30)) == 90)\n    assert(minMergeCost(Array(3, 4, 3, 9, 6, 7, 8, 10 )) == 147)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minMergeCost", "signature": "def minMergeCost(sandPiles: Array[Int]): Int =", "docstring": "Computes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nComputes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.\n\n* Incomplete Code:\ndef minMergeCost(sandPiles: Array[Int]): Int =\n{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n[MASK]\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n[MASK]\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}"}
{"task_id": "Scala/31-0-single", "prompt": "\nobject Solution {\n  /**\n  * Reverse the given string based on the following rules:\n  * - Keep all non-alphabetic characters in their original positions.\n  * - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  *\n  * @param s The input string.\n  * @return The reversed string.\n  *\n  * Example:\n  * reverseString(\"ab-cd\")\n  * Output: \"dc-ba\"\n  */\n  def reverseString(s: String): String = ", "canonical_solution": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"ab-cd\") == \"dc-ba\")\n    assert(reverseString(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String): String =", "docstring": "Reverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"\n\n* Incomplete Code:\ndef reverseString(s: String): String =\n  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n[MASK]\n          res\n        } else c\n      }.mkString\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n[MASK]\n          res\n        } else c\n      }.mkString\n    }"}
{"task_id": "Scala/31-1-single", "prompt": "\nobject Solution {\n  /**\n  * Reverse the given string based on the following rules:\n  * - Keep all non-alphabetic characters in their original positions.\n  * - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  *\n  * @param s The input string.\n  * @return The reversed string.\n  *\n  * Example:\n  * reverseString(\"ab-cd\")\n  * Output: \"dc-ba\"\n  */\n  def reverseString(s: String): String = ", "canonical_solution": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"ab-cd\") == \"dc-ba\")\n    assert(reverseString(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String): String =", "docstring": "Reverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"\n\n* Incomplete Code:\ndef reverseString(s: String): String =\n  {\n \n    val stack = s.filter(_.isLetter).reverse\n[MASK]\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n[MASK]\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }"}
{"task_id": "Scala/32-0-single", "prompt": "object Solution {\n    /**\n       * Calculate the maximum number of consecutive 1s in a binary array.\n       *\n       * @param nums The binary array.\n       * @return The maximum number of consecutive 1s.\n       *\n       * Example:\n       * findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\n       * Output: 3\n       */\n  def findMaxConsecutiveOnes(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    //test case 1\n    assert(findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1, 0, 0, 1, 1)) == 3)\n    \n    //test case 2\n    assert(findMaxConsecutiveOnes(Array(0, 0, 0)) == 0)\n    \n    //test case 3\n    assert(findMaxConsecutiveOnes(Array(1, 1, 1, 1, 1)) == 5)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findMaxConsecutiveOnes", "signature": "def findMaxConsecutiveOnes(nums: Array[Int]): Int =", "docstring": "Calculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3\n\n* Incomplete Code:\ndef findMaxConsecutiveOnes(nums: Array[Int]): Int =\n  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n[MASK]\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n[MASK]\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n"}
{"task_id": "Scala/32-1-single", "prompt": "object Solution {\n    /**\n       * Calculate the maximum number of consecutive 1s in a binary array.\n       *\n       * @param nums The binary array.\n       * @return The maximum number of consecutive 1s.\n       *\n       * Example:\n       * findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\n       * Output: 3\n       */\n  def findMaxConsecutiveOnes(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    //test case 1\n    assert(findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1, 0, 0, 1, 1)) == 3)\n    \n    //test case 2\n    assert(findMaxConsecutiveOnes(Array(0, 0, 0)) == 0)\n    \n    //test case 3\n    assert(findMaxConsecutiveOnes(Array(1, 1, 1, 1, 1)) == 5)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findMaxConsecutiveOnes", "signature": "def findMaxConsecutiveOnes(nums: Array[Int]): Int =", "docstring": "Calculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3\n\n* Incomplete Code:\ndef findMaxConsecutiveOnes(nums: Array[Int]): Int =\n  {\n\n       var maxConsecutiveOnes = 0\n[MASK]\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var maxConsecutiveOnes = 0\n[MASK]\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n"}
{"task_id": "Scala/34-0-single", "prompt": "\nobject Solution {\n    /**\n       * Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n       *\n       * @param nums An array of integers.\n       * @return None (In-place modification of the input array).\n       *\n       * Example:\n       * moveZeroes(Array(0, 1, 0, 3, 12))\n       * Output: Array(1, 3, 12, 0, 0)\n       */\n  def moveZeroes(nums: Array[Int]): Unit = ", "canonical_solution": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(1,0,2,0,3)\n    Solution.moveZeroes(nums1)\n    assert(nums1 sameElements Array(1,2,3,0,0))\n\n    val nums2 = Array(0,0,0,1,2)\n    Solution.moveZeroes(nums2)\n    assert(nums2 sameElements Array(1,2,0,0,0))\n\n    val nums3 = Array(1,2,3,0,0)\n    Solution.moveZeroes(nums3)\n    assert(nums3 sameElements Array(1,2,3,0,0))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveZeroes", "signature": "def moveZeroes(nums: Array[Int]): Unit =", "docstring": "Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)\n\n* Incomplete Code:\ndef moveZeroes(nums: Array[Int]): Unit =\n  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n[MASK]\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n[MASK]\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }"}
{"task_id": "Scala/34-1-single", "prompt": "\nobject Solution {\n    /**\n       * Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n       *\n       * @param nums An array of integers.\n       * @return None (In-place modification of the input array).\n       *\n       * Example:\n       * moveZeroes(Array(0, 1, 0, 3, 12))\n       * Output: Array(1, 3, 12, 0, 0)\n       */\n  def moveZeroes(nums: Array[Int]): Unit = ", "canonical_solution": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(1,0,2,0,3)\n    Solution.moveZeroes(nums1)\n    assert(nums1 sameElements Array(1,2,3,0,0))\n\n    val nums2 = Array(0,0,0,1,2)\n    Solution.moveZeroes(nums2)\n    assert(nums2 sameElements Array(1,2,0,0,0))\n\n    val nums3 = Array(1,2,3,0,0)\n    Solution.moveZeroes(nums3)\n    assert(nums3 sameElements Array(1,2,3,0,0))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveZeroes", "signature": "def moveZeroes(nums: Array[Int]): Unit =", "docstring": "Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)\n\n* Incomplete Code:\ndef moveZeroes(nums: Array[Int]): Unit =\n  {\n\n[MASK]\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }"}
{"task_id": "Scala/36-0-single", "prompt": "\nobject Solution {\n      /**\n       * Count the number of palindrome substrings in a given string.\n       *\n       * @param s The input string.\n       * @return The number of palindrome substrings.\n       *\n       * Example:\n       * countPalindromeSubstrings(\"abc\")\n       * Output: 3\n       *\n       * Example:\n       * countPalindromeSubstrings(\"aaa\")\n       * Output: 6\n       */\n  def countPalindromeSubstrings(s: String): Int = ", "canonical_solution": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countPalindromeSubstrings(\"abc\") == 3)\n    assert(countPalindromeSubstrings(\"aaa\") == 6)\n    assert(countPalindromeSubstrings(\"abba\") == 6)\n    assert(countPalindromeSubstrings(\"abcd\") == 4)\n    assert(countPalindromeSubstrings(\"aabbccd\") == 10)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPalindromeSubstrings", "signature": "def countPalindromeSubstrings(s: String): Int =", "docstring": "Count the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6\n\n* Incomplete Code:\ndef countPalindromeSubstrings(s: String): Int =\n  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n[MASK]\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n[MASK]\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }"}
{"task_id": "Scala/36-1-single", "prompt": "\nobject Solution {\n      /**\n       * Count the number of palindrome substrings in a given string.\n       *\n       * @param s The input string.\n       * @return The number of palindrome substrings.\n       *\n       * Example:\n       * countPalindromeSubstrings(\"abc\")\n       * Output: 3\n       *\n       * Example:\n       * countPalindromeSubstrings(\"aaa\")\n       * Output: 6\n       */\n  def countPalindromeSubstrings(s: String): Int = ", "canonical_solution": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countPalindromeSubstrings(\"abc\") == 3)\n    assert(countPalindromeSubstrings(\"aaa\") == 6)\n    assert(countPalindromeSubstrings(\"abba\") == 6)\n    assert(countPalindromeSubstrings(\"abcd\") == 4)\n    assert(countPalindromeSubstrings(\"aabbccd\") == 10)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPalindromeSubstrings", "signature": "def countPalindromeSubstrings(s: String): Int =", "docstring": "Count the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6\n\n* Incomplete Code:\ndef countPalindromeSubstrings(s: String): Int =\n  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n[MASK]\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n[MASK]\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }"}
{"task_id": "Scala/37-0-single", "prompt": "object Solution {\n  case class ListNode(var value: Int, var next: ListNode = null)\n  /**\n    * Remove the nth node from the end of a linked list and return the head of the modified list.\n    *\n    * @param head The head of the linked list.\n    * @param n The position of the node to be removed from the end of the list.\n    * @return The head of the modified list.\n    *\n    * Example:\n    * removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n    * Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n    */\n  def removeNthFromEnd(head: ListNode, n: Int): ListNode = ", "canonical_solution": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }", "test": "  def main(args: Array[String]): Unit = {\n  // Test cases\n  val test1 = createList(Array(1, 2, 3, 4, 5))\n  assert(listToString(removeNthFromEnd(test1, 2)) == \"1->2->3->5\")\n\n  val test2 = createList(Array(1))\n  assert(listToString(removeNthFromEnd(test2, 1)) == \"\")\n\n  val test3 = createList(Array(1, 2))\n  assert(listToString(removeNthFromEnd(test3, 1)) == \"1\")\n\n  println(\"All tests passed\")}\n}", "entry_point": "removeNthFromEnd", "signature": "def removeNthFromEnd(head: ListNode, n: Int): ListNode =", "docstring": "Remove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n\n* Incomplete Code:\ndef removeNthFromEnd(head: ListNode, n: Int): ListNode =\n  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n[MASK]\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n[MASK]\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }"}
{"task_id": "Scala/37-1-single", "prompt": "object Solution {\n  case class ListNode(var value: Int, var next: ListNode = null)\n  /**\n    * Remove the nth node from the end of a linked list and return the head of the modified list.\n    *\n    * @param head The head of the linked list.\n    * @param n The position of the node to be removed from the end of the list.\n    * @return The head of the modified list.\n    *\n    * Example:\n    * removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n    * Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n    */\n  def removeNthFromEnd(head: ListNode, n: Int): ListNode = ", "canonical_solution": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }", "test": "  def main(args: Array[String]): Unit = {\n  // Test cases\n  val test1 = createList(Array(1, 2, 3, 4, 5))\n  assert(listToString(removeNthFromEnd(test1, 2)) == \"1->2->3->5\")\n\n  val test2 = createList(Array(1))\n  assert(listToString(removeNthFromEnd(test2, 1)) == \"\")\n\n  val test3 = createList(Array(1, 2))\n  assert(listToString(removeNthFromEnd(test3, 1)) == \"1\")\n\n  println(\"All tests passed\")}\n}", "entry_point": "removeNthFromEnd", "signature": "def removeNthFromEnd(head: ListNode, n: Int): ListNode =", "docstring": "Remove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n\n* Incomplete Code:\ndef removeNthFromEnd(head: ListNode, n: Int): ListNode =\n  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n[MASK]\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n[MASK]\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }"}
{"task_id": "Scala/38-0-single", "prompt": "\nobject Solution {\n/**\n  * Count the number of integers with unique digits from 0 to 10^n.\n  *\n  * @param n The number of digits.\n  * @return The count of integers with unique digits.\n  *\n  * Example:\n  * countNumbersWithUniqueDigits(2)\n  * Output: 91\n  *\n  * Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n  * The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n  *\n  * countNumbersWithUniqueDigits(0)\n  * Output: 1\n  *\n  * Explanation: When n is 0, there is only one number, which is 0 itself.\n  */\n  def countNumbersWithUniqueDigits(n: Int): Int = ", "canonical_solution": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countNumbersWithUniqueDigits(1) == 10, \"Test case 1 failed\")\n    assert(countNumbersWithUniqueDigits(3) == 739, \"Test case 2 failed\")\n    assert(countNumbersWithUniqueDigits(4) == 5275, \"Test case 3 failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countNumbersWithUniqueDigits", "signature": "def countNumbersWithUniqueDigits(n: Int): Int =", "docstring": "Count the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.\n\n* Incomplete Code:\ndef countNumbersWithUniqueDigits(n: Int): Int =\n  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n[MASK]\n  }"}
{"task_id": "Scala/38-1-single", "prompt": "\nobject Solution {\n/**\n  * Count the number of integers with unique digits from 0 to 10^n.\n  *\n  * @param n The number of digits.\n  * @return The count of integers with unique digits.\n  *\n  * Example:\n  * countNumbersWithUniqueDigits(2)\n  * Output: 91\n  *\n  * Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n  * The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n  *\n  * countNumbersWithUniqueDigits(0)\n  * Output: 1\n  *\n  * Explanation: When n is 0, there is only one number, which is 0 itself.\n  */\n  def countNumbersWithUniqueDigits(n: Int): Int = ", "canonical_solution": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countNumbersWithUniqueDigits(1) == 10, \"Test case 1 failed\")\n    assert(countNumbersWithUniqueDigits(3) == 739, \"Test case 2 failed\")\n    assert(countNumbersWithUniqueDigits(4) == 5275, \"Test case 3 failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countNumbersWithUniqueDigits", "signature": "def countNumbersWithUniqueDigits(n: Int): Int =", "docstring": "Count the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.\n\n* Incomplete Code:\ndef countNumbersWithUniqueDigits(n: Int): Int =\n  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n[MASK]\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n[MASK]\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }"}
{"task_id": "Scala/39-0-single", "prompt": "import scala.annotation.tailrec\n\nobject Solution {\n    class ListNode(var x: Int) {\n    var next: ListNode = null\n  }\n    /**\n      * Swap every two adjacent nodes in a linked list and return its head.\n      *\n      * @param head The head node of the linked list.\n      * @return The head node of the linked list after swapping adjacent nodes.\n      *\n      * Example:\n      * swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n      * swapPairs(null) should return null\n      * swapPairs(ListNode(1)) should return ListNode(1)\n      */\n  def swapPairs(head: ListNode): ListNode = ", "canonical_solution": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n", "test": "    def main(args: Array[String]): Unit = {\n    // Test cases\n    val test1 = createList(Array(5, 6, 7, 8))\n    assert(listToString(swapPairs(test1)) == \"6->5->8->7\")\n\n    val test2 = createList(Array())\n    assert(listToString(swapPairs(test2)) == \"\")\n\n    val test3 = createList(Array(9))\n    assert(listToString(swapPairs(test3)) == \"9\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "swapPairs", "signature": "def swapPairs(head: ListNode): ListNode =", "docstring": "Swap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSwap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)\n\n* Incomplete Code:\ndef swapPairs(head: ListNode): ListNode =\n  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n[MASK]\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n[MASK]\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n"}
{"task_id": "Scala/39-1-single", "prompt": "import scala.annotation.tailrec\n\nobject Solution {\n    class ListNode(var x: Int) {\n    var next: ListNode = null\n  }\n    /**\n      * Swap every two adjacent nodes in a linked list and return its head.\n      *\n      * @param head The head node of the linked list.\n      * @return The head node of the linked list after swapping adjacent nodes.\n      *\n      * Example:\n      * swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n      * swapPairs(null) should return null\n      * swapPairs(ListNode(1)) should return ListNode(1)\n      */\n  def swapPairs(head: ListNode): ListNode = ", "canonical_solution": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n", "test": "    def main(args: Array[String]): Unit = {\n    // Test cases\n    val test1 = createList(Array(5, 6, 7, 8))\n    assert(listToString(swapPairs(test1)) == \"6->5->8->7\")\n\n    val test2 = createList(Array())\n    assert(listToString(swapPairs(test2)) == \"\")\n\n    val test3 = createList(Array(9))\n    assert(listToString(swapPairs(test3)) == \"9\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "swapPairs", "signature": "def swapPairs(head: ListNode): ListNode =", "docstring": "Swap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSwap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)\n\n* Incomplete Code:\ndef swapPairs(head: ListNode): ListNode =\n  {\n\n[MASK]\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n"}
{"task_id": "Scala/40-0-single", "prompt": "import scala.collection.mutable.{Queue, ListBuffer}\n\nclass TreeNode(var _value: Int) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n  /**\n    * Return the level order traversal of a binary tree.\n    *\n    \n    * @param root The root node of the binary tree.\n    * @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n    *\n    * Example:\n    * levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: List(List(3), List(9, 20), List(15, 7))\n    */\n  def levelOrder(root: TreeNode): List[List[Int]] = ", "canonical_solution": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val example1 = new TreeNode(1)\n    example1.left = new TreeNode(2)\n    example1.right = new TreeNode(3)\n\n    assert(levelOrder(example1) == List(List(1), List(2, 3)))\n\n    val example2 = new TreeNode(4)\n    example2.left = new TreeNode(2)\n    example2.right = new TreeNode(6)\n    example2.left.left = new TreeNode(1)\n    example2.left.right = new TreeNode(3)\n    example2.right.left = new TreeNode(5)\n    example2.right.right = new TreeNode(7)\n\n    assert(levelOrder(example2) == List(List(4), List(2, 6), List(1, 3, 5, 7)))\n    \n    val example3 = new TreeNode(8)\n\n    assert(levelOrder(example3) == List(List(8)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "levelOrder", "signature": "def levelOrder(root: TreeNode): List[List[Int]] =", "docstring": "Return the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturn the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))\n\n* Incomplete Code:\ndef levelOrder(root: TreeNode): List[List[Int]] =\n  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n[MASK]\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n[MASK]\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  "}
{"task_id": "Scala/40-1-single", "prompt": "import scala.collection.mutable.{Queue, ListBuffer}\n\nclass TreeNode(var _value: Int) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n  /**\n    * Return the level order traversal of a binary tree.\n    *\n    \n    * @param root The root node of the binary tree.\n    * @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n    *\n    * Example:\n    * levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: List(List(3), List(9, 20), List(15, 7))\n    */\n  def levelOrder(root: TreeNode): List[List[Int]] = ", "canonical_solution": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val example1 = new TreeNode(1)\n    example1.left = new TreeNode(2)\n    example1.right = new TreeNode(3)\n\n    assert(levelOrder(example1) == List(List(1), List(2, 3)))\n\n    val example2 = new TreeNode(4)\n    example2.left = new TreeNode(2)\n    example2.right = new TreeNode(6)\n    example2.left.left = new TreeNode(1)\n    example2.left.right = new TreeNode(3)\n    example2.right.left = new TreeNode(5)\n    example2.right.right = new TreeNode(7)\n\n    assert(levelOrder(example2) == List(List(4), List(2, 6), List(1, 3, 5, 7)))\n    \n    val example3 = new TreeNode(8)\n\n    assert(levelOrder(example3) == List(List(8)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "levelOrder", "signature": "def levelOrder(root: TreeNode): List[List[Int]] =", "docstring": "Return the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturn the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))\n\n* Incomplete Code:\ndef levelOrder(root: TreeNode): List[List[Int]] =\n  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n[MASK]\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n[MASK]\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  "}
{"task_id": "Scala/41-0-single", "prompt": "\nobject Solution {\n/**\n  * Count the number of prime numbers less than a non-negative integer n.\n  *\n  * @param n The non-negative integer.\n  * @return The number of prime numbers less than n.\n  *\n  * Example:\n  * countPrimes(10)\n  * Output: 4\n  *\n  * Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n  */\n  def countPrimes(n: Int): Int = ", "canonical_solution": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Additional test cases\n    assert(countPrimes(15) == 6)\n    assert(countPrimes(30) == 10)\n    assert(countPrimes(50) == 15)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrimes", "signature": "def countPrimes(n: Int): Int =", "docstring": "Count the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n\n* Incomplete Code:\ndef countPrimes(n: Int): Int =\n  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n[MASK]\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n[MASK]\n    }\n  }"}
{"task_id": "Scala/41-1-single", "prompt": "\nobject Solution {\n/**\n  * Count the number of prime numbers less than a non-negative integer n.\n  *\n  * @param n The non-negative integer.\n  * @return The number of prime numbers less than n.\n  *\n  * Example:\n  * countPrimes(10)\n  * Output: 4\n  *\n  * Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n  */\n  def countPrimes(n: Int): Int = ", "canonical_solution": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Additional test cases\n    assert(countPrimes(15) == 6)\n    assert(countPrimes(30) == 10)\n    assert(countPrimes(50) == 15)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrimes", "signature": "def countPrimes(n: Int): Int =", "docstring": "Count the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n\n* Incomplete Code:\ndef countPrimes(n: Int): Int =\n  {\n\n     if (n <= 2) 0\n[MASK]\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n     if (n <= 2) 0\n[MASK]\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }"}
{"task_id": "Scala/42-0-single", "prompt": "\nobject Solution {\n  /**\n    * Check if the binary representation of a positive integer has alternating bits.\n    *\n    * @param n The positive integer to check.\n    * @return True if the binary representation has alternating bits, false otherwise.\n    *\n    * Example:\n    * hasAlternatingBits(5)\n    * Output: true\n    */\n  def hasAlternatingBits(n: Int): Boolean = ", "canonical_solution": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hasAlternatingBits(10)) // Binary representation of 10 is 1010 which has alternating bits\n    assert(!hasAlternatingBits(7)) // Binary representation of 7 is 111 which does not have alternating bits\n    assert(hasAlternatingBits(21)) // Binary representation of 21 is 10101 which has alternating bits\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "hasAlternatingBits", "signature": "def hasAlternatingBits(n: Int): Boolean =", "docstring": "Check if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true\n\n* Incomplete Code:\ndef hasAlternatingBits(n: Int): Boolean =\n  {\n\n    val binaryString = n.toBinaryString\n[MASK]\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val binaryString = n.toBinaryString\n[MASK]\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }"}
{"task_id": "Scala/42-1-single", "prompt": "\nobject Solution {\n  /**\n    * Check if the binary representation of a positive integer has alternating bits.\n    *\n    * @param n The positive integer to check.\n    * @return True if the binary representation has alternating bits, false otherwise.\n    *\n    * Example:\n    * hasAlternatingBits(5)\n    * Output: true\n    */\n  def hasAlternatingBits(n: Int): Boolean = ", "canonical_solution": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hasAlternatingBits(10)) // Binary representation of 10 is 1010 which has alternating bits\n    assert(!hasAlternatingBits(7)) // Binary representation of 7 is 111 which does not have alternating bits\n    assert(hasAlternatingBits(21)) // Binary representation of 21 is 10101 which has alternating bits\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "hasAlternatingBits", "signature": "def hasAlternatingBits(n: Int): Boolean =", "docstring": "Check if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true\n\n* Incomplete Code:\ndef hasAlternatingBits(n: Int): Boolean =\n  {\n\n[MASK]\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }"}
{"task_id": "Scala/43-0-single", "prompt": "import scala.collection.mutable.ArrayBuffer\n\nobject Solution {\n  /**\n    * Move all even elements to the front of the array, followed by all odd elements.\n    *\n    * @param nums An array of integers.\n    * @return The modified array with even elements in the front and odd elements at the end.\n    *\n    * Example:\n    * moveEvenOdd(Array(3, 1, 2, 4))\n    * Output: Array(2, 4, 3, 1)\n    *\n    * Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n    */\n  def moveEvenOdd(nums: Array[Int]): Array[Int] = ", "canonical_solution": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(moveEvenOdd(Array(5, 8, 3, 6)).sameElements(Array(8, 6, 5, 3)))\n\n    // Test case 2\n    assert(moveEvenOdd(Array(7, 2)).sameElements(Array(2, 7)))\n\n    // Test case 3\n    assert(moveEvenOdd(Array(9, 1, 4, 7, 6)).sameElements(Array(4, 6, 9, 1, 7)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveEvenOdd", "signature": "def moveEvenOdd(nums: Array[Int]): Array[Int] =", "docstring": "Move all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n\n* Incomplete Code:\ndef moveEvenOdd(nums: Array[Int]): Array[Int] =\n  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n[MASK]\n  }"}
{"task_id": "Scala/43-1-single", "prompt": "import scala.collection.mutable.ArrayBuffer\n\nobject Solution {\n  /**\n    * Move all even elements to the front of the array, followed by all odd elements.\n    *\n    * @param nums An array of integers.\n    * @return The modified array with even elements in the front and odd elements at the end.\n    *\n    * Example:\n    * moveEvenOdd(Array(3, 1, 2, 4))\n    * Output: Array(2, 4, 3, 1)\n    *\n    * Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n    */\n  def moveEvenOdd(nums: Array[Int]): Array[Int] = ", "canonical_solution": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(moveEvenOdd(Array(5, 8, 3, 6)).sameElements(Array(8, 6, 5, 3)))\n\n    // Test case 2\n    assert(moveEvenOdd(Array(7, 2)).sameElements(Array(2, 7)))\n\n    // Test case 3\n    assert(moveEvenOdd(Array(9, 1, 4, 7, 6)).sameElements(Array(4, 6, 9, 1, 7)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveEvenOdd", "signature": "def moveEvenOdd(nums: Array[Int]): Array[Int] =", "docstring": "Move all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n\n* Incomplete Code:\ndef moveEvenOdd(nums: Array[Int]): Array[Int] =\n  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n[MASK]\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n[MASK]\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }"}
{"task_id": "Scala/46-0-single", "prompt": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n  /**\n  * Generate all unique permutations of a sequence of numbers.\n  *\n  * @param nums The sequence of numbers.\n  * @return A list of all unique permutations.\n  *\n  * Example:\n  * permute(Array(1, 1, 2))\n  * Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n  */\n  def permute(nums: Array[Int]): List[List[Int]] = ", "canonical_solution": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(permute(Array(2, 3, 5)).toSet == Set(\n      List(2, 3, 5), List(2, 5, 3), List(3, 2, 5),\n      List(3, 5, 2), List(5, 2, 3), List(5, 3, 2)\n    ))\n\n    // Test case 2\n    assert(permute(Array(0, -1, 1)).toSet == Set(\n      List(0, -1, 1), List(0, 1, -1), List(-1, 0, 1),\n      List(-1, 1, 0), List(1, 0, -1), List(1, -1, 0)\n    ))\n\n    // Test case 3\n    assert(permute(Array(1, 2)).toSet == Set(\n      List(1, 2), List(2, 1)\n    ))\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "permute", "signature": "def permute(nums: Array[Int]): List[List[Int]] =", "docstring": "Generate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n\n* Incomplete Code:\ndef permute(nums: Array[Int]): List[List[Int]] =\n  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n[MASK]\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n[MASK]\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n"}
{"task_id": "Scala/46-1-single", "prompt": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n  /**\n  * Generate all unique permutations of a sequence of numbers.\n  *\n  * @param nums The sequence of numbers.\n  * @return A list of all unique permutations.\n  *\n  * Example:\n  * permute(Array(1, 1, 2))\n  * Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n  */\n  def permute(nums: Array[Int]): List[List[Int]] = ", "canonical_solution": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(permute(Array(2, 3, 5)).toSet == Set(\n      List(2, 3, 5), List(2, 5, 3), List(3, 2, 5),\n      List(3, 5, 2), List(5, 2, 3), List(5, 3, 2)\n    ))\n\n    // Test case 2\n    assert(permute(Array(0, -1, 1)).toSet == Set(\n      List(0, -1, 1), List(0, 1, -1), List(-1, 0, 1),\n      List(-1, 1, 0), List(1, 0, -1), List(1, -1, 0)\n    ))\n\n    // Test case 3\n    assert(permute(Array(1, 2)).toSet == Set(\n      List(1, 2), List(2, 1)\n    ))\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "permute", "signature": "def permute(nums: Array[Int]): List[List[Int]] =", "docstring": "Generate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n\n* Incomplete Code:\ndef permute(nums: Array[Int]): List[List[Int]] =\n  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n[MASK]\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n[MASK]\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n"}
{"task_id": "Scala/47-0-single", "prompt": "\nobject Solution {\n      /**\n       * Reverse the first k characters of every 2k characters in the given string.\n       *\n       * @param s The input string.\n       * @param k The integer k.\n       * @return The modified string.\n       *\n       * Example:\n       * reverseString(\"abcdefg\", 2)\n       * Output: \"bacdfeg\"\n       *\n       * reverseString(\"abcd\", 2)\n       * Output: \"bacd\"\n       */\n  def reverseString(s: String, k: Int): String = ", "canonical_solution": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"example\", 3) == \"axemple\")\n    assert(reverseString(\"helloScala\", 4) == \"llehoScaal\")\n    assert(reverseString(\"scalaisfun\", 5) == \"alacsisfun\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String, k: Int): String =", "docstring": "Reverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"\n\n* Incomplete Code:\ndef reverseString(s: String, k: Int): String =\n  {\n\n    s.grouped(2 * k).map {\n[MASK]\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    s.grouped(2 * k).map {\n[MASK]\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }"}
{"task_id": "Scala/47-1-single", "prompt": "\nobject Solution {\n      /**\n       * Reverse the first k characters of every 2k characters in the given string.\n       *\n       * @param s The input string.\n       * @param k The integer k.\n       * @return The modified string.\n       *\n       * Example:\n       * reverseString(\"abcdefg\", 2)\n       * Output: \"bacdfeg\"\n       *\n       * reverseString(\"abcd\", 2)\n       * Output: \"bacd\"\n       */\n  def reverseString(s: String, k: Int): String = ", "canonical_solution": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"example\", 3) == \"axemple\")\n    assert(reverseString(\"helloScala\", 4) == \"llehoScaal\")\n    assert(reverseString(\"scalaisfun\", 5) == \"alacsisfun\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String, k: Int): String =", "docstring": "Reverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"\n\n* Incomplete Code:\ndef reverseString(s: String, k: Int): String =\n  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n[MASK]\n    }.mkString\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n[MASK]\n    }.mkString\n  }"}
{"task_id": "Scala/50-0-single", "prompt": "object Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  def minPerfectSquareSum(n: Int): Int = ", "canonical_solution": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(minPerfectSquareSum(26) == 2, \"Test case 1 failed\")\n    assert(minPerfectSquareSum(17) == 2, \"Test case 2 failed\")\n    assert(minPerfectSquareSum(99) == 3, \"Test case 3 failed\")\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "def minPerfectSquareSum(n: Int): Int =", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2\n\n* Incomplete Code:\ndef minPerfectSquareSum(n: Int): Int =\n  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n[MASK]\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n[MASK]\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }"}
{"task_id": "Scala/50-1-single", "prompt": "object Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  def minPerfectSquareSum(n: Int): Int = ", "canonical_solution": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(minPerfectSquareSum(26) == 2, \"Test case 1 failed\")\n    assert(minPerfectSquareSum(17) == 2, \"Test case 2 failed\")\n    assert(minPerfectSquareSum(99) == 3, \"Test case 3 failed\")\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "def minPerfectSquareSum(n: Int): Int =", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2\n\n* Incomplete Code:\ndef minPerfectSquareSum(n: Int): Int =\n  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n[MASK]\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n[MASK]\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }"}
{"task_id": "Scala/1-0-multi", "prompt": "object Main extends App {\n\n  /**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n  */\n  def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "canonical_solution": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }", "test": "// Test cases\n  def test(): Unit = {\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n  }\n\n  // Run the test\n  test()\n}", "entry_point": "hasCloseElements", "signature": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n\n* Incomplete Code:\ndef hasCloseElements(numbers: List[Double], threshold: Double): Boolean =\n{\n    \n[MASK]\n[MASK]\n      (elem2, idx2) <- numbers.zipWithIndex\n[MASK]\n    } {\n      val distance = math.abs(elem - elem2)\n[MASK]\n        return true\n      }\n    }\n    false\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n    \n[MASK]\n[MASK]\n      (elem2, idx2) <- numbers.zipWithIndex\n[MASK]\n    } {\n      val distance = math.abs(elem - elem2)\n[MASK]\n        return true\n      }\n    }\n    false\n  }"}
{"task_id": "Scala/1-1-multi", "prompt": "object Main extends App {\n\n  /**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n  */\n  def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "canonical_solution": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }", "test": "// Test cases\n  def test(): Unit = {\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n  }\n\n  // Run the test\n  test()\n}", "entry_point": "hasCloseElements", "signature": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n\n* Incomplete Code:\ndef hasCloseElements(numbers: List[Double], threshold: Double): Boolean =\n{\n    \n[MASK]\n      (elem, idx) <- numbers.zipWithIndex\n[MASK]\n[MASK]\n    } {\n[MASK]\n      if (distance < threshold) {\n        return true\n      }\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n    \n[MASK]\n      (elem, idx) <- numbers.zipWithIndex\n[MASK]\n[MASK]\n    } {\n[MASK]\n      if (distance < threshold) {\n        return true\n      }\n    }\n[MASK]\n  }"}
{"task_id": "Scala/2-0-multi", "prompt": "object Solution {\n  /**\n    * Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n    *\n    * A subarray is defined as a contiguous sequence of numbers in an array.\n    *\n    * An ascending subarray is a subarray where the numbers are in strictly increasing order.\n    *\n    * Example:\n    * maxAscendingSum(Array(10,20,30,5,10,50))\n    * Output: 65\n    */\n  def maxAscendingSum(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(maxAscendingSum(Array(1, 2, 3, 4, 5, 6)) == 21)\n    assert(maxAscendingSum(Array(10, 20, 30, 40, 50, 5, 6, 7, 8, 9)) == 150)\n    assert(maxAscendingSum(Array(100, 200, 300, 400, 500, 1, 2, 3, 4, 5)) == 1500)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxAscendingSum", "signature": "def maxAscendingSum(nums: Array[Int]): Int =", "docstring": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65\n\n* Incomplete Code:\ndef maxAscendingSum(nums: Array[Int]): Int =\n  {\n\n    var maxSum = 0\n[MASK]\n\n[MASK]\n[MASK]\n[MASK]\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var maxSum = 0\n[MASK]\n\n[MASK]\n[MASK]\n[MASK]\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n[MASK]\n  }"}
{"task_id": "Scala/2-1-multi", "prompt": "object Solution {\n  /**\n    * Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n    *\n    * A subarray is defined as a contiguous sequence of numbers in an array.\n    *\n    * An ascending subarray is a subarray where the numbers are in strictly increasing order.\n    *\n    * Example:\n    * maxAscendingSum(Array(10,20,30,5,10,50))\n    * Output: 65\n    */\n  def maxAscendingSum(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(maxAscendingSum(Array(1, 2, 3, 4, 5, 6)) == 21)\n    assert(maxAscendingSum(Array(10, 20, 30, 40, 50, 5, 6, 7, 8, 9)) == 150)\n    assert(maxAscendingSum(Array(100, 200, 300, 400, 500, 1, 2, 3, 4, 5)) == 1500)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxAscendingSum", "signature": "def maxAscendingSum(nums: Array[Int]): Int =", "docstring": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65\n\n* Incomplete Code:\ndef maxAscendingSum(nums: Array[Int]): Int =\n  {\n\n    var maxSum = 0\n[MASK]\n\n[MASK]\n[MASK]\n        currentSum += nums(i)\n      } else {\n[MASK]\n[MASK]\n      }\n    }\n\n    maxSum.max(currentSum)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var maxSum = 0\n[MASK]\n\n[MASK]\n[MASK]\n        currentSum += nums(i)\n      } else {\n[MASK]\n[MASK]\n      }\n    }\n\n    maxSum.max(currentSum)\n  }"}
{"task_id": "Scala/4-0-multi", "prompt": "import scala.collection.mutable.ArrayBuffer\nobject Solution {\n    /**\n    * Find the most competitive subsequence of length k from the given integer array.\n    *\n    * @param nums The integer array.\n    * @param k The length of the subsequence.\n    * @return The most competitive subsequence.\n    *\n    * Example:\n    * mostCompetitive(Array(3, 5, 2, 6), 2)\n    * Output: Array(2, 6)\n    */\n  def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = ", "canonical_solution": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }", "test": "        def main(args: Array[String]): Unit = {\n            assert(mostCompetitive(Array(3, 5, 2, 6), 2).sameElements(Array(2, 6)))\n            assert(mostCompetitive(Array(2, 4, 3, 3, 5, 4, 9, 6), 4).sameElements(Array(2, 3, 3, 4)))\n            assert(mostCompetitive(Array(6, 7, 5, 3, 5, 6, 4, 2), 3).sameElements(Array(3, 4, 2)))\n            println(\"All tests passed\")\n        }\n    }", "entry_point": "mostCompetitive", "signature": "def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =", "docstring": "Find the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)\n\n* Incomplete Code:\ndef mostCompetitive(nums: Array[Int], k: Int): Array[Int] =\n  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n[MASK]\n[MASK]\n                }\n                if (stack.length < k) {\n[MASK]\n                }\n            }\n            stack.toArray\n        }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n[MASK]\n[MASK]\n                }\n                if (stack.length < k) {\n[MASK]\n                }\n            }\n            stack.toArray\n        }"}
{"task_id": "Scala/4-1-multi", "prompt": "import scala.collection.mutable.ArrayBuffer\nobject Solution {\n    /**\n    * Find the most competitive subsequence of length k from the given integer array.\n    *\n    * @param nums The integer array.\n    * @param k The length of the subsequence.\n    * @return The most competitive subsequence.\n    *\n    * Example:\n    * mostCompetitive(Array(3, 5, 2, 6), 2)\n    * Output: Array(2, 6)\n    */\n  def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = ", "canonical_solution": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }", "test": "        def main(args: Array[String]): Unit = {\n            assert(mostCompetitive(Array(3, 5, 2, 6), 2).sameElements(Array(2, 6)))\n            assert(mostCompetitive(Array(2, 4, 3, 3, 5, 4, 9, 6), 4).sameElements(Array(2, 3, 3, 4)))\n            assert(mostCompetitive(Array(6, 7, 5, 3, 5, 6, 4, 2), 3).sameElements(Array(3, 4, 2)))\n            println(\"All tests passed\")\n        }\n    }", "entry_point": "mostCompetitive", "signature": "def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =", "docstring": "Find the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)\n\n* Incomplete Code:\ndef mostCompetitive(nums: Array[Int], k: Int): Array[Int] =\n  {\n \n            val stack = new ArrayBuffer[Int]()\n[MASK]\n[MASK]\n                    stack.remove(stack.length - 1)\n                }\n[MASK]\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n            val stack = new ArrayBuffer[Int]()\n[MASK]\n[MASK]\n                    stack.remove(stack.length - 1)\n                }\n[MASK]\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }"}
{"task_id": "Scala/5-0-multi", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n    /**\n      * Generate all possible palindrome strings by rearranging the characters in the input string.\n      *\n      * @param s The input string.\n      * @return A list of all possible palindrome strings, without duplicates.\n      *\n      * Example:\n      * generatePalindromes(\"aabb\")\n      * Output: List(\"abba\", \"baab\")\n      */\n  def generatePalindromes(s: String): List[String] = ", "canonical_solution": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val result1 = generatePalindromes(\"aabb\")\n    assert(result1.contains(\"abba\"))\n    assert(result1.contains(\"baab\"))\n    \n    val result2 = generatePalindromes(\"abc\")\n    assert(result2.isEmpty)\n\n    val result3 = generatePalindromes(\"aabbc\")\n    assert(result3.contains(\"abcba\"))\n    assert(result3.contains(\"bacab\"))\n    \n    println(\"All tests passed\")\n}\n    \n}", "entry_point": "generatePalindromes", "signature": "def generatePalindromes(s: String): List[String] =", "docstring": "Generate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")\n\n* Incomplete Code:\ndef generatePalindromes(s: String): List[String] =\n  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n[MASK]\n      if (count(i) % 2 != 0) {\n[MASK]\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n[MASK]\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n[MASK]\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n[MASK]\n      if (count(i) % 2 != 0) {\n[MASK]\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n[MASK]\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n[MASK]\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }"}
{"task_id": "Scala/5-1-multi", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n    /**\n      * Generate all possible palindrome strings by rearranging the characters in the input string.\n      *\n      * @param s The input string.\n      * @return A list of all possible palindrome strings, without duplicates.\n      *\n      * Example:\n      * generatePalindromes(\"aabb\")\n      * Output: List(\"abba\", \"baab\")\n      */\n  def generatePalindromes(s: String): List[String] = ", "canonical_solution": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val result1 = generatePalindromes(\"aabb\")\n    assert(result1.contains(\"abba\"))\n    assert(result1.contains(\"baab\"))\n    \n    val result2 = generatePalindromes(\"abc\")\n    assert(result2.isEmpty)\n\n    val result3 = generatePalindromes(\"aabbc\")\n    assert(result3.contains(\"abcba\"))\n    assert(result3.contains(\"bacab\"))\n    \n    println(\"All tests passed\")\n}\n    \n}", "entry_point": "generatePalindromes", "signature": "def generatePalindromes(s: String): List[String] =", "docstring": "Generate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")\n\n* Incomplete Code:\ndef generatePalindromes(s: String): List[String] =\n  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n[MASK]\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n[MASK]\n      return\n    }\n\n    for (i <- count.indices) {\n[MASK]\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n[MASK]\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n[MASK]\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n[MASK]\n      return\n    }\n\n    for (i <- count.indices) {\n[MASK]\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n[MASK]\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }"}
{"task_id": "Scala/6-0-multi", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n    /**\n      * Find the value of the bottom-most left node in a binary tree.\n      *\n      * @param root The root node of the binary tree.\n      * @return The value of the bottom-most left node.\n      *\n      * Example:\n      * findBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\n      * Output: 1\n      *\n      * findBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\n      * Output: 7\n      */\n  def findBottomLeftValue(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2)\n    root1.left = new TreeNode(1)\n    root1.right = new TreeNode(3)\n    assert(findBottomLeftValue(root1) == 1)\n\n    // Test Case 2\n    val root2 = new TreeNode(1)\n    root2.left = new TreeNode(2)\n    root2.left.left = new TreeNode(4)\n    root2.right = new TreeNode(3)\n    root2.right.left = new TreeNode(5)\n    root2.right.left.left = new TreeNode(7)\n    root2.right.left.right = new TreeNode(6)\n    assert(findBottomLeftValue(root2) == 7)\n\n    // Test Case 3\n    val root3 = new TreeNode(5)\n    root3.left = new TreeNode(3)\n    root3.right = new TreeNode(6)\n    root3.left.left = new TreeNode(2)\n    root3.left.right = new TreeNode(4)\n    root3.left.left.left = new TreeNode(1)\n    assert(findBottomLeftValue(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findBottomLeftValue", "signature": "def findBottomLeftValue(root: TreeNode): Int =", "docstring": "Find the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7\n\n* Incomplete Code:\ndef findBottomLeftValue(root: TreeNode): Int =\n  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n[MASK]\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n[MASK]\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n[MASK]\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n[MASK]\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }"}
{"task_id": "Scala/6-1-multi", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n    /**\n      * Find the value of the bottom-most left node in a binary tree.\n      *\n      * @param root The root node of the binary tree.\n      * @return The value of the bottom-most left node.\n      *\n      * Example:\n      * findBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\n      * Output: 1\n      *\n      * findBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\n      * Output: 7\n      */\n  def findBottomLeftValue(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2)\n    root1.left = new TreeNode(1)\n    root1.right = new TreeNode(3)\n    assert(findBottomLeftValue(root1) == 1)\n\n    // Test Case 2\n    val root2 = new TreeNode(1)\n    root2.left = new TreeNode(2)\n    root2.left.left = new TreeNode(4)\n    root2.right = new TreeNode(3)\n    root2.right.left = new TreeNode(5)\n    root2.right.left.left = new TreeNode(7)\n    root2.right.left.right = new TreeNode(6)\n    assert(findBottomLeftValue(root2) == 7)\n\n    // Test Case 3\n    val root3 = new TreeNode(5)\n    root3.left = new TreeNode(3)\n    root3.right = new TreeNode(6)\n    root3.left.left = new TreeNode(2)\n    root3.left.right = new TreeNode(4)\n    root3.left.left.left = new TreeNode(1)\n    assert(findBottomLeftValue(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findBottomLeftValue", "signature": "def findBottomLeftValue(root: TreeNode): Int =", "docstring": "Find the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7\n\n* Incomplete Code:\ndef findBottomLeftValue(root: TreeNode): Int =\n  {\n\n    if (root == null)\n[MASK]\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n[MASK]\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n[MASK]\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n[MASK]\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n[MASK]\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null)\n[MASK]\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n[MASK]\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n[MASK]\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n[MASK]\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n[MASK]\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }"}
{"task_id": "Scala/7-0-multi", "prompt": "// Definition for a binary tree node.\ncase class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Determine whether a binary tree is a valid binary search tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a valid binary search tree, false otherwise.\n    *\n    * Example:\n    * isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\n    * isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n    */\n  def isValidBST(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2, new TreeNode(1), new TreeNode(3))\n    assert(isValidBST(root1), \"Test Case 1 Failed\")\n\n    // Test Case 2\n    val root2 = new TreeNode(5, new TreeNode(1), new TreeNode(4, new TreeNode(3), new TreeNode(6)))\n    assert(!isValidBST(root2), \"Test Case 2 Failed\")\n\n    // Test Case 3\n    val root3 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(5))\n    assert(isValidBST(root3), \"Test Case 3 Failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isValidBST", "signature": "def isValidBST(root: TreeNode): Boolean =", "docstring": "Determine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n\n* Incomplete Code:\ndef isValidBST(root: TreeNode): Boolean =\n  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n[MASK]\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n[MASK]\n[MASK]\n[MASK]\n      }\n    }\n    \n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n[MASK]\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n[MASK]\n[MASK]\n[MASK]\n      }\n    }\n    \n[MASK]\n  }"}
{"task_id": "Scala/7-1-multi", "prompt": "// Definition for a binary tree node.\ncase class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Determine whether a binary tree is a valid binary search tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a valid binary search tree, false otherwise.\n    *\n    * Example:\n    * isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\n    * isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n    */\n  def isValidBST(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2, new TreeNode(1), new TreeNode(3))\n    assert(isValidBST(root1), \"Test Case 1 Failed\")\n\n    // Test Case 2\n    val root2 = new TreeNode(5, new TreeNode(1), new TreeNode(4, new TreeNode(3), new TreeNode(6)))\n    assert(!isValidBST(root2), \"Test Case 2 Failed\")\n\n    // Test Case 3\n    val root3 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(5))\n    assert(isValidBST(root3), \"Test Case 3 Failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isValidBST", "signature": "def isValidBST(root: TreeNode): Boolean =", "docstring": "Determine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n\n* Incomplete Code:\ndef isValidBST(root: TreeNode): Boolean =\n  {\n\n[MASK]\n[MASK]\n[MASK]\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n[MASK]\n[MASK]\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }"}
{"task_id": "Scala/8-0-multi", "prompt": "object Solution {\n    /**\n     * Find all the numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * @param nums An array containing n integers.\n     * @return An array of numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * Example:\n     * findDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\n     * Output: Array(5,6)\n     *\n     * findDisappearedNumbers(Array(1,1))\n     * Output: Array(2)\n     */\n  def findDisappearedNumbers(nums: Array[Int]): List[Int] = ", "canonical_solution": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(4, 3, 2, 7, 8, 2, 3, 1)\n    val result1 = findDisappearedNumbers(nums1)\n    assert(result1.contains(5))\n    assert(result1.contains(6))\n\n    val nums2 = Array(1, 1)\n    val result2 = findDisappearedNumbers(nums2)\n    assert(result2.contains(2))\n\n    val nums3 = Array(2, 2, 2, 2, 2)\n    val result3 = findDisappearedNumbers(nums3)\n    assert(result3.contains(1))\n    assert(result3.contains(3))\n    assert(result3.contains(4))\n    assert(result3.contains(5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findDisappearedNumbers", "signature": "def findDisappearedNumbers(nums: Array[Int]): List[Int] =", "docstring": "Find all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)\n\n* Incomplete Code:\ndef findDisappearedNumbers(nums: Array[Int]): List[Int] =\n  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n[MASK]\n      if (nums(i) > 0) {\n[MASK]\n      }\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n[MASK]\n      if (nums(i) > 0) {\n[MASK]\n      }\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/8-1-multi", "prompt": "object Solution {\n    /**\n     * Find all the numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * @param nums An array containing n integers.\n     * @return An array of numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * Example:\n     * findDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\n     * Output: Array(5,6)\n     *\n     * findDisappearedNumbers(Array(1,1))\n     * Output: Array(2)\n     */\n  def findDisappearedNumbers(nums: Array[Int]): List[Int] = ", "canonical_solution": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(4, 3, 2, 7, 8, 2, 3, 1)\n    val result1 = findDisappearedNumbers(nums1)\n    assert(result1.contains(5))\n    assert(result1.contains(6))\n\n    val nums2 = Array(1, 1)\n    val result2 = findDisappearedNumbers(nums2)\n    assert(result2.contains(2))\n\n    val nums3 = Array(2, 2, 2, 2, 2)\n    val result3 = findDisappearedNumbers(nums3)\n    assert(result3.contains(1))\n    assert(result3.contains(3))\n    assert(result3.contains(4))\n    assert(result3.contains(5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findDisappearedNumbers", "signature": "def findDisappearedNumbers(nums: Array[Int]): List[Int] =", "docstring": "Find all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)\n\n* Incomplete Code:\ndef findDisappearedNumbers(nums: Array[Int]): List[Int] =\n  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n[MASK]\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n[MASK]\n[MASK]\n        result += (i + 1)\n      }\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n[MASK]\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n[MASK]\n[MASK]\n        result += (i + 1)\n      }\n    }\n\n[MASK]\n  }"}
{"task_id": "Scala/9-0-multi", "prompt": "object Solution {\n  /**\n    * Given an integer n, returns an array consisting of n unique integers that add up to 0.\n    *\n    * @param n The number of integers in the array.\n    * @return An array of n unique integers that add up to 0.\n    *\n    * Example:\n    * sumZero(5)\n    * Output: [-7, -1, 1, 3, 4]\n    *\n    * Note:\n    * Other valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n    */\n  def sumZero(n: Int): Array[Int] = ", "canonical_solution": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }", "test": "  \n  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val result1 = sumZero(4)\n    assert(result1.sameElements(Array(1, 2, 3, -6)))\n    \n    // Test case 2\n    val result2 = sumZero(6)\n    assert(result2.sameElements(Array(1, 2, 3, 4, 5, -15)))\n    \n    // Test case 3\n    val result3 = sumZero(8)\n    assert(result3.sameElements(Array(1, 2, 3, 4, 5, 6, 7, -28)))\n    \n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "sumZero", "signature": "def sumZero(n: Int): Array[Int] =", "docstring": "Given an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n\n* Incomplete Code:\ndef sumZero(n: Int): Array[Int] =\n  {\n\n    // function implementation goes here\n[MASK]\n[MASK]\n    \n[MASK]\n[MASK]\n      sum += result(i)\n    }\n    \n[MASK]\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // function implementation goes here\n[MASK]\n[MASK]\n    \n[MASK]\n[MASK]\n      sum += result(i)\n    }\n    \n[MASK]\n    result\n  }"}
{"task_id": "Scala/9-1-multi", "prompt": "object Solution {\n  /**\n    * Given an integer n, returns an array consisting of n unique integers that add up to 0.\n    *\n    * @param n The number of integers in the array.\n    * @return An array of n unique integers that add up to 0.\n    *\n    * Example:\n    * sumZero(5)\n    * Output: [-7, -1, 1, 3, 4]\n    *\n    * Note:\n    * Other valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n    */\n  def sumZero(n: Int): Array[Int] = ", "canonical_solution": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }", "test": "  \n  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val result1 = sumZero(4)\n    assert(result1.sameElements(Array(1, 2, 3, -6)))\n    \n    // Test case 2\n    val result2 = sumZero(6)\n    assert(result2.sameElements(Array(1, 2, 3, 4, 5, -15)))\n    \n    // Test case 3\n    val result3 = sumZero(8)\n    assert(result3.sameElements(Array(1, 2, 3, 4, 5, 6, 7, -28)))\n    \n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "sumZero", "signature": "def sumZero(n: Int): Array[Int] =", "docstring": "Given an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n\n* Incomplete Code:\ndef sumZero(n: Int): Array[Int] =\n  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n[MASK]\n      result(i) = i + 1\n[MASK]\n    }\n    \n[MASK]\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n[MASK]\n      result(i) = i + 1\n[MASK]\n    }\n    \n[MASK]\n    result\n  }"}
{"task_id": "Scala/11-0-multi", "prompt": "\nobject Solution {\n  /**\n    * Calculate the total amount of water that can be trapped between the given heights.\n    *\n    * @param height An array representing the heights of each bar.\n    * @return The total amount of water that can be trapped.\n    *\n    * Example:\n    * trap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\n    * Output: 6\n    *\n    * Explanation:\n    * The heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n    */\n  def trap(height: Array[Int]): Int = ", "canonical_solution": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(trap(Array(1, 0, 2, 0, 1)) == 2)\n    assert(trap(Array(3, 2, 1, 0, 1, 2, 3)) == 9)\n    assert(trap(Array(2, 1, 4, 3, 1, 2)) == 2)\n\n    println(\"All tests passed\")\n  }\n}\n      ", "entry_point": "trap", "signature": "def trap(height: Array[Int]): Int =", "docstring": "Calculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n\n* Incomplete Code:\ndef trap(height: Array[Int]): Int =\n  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n[MASK]\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n[MASK]\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n[MASK]\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n[MASK]\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }"}
{"task_id": "Scala/11-1-multi", "prompt": "\nobject Solution {\n  /**\n    * Calculate the total amount of water that can be trapped between the given heights.\n    *\n    * @param height An array representing the heights of each bar.\n    * @return The total amount of water that can be trapped.\n    *\n    * Example:\n    * trap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\n    * Output: 6\n    *\n    * Explanation:\n    * The heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n    */\n  def trap(height: Array[Int]): Int = ", "canonical_solution": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(trap(Array(1, 0, 2, 0, 1)) == 2)\n    assert(trap(Array(3, 2, 1, 0, 1, 2, 3)) == 9)\n    assert(trap(Array(2, 1, 4, 3, 1, 2)) == 2)\n\n    println(\"All tests passed\")\n  }\n}\n      ", "entry_point": "trap", "signature": "def trap(height: Array[Int]): Int =", "docstring": "Calculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n\n* Incomplete Code:\ndef trap(height: Array[Int]): Int =\n  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n[MASK]\n\n    var max = 0\n    for (i <- 0 until n) {\n[MASK]\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n[MASK]\n\n    var max = 0\n    for (i <- 0 until n) {\n[MASK]\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }"}
{"task_id": "Scala/12-0-multi", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n  /**\n    * Remove the minimum number of invalid parentheses from the given string to make it valid.\n    *\n    * @param s The input string containing parentheses and letters.\n    * @return A list of all possible valid strings after removing invalid parentheses.\n    *\n    * Example:\n    * removeInvalidParentheses(\"()())()\")\n    * Output: List(\"(())()\", \"()()()\")\n    */\n  def removeInvalidParentheses(s: String): List[String] = ", "canonical_solution": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test 1\n    val result1 = removeInvalidParentheses(\"()())()\")\n    assert(result1.contains(\"(())()\"))\n    assert(result1.contains(\"()()()\"))\n\n    // Test 2\n    val result2 = removeInvalidParentheses(\"(a)())()\")\n    assert(result2.contains(\"(a())()\"))\n    assert(result2.contains(\"(a)()()\"))\n\n    // Test 3\n    val result3 = removeInvalidParentheses(\")(\")\n    assert(result3.contains(\"\"))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeInvalidParentheses", "signature": "def removeInvalidParentheses(s: String): List[String] =", "docstring": "Remove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")\n\n* Incomplete Code:\ndef removeInvalidParentheses(s: String): List[String] =\n  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n[MASK]\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n[MASK]\n    if (open == '(') {\n[MASK]\n    } else {\n      result += reversed\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n[MASK]\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n[MASK]\n    if (open == '(') {\n[MASK]\n    } else {\n      result += reversed\n    }\n  }"}
{"task_id": "Scala/12-1-multi", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n  /**\n    * Remove the minimum number of invalid parentheses from the given string to make it valid.\n    *\n    * @param s The input string containing parentheses and letters.\n    * @return A list of all possible valid strings after removing invalid parentheses.\n    *\n    * Example:\n    * removeInvalidParentheses(\"()())()\")\n    * Output: List(\"(())()\", \"()()()\")\n    */\n  def removeInvalidParentheses(s: String): List[String] = ", "canonical_solution": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test 1\n    val result1 = removeInvalidParentheses(\"()())()\")\n    assert(result1.contains(\"(())()\"))\n    assert(result1.contains(\"()()()\"))\n\n    // Test 2\n    val result2 = removeInvalidParentheses(\"(a)())()\")\n    assert(result2.contains(\"(a())()\"))\n    assert(result2.contains(\"(a)()()\"))\n\n    // Test 3\n    val result3 = removeInvalidParentheses(\")(\")\n    assert(result3.contains(\"\"))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeInvalidParentheses", "signature": "def removeInvalidParentheses(s: String): List[String] =", "docstring": "Remove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")\n\n* Incomplete Code:\ndef removeInvalidParentheses(s: String): List[String] =\n  {\n    val result = ListBuffer[String]()\n[MASK]\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n[MASK]\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n[MASK]\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val result = ListBuffer[String]()\n[MASK]\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n[MASK]\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n[MASK]\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }"}
{"task_id": "Scala/13-0-multi", "prompt": "case class TreeNode(var value: Int, var left: Option[TreeNode] = None, var right: Option[TreeNode] = None)\nobject Solution {\n\n    /**\n     * Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n     *\n     * @param root The root node of the binary search tree.\n     * @return The minimum difference between any two different nodes values.\n     *\n     * Example:\n     * minDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\n     * Output: 1\n     */\n  def minDiffInBST(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val root = TreeNode(5, Some(TreeNode(3)), Some(TreeNode(7)))\n    root.left.get.left = Some(TreeNode(2))\n    root.left.get.right = Some(TreeNode(4))\n    root.right.get.left = Some(TreeNode(6))\n    root.right.get.right = Some(TreeNode(8))\n\n    assert(minDiffInBST(root) == 1)\n\n    val root2 = TreeNode(8, Some(TreeNode(4)), Some(TreeNode(12)))\n    root2.left.get.left = Some(TreeNode(2))\n    root2.left.get.right = Some(TreeNode(6))\n    root2.right.get.left = Some(TreeNode(10))\n    root2.right.get.right = Some(TreeNode(14))\n\n    assert(minDiffInBST(root2) == 2)\n\n    val root3 = TreeNode(1)\n    root3.right = Some(TreeNode(3))\n    root3.right.get.right = Some(TreeNode(6))\n    root3.right.get.right.get.left = Some(TreeNode(4))\n\n    assert(minDiffInBST(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minDiffInBST", "signature": "def minDiffInBST(root: TreeNode): Int =", "docstring": "Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1\n\n* Incomplete Code:\ndef minDiffInBST(root: TreeNode): Int =\n  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n[MASK]\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n[MASK]\n      }\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n[MASK]\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n[MASK]\n      }\n    }\n\n[MASK]\n  }"}
{"task_id": "Scala/13-1-multi", "prompt": "case class TreeNode(var value: Int, var left: Option[TreeNode] = None, var right: Option[TreeNode] = None)\nobject Solution {\n\n    /**\n     * Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n     *\n     * @param root The root node of the binary search tree.\n     * @return The minimum difference between any two different nodes values.\n     *\n     * Example:\n     * minDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\n     * Output: 1\n     */\n  def minDiffInBST(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val root = TreeNode(5, Some(TreeNode(3)), Some(TreeNode(7)))\n    root.left.get.left = Some(TreeNode(2))\n    root.left.get.right = Some(TreeNode(4))\n    root.right.get.left = Some(TreeNode(6))\n    root.right.get.right = Some(TreeNode(8))\n\n    assert(minDiffInBST(root) == 1)\n\n    val root2 = TreeNode(8, Some(TreeNode(4)), Some(TreeNode(12)))\n    root2.left.get.left = Some(TreeNode(2))\n    root2.left.get.right = Some(TreeNode(6))\n    root2.right.get.left = Some(TreeNode(10))\n    root2.right.get.right = Some(TreeNode(14))\n\n    assert(minDiffInBST(root2) == 2)\n\n    val root3 = TreeNode(1)\n    root3.right = Some(TreeNode(3))\n    root3.right.get.right = Some(TreeNode(6))\n    root3.right.get.right.get.left = Some(TreeNode(4))\n\n    assert(minDiffInBST(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minDiffInBST", "signature": "def minDiffInBST(root: TreeNode): Int =", "docstring": "Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1\n\n* Incomplete Code:\ndef minDiffInBST(root: TreeNode): Int =\n  {\n\n[MASK]\n    var prev: Option[TreeNode] = None\n\n[MASK]\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n[MASK]\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n[MASK]\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    var prev: Option[TreeNode] = None\n\n[MASK]\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n[MASK]\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n[MASK]\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }"}
{"task_id": "Scala/14-0-multi", "prompt": "object Solution {\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n  /**\n    * Find the maximum depth of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The maximum depth of the binary tree.\n    *\n    * Example:\n    * maxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: 3\n    */\n  def maxDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    val root1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    val root2 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), null)))\n    val root3 = TreeNode(10, null, null)\n\n    assert(maxDepth(root1) == 3)\n    assert(maxDepth(root2) == 4)\n    assert(maxDepth(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxDepth", "signature": "def maxDepth(root: TreeNode): Int =", "docstring": "Find the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3\n\n* Incomplete Code:\ndef maxDepth(root: TreeNode): Int =\n  {\n\n[MASK]\n[MASK]\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n[MASK]\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n[MASK]\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n[MASK]\n  }\n"}
{"task_id": "Scala/14-1-multi", "prompt": "object Solution {\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n  /**\n    * Find the maximum depth of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The maximum depth of the binary tree.\n    *\n    * Example:\n    * maxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: 3\n    */\n  def maxDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    val root1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    val root2 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), null)))\n    val root3 = TreeNode(10, null, null)\n\n    assert(maxDepth(root1) == 3)\n    assert(maxDepth(root2) == 4)\n    assert(maxDepth(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxDepth", "signature": "def maxDepth(root: TreeNode): Int =", "docstring": "Find the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3\n\n* Incomplete Code:\ndef maxDepth(root: TreeNode): Int =\n  {\n\n[MASK]\n      return 0\n    }\n\n[MASK]\n    val rightDepth = maxDepth(root.right)\n\n[MASK]\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n      return 0\n    }\n\n[MASK]\n    val rightDepth = maxDepth(root.right)\n\n[MASK]\n  }\n"}
{"task_id": "Scala/15-0-multi", "prompt": "object Solution {\n    /**\n    * Check if a string is a k-palindrome.\n    *\n    * A k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n    *\n    * @param s The input string.\n    * @param k The maximum number of characters that can be removed.\n    * @return True if the string is a k-palindrome, otherwise false.\n    *\n    * Example:\n    * isKPalindrome(\"abcdeca\", 2)\n    * Output: true\n    *\n    * isKPalindrome(\"abbababa\", 1)\n    * Output: true\n    */\n  def isKPalindrome(s: String, k: Int): Boolean = ", "canonical_solution": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(isKPalindrome(\"abcdeca\", 2) == true)\n    assert(isKPalindrome(\"abbababa\", 1) == true)\n    assert(isKPalindrome(\"abcdefg\", 3) == false)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isKPalindrome", "signature": "def isKPalindrome(s: String, k: Int): Boolean =", "docstring": "Check if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true\n\n* Incomplete Code:\ndef isKPalindrome(s: String, k: Int): Boolean =\n  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n[MASK]\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n[MASK]\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n[MASK]\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n[MASK]\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n[MASK]\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n[MASK]\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }"}
{"task_id": "Scala/15-1-multi", "prompt": "object Solution {\n    /**\n    * Check if a string is a k-palindrome.\n    *\n    * A k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n    *\n    * @param s The input string.\n    * @param k The maximum number of characters that can be removed.\n    * @return True if the string is a k-palindrome, otherwise false.\n    *\n    * Example:\n    * isKPalindrome(\"abcdeca\", 2)\n    * Output: true\n    *\n    * isKPalindrome(\"abbababa\", 1)\n    * Output: true\n    */\n  def isKPalindrome(s: String, k: Int): Boolean = ", "canonical_solution": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(isKPalindrome(\"abcdeca\", 2) == true)\n    assert(isKPalindrome(\"abbababa\", 1) == true)\n    assert(isKPalindrome(\"abcdefg\", 3) == false)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isKPalindrome", "signature": "def isKPalindrome(s: String, k: Int): Boolean =", "docstring": "Check if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true\n\n* Incomplete Code:\ndef isKPalindrome(s: String, k: Int): Boolean =\n  {\n\n    // Check if a string is a k-palindrome.\n\n[MASK]\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n[MASK]\n[MASK]\n      }\n\n[MASK]\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n[MASK]\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // Check if a string is a k-palindrome.\n\n[MASK]\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n[MASK]\n[MASK]\n      }\n\n[MASK]\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n[MASK]\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }"}
{"task_id": "Scala/16-0-multi", "prompt": "object Solution {\n\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n   /**\n    * Find the diameter of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The length of the longest path between any two nodes in the tree.\n    *\n    * Example:\n    * diameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\n    * Output: 3\n    *\n    * Note:\n    * The diameter of a binary tree is defined as the length of the longest path between any two nodes,\n    * which may or may not pass through the root.\n    * The length of a path is represented by the number of edges between two nodes.\n    * The given tree is guaranteed to have at most 104 nodes,\n    * and the values of the nodes in the tree are in the range [-100, 100].\n    */\n  def diameterOfBinaryTree(root: TreeNode): Int = ", "canonical_solution": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n    assert(diameterOfBinaryTree(root1) == 3)\n\n    // Test case 2\n    val root2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert(diameterOfBinaryTree(root2) == 3)\n\n    // Test case 3\n    val root3 = TreeNode(1, null, TreeNode(2, null, TreeNode(3, null, TreeNode(4))))\n    assert(diameterOfBinaryTree(root3) == 3)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "diameterOfBinaryTree", "signature": "def diameterOfBinaryTree(root: TreeNode): Int =", "docstring": "Find the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].\n\n* Incomplete Code:\ndef diameterOfBinaryTree(root: TreeNode): Int =\n  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n[MASK]\n[MASK]\n[MASK]\n        val rightHeight = height(node.right)\n[MASK]\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n[MASK]\n[MASK]\n[MASK]\n        val rightHeight = height(node.right)\n[MASK]\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }"}
{"task_id": "Scala/16-1-multi", "prompt": "object Solution {\n\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n   /**\n    * Find the diameter of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The length of the longest path between any two nodes in the tree.\n    *\n    * Example:\n    * diameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\n    * Output: 3\n    *\n    * Note:\n    * The diameter of a binary tree is defined as the length of the longest path between any two nodes,\n    * which may or may not pass through the root.\n    * The length of a path is represented by the number of edges between two nodes.\n    * The given tree is guaranteed to have at most 104 nodes,\n    * and the values of the nodes in the tree are in the range [-100, 100].\n    */\n  def diameterOfBinaryTree(root: TreeNode): Int = ", "canonical_solution": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n    assert(diameterOfBinaryTree(root1) == 3)\n\n    // Test case 2\n    val root2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert(diameterOfBinaryTree(root2) == 3)\n\n    // Test case 3\n    val root3 = TreeNode(1, null, TreeNode(2, null, TreeNode(3, null, TreeNode(4))))\n    assert(diameterOfBinaryTree(root3) == 3)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "diameterOfBinaryTree", "signature": "def diameterOfBinaryTree(root: TreeNode): Int =", "docstring": "Find the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].\n\n* Incomplete Code:\ndef diameterOfBinaryTree(root: TreeNode): Int =\n  {\n \n    def height(node: TreeNode): Int = {\n[MASK]\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n[MASK]\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n[MASK]\n[MASK]\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    def height(node: TreeNode): Int = {\n[MASK]\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n[MASK]\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n[MASK]\n[MASK]\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }"}
{"task_id": "Scala/17-0-multi", "prompt": "object Solution {\n\n    /**\n     * Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n     *\n     * @param date The date in the format \"YYYY-MM-DD\".\n     * @return The day of the year.\n     *\n     * Example:\n     * dayOfYear(\"2019-01-09\")\n     * Output: 9\n     *\n     * dayOfYear(\"2019-02-10\")\n     * Output: 41\n     */\n  def dayOfYear(date: String): Int = ", "canonical_solution": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(dayOfYear(\"2022-03-15\") == 74)\n    assert(dayOfYear(\"2023-11-30\") == 334)\n    assert(dayOfYear(\"2024-07-01\") == 183)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "dayOfYear", "signature": "def dayOfYear(date: String): Int =", "docstring": "Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41\n\n* Incomplete Code:\ndef dayOfYear(date: String): Int =\n  {\n\n[MASK]\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n[MASK]\n\n[MASK]\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n[MASK]\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n[MASK]\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n[MASK]\n\n[MASK]\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n[MASK]\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n[MASK]\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }"}
{"task_id": "Scala/17-1-multi", "prompt": "object Solution {\n\n    /**\n     * Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n     *\n     * @param date The date in the format \"YYYY-MM-DD\".\n     * @return The day of the year.\n     *\n     * Example:\n     * dayOfYear(\"2019-01-09\")\n     * Output: 9\n     *\n     * dayOfYear(\"2019-02-10\")\n     * Output: 41\n     */\n  def dayOfYear(date: String): Int = ", "canonical_solution": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(dayOfYear(\"2022-03-15\") == 74)\n    assert(dayOfYear(\"2023-11-30\") == 334)\n    assert(dayOfYear(\"2024-07-01\") == 183)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "dayOfYear", "signature": "def dayOfYear(date: String): Int =", "docstring": "Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41\n\n* Incomplete Code:\ndef dayOfYear(date: String): Int =\n  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n[MASK]\n[MASK]\n    }\n\n[MASK]\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n[MASK]\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n[MASK]\n[MASK]\n    }\n\n[MASK]\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n[MASK]\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }"}
{"task_id": "Scala/18-0-multi", "prompt": "\nobject Solution {\n  /**\n    * Convert a non-negative integer to its English representation.\n    *\n    * @param num The number to be converted.\n    * @return The English representation of the number.\n    *\n    * Example:\n    * numberToWords(123)\n    * Output: \"One Hundred Twenty Three\"\n    *\n    * numberToWords(12345)\n    * Output: \"Twelve Thousand Three Hundred Forty Five\"\n    *\n    * numberToWords(1234567)\n    * Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n    */\n  def numberToWords(num: Int): String = ", "canonical_solution": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(numberToWords(567) == \"Five Hundred Sixty Seven\")\n    assert(numberToWords(123456) == \"One Hundred Twenty Three Thousand Four Hundred Fifty Six\")\n    assert(numberToWords(987654321) == \"Nine Hundred Eighty Seven Million Six Hundred Fifty Four Thousand Three Hundred Twenty One\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberToWords", "signature": "def numberToWords(num: Int): String =", "docstring": "Convert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nConvert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n* Incomplete Code:\ndef numberToWords(num: Int): String =\n  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n[MASK]\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n[MASK]\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n[MASK]\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n[MASK]\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n[MASK]\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n[MASK]\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n"}
{"task_id": "Scala/18-1-multi", "prompt": "\nobject Solution {\n  /**\n    * Convert a non-negative integer to its English representation.\n    *\n    * @param num The number to be converted.\n    * @return The English representation of the number.\n    *\n    * Example:\n    * numberToWords(123)\n    * Output: \"One Hundred Twenty Three\"\n    *\n    * numberToWords(12345)\n    * Output: \"Twelve Thousand Three Hundred Forty Five\"\n    *\n    * numberToWords(1234567)\n    * Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n    */\n  def numberToWords(num: Int): String = ", "canonical_solution": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(numberToWords(567) == \"Five Hundred Sixty Seven\")\n    assert(numberToWords(123456) == \"One Hundred Twenty Three Thousand Four Hundred Fifty Six\")\n    assert(numberToWords(987654321) == \"Nine Hundred Eighty Seven Million Six Hundred Fifty Four Thousand Three Hundred Twenty One\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberToWords", "signature": "def numberToWords(num: Int): String =", "docstring": "Convert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nConvert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n* Incomplete Code:\ndef numberToWords(num: Int): String =\n  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n[MASK]\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n[MASK]\n\n      while (n > 0) {\n[MASK]\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n[MASK]\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n[MASK]\n\n      while (n > 0) {\n[MASK]\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n"}
{"task_id": "Scala/19-0-multi", "prompt": "\nobject Solution {\n  /**\n    * Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\n    * Calculate and return the total number of complete rows that can be formed.\n    *\n    * @param n The total number of coins.\n    * @return The total number of complete rows that can be formed.\n    *\n    * Example:\n    * arrangeCoins(5)\n    * Output: 2\n    * Explanation: The third row is incomplete, so return 2.\n    */\n  def arrangeCoins(n: Int): Int = ", "canonical_solution": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(arrangeCoins(8) == 3)\n    assert(arrangeCoins(15) == 5)\n    assert(arrangeCoins(20) == 5)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "arrangeCoins", "signature": "def arrangeCoins(n: Int): Int =", "docstring": "Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.\n\n* Incomplete Code:\ndef arrangeCoins(n: Int): Int =\n  {\n \n[MASK]\n[MASK]\n    while (remaining >= row) {\n      remaining -= row\n[MASK]\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n[MASK]\n[MASK]\n    while (remaining >= row) {\n      remaining -= row\n[MASK]\n    }\n[MASK]\n  }"}
{"task_id": "Scala/19-1-multi", "prompt": "\nobject Solution {\n  /**\n    * Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\n    * Calculate and return the total number of complete rows that can be formed.\n    *\n    * @param n The total number of coins.\n    * @return The total number of complete rows that can be formed.\n    *\n    * Example:\n    * arrangeCoins(5)\n    * Output: 2\n    * Explanation: The third row is incomplete, so return 2.\n    */\n  def arrangeCoins(n: Int): Int = ", "canonical_solution": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(arrangeCoins(8) == 3)\n    assert(arrangeCoins(15) == 5)\n    assert(arrangeCoins(20) == 5)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "arrangeCoins", "signature": "def arrangeCoins(n: Int): Int =", "docstring": "Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.\n\n* Incomplete Code:\ndef arrangeCoins(n: Int): Int =\n  {\n \n    var row = 1\n[MASK]\n[MASK]\n      remaining -= row\n[MASK]\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    var row = 1\n[MASK]\n[MASK]\n      remaining -= row\n[MASK]\n    }\n[MASK]\n  }"}
{"task_id": "Scala/20-0-multi", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\nobject Solution {\n  /**\n   * Calculate the minimum depth of a binary tree.\n   *\n   * The minimum depth is the number of nodes along the shortest path from the root node to\n   * the nearest leaf node.\n   *\n   * @param root The root node of the binary tree.\n   * @return The minimum depth of the tree.\n   *\n   * Examples:\n   * minimumDepth([3,9,20,null,null,15,7])\n   * Output: 2\n   *\n   * minimumDepth([2,null,3,null,4,null,5,null,6])\n   * Output: 5\n   *\n   * Constraints:\n   * - The number of nodes in the tree is in the range [0, 10^5].\n   * - The value of each node is in the range [-1000, 1000].\n   */\n\n  def minimumDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = new TreeNode(3)\n    root1.left = new TreeNode(9)\n    root1.right = new TreeNode(20)\n    root1.right.left = new TreeNode(15)\n    root1.right.right = new TreeNode(7)\n    assert(minimumDepth(root1) == 2)\n    \n    // Test case 2\n    val root2 = new TreeNode(2)\n    root2.right = new TreeNode(3)\n    root2.right.right = new TreeNode(4)\n    root2.right.right.right = new TreeNode(5)\n    root2.right.right.right.right = new TreeNode(6)\n    assert(minimumDepth(root2) == 5)\n    \n    // Test case 3\n    val root3: TreeNode = null\n    assert(minimumDepth(root3) == 0)\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "minimumDepth", "signature": "def minimumDepth(root: TreeNode): Int =", "docstring": "Calculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].\n\n* Incomplete Code:\ndef minimumDepth(root: TreeNode): Int =\n  {\n    if (root == null) {\n[MASK]\n    }\n    \n    if (root.left == null && root.right == null) {\n[MASK]\n    }\n    \n[MASK]\n      return minimumDepth(root.right) + 1\n    }\n    \n[MASK]\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (root == null) {\n[MASK]\n    }\n    \n    if (root.left == null && root.right == null) {\n[MASK]\n    }\n    \n[MASK]\n      return minimumDepth(root.right) + 1\n    }\n    \n[MASK]\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  "}
{"task_id": "Scala/20-1-multi", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\nobject Solution {\n  /**\n   * Calculate the minimum depth of a binary tree.\n   *\n   * The minimum depth is the number of nodes along the shortest path from the root node to\n   * the nearest leaf node.\n   *\n   * @param root The root node of the binary tree.\n   * @return The minimum depth of the tree.\n   *\n   * Examples:\n   * minimumDepth([3,9,20,null,null,15,7])\n   * Output: 2\n   *\n   * minimumDepth([2,null,3,null,4,null,5,null,6])\n   * Output: 5\n   *\n   * Constraints:\n   * - The number of nodes in the tree is in the range [0, 10^5].\n   * - The value of each node is in the range [-1000, 1000].\n   */\n\n  def minimumDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = new TreeNode(3)\n    root1.left = new TreeNode(9)\n    root1.right = new TreeNode(20)\n    root1.right.left = new TreeNode(15)\n    root1.right.right = new TreeNode(7)\n    assert(minimumDepth(root1) == 2)\n    \n    // Test case 2\n    val root2 = new TreeNode(2)\n    root2.right = new TreeNode(3)\n    root2.right.right = new TreeNode(4)\n    root2.right.right.right = new TreeNode(5)\n    root2.right.right.right.right = new TreeNode(6)\n    assert(minimumDepth(root2) == 5)\n    \n    // Test case 3\n    val root3: TreeNode = null\n    assert(minimumDepth(root3) == 0)\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "minimumDepth", "signature": "def minimumDepth(root: TreeNode): Int =", "docstring": "Calculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].\n\n* Incomplete Code:\ndef minimumDepth(root: TreeNode): Int =\n  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n[MASK]\n    }\n    \n[MASK]\n[MASK]\n    }\n    \n[MASK]\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n[MASK]\n    }\n    \n[MASK]\n[MASK]\n    }\n    \n[MASK]\n  }\n  "}
{"task_id": "Scala/21-0-multi", "prompt": "\nobject Solution {\n  /**\n     * Given a string s, you need to split it into some substrings so that each substring is a palindrome.\n     * Return the minimum number of splits required.\n     *\n     * @param s The input string.\n     * @return The minimum number of splits required.\n     *\n     * Example:\n     * minCut(\"aab\")\n     * Output: 1\n     *\n     * Explanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n     *\n     * Constraints:\n     * - 1 <= s.length <= 2000\n     * - s consists only of lowercase English letters.\n     */\n  def minCut(s: String): Int = ", "canonical_solution": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(minCut(\"abcba\") == 0)\n    assert(minCut(\"aabba\") == 1)\n    assert(minCut(\"abbababa\") == 2)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minCut", "signature": "def minCut(s: String): Int =", "docstring": "Given a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.\n\n* Incomplete Code:\ndef minCut(s: String): Int =\n  {\n\n    val n = s.length\n[MASK]\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n[MASK]\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = s.length\n[MASK]\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n[MASK]\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }"}
{"task_id": "Scala/21-1-multi", "prompt": "\nobject Solution {\n  /**\n     * Given a string s, you need to split it into some substrings so that each substring is a palindrome.\n     * Return the minimum number of splits required.\n     *\n     * @param s The input string.\n     * @return The minimum number of splits required.\n     *\n     * Example:\n     * minCut(\"aab\")\n     * Output: 1\n     *\n     * Explanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n     *\n     * Constraints:\n     * - 1 <= s.length <= 2000\n     * - s consists only of lowercase English letters.\n     */\n  def minCut(s: String): Int = ", "canonical_solution": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(minCut(\"abcba\") == 0)\n    assert(minCut(\"aabba\") == 1)\n    assert(minCut(\"abbababa\") == 2)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minCut", "signature": "def minCut(s: String): Int =", "docstring": "Given a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.\n\n* Incomplete Code:\ndef minCut(s: String): Int =\n  {\n\n[MASK]\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n[MASK]\n      for (j <- 0 to i) {\n[MASK]\n[MASK]\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n[MASK]\n      for (j <- 0 to i) {\n[MASK]\n[MASK]\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }"}
{"task_id": "Scala/22-0-multi", "prompt": "class TreeNode(val value: Int, var left: TreeNode = null, var right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Check if a binary tree is symmetric.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is symmetric, False otherwise.\n    *\n    * Example:\n    * isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\n    * Output: true\n    */\n  def isSymmetric(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }", "test": "def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), new TreeNode(4)\n      ),\n      new TreeNode(2,\n        new TreeNode(4), new TreeNode(3)\n      )\n    )\n    assert(isSymmetric(root1))\n\n    // Test Case 2\n    val root2 = new TreeNode(1,\n      new TreeNode(2,\n        null, new TreeNode(3)\n      ),\n      new TreeNode(2,\n        null, new TreeNode(3)\n      )\n    )\n    assert(!isSymmetric(root2))\n\n    // Test Case 3\n    val root3 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), null\n      ),\n      new TreeNode(2,\n        new TreeNode(3), null\n      )\n    )\n    assert(!isSymmetric(root3))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isSymmetric", "signature": "def isSymmetric(root: TreeNode): Boolean =", "docstring": "Check if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true\n\n* Incomplete Code:\ndef isSymmetric(root: TreeNode): Boolean =\n  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n[MASK]\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n[MASK]\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n[MASK]\n  }"}
{"task_id": "Scala/22-1-multi", "prompt": "class TreeNode(val value: Int, var left: TreeNode = null, var right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Check if a binary tree is symmetric.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is symmetric, False otherwise.\n    *\n    * Example:\n    * isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\n    * Output: true\n    */\n  def isSymmetric(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }", "test": "def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), new TreeNode(4)\n      ),\n      new TreeNode(2,\n        new TreeNode(4), new TreeNode(3)\n      )\n    )\n    assert(isSymmetric(root1))\n\n    // Test Case 2\n    val root2 = new TreeNode(1,\n      new TreeNode(2,\n        null, new TreeNode(3)\n      ),\n      new TreeNode(2,\n        null, new TreeNode(3)\n      )\n    )\n    assert(!isSymmetric(root2))\n\n    // Test Case 3\n    val root3 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), null\n      ),\n      new TreeNode(2,\n        new TreeNode(3), null\n      )\n    )\n    assert(!isSymmetric(root3))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isSymmetric", "signature": "def isSymmetric(root: TreeNode): Boolean =", "docstring": "Check if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true\n\n* Incomplete Code:\ndef isSymmetric(root: TreeNode): Boolean =\n  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n[MASK]\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n[MASK]\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n[MASK]\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n[MASK]\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }"}
{"task_id": "Scala/23-0-multi", "prompt": "object Solution {\n    /**\n     * Find the smallest positive integer b such that the product of all digits of b is equal to a.\n     *\n     * @param a The given integer.\n     * @return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\n     *         is not a 32-bit signed integer, return 0.\n     *\n     * Example:\n     * findSmallestInteger(48)\n     * Output: 68\n     *\n     * Example:\n     * findSmallestInteger(15)\n     * Output: 35\n     */\n  def findSmallestInteger(a: Int): Int = ", "canonical_solution": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(findSmallestInteger(48) == 68)\n    assert(findSmallestInteger(15) == 35)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findSmallestInteger", "signature": "def findSmallestInteger(a: Int): Int =", "docstring": "Find the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35\n\n* Incomplete Code:\ndef findSmallestInteger(a: Int): Int =\n  {\n\n[MASK]\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n[MASK]\n[MASK]\n        return i\n      }\n    }\n    0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n[MASK]\n[MASK]\n        return i\n      }\n    }\n    0\n  }"}
{"task_id": "Scala/23-1-multi", "prompt": "object Solution {\n    /**\n     * Find the smallest positive integer b such that the product of all digits of b is equal to a.\n     *\n     * @param a The given integer.\n     * @return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\n     *         is not a 32-bit signed integer, return 0.\n     *\n     * Example:\n     * findSmallestInteger(48)\n     * Output: 68\n     *\n     * Example:\n     * findSmallestInteger(15)\n     * Output: 35\n     */\n  def findSmallestInteger(a: Int): Int = ", "canonical_solution": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(findSmallestInteger(48) == 68)\n    assert(findSmallestInteger(15) == 35)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findSmallestInteger", "signature": "def findSmallestInteger(a: Int): Int =", "docstring": "Find the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35\n\n* Incomplete Code:\ndef findSmallestInteger(a: Int): Int =\n  {\n\n[MASK]\n      var product = 1\n[MASK]\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n      var product = 1\n[MASK]\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }"}
{"task_id": "Scala/24-0-multi", "prompt": "object Solution {\n    /**\n     * Calculate the sum of the digits in a number with assigned signs.\n     *\n     * @param n The input number.\n     * @return The sum of the digits with assigned signs.\n     *\n     * Example:\n     * signSum(521)\n     * Output: 4\n     */\n  def signSum(n: Int): Int = ", "canonical_solution": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(signSum(123) == 6)\n    assert(signSum(-456) == -15)\n    assert(signSum(789) == 24)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "signSum", "signature": "def signSum(n: Int): Int =", "docstring": "Calculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4\n\n* Incomplete Code:\ndef signSum(n: Int): Int =\n  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n[MASK]\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n[MASK]\n    }\n\n    sum\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n[MASK]\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n[MASK]\n    }\n\n    sum\n  }"}
{"task_id": "Scala/24-1-multi", "prompt": "object Solution {\n    /**\n     * Calculate the sum of the digits in a number with assigned signs.\n     *\n     * @param n The input number.\n     * @return The sum of the digits with assigned signs.\n     *\n     * Example:\n     * signSum(521)\n     * Output: 4\n     */\n  def signSum(n: Int): Int = ", "canonical_solution": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(signSum(123) == 6)\n    assert(signSum(-456) == -15)\n    assert(signSum(789) == 24)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "signSum", "signature": "def signSum(n: Int): Int =", "docstring": "Calculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4\n\n* Incomplete Code:\ndef signSum(n: Int): Int =\n  {\n\n    val sign = if (n >= 0) 1 else -1\n[MASK]\n    var sum = 0\n    var num = absolute\n\n[MASK]\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val sign = if (n >= 0) 1 else -1\n[MASK]\n    var sum = 0\n    var num = absolute\n\n[MASK]\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }"}
{"task_id": "Scala/25-0-multi", "prompt": "\nobject Solution {\n    /**\n    * Returns the elements of the matrix in clockwise spiral order.\n    *\n    * @param matrix The input matrix.\n    * @return The elements of the matrix in spiral order.\n    *\n    * Example:\n    * spiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\n    * Output: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n    */\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = ", "canonical_solution": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val matrix1 = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))\n    val result1 = spiralOrder(matrix1)\n    assert(result1 == List(1, 2, 3, 6, 9, 8, 7, 4, 5))\n\n    val matrix2 = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12))\n    val result2 = spiralOrder(matrix2)\n    assert(result2 == List(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7))\n\n    val matrix3 = Array(Array(1, 2, 3, 4, 5), Array(6, 7, 8, 9, 10), Array(11, 12, 13, 14, 15))\n    val result3 = spiralOrder(matrix3)\n    assert(result3 == List(1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "spiralOrder", "signature": "def spiralOrder(matrix: Array[Array[Int]]): List[Int] =", "docstring": "Returns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n\n* Incomplete Code:\ndef spiralOrder(matrix: Array[Array[Int]]): List[Int] =\n  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n[MASK]\n[MASK]\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n[MASK]\n[MASK]\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n[MASK]\n  }"}
{"task_id": "Scala/25-1-multi", "prompt": "\nobject Solution {\n    /**\n    * Returns the elements of the matrix in clockwise spiral order.\n    *\n    * @param matrix The input matrix.\n    * @return The elements of the matrix in spiral order.\n    *\n    * Example:\n    * spiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\n    * Output: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n    */\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = ", "canonical_solution": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val matrix1 = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))\n    val result1 = spiralOrder(matrix1)\n    assert(result1 == List(1, 2, 3, 6, 9, 8, 7, 4, 5))\n\n    val matrix2 = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12))\n    val result2 = spiralOrder(matrix2)\n    assert(result2 == List(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7))\n\n    val matrix3 = Array(Array(1, 2, 3, 4, 5), Array(6, 7, 8, 9, 10), Array(11, 12, 13, 14, 15))\n    val result3 = spiralOrder(matrix3)\n    assert(result3 == List(1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "spiralOrder", "signature": "def spiralOrder(matrix: Array[Array[Int]]): List[Int] =", "docstring": "Returns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n\n* Incomplete Code:\ndef spiralOrder(matrix: Array[Array[Int]]): List[Int] =\n  {\n  \n       \n       // Function implementation to be filled\n[MASK]\n      return List()\n    }\n\n    val m = matrix.length\n[MASK]\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n[MASK]\n\n    while (result.length < m * n) {\n      // Traverse top row\n[MASK]\n        result += matrix(top)(i)\n      }\n[MASK]\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n  \n       \n       // Function implementation to be filled\n[MASK]\n      return List()\n    }\n\n    val m = matrix.length\n[MASK]\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n[MASK]\n\n    while (result.length < m * n) {\n      // Traverse top row\n[MASK]\n        result += matrix(top)(i)\n      }\n[MASK]\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/26-0-multi", "prompt": "class TreeNode(var value: Int, var left: TreeNode = null, var right: TreeNode = null)\nobject Solution {\n  /**\n    * Determine if a given binary tree is a univalued tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a univalued tree, False otherwise.\n    *\n    * Example:\n    * isUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\n    * Output: true\n    *\n    * isUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\n    * Output: false\n    */\n  def isUnivalTree(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val tree1 = new TreeNode(2)\n    tree1.left = new TreeNode(2)\n    tree1.left.left = new TreeNode(2)\n    tree1.left.left.left = new TreeNode(5)\n    tree1.left.left.right = new TreeNode(2)\n    assert(!isUnivalTree(tree1))  // Output: false\n\n    // Test Case 2\n    val tree2 = new TreeNode(1)\n    tree2.left = new TreeNode(1)\n    tree2.left.left = new TreeNode(1)\n    tree2.left.right = new TreeNode(1)\n    tree2.right = new TreeNode(1)\n    tree2.right.right = new TreeNode(1)\n    assert(isUnivalTree(tree2))  // Output: true\n\n    // Test Case 3\n    val tree3 = new TreeNode(3)\n    tree3.left = new TreeNode(3)\n    tree3.right = new TreeNode(3)\n    assert(isUnivalTree(tree3))  // Output: true\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "isUnivalTree", "signature": "def isUnivalTree(root: TreeNode): Boolean =", "docstring": "Determine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false\n\n* Incomplete Code:\ndef isUnivalTree(root: TreeNode): Boolean =\n  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n[MASK]\n    if (node == null) {\n      true\n[MASK]\n[MASK]\n    } else {\n[MASK]\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n[MASK]\n    if (node == null) {\n      true\n[MASK]\n[MASK]\n    } else {\n[MASK]\n    }\n  }"}
{"task_id": "Scala/26-1-multi", "prompt": "class TreeNode(var value: Int, var left: TreeNode = null, var right: TreeNode = null)\nobject Solution {\n  /**\n    * Determine if a given binary tree is a univalued tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a univalued tree, False otherwise.\n    *\n    * Example:\n    * isUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\n    * Output: true\n    *\n    * isUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\n    * Output: false\n    */\n  def isUnivalTree(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val tree1 = new TreeNode(2)\n    tree1.left = new TreeNode(2)\n    tree1.left.left = new TreeNode(2)\n    tree1.left.left.left = new TreeNode(5)\n    tree1.left.left.right = new TreeNode(2)\n    assert(!isUnivalTree(tree1))  // Output: false\n\n    // Test Case 2\n    val tree2 = new TreeNode(1)\n    tree2.left = new TreeNode(1)\n    tree2.left.left = new TreeNode(1)\n    tree2.left.right = new TreeNode(1)\n    tree2.right = new TreeNode(1)\n    tree2.right.right = new TreeNode(1)\n    assert(isUnivalTree(tree2))  // Output: true\n\n    // Test Case 3\n    val tree3 = new TreeNode(3)\n    tree3.left = new TreeNode(3)\n    tree3.right = new TreeNode(3)\n    assert(isUnivalTree(tree3))  // Output: true\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "isUnivalTree", "signature": "def isUnivalTree(root: TreeNode): Boolean =", "docstring": "Determine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false\n\n* Incomplete Code:\ndef isUnivalTree(root: TreeNode): Boolean =\n  {\n\n    if (root == null) {\n      true\n    } else {\n[MASK]\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n[MASK]\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n      true\n    } else {\n[MASK]\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n[MASK]\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }"}
{"task_id": "Scala/27-0-multi", "prompt": "object Solution {\n    /**\n     * Remove the trailing zeros from a given integer represented as a string.\n     *\n     * @param num The string representation of the integer.\n     * @return The integer with trailing zeros removed represented as a string.\n     *\n     * Example:\n     * removeTrailingZeros(\"51230100\")\n     * Output: \"512301\"\n     *\n     * removeTrailingZeros(\"123\")\n     * Output: \"123\"\n     */\n  def removeTrailingZeros(num: String): String = ", "canonical_solution": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(removeTrailingZeros(\"51230100\") == \"512301\")\n    assert(removeTrailingZeros(\"123\") == \"123\")\n    assert(removeTrailingZeros(\"1000010\") == \"100001\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeTrailingZeros", "signature": "def removeTrailingZeros(num: String): String =", "docstring": "Remove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"\n\n* Incomplete Code:\ndef removeTrailingZeros(num: String): String =\n  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n[MASK]\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n[MASK]\n    }\n[MASK]\n  }"}
{"task_id": "Scala/27-1-multi", "prompt": "object Solution {\n    /**\n     * Remove the trailing zeros from a given integer represented as a string.\n     *\n     * @param num The string representation of the integer.\n     * @return The integer with trailing zeros removed represented as a string.\n     *\n     * Example:\n     * removeTrailingZeros(\"51230100\")\n     * Output: \"512301\"\n     *\n     * removeTrailingZeros(\"123\")\n     * Output: \"123\"\n     */\n  def removeTrailingZeros(num: String): String = ", "canonical_solution": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(removeTrailingZeros(\"51230100\") == \"512301\")\n    assert(removeTrailingZeros(\"123\") == \"123\")\n    assert(removeTrailingZeros(\"1000010\") == \"100001\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeTrailingZeros", "signature": "def removeTrailingZeros(num: String): String =", "docstring": "Remove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"\n\n* Incomplete Code:\ndef removeTrailingZeros(num: String): String =\n  {\n\n[MASK]\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n[MASK]\n  }"}
{"task_id": "Scala/28-0-multi", "prompt": "object Solution {\n  /**\n    * Check if the binary string contains at most one segment of consecutive '1's.\n    *\n    * @param s The input binary string.\n    * @return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n    *\n    * Example:\n    * checkOnesSegment(\"1001\")\n    * Output: false\n    *\n    * Example:\n    * checkOnesSegment(\"110\")\n    * Output: true\n    */\n  def checkOnesSegment(s: String): Boolean = ", "canonical_solution": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(checkOnesSegment(\"10101\") == true)\n    assert(checkOnesSegment(\"111000\") == false)\n    assert(checkOnesSegment(\"100111000\") == false)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "checkOnesSegment", "signature": "def checkOnesSegment(s: String): Boolean =", "docstring": "Check if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true\n\n* Incomplete Code:\ndef checkOnesSegment(s: String): Boolean =\n  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n[MASK]\n          return false\n        }\n[MASK]\n[MASK]\n      }\n    }\n    true\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n[MASK]\n          return false\n        }\n[MASK]\n[MASK]\n      }\n    }\n    true\n  }"}
{"task_id": "Scala/28-1-multi", "prompt": "object Solution {\n  /**\n    * Check if the binary string contains at most one segment of consecutive '1's.\n    *\n    * @param s The input binary string.\n    * @return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n    *\n    * Example:\n    * checkOnesSegment(\"1001\")\n    * Output: false\n    *\n    * Example:\n    * checkOnesSegment(\"110\")\n    * Output: true\n    */\n  def checkOnesSegment(s: String): Boolean = ", "canonical_solution": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(checkOnesSegment(\"10101\") == true)\n    assert(checkOnesSegment(\"111000\") == false)\n    assert(checkOnesSegment(\"100111000\") == false)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "checkOnesSegment", "signature": "def checkOnesSegment(s: String): Boolean =", "docstring": "Check if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true\n\n* Incomplete Code:\ndef checkOnesSegment(s: String): Boolean =\n  {\n[MASK]\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n[MASK]\n  }"}
{"task_id": "Scala/29-0-multi", "prompt": "object Solution {\n/**\n * Computes the minimum cost of merging N piles of sand into one pile. \n * The cost of merging two adjacent piles is the sum of their sizes. \n * The function aims to find a merge strategy that minimizes the total cost.\n *\n * @param sandPiles An array of integers representing the sizes of each sand pile.\n * @return The minimum total cost of merging all piles into one.\n *\n * Example:\n * minMergeCost(Array(1, 3, 5, 2))\n * Output: 22\n * \n * Explanation:\n * Merging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9), \n * and finally merging the last two piles (cost = 11), results in a total cost of 22.\n */\n\ndef minMergeCost(sandPiles: Array[Int]): Int = ", "canonical_solution": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}", "test": "  def main(args: Array[String]): Unit = {\n    assert(minMergeCost(Array(1, 3, 5, 2)) == 22)\n    assert(minMergeCost(Array(4, 3, 3)) == 16)\n    assert(minMergeCost(Array(10, 20, 30)) == 90)\n    assert(minMergeCost(Array(3, 4, 3, 9, 6, 7, 8, 10 )) == 147)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minMergeCost", "signature": "def minMergeCost(sandPiles: Array[Int]): Int =", "docstring": "Computes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nComputes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.\n\n* Incomplete Code:\ndef minMergeCost(sandPiles: Array[Int]): Int =\n{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n[MASK]\n      val right = left + length - 1\n[MASK]\n      for (k <- left until right) {\n[MASK]\n[MASK]\n      }\n    }\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n[MASK]\n      val right = left + length - 1\n[MASK]\n      for (k <- left until right) {\n[MASK]\n[MASK]\n      }\n    }\n  }\n\n[MASK]\n}"}
{"task_id": "Scala/29-1-multi", "prompt": "object Solution {\n/**\n * Computes the minimum cost of merging N piles of sand into one pile. \n * The cost of merging two adjacent piles is the sum of their sizes. \n * The function aims to find a merge strategy that minimizes the total cost.\n *\n * @param sandPiles An array of integers representing the sizes of each sand pile.\n * @return The minimum total cost of merging all piles into one.\n *\n * Example:\n * minMergeCost(Array(1, 3, 5, 2))\n * Output: 22\n * \n * Explanation:\n * Merging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9), \n * and finally merging the last two piles (cost = 11), results in a total cost of 22.\n */\n\ndef minMergeCost(sandPiles: Array[Int]): Int = ", "canonical_solution": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}", "test": "  def main(args: Array[String]): Unit = {\n    assert(minMergeCost(Array(1, 3, 5, 2)) == 22)\n    assert(minMergeCost(Array(4, 3, 3)) == 16)\n    assert(minMergeCost(Array(10, 20, 30)) == 90)\n    assert(minMergeCost(Array(3, 4, 3, 9, 6, 7, 8, 10 )) == 147)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minMergeCost", "signature": "def minMergeCost(sandPiles: Array[Int]): Int =", "docstring": "Computes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nComputes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.\n\n* Incomplete Code:\ndef minMergeCost(sandPiles: Array[Int]): Int =\n{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n[MASK]\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n[MASK]\n      }\n    }\n  }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n[MASK]\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n[MASK]\n      }\n    }\n  }\n\n[MASK]\n}"}
{"task_id": "Scala/31-0-multi", "prompt": "\nobject Solution {\n  /**\n  * Reverse the given string based on the following rules:\n  * - Keep all non-alphabetic characters in their original positions.\n  * - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  *\n  * @param s The input string.\n  * @return The reversed string.\n  *\n  * Example:\n  * reverseString(\"ab-cd\")\n  * Output: \"dc-ba\"\n  */\n  def reverseString(s: String): String = ", "canonical_solution": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"ab-cd\") == \"dc-ba\")\n    assert(reverseString(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String): String =", "docstring": "Reverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"\n\n* Incomplete Code:\ndef reverseString(s: String): String =\n  {\n \n[MASK]\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n[MASK]\n          index += 1\n          res\n[MASK]\n[MASK]\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n[MASK]\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n[MASK]\n          index += 1\n          res\n[MASK]\n[MASK]\n    }"}
{"task_id": "Scala/31-1-multi", "prompt": "\nobject Solution {\n  /**\n  * Reverse the given string based on the following rules:\n  * - Keep all non-alphabetic characters in their original positions.\n  * - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  *\n  * @param s The input string.\n  * @return The reversed string.\n  *\n  * Example:\n  * reverseString(\"ab-cd\")\n  * Output: \"dc-ba\"\n  */\n  def reverseString(s: String): String = ", "canonical_solution": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"ab-cd\") == \"dc-ba\")\n    assert(reverseString(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String): String =", "docstring": "Reverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"\n\n* Incomplete Code:\ndef reverseString(s: String): String =\n  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n[MASK]\n[MASK]\n[MASK]\n          res\n[MASK]\n      }.mkString\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n[MASK]\n[MASK]\n[MASK]\n          res\n[MASK]\n      }.mkString\n    }"}
{"task_id": "Scala/32-0-multi", "prompt": "object Solution {\n    /**\n       * Calculate the maximum number of consecutive 1s in a binary array.\n       *\n       * @param nums The binary array.\n       * @return The maximum number of consecutive 1s.\n       *\n       * Example:\n       * findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\n       * Output: 3\n       */\n  def findMaxConsecutiveOnes(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    //test case 1\n    assert(findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1, 0, 0, 1, 1)) == 3)\n    \n    //test case 2\n    assert(findMaxConsecutiveOnes(Array(0, 0, 0)) == 0)\n    \n    //test case 3\n    assert(findMaxConsecutiveOnes(Array(1, 1, 1, 1, 1)) == 5)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findMaxConsecutiveOnes", "signature": "def findMaxConsecutiveOnes(nums: Array[Int]): Int =", "docstring": "Calculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3\n\n* Incomplete Code:\ndef findMaxConsecutiveOnes(nums: Array[Int]): Int =\n  {\n\n       var maxConsecutiveOnes = 0\n[MASK]\n      for (num <- nums) {\n[MASK]\n              currentCount += 1\n[MASK]\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var maxConsecutiveOnes = 0\n[MASK]\n      for (num <- nums) {\n[MASK]\n              currentCount += 1\n[MASK]\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n"}
{"task_id": "Scala/32-1-multi", "prompt": "object Solution {\n    /**\n       * Calculate the maximum number of consecutive 1s in a binary array.\n       *\n       * @param nums The binary array.\n       * @return The maximum number of consecutive 1s.\n       *\n       * Example:\n       * findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\n       * Output: 3\n       */\n  def findMaxConsecutiveOnes(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    //test case 1\n    assert(findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1, 0, 0, 1, 1)) == 3)\n    \n    //test case 2\n    assert(findMaxConsecutiveOnes(Array(0, 0, 0)) == 0)\n    \n    //test case 3\n    assert(findMaxConsecutiveOnes(Array(1, 1, 1, 1, 1)) == 5)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findMaxConsecutiveOnes", "signature": "def findMaxConsecutiveOnes(nums: Array[Int]): Int =", "docstring": "Calculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3\n\n* Incomplete Code:\ndef findMaxConsecutiveOnes(nums: Array[Int]): Int =\n  {\n\n[MASK]\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n[MASK]\n[MASK]\n          }\n      }\n      maxConsecutiveOnes\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n[MASK]\n[MASK]\n          }\n      }\n      maxConsecutiveOnes\n  }\n"}
{"task_id": "Scala/34-0-multi", "prompt": "\nobject Solution {\n    /**\n       * Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n       *\n       * @param nums An array of integers.\n       * @return None (In-place modification of the input array).\n       *\n       * Example:\n       * moveZeroes(Array(0, 1, 0, 3, 12))\n       * Output: Array(1, 3, 12, 0, 0)\n       */\n  def moveZeroes(nums: Array[Int]): Unit = ", "canonical_solution": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(1,0,2,0,3)\n    Solution.moveZeroes(nums1)\n    assert(nums1 sameElements Array(1,2,3,0,0))\n\n    val nums2 = Array(0,0,0,1,2)\n    Solution.moveZeroes(nums2)\n    assert(nums2 sameElements Array(1,2,0,0,0))\n\n    val nums3 = Array(1,2,3,0,0)\n    Solution.moveZeroes(nums3)\n    assert(nums3 sameElements Array(1,2,3,0,0))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveZeroes", "signature": "def moveZeroes(nums: Array[Int]): Unit =", "docstring": "Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)\n\n* Incomplete Code:\ndef moveZeroes(nums: Array[Int]): Unit =\n  {\n\n       var position = 0\n        for (i <- nums.indices) {\n[MASK]\n[MASK]\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n[MASK]\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n[MASK]\n[MASK]\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n[MASK]\n        }\n    }"}
{"task_id": "Scala/34-1-multi", "prompt": "\nobject Solution {\n    /**\n       * Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n       *\n       * @param nums An array of integers.\n       * @return None (In-place modification of the input array).\n       *\n       * Example:\n       * moveZeroes(Array(0, 1, 0, 3, 12))\n       * Output: Array(1, 3, 12, 0, 0)\n       */\n  def moveZeroes(nums: Array[Int]): Unit = ", "canonical_solution": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(1,0,2,0,3)\n    Solution.moveZeroes(nums1)\n    assert(nums1 sameElements Array(1,2,3,0,0))\n\n    val nums2 = Array(0,0,0,1,2)\n    Solution.moveZeroes(nums2)\n    assert(nums2 sameElements Array(1,2,0,0,0))\n\n    val nums3 = Array(1,2,3,0,0)\n    Solution.moveZeroes(nums3)\n    assert(nums3 sameElements Array(1,2,3,0,0))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveZeroes", "signature": "def moveZeroes(nums: Array[Int]): Unit =", "docstring": "Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)\n\n* Incomplete Code:\ndef moveZeroes(nums: Array[Int]): Unit =\n  {\n\n       var position = 0\n[MASK]\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n[MASK]\n            }\n        }\n        for (i <- position until nums.length) {\n[MASK]\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var position = 0\n[MASK]\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n[MASK]\n            }\n        }\n        for (i <- position until nums.length) {\n[MASK]\n        }\n    }"}
{"task_id": "Scala/36-0-multi", "prompt": "\nobject Solution {\n      /**\n       * Count the number of palindrome substrings in a given string.\n       *\n       * @param s The input string.\n       * @return The number of palindrome substrings.\n       *\n       * Example:\n       * countPalindromeSubstrings(\"abc\")\n       * Output: 3\n       *\n       * Example:\n       * countPalindromeSubstrings(\"aaa\")\n       * Output: 6\n       */\n  def countPalindromeSubstrings(s: String): Int = ", "canonical_solution": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countPalindromeSubstrings(\"abc\") == 3)\n    assert(countPalindromeSubstrings(\"aaa\") == 6)\n    assert(countPalindromeSubstrings(\"abba\") == 6)\n    assert(countPalindromeSubstrings(\"abcd\") == 4)\n    assert(countPalindromeSubstrings(\"aabbccd\") == 10)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPalindromeSubstrings", "signature": "def countPalindromeSubstrings(s: String): Int =", "docstring": "Count the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6\n\n* Incomplete Code:\ndef countPalindromeSubstrings(s: String): Int =\n  {\n\n       var count = 0\n[MASK]\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n[MASK]\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n[MASK]\n    var l = left\n[MASK]\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var count = 0\n[MASK]\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n[MASK]\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n[MASK]\n    var l = left\n[MASK]\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n[MASK]\n  }"}
{"task_id": "Scala/36-1-multi", "prompt": "\nobject Solution {\n      /**\n       * Count the number of palindrome substrings in a given string.\n       *\n       * @param s The input string.\n       * @return The number of palindrome substrings.\n       *\n       * Example:\n       * countPalindromeSubstrings(\"abc\")\n       * Output: 3\n       *\n       * Example:\n       * countPalindromeSubstrings(\"aaa\")\n       * Output: 6\n       */\n  def countPalindromeSubstrings(s: String): Int = ", "canonical_solution": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countPalindromeSubstrings(\"abc\") == 3)\n    assert(countPalindromeSubstrings(\"aaa\") == 6)\n    assert(countPalindromeSubstrings(\"abba\") == 6)\n    assert(countPalindromeSubstrings(\"abcd\") == 4)\n    assert(countPalindromeSubstrings(\"aabbccd\") == 10)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPalindromeSubstrings", "signature": "def countPalindromeSubstrings(s: String): Int =", "docstring": "Count the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6\n\n* Incomplete Code:\ndef countPalindromeSubstrings(s: String): Int =\n  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n[MASK]\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n[MASK]\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n[MASK]\n    var l = left\n    var r = right\n[MASK]\n      count += 1\n      l -= 1\n      r += 1\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n[MASK]\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n[MASK]\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n[MASK]\n    var l = left\n    var r = right\n[MASK]\n      count += 1\n      l -= 1\n      r += 1\n    }\n[MASK]\n  }"}
{"task_id": "Scala/37-0-multi", "prompt": "object Solution {\n  case class ListNode(var value: Int, var next: ListNode = null)\n  /**\n    * Remove the nth node from the end of a linked list and return the head of the modified list.\n    *\n    * @param head The head of the linked list.\n    * @param n The position of the node to be removed from the end of the list.\n    * @return The head of the modified list.\n    *\n    * Example:\n    * removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n    * Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n    */\n  def removeNthFromEnd(head: ListNode, n: Int): ListNode = ", "canonical_solution": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }", "test": "  def main(args: Array[String]): Unit = {\n  // Test cases\n  val test1 = createList(Array(1, 2, 3, 4, 5))\n  assert(listToString(removeNthFromEnd(test1, 2)) == \"1->2->3->5\")\n\n  val test2 = createList(Array(1))\n  assert(listToString(removeNthFromEnd(test2, 1)) == \"\")\n\n  val test3 = createList(Array(1, 2))\n  assert(listToString(removeNthFromEnd(test3, 1)) == \"1\")\n\n  println(\"All tests passed\")}\n}", "entry_point": "removeNthFromEnd", "signature": "def removeNthFromEnd(head: ListNode, n: Int): ListNode =", "docstring": "Remove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n\n* Incomplete Code:\ndef removeNthFromEnd(head: ListNode, n: Int): ListNode =\n  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n[MASK]\n      second = second.next\n    }\n    second.next = second.next.next\n[MASK]\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n[MASK]\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n[MASK]\n    }\n    dummy.next\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n[MASK]\n      second = second.next\n    }\n    second.next = second.next.next\n[MASK]\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n[MASK]\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n[MASK]\n    }\n    dummy.next\n  }"}
{"task_id": "Scala/37-1-multi", "prompt": "object Solution {\n  case class ListNode(var value: Int, var next: ListNode = null)\n  /**\n    * Remove the nth node from the end of a linked list and return the head of the modified list.\n    *\n    * @param head The head of the linked list.\n    * @param n The position of the node to be removed from the end of the list.\n    * @return The head of the modified list.\n    *\n    * Example:\n    * removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n    * Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n    */\n  def removeNthFromEnd(head: ListNode, n: Int): ListNode = ", "canonical_solution": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }", "test": "  def main(args: Array[String]): Unit = {\n  // Test cases\n  val test1 = createList(Array(1, 2, 3, 4, 5))\n  assert(listToString(removeNthFromEnd(test1, 2)) == \"1->2->3->5\")\n\n  val test2 = createList(Array(1))\n  assert(listToString(removeNthFromEnd(test2, 1)) == \"\")\n\n  val test3 = createList(Array(1, 2))\n  assert(listToString(removeNthFromEnd(test3, 1)) == \"1\")\n\n  println(\"All tests passed\")}\n}", "entry_point": "removeNthFromEnd", "signature": "def removeNthFromEnd(head: ListNode, n: Int): ListNode =", "docstring": "Remove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n\n* Incomplete Code:\ndef removeNthFromEnd(head: ListNode, n: Int): ListNode =\n  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n[MASK]\n    }\n[MASK]\n    dummy.next\n  }\n\n[MASK]\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n[MASK]\n[MASK]\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n[MASK]\n    }\n[MASK]\n    dummy.next\n  }\n\n[MASK]\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n[MASK]\n[MASK]\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }"}
{"task_id": "Scala/38-0-multi", "prompt": "\nobject Solution {\n/**\n  * Count the number of integers with unique digits from 0 to 10^n.\n  *\n  * @param n The number of digits.\n  * @return The count of integers with unique digits.\n  *\n  * Example:\n  * countNumbersWithUniqueDigits(2)\n  * Output: 91\n  *\n  * Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n  * The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n  *\n  * countNumbersWithUniqueDigits(0)\n  * Output: 1\n  *\n  * Explanation: When n is 0, there is only one number, which is 0 itself.\n  */\n  def countNumbersWithUniqueDigits(n: Int): Int = ", "canonical_solution": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countNumbersWithUniqueDigits(1) == 10, \"Test case 1 failed\")\n    assert(countNumbersWithUniqueDigits(3) == 739, \"Test case 2 failed\")\n    assert(countNumbersWithUniqueDigits(4) == 5275, \"Test case 3 failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countNumbersWithUniqueDigits", "signature": "def countNumbersWithUniqueDigits(n: Int): Int =", "docstring": "Count the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.\n\n* Incomplete Code:\ndef countNumbersWithUniqueDigits(n: Int): Int =\n  {\n\n[MASK]\n[MASK]\n[MASK]\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n[MASK]\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n[MASK]\n[MASK]\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n[MASK]\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }"}
{"task_id": "Scala/38-1-multi", "prompt": "\nobject Solution {\n/**\n  * Count the number of integers with unique digits from 0 to 10^n.\n  *\n  * @param n The number of digits.\n  * @return The count of integers with unique digits.\n  *\n  * Example:\n  * countNumbersWithUniqueDigits(2)\n  * Output: 91\n  *\n  * Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n  * The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n  *\n  * countNumbersWithUniqueDigits(0)\n  * Output: 1\n  *\n  * Explanation: When n is 0, there is only one number, which is 0 itself.\n  */\n  def countNumbersWithUniqueDigits(n: Int): Int = ", "canonical_solution": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countNumbersWithUniqueDigits(1) == 10, \"Test case 1 failed\")\n    assert(countNumbersWithUniqueDigits(3) == 739, \"Test case 2 failed\")\n    assert(countNumbersWithUniqueDigits(4) == 5275, \"Test case 3 failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countNumbersWithUniqueDigits", "signature": "def countNumbersWithUniqueDigits(n: Int): Int =", "docstring": "Count the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.\n\n* Incomplete Code:\ndef countNumbersWithUniqueDigits(n: Int): Int =\n  {\n\n    if (n == 0) return 1\n[MASK]\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n[MASK]\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (n == 0) return 1\n[MASK]\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n[MASK]\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }"}
{"task_id": "Scala/39-0-multi", "prompt": "import scala.annotation.tailrec\n\nobject Solution {\n    class ListNode(var x: Int) {\n    var next: ListNode = null\n  }\n    /**\n      * Swap every two adjacent nodes in a linked list and return its head.\n      *\n      * @param head The head node of the linked list.\n      * @return The head node of the linked list after swapping adjacent nodes.\n      *\n      * Example:\n      * swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n      * swapPairs(null) should return null\n      * swapPairs(ListNode(1)) should return ListNode(1)\n      */\n  def swapPairs(head: ListNode): ListNode = ", "canonical_solution": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n", "test": "    def main(args: Array[String]): Unit = {\n    // Test cases\n    val test1 = createList(Array(5, 6, 7, 8))\n    assert(listToString(swapPairs(test1)) == \"6->5->8->7\")\n\n    val test2 = createList(Array())\n    assert(listToString(swapPairs(test2)) == \"\")\n\n    val test3 = createList(Array(9))\n    assert(listToString(swapPairs(test3)) == \"9\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "swapPairs", "signature": "def swapPairs(head: ListNode): ListNode =", "docstring": "Swap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSwap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)\n\n* Incomplete Code:\ndef swapPairs(head: ListNode): ListNode =\n  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n[MASK]\n[MASK]\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n[MASK]\n      nums.foreach { num =>\n[MASK]\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n[MASK]\n[MASK]\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n[MASK]\n      nums.foreach { num =>\n[MASK]\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n"}
{"task_id": "Scala/39-1-multi", "prompt": "import scala.annotation.tailrec\n\nobject Solution {\n    class ListNode(var x: Int) {\n    var next: ListNode = null\n  }\n    /**\n      * Swap every two adjacent nodes in a linked list and return its head.\n      *\n      * @param head The head node of the linked list.\n      * @return The head node of the linked list after swapping adjacent nodes.\n      *\n      * Example:\n      * swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n      * swapPairs(null) should return null\n      * swapPairs(ListNode(1)) should return ListNode(1)\n      */\n  def swapPairs(head: ListNode): ListNode = ", "canonical_solution": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n", "test": "    def main(args: Array[String]): Unit = {\n    // Test cases\n    val test1 = createList(Array(5, 6, 7, 8))\n    assert(listToString(swapPairs(test1)) == \"6->5->8->7\")\n\n    val test2 = createList(Array())\n    assert(listToString(swapPairs(test2)) == \"\")\n\n    val test3 = createList(Array(9))\n    assert(listToString(swapPairs(test3)) == \"9\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "swapPairs", "signature": "def swapPairs(head: ListNode): ListNode =", "docstring": "Swap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSwap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)\n\n* Incomplete Code:\ndef swapPairs(head: ListNode): ListNode =\n  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n[MASK]\n[MASK]\n          }\n        }\n\n        swap(dummy)\n[MASK]\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n[MASK]\n  }\n\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n[MASK]\n[MASK]\n          }\n        }\n\n        swap(dummy)\n[MASK]\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n[MASK]\n  }\n\n"}
{"task_id": "Scala/40-0-multi", "prompt": "import scala.collection.mutable.{Queue, ListBuffer}\n\nclass TreeNode(var _value: Int) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n  /**\n    * Return the level order traversal of a binary tree.\n    *\n    \n    * @param root The root node of the binary tree.\n    * @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n    *\n    * Example:\n    * levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: List(List(3), List(9, 20), List(15, 7))\n    */\n  def levelOrder(root: TreeNode): List[List[Int]] = ", "canonical_solution": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val example1 = new TreeNode(1)\n    example1.left = new TreeNode(2)\n    example1.right = new TreeNode(3)\n\n    assert(levelOrder(example1) == List(List(1), List(2, 3)))\n\n    val example2 = new TreeNode(4)\n    example2.left = new TreeNode(2)\n    example2.right = new TreeNode(6)\n    example2.left.left = new TreeNode(1)\n    example2.left.right = new TreeNode(3)\n    example2.right.left = new TreeNode(5)\n    example2.right.right = new TreeNode(7)\n\n    assert(levelOrder(example2) == List(List(4), List(2, 6), List(1, 3, 5, 7)))\n    \n    val example3 = new TreeNode(8)\n\n    assert(levelOrder(example3) == List(List(8)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "levelOrder", "signature": "def levelOrder(root: TreeNode): List[List[Int]] =", "docstring": "Return the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturn the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))\n\n* Incomplete Code:\ndef levelOrder(root: TreeNode): List[List[Int]] =\n  {\n\n       var result = List[List[Int]]()\n[MASK]\n    \n[MASK]\n    queue.enqueue(root)\n    \n[MASK]\n[MASK]\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n[MASK]\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var result = List[List[Int]]()\n[MASK]\n    \n[MASK]\n    queue.enqueue(root)\n    \n[MASK]\n[MASK]\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n[MASK]\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  "}
{"task_id": "Scala/40-1-multi", "prompt": "import scala.collection.mutable.{Queue, ListBuffer}\n\nclass TreeNode(var _value: Int) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n  /**\n    * Return the level order traversal of a binary tree.\n    *\n    \n    * @param root The root node of the binary tree.\n    * @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n    *\n    * Example:\n    * levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: List(List(3), List(9, 20), List(15, 7))\n    */\n  def levelOrder(root: TreeNode): List[List[Int]] = ", "canonical_solution": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val example1 = new TreeNode(1)\n    example1.left = new TreeNode(2)\n    example1.right = new TreeNode(3)\n\n    assert(levelOrder(example1) == List(List(1), List(2, 3)))\n\n    val example2 = new TreeNode(4)\n    example2.left = new TreeNode(2)\n    example2.right = new TreeNode(6)\n    example2.left.left = new TreeNode(1)\n    example2.left.right = new TreeNode(3)\n    example2.right.left = new TreeNode(5)\n    example2.right.right = new TreeNode(7)\n\n    assert(levelOrder(example2) == List(List(4), List(2, 6), List(1, 3, 5, 7)))\n    \n    val example3 = new TreeNode(8)\n\n    assert(levelOrder(example3) == List(List(8)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "levelOrder", "signature": "def levelOrder(root: TreeNode): List[List[Int]] =", "docstring": "Return the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturn the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))\n\n* Incomplete Code:\ndef levelOrder(root: TreeNode): List[List[Int]] =\n  {\n\n       var result = List[List[Int]]()\n[MASK]\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n[MASK]\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n[MASK]\n[MASK]\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n[MASK]\n    }\n    \n    result\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var result = List[List[Int]]()\n[MASK]\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n[MASK]\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n[MASK]\n[MASK]\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n[MASK]\n    }\n    \n    result\n  }\n  "}
{"task_id": "Scala/41-0-multi", "prompt": "\nobject Solution {\n/**\n  * Count the number of prime numbers less than a non-negative integer n.\n  *\n  * @param n The non-negative integer.\n  * @return The number of prime numbers less than n.\n  *\n  * Example:\n  * countPrimes(10)\n  * Output: 4\n  *\n  * Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n  */\n  def countPrimes(n: Int): Int = ", "canonical_solution": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Additional test cases\n    assert(countPrimes(15) == 6)\n    assert(countPrimes(30) == 10)\n    assert(countPrimes(50) == 15)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrimes", "signature": "def countPrimes(n: Int): Int =", "docstring": "Count the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n\n* Incomplete Code:\ndef countPrimes(n: Int): Int =\n  {\n\n[MASK]\n    else {\n      val isPrime = Array.fill(n)(true)\n[MASK]\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n[MASK]\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n    else {\n      val isPrime = Array.fill(n)(true)\n[MASK]\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n[MASK]\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }"}
{"task_id": "Scala/41-1-multi", "prompt": "\nobject Solution {\n/**\n  * Count the number of prime numbers less than a non-negative integer n.\n  *\n  * @param n The non-negative integer.\n  * @return The number of prime numbers less than n.\n  *\n  * Example:\n  * countPrimes(10)\n  * Output: 4\n  *\n  * Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n  */\n  def countPrimes(n: Int): Int = ", "canonical_solution": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Additional test cases\n    assert(countPrimes(15) == 6)\n    assert(countPrimes(30) == 10)\n    assert(countPrimes(50) == 15)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrimes", "signature": "def countPrimes(n: Int): Int =", "docstring": "Count the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n\n* Incomplete Code:\ndef countPrimes(n: Int): Int =\n  {\n\n[MASK]\n[MASK]\n[MASK]\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n[MASK]\n      } {\n        isPrime(j) = false\n      }\n[MASK]\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n[MASK]\n[MASK]\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n[MASK]\n      } {\n        isPrime(j) = false\n      }\n[MASK]\n    }\n  }"}
{"task_id": "Scala/42-0-multi", "prompt": "\nobject Solution {\n  /**\n    * Check if the binary representation of a positive integer has alternating bits.\n    *\n    * @param n The positive integer to check.\n    * @return True if the binary representation has alternating bits, false otherwise.\n    *\n    * Example:\n    * hasAlternatingBits(5)\n    * Output: true\n    */\n  def hasAlternatingBits(n: Int): Boolean = ", "canonical_solution": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hasAlternatingBits(10)) // Binary representation of 10 is 1010 which has alternating bits\n    assert(!hasAlternatingBits(7)) // Binary representation of 7 is 111 which does not have alternating bits\n    assert(hasAlternatingBits(21)) // Binary representation of 21 is 10101 which has alternating bits\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "hasAlternatingBits", "signature": "def hasAlternatingBits(n: Int): Boolean =", "docstring": "Check if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true\n\n* Incomplete Code:\ndef hasAlternatingBits(n: Int): Boolean =\n  {\n\n    val binaryString = n.toBinaryString\n[MASK]\n[MASK]\n    }\n    true\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val binaryString = n.toBinaryString\n[MASK]\n[MASK]\n    }\n    true\n  }"}
{"task_id": "Scala/42-1-multi", "prompt": "\nobject Solution {\n  /**\n    * Check if the binary representation of a positive integer has alternating bits.\n    *\n    * @param n The positive integer to check.\n    * @return True if the binary representation has alternating bits, false otherwise.\n    *\n    * Example:\n    * hasAlternatingBits(5)\n    * Output: true\n    */\n  def hasAlternatingBits(n: Int): Boolean = ", "canonical_solution": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hasAlternatingBits(10)) // Binary representation of 10 is 1010 which has alternating bits\n    assert(!hasAlternatingBits(7)) // Binary representation of 7 is 111 which does not have alternating bits\n    assert(hasAlternatingBits(21)) // Binary representation of 21 is 10101 which has alternating bits\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "hasAlternatingBits", "signature": "def hasAlternatingBits(n: Int): Boolean =", "docstring": "Check if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true\n\n* Incomplete Code:\ndef hasAlternatingBits(n: Int): Boolean =\n  {\n\n    val binaryString = n.toBinaryString\n[MASK]\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val binaryString = n.toBinaryString\n[MASK]\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n[MASK]\n  }"}
{"task_id": "Scala/43-0-multi", "prompt": "import scala.collection.mutable.ArrayBuffer\n\nobject Solution {\n  /**\n    * Move all even elements to the front of the array, followed by all odd elements.\n    *\n    * @param nums An array of integers.\n    * @return The modified array with even elements in the front and odd elements at the end.\n    *\n    * Example:\n    * moveEvenOdd(Array(3, 1, 2, 4))\n    * Output: Array(2, 4, 3, 1)\n    *\n    * Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n    */\n  def moveEvenOdd(nums: Array[Int]): Array[Int] = ", "canonical_solution": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(moveEvenOdd(Array(5, 8, 3, 6)).sameElements(Array(8, 6, 5, 3)))\n\n    // Test case 2\n    assert(moveEvenOdd(Array(7, 2)).sameElements(Array(2, 7)))\n\n    // Test case 3\n    assert(moveEvenOdd(Array(9, 1, 4, 7, 6)).sameElements(Array(4, 6, 9, 1, 7)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveEvenOdd", "signature": "def moveEvenOdd(nums: Array[Int]): Array[Int] =", "docstring": "Move all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n\n* Incomplete Code:\ndef moveEvenOdd(nums: Array[Int]): Array[Int] =\n  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n[MASK]\n[MASK]\n    }\n\n    // Concatenate the even and odd numbers\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n[MASK]\n[MASK]\n    }\n\n    // Concatenate the even and odd numbers\n[MASK]\n  }"}
{"task_id": "Scala/43-1-multi", "prompt": "import scala.collection.mutable.ArrayBuffer\n\nobject Solution {\n  /**\n    * Move all even elements to the front of the array, followed by all odd elements.\n    *\n    * @param nums An array of integers.\n    * @return The modified array with even elements in the front and odd elements at the end.\n    *\n    * Example:\n    * moveEvenOdd(Array(3, 1, 2, 4))\n    * Output: Array(2, 4, 3, 1)\n    *\n    * Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n    */\n  def moveEvenOdd(nums: Array[Int]): Array[Int] = ", "canonical_solution": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(moveEvenOdd(Array(5, 8, 3, 6)).sameElements(Array(8, 6, 5, 3)))\n\n    // Test case 2\n    assert(moveEvenOdd(Array(7, 2)).sameElements(Array(2, 7)))\n\n    // Test case 3\n    assert(moveEvenOdd(Array(9, 1, 4, 7, 6)).sameElements(Array(4, 6, 9, 1, 7)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveEvenOdd", "signature": "def moveEvenOdd(nums: Array[Int]): Array[Int] =", "docstring": "Move all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n\n* Incomplete Code:\ndef moveEvenOdd(nums: Array[Int]): Array[Int] =\n  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n[MASK]\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n[MASK]\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n[MASK]\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n[MASK]\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }"}
{"task_id": "Scala/46-0-multi", "prompt": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n  /**\n  * Generate all unique permutations of a sequence of numbers.\n  *\n  * @param nums The sequence of numbers.\n  * @return A list of all unique permutations.\n  *\n  * Example:\n  * permute(Array(1, 1, 2))\n  * Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n  */\n  def permute(nums: Array[Int]): List[List[Int]] = ", "canonical_solution": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(permute(Array(2, 3, 5)).toSet == Set(\n      List(2, 3, 5), List(2, 5, 3), List(3, 2, 5),\n      List(3, 5, 2), List(5, 2, 3), List(5, 3, 2)\n    ))\n\n    // Test case 2\n    assert(permute(Array(0, -1, 1)).toSet == Set(\n      List(0, -1, 1), List(0, 1, -1), List(-1, 0, 1),\n      List(-1, 1, 0), List(1, 0, -1), List(1, -1, 0)\n    ))\n\n    // Test case 3\n    assert(permute(Array(1, 2)).toSet == Set(\n      List(1, 2), List(2, 1)\n    ))\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "permute", "signature": "def permute(nums: Array[Int]): List[List[Int]] =", "docstring": "Generate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n\n* Incomplete Code:\ndef permute(nums: Array[Int]): List[List[Int]] =\n  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n[MASK]\n        results += tempList.toList\n[MASK]\n        for (i <- nums.indices) {\n          if (!used(i)) {\n[MASK]\n            tempList += nums(i)\n[MASK]\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n[MASK]\n        results += tempList.toList\n[MASK]\n        for (i <- nums.indices) {\n          if (!used(i)) {\n[MASK]\n            tempList += nums(i)\n[MASK]\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n"}
{"task_id": "Scala/46-1-multi", "prompt": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n  /**\n  * Generate all unique permutations of a sequence of numbers.\n  *\n  * @param nums The sequence of numbers.\n  * @return A list of all unique permutations.\n  *\n  * Example:\n  * permute(Array(1, 1, 2))\n  * Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n  */\n  def permute(nums: Array[Int]): List[List[Int]] = ", "canonical_solution": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(permute(Array(2, 3, 5)).toSet == Set(\n      List(2, 3, 5), List(2, 5, 3), List(3, 2, 5),\n      List(3, 5, 2), List(5, 2, 3), List(5, 3, 2)\n    ))\n\n    // Test case 2\n    assert(permute(Array(0, -1, 1)).toSet == Set(\n      List(0, -1, 1), List(0, 1, -1), List(-1, 0, 1),\n      List(-1, 1, 0), List(1, 0, -1), List(1, -1, 0)\n    ))\n\n    // Test case 3\n    assert(permute(Array(1, 2)).toSet == Set(\n      List(1, 2), List(2, 1)\n    ))\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "permute", "signature": "def permute(nums: Array[Int]): List[List[Int]] =", "docstring": "Generate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n\n* Incomplete Code:\ndef permute(nums: Array[Int]): List[List[Int]] =\n  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n[MASK]\n      if (tempList.size == nums.length) {\n[MASK]\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n[MASK]\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n[MASK]\n      if (tempList.size == nums.length) {\n[MASK]\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n[MASK]\n  }\n"}
{"task_id": "Scala/47-0-multi", "prompt": "\nobject Solution {\n      /**\n       * Reverse the first k characters of every 2k characters in the given string.\n       *\n       * @param s The input string.\n       * @param k The integer k.\n       * @return The modified string.\n       *\n       * Example:\n       * reverseString(\"abcdefg\", 2)\n       * Output: \"bacdfeg\"\n       *\n       * reverseString(\"abcd\", 2)\n       * Output: \"bacd\"\n       */\n  def reverseString(s: String, k: Int): String = ", "canonical_solution": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"example\", 3) == \"axemple\")\n    assert(reverseString(\"helloScala\", 4) == \"llehoScaal\")\n    assert(reverseString(\"scalaisfun\", 5) == \"alacsisfun\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String, k: Int): String =", "docstring": "Reverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"\n\n* Incomplete Code:\ndef reverseString(s: String, k: Int): String =\n  {\n\n    s.grouped(2 * k).map {\n[MASK]\n[MASK]\n    }.mkString\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    s.grouped(2 * k).map {\n[MASK]\n[MASK]\n    }.mkString\n  }"}
{"task_id": "Scala/47-1-multi", "prompt": "\nobject Solution {\n      /**\n       * Reverse the first k characters of every 2k characters in the given string.\n       *\n       * @param s The input string.\n       * @param k The integer k.\n       * @return The modified string.\n       *\n       * Example:\n       * reverseString(\"abcdefg\", 2)\n       * Output: \"bacdfeg\"\n       *\n       * reverseString(\"abcd\", 2)\n       * Output: \"bacd\"\n       */\n  def reverseString(s: String, k: Int): String = ", "canonical_solution": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"example\", 3) == \"axemple\")\n    assert(reverseString(\"helloScala\", 4) == \"llehoScaal\")\n    assert(reverseString(\"scalaisfun\", 5) == \"alacsisfun\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String, k: Int): String =", "docstring": "Reverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"\n\n* Incomplete Code:\ndef reverseString(s: String, k: Int): String =\n  {\n\n[MASK]\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n[MASK]\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n[MASK]\n  }"}
{"task_id": "Scala/50-0-multi", "prompt": "object Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  def minPerfectSquareSum(n: Int): Int = ", "canonical_solution": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(minPerfectSquareSum(26) == 2, \"Test case 1 failed\")\n    assert(minPerfectSquareSum(17) == 2, \"Test case 2 failed\")\n    assert(minPerfectSquareSum(99) == 3, \"Test case 3 failed\")\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "def minPerfectSquareSum(n: Int): Int =", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2\n\n* Incomplete Code:\ndef minPerfectSquareSum(n: Int): Int =\n  {\n[MASK]\n[MASK]\n\n    for (i <- 1 to n) {\n[MASK]\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n[MASK]\n      }\n    }\n[MASK]\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n[MASK]\n[MASK]\n\n    for (i <- 1 to n) {\n[MASK]\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n[MASK]\n      }\n    }\n[MASK]\n  }"}
{"task_id": "Scala/50-1-multi", "prompt": "object Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  def minPerfectSquareSum(n: Int): Int = ", "canonical_solution": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(minPerfectSquareSum(26) == 2, \"Test case 1 failed\")\n    assert(minPerfectSquareSum(17) == 2, \"Test case 2 failed\")\n    assert(minPerfectSquareSum(99) == 3, \"Test case 3 failed\")\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "def minPerfectSquareSum(n: Int): Int =", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2\n\n* Incomplete Code:\ndef minPerfectSquareSum(n: Int): Int =\n  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n[MASK]\n[MASK]\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n[MASK]\n[MASK]\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }"}
{"task_id": "Scala/1-0-span", "prompt": "object Main extends App {\n\n  /**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n  */\n  def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "canonical_solution": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }", "test": "// Test cases\n  def test(): Unit = {\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n  }\n\n  // Run the test\n  test()\n}", "entry_point": "hasCloseElements", "signature": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n\n* Incomplete Code:\ndef hasCloseElements(numbers: List[Double], threshold: Double): Boolean =\n{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n    [MASK] false\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n    [MASK] false\n  }"}
{"task_id": "Scala/1-1-span", "prompt": "object Main extends App {\n\n  /**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n  */\n  def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "canonical_solution": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }", "test": "// Test cases\n  def test(): Unit = {\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n  }\n\n  // Run the test\n  test()\n}", "entry_point": "hasCloseElements", "signature": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n\n* Incomplete Code:\ndef hasCloseElements(numbers: List[Double], threshold: Double): Boolean =\n{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n    [MASK]alse\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n    [MASK]alse\n  }"}
{"task_id": "Scala/2-0-span", "prompt": "object Solution {\n  /**\n    * Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n    *\n    * A subarray is defined as a contiguous sequence of numbers in an array.\n    *\n    * An ascending subarray is a subarray where the numbers are in strictly increasing order.\n    *\n    * Example:\n    * maxAscendingSum(Array(10,20,30,5,10,50))\n    * Output: 65\n    */\n  def maxAscendingSum(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(maxAscendingSum(Array(1, 2, 3, 4, 5, 6)) == 21)\n    assert(maxAscendingSum(Array(10, 20, 30, 40, 50, 5, 6, 7, 8, 9)) == 150)\n    assert(maxAscendingSum(Array(100, 200, 300, 400, 500, 1, 2, 3, 4, 5)) == 1500)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxAscendingSum", "signature": "def maxAscendingSum(nums: Array[Int]): Int =", "docstring": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65\n\n* Incomplete Code:\ndef maxAscendingSum(nums: Array[Int]): Int =\n  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums([MASK]Sum.max(currentSum)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums([MASK]Sum.max(currentSum)\n  }"}
{"task_id": "Scala/2-1-span", "prompt": "object Solution {\n  /**\n    * Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n    *\n    * A subarray is defined as a contiguous sequence of numbers in an array.\n    *\n    * An ascending subarray is a subarray where the numbers are in strictly increasing order.\n    *\n    * Example:\n    * maxAscendingSum(Array(10,20,30,5,10,50))\n    * Output: 65\n    */\n  def maxAscendingSum(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(maxAscendingSum(Array(1, 2, 3, 4, 5, 6)) == 21)\n    assert(maxAscendingSum(Array(10, 20, 30, 40, 50, 5, 6, 7, 8, 9)) == 150)\n    assert(maxAscendingSum(Array(100, 200, 300, 400, 500, 1, 2, 3, 4, 5)) == 1500)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxAscendingSum", "signature": "def maxAscendingSum(nums: Array[Int]): Int =", "docstring": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65\n\n* Incomplete Code:\ndef maxAscendingSum(nums: Array[Int]): Int =\n  {\n\n    var maxSum [MASK]  var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var maxSum [MASK]  var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }"}
{"task_id": "Scala/3-0-span", "prompt": "object Solution {\n  /**\n    * Calculate the total number of matches in a tournament with n teams.\n    *\n    * @param n The number of teams in the tournament.\n    * @return The total number of matches.\n    *\n    * Example:\n    * numberOfMatches(7)\n    * Output: 6\n    */\n  def numberOfMatches(n: Int): Int = ", "canonical_solution": "  {\n\n     // implementation\n     if (n == 1) 0\n    else if (n % 2 == 0) n / 2 + numberOfMatches(n / 2)\n    else (n - 1) / 2 + numberOfMatches((n - 1) / 2 + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(numberOfMatches(8) == 7)\n    assert(numberOfMatches(10) == 9)\n    assert(numberOfMatches(12) == 11)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberOfMatches", "signature": "def numberOfMatches(n: Int): Int =", "docstring": "Calculate the total number of matches in a tournament with n teams.\n\n@param n The number of teams in the tournament.\n@return The total number of matches.\n\nExample:\nnumberOfMatches(7)\nOutput: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total number of matches in a tournament with n teams.\n\n@param n The number of teams in the tournament.\n@return The total number of matches.\n\nExample:\nnumberOfMatches(7)\nOutput: 6\n\n* Incomplete Code:\ndef numberOfMatches(n: Int): Int =\n  {\n\n     // implementation\n     if (n == 1) 0\n    else if (n % 2[MASK]fMatches(n / 2)\n    else (n - 1) / 2 + numberOfMatches((n - 1) / 2 + 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n     // implementation\n     if (n == 1) 0\n    else if (n % 2[MASK]fMatches(n / 2)\n    else (n - 1) / 2 + numberOfMatches((n - 1) / 2 + 1)\n  }"}
{"task_id": "Scala/3-1-span", "prompt": "object Solution {\n  /**\n    * Calculate the total number of matches in a tournament with n teams.\n    *\n    * @param n The number of teams in the tournament.\n    * @return The total number of matches.\n    *\n    * Example:\n    * numberOfMatches(7)\n    * Output: 6\n    */\n  def numberOfMatches(n: Int): Int = ", "canonical_solution": "  {\n\n     // implementation\n     if (n == 1) 0\n    else if (n % 2 == 0) n / 2 + numberOfMatches(n / 2)\n    else (n - 1) / 2 + numberOfMatches((n - 1) / 2 + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(numberOfMatches(8) == 7)\n    assert(numberOfMatches(10) == 9)\n    assert(numberOfMatches(12) == 11)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberOfMatches", "signature": "def numberOfMatches(n: Int): Int =", "docstring": "Calculate the total number of matches in a tournament with n teams.\n\n@param n The number of teams in the tournament.\n@return The total number of matches.\n\nExample:\nnumberOfMatches(7)\nOutput: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total number of matches in a tournament with n teams.\n\n@param n The number of teams in the tournament.\n@return The total number of matches.\n\nExample:\nnumberOfMatches(7)\nOutput: 6\n\n* Incomplete Code:\ndef numberOfMatches(n: Int): Int =\n  {\n\n     // implementation\n     if (n == 1) 0\n    else if (n % 2 == 0) n / 2 + numberOfMatches(n / 2)\n    else[MASK]fMatches((n - 1) / 2 + 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n     // implementation\n     if (n == 1) 0\n    else if (n % 2 == 0) n / 2 + numberOfMatches(n / 2)\n    else[MASK]fMatches((n - 1) / 2 + 1)\n  }"}
{"task_id": "Scala/4-0-span", "prompt": "import scala.collection.mutable.ArrayBuffer\nobject Solution {\n    /**\n    * Find the most competitive subsequence of length k from the given integer array.\n    *\n    * @param nums The integer array.\n    * @param k The length of the subsequence.\n    * @return The most competitive subsequence.\n    *\n    * Example:\n    * mostCompetitive(Array(3, 5, 2, 6), 2)\n    * Output: Array(2, 6)\n    */\n  def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = ", "canonical_solution": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }", "test": "        def main(args: Array[String]): Unit = {\n            assert(mostCompetitive(Array(3, 5, 2, 6), 2).sameElements(Array(2, 6)))\n            assert(mostCompetitive(Array(2, 4, 3, 3, 5, 4, 9, 6), 4).sameElements(Array(2, 3, 3, 4)))\n            assert(mostCompetitive(Array(6, 7, 5, 3, 5, 6, 4, 2), 3).sameElements(Array(3, 4, 2)))\n            println(\"All tests passed\")\n        }\n    }", "entry_point": "mostCompetitive", "signature": "def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =", "docstring": "Find the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)\n\n* Incomplete Code:\ndef mostCompetitive(nums: Array[Int], k: Int): Array[Int] =\n  {\n \n   [MASK]    if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n   [MASK]    if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }"}
{"task_id": "Scala/4-1-span", "prompt": "import scala.collection.mutable.ArrayBuffer\nobject Solution {\n    /**\n    * Find the most competitive subsequence of length k from the given integer array.\n    *\n    * @param nums The integer array.\n    * @param k The length of the subsequence.\n    * @return The most competitive subsequence.\n    *\n    * Example:\n    * mostCompetitive(Array(3, 5, 2, 6), 2)\n    * Output: Array(2, 6)\n    */\n  def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = ", "canonical_solution": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }", "test": "        def main(args: Array[String]): Unit = {\n            assert(mostCompetitive(Array(3, 5, 2, 6), 2).sameElements(Array(2, 6)))\n            assert(mostCompetitive(Array(2, 4, 3, 3, 5, 4, 9, 6), 4).sameElements(Array(2, 3, 3, 4)))\n            assert(mostCompetitive(Array(6, 7, 5, 3, 5, 6, 4, 2), 3).sameElements(Array(3, 4, 2)))\n            println(\"All tests passed\")\n        }\n    }", "entry_point": "mostCompetitive", "signature": "def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =", "docstring": "Find the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)\n\n* Incomplete Code:\ndef mostCompetitive(nums: Array[Int], k: Int): Array[Int] =\n  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if[MASK]                   stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if[MASK]                   stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }"}
{"task_id": "Scala/5-0-span", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n    /**\n      * Generate all possible palindrome strings by rearranging the characters in the input string.\n      *\n      * @param s The input string.\n      * @return A list of all possible palindrome strings, without duplicates.\n      *\n      * Example:\n      * generatePalindromes(\"aabb\")\n      * Output: List(\"abba\", \"baab\")\n      */\n  def generatePalindromes(s: String): List[String] = ", "canonical_solution": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val result1 = generatePalindromes(\"aabb\")\n    assert(result1.contains(\"abba\"))\n    assert(result1.contains(\"baab\"))\n    \n    val result2 = generatePalindromes(\"abc\")\n    assert(result2.isEmpty)\n\n    val result3 = generatePalindromes(\"aabbc\")\n    assert(result3.contains(\"abcba\"))\n    assert(result3.contains(\"bacab\"))\n    \n    println(\"All tests passed\")\n}\n    \n}", "entry_point": "generatePalindromes", "signature": "def generatePalindromes(s: String): List[String] =", "docstring": "Generate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")\n\n* Incomplete Code:\ndef generatePalindromes(s: String): List[String] =\n  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count[MASK]1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count[MASK]1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }"}
{"task_id": "Scala/5-1-span", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n    /**\n      * Generate all possible palindrome strings by rearranging the characters in the input string.\n      *\n      * @param s The input string.\n      * @return A list of all possible palindrome strings, without duplicates.\n      *\n      * Example:\n      * generatePalindromes(\"aabb\")\n      * Output: List(\"abba\", \"baab\")\n      */\n  def generatePalindromes(s: String): List[String] = ", "canonical_solution": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val result1 = generatePalindromes(\"aabb\")\n    assert(result1.contains(\"abba\"))\n    assert(result1.contains(\"baab\"))\n    \n    val result2 = generatePalindromes(\"abc\")\n    assert(result2.isEmpty)\n\n    val result3 = generatePalindromes(\"aabbc\")\n    assert(result3.contains(\"abcba\"))\n    assert(result3.contains(\"bacab\"))\n    \n    println(\"All tests passed\")\n}\n    \n}", "entry_point": "generatePalindromes", "signature": "def generatePalindromes(s: String): List[String] =", "docstring": "Generate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")\n\n* Incomplete Code:\ndef generatePalindromes(s: String): List[String] =\n  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[[MASK]unt += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[[MASK]unt += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }"}
{"task_id": "Scala/6-0-span", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n    /**\n      * Find the value of the bottom-most left node in a binary tree.\n      *\n      * @param root The root node of the binary tree.\n      * @return The value of the bottom-most left node.\n      *\n      * Example:\n      * findBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\n      * Output: 1\n      *\n      * findBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\n      * Output: 7\n      */\n  def findBottomLeftValue(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2)\n    root1.left = new TreeNode(1)\n    root1.right = new TreeNode(3)\n    assert(findBottomLeftValue(root1) == 1)\n\n    // Test Case 2\n    val root2 = new TreeNode(1)\n    root2.left = new TreeNode(2)\n    root2.left.left = new TreeNode(4)\n    root2.right = new TreeNode(3)\n    root2.right.left = new TreeNode(5)\n    root2.right.left.left = new TreeNode(7)\n    root2.right.left.right = new TreeNode(6)\n    assert(findBottomLeftValue(root2) == 7)\n\n    // Test Case 3\n    val root3 = new TreeNode(5)\n    root3.left = new TreeNode(3)\n    root3.right = new TreeNode(6)\n    root3.left.left = new TreeNode(2)\n    root3.left.right = new TreeNode(4)\n    root3.left.left.left = new TreeNode(1)\n    assert(findBottomLeftValue(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findBottomLeftValue", "signature": "def findBottomLeftValue(root: TreeNode): Int =", "docstring": "Find the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7\n\n* Incomplete Code:\ndef findBottomLeftValue(root: TreeNode): Int =\n  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala[MASK]val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala[MASK]val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }"}
{"task_id": "Scala/6-1-span", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n    /**\n      * Find the value of the bottom-most left node in a binary tree.\n      *\n      * @param root The root node of the binary tree.\n      * @return The value of the bottom-most left node.\n      *\n      * Example:\n      * findBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\n      * Output: 1\n      *\n      * findBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\n      * Output: 7\n      */\n  def findBottomLeftValue(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2)\n    root1.left = new TreeNode(1)\n    root1.right = new TreeNode(3)\n    assert(findBottomLeftValue(root1) == 1)\n\n    // Test Case 2\n    val root2 = new TreeNode(1)\n    root2.left = new TreeNode(2)\n    root2.left.left = new TreeNode(4)\n    root2.right = new TreeNode(3)\n    root2.right.left = new TreeNode(5)\n    root2.right.left.left = new TreeNode(7)\n    root2.right.left.right = new TreeNode(6)\n    assert(findBottomLeftValue(root2) == 7)\n\n    // Test Case 3\n    val root3 = new TreeNode(5)\n    root3.left = new TreeNode(3)\n    root3.right = new TreeNode(6)\n    root3.left.left = new TreeNode(2)\n    root3.left.right = new TreeNode(4)\n    root3.left.left.left = new TreeNode(1)\n    assert(findBottomLeftValue(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findBottomLeftValue", "signature": "def findBottomLeftValue(root: TreeNode): Int =", "docstring": "Find the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7\n\n* Incomplete Code:\ndef findBottomLeftValue(root: TreeNode): Int =\n  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n    [MASK]result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n    [MASK]result\n  }"}
{"task_id": "Scala/7-0-span", "prompt": "// Definition for a binary tree node.\ncase class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Determine whether a binary tree is a valid binary search tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a valid binary search tree, false otherwise.\n    *\n    * Example:\n    * isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\n    * isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n    */\n  def isValidBST(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2, new TreeNode(1), new TreeNode(3))\n    assert(isValidBST(root1), \"Test Case 1 Failed\")\n\n    // Test Case 2\n    val root2 = new TreeNode(5, new TreeNode(1), new TreeNode(4, new TreeNode(3), new TreeNode(6)))\n    assert(!isValidBST(root2), \"Test Case 2 Failed\")\n\n    // Test Case 3\n    val root3 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(5))\n    assert(isValidBST(root3), \"Test Case 3 Failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isValidBST", "signature": "def isValidBST(root: TreeNode): Boolean =", "docstring": "Determine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n\n* Incomplete Code:\ndef isValidBST(root: TreeNode): Boolean =\n  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        tru[MASK]else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        tru[MASK]else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }"}
{"task_id": "Scala/7-1-span", "prompt": "// Definition for a binary tree node.\ncase class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Determine whether a binary tree is a valid binary search tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a valid binary search tree, false otherwise.\n    *\n    * Example:\n    * isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\n    * isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n    */\n  def isValidBST(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2, new TreeNode(1), new TreeNode(3))\n    assert(isValidBST(root1), \"Test Case 1 Failed\")\n\n    // Test Case 2\n    val root2 = new TreeNode(5, new TreeNode(1), new TreeNode(4, new TreeNode(3), new TreeNode(6)))\n    assert(!isValidBST(root2), \"Test Case 2 Failed\")\n\n    // Test Case 3\n    val root3 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(5))\n    assert(isValidBST(root3), \"Test Case 3 Failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isValidBST", "signature": "def isValidBST(root: TreeNode): Boolean =", "docstring": "Determine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n\n* Incomplete Code:\ndef isValidBST(root: TreeNode): Boolean =\n  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        fals[MASK]per(root, None, None)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        fals[MASK]per(root, None, None)\n  }"}
{"task_id": "Scala/8-0-span", "prompt": "object Solution {\n    /**\n     * Find all the numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * @param nums An array containing n integers.\n     * @return An array of numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * Example:\n     * findDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\n     * Output: Array(5,6)\n     *\n     * findDisappearedNumbers(Array(1,1))\n     * Output: Array(2)\n     */\n  def findDisappearedNumbers(nums: Array[Int]): List[Int] = ", "canonical_solution": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(4, 3, 2, 7, 8, 2, 3, 1)\n    val result1 = findDisappearedNumbers(nums1)\n    assert(result1.contains(5))\n    assert(result1.contains(6))\n\n    val nums2 = Array(1, 1)\n    val result2 = findDisappearedNumbers(nums2)\n    assert(result2.contains(2))\n\n    val nums3 = Array(2, 2, 2, 2, 2)\n    val result3 = findDisappearedNumbers(nums3)\n    assert(result3.contains(1))\n    assert(result3.contains(3))\n    assert(result3.contains(4))\n    assert(result3.contains(5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findDisappearedNumbers", "signature": "def findDisappearedNumbers(nums: Array[Int]): List[Int] =", "docstring": "Find all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)\n\n* Incomplete Code:\ndef findDisappearedNumbers(nums: Array[Int]): List[Int] =\n  {\n\n    val result = collection.mutable.ListBuffer[[MASK]dex)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val result = collection.mutable.ListBuffer[[MASK]dex)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/8-1-span", "prompt": "object Solution {\n    /**\n     * Find all the numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * @param nums An array containing n integers.\n     * @return An array of numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * Example:\n     * findDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\n     * Output: Array(5,6)\n     *\n     * findDisappearedNumbers(Array(1,1))\n     * Output: Array(2)\n     */\n  def findDisappearedNumbers(nums: Array[Int]): List[Int] = ", "canonical_solution": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(4, 3, 2, 7, 8, 2, 3, 1)\n    val result1 = findDisappearedNumbers(nums1)\n    assert(result1.contains(5))\n    assert(result1.contains(6))\n\n    val nums2 = Array(1, 1)\n    val result2 = findDisappearedNumbers(nums2)\n    assert(result2.contains(2))\n\n    val nums3 = Array(2, 2, 2, 2, 2)\n    val result3 = findDisappearedNumbers(nums3)\n    assert(result3.contains(1))\n    assert(result3.contains(3))\n    assert(result3.contains(4))\n    assert(result3.contains(5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findDisappearedNumbers", "signature": "def findDisappearedNumbers(nums: Array[Int]): List[Int] =", "docstring": "Find all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)\n\n* Incomplete Code:\ndef findDisappearedNumbers(nums: Array[Int]): List[Int] =\n  {\n\n    [MASK]or (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    [MASK]or (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/9-0-span", "prompt": "object Solution {\n  /**\n    * Given an integer n, returns an array consisting of n unique integers that add up to 0.\n    *\n    * @param n The number of integers in the array.\n    * @return An array of n unique integers that add up to 0.\n    *\n    * Example:\n    * sumZero(5)\n    * Output: [-7, -1, 1, 3, 4]\n    *\n    * Note:\n    * Other valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n    */\n  def sumZero(n: Int): Array[Int] = ", "canonical_solution": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }", "test": "  \n  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val result1 = sumZero(4)\n    assert(result1.sameElements(Array(1, 2, 3, -6)))\n    \n    // Test case 2\n    val result2 = sumZero(6)\n    assert(result2.sameElements(Array(1, 2, 3, 4, 5, -15)))\n    \n    // Test case 3\n    val result3 = sumZero(8)\n    assert(result3.sameElements(Array(1, 2, 3, 4, 5, 6, 7, -28)))\n    \n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "sumZero", "signature": "def sumZero(n: Int): Array[Int] =", "docstring": "Given an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n\n* Incomplete Code:\ndef sumZero(n: Int): Array[Int] =\n  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n   [MASK]t(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n   [MASK]t(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }"}
{"task_id": "Scala/9-1-span", "prompt": "object Solution {\n  /**\n    * Given an integer n, returns an array consisting of n unique integers that add up to 0.\n    *\n    * @param n The number of integers in the array.\n    * @return An array of n unique integers that add up to 0.\n    *\n    * Example:\n    * sumZero(5)\n    * Output: [-7, -1, 1, 3, 4]\n    *\n    * Note:\n    * Other valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n    */\n  def sumZero(n: Int): Array[Int] = ", "canonical_solution": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }", "test": "  \n  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val result1 = sumZero(4)\n    assert(result1.sameElements(Array(1, 2, 3, -6)))\n    \n    // Test case 2\n    val result2 = sumZero(6)\n    assert(result2.sameElements(Array(1, 2, 3, 4, 5, -15)))\n    \n    // Test case 3\n    val result3 = sumZero(8)\n    assert(result3.sameElements(Array(1, 2, 3, 4, 5, 6, 7, -28)))\n    \n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "sumZero", "signature": "def sumZero(n: Int): Array[Int] =", "docstring": "Given an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n\n* Incomplete Code:\ndef sumZero(n: Int): Array[Int] =\n  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result([MASK]   result\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result([MASK]   result\n  }"}
{"task_id": "Scala/10-0-span", "prompt": "\nobject Solution {\n    /**\n    * Calculate the number of arguments passed to the function.\n    *\n    * @param args An array of arguments.\n    * @return The number of arguments passed.\n    *\n    * Example:\n    * argumentsLength(Array(5))\n    * Output: 1\n    */\n  def argumentsLength(args: Array[Any]): Int = ", "canonical_solution": "  {\n      args.length\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val testCase1 = Array[Any](\"Hello\", \"World\")\n    assert(argumentsLength(testCase1) == 2)\n\n    // Test Case 2\n    val testCase2 = Array[Any](1, 2, 3, 4, 5)\n    assert(argumentsLength(testCase2) == 5)\n\n    // Test Case 3\n    val testCase3 = Array[Any](10)\n    assert(argumentsLength(testCase3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "argumentsLength", "signature": "def argumentsLength(args: Array[Any]): Int =", "docstring": "Calculate the number of arguments passed to the function.\n\n@param args An array of arguments.\n@return The number of arguments passed.\n\nExample:\nargumentsLength(Array(5))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of arguments passed to the function.\n\n@param args An array of arguments.\n@return The number of arguments passed.\n\nExample:\nargumentsLength(Array(5))\nOutput: 1\n\n* Incomplete Code:\ndef argumentsLength(args: Array[Any]): Int =\n  {\n [MASK]rgs.length\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n [MASK]rgs.length\n  }"}
{"task_id": "Scala/10-1-span", "prompt": "\nobject Solution {\n    /**\n    * Calculate the number of arguments passed to the function.\n    *\n    * @param args An array of arguments.\n    * @return The number of arguments passed.\n    *\n    * Example:\n    * argumentsLength(Array(5))\n    * Output: 1\n    */\n  def argumentsLength(args: Array[Any]): Int = ", "canonical_solution": "  {\n      args.length\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val testCase1 = Array[Any](\"Hello\", \"World\")\n    assert(argumentsLength(testCase1) == 2)\n\n    // Test Case 2\n    val testCase2 = Array[Any](1, 2, 3, 4, 5)\n    assert(argumentsLength(testCase2) == 5)\n\n    // Test Case 3\n    val testCase3 = Array[Any](10)\n    assert(argumentsLength(testCase3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "argumentsLength", "signature": "def argumentsLength(args: Array[Any]): Int =", "docstring": "Calculate the number of arguments passed to the function.\n\n@param args An array of arguments.\n@return The number of arguments passed.\n\nExample:\nargumentsLength(Array(5))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of arguments passed to the function.\n\n@param args An array of arguments.\n@return The number of arguments passed.\n\nExample:\nargumentsLength(Array(5))\nOutput: 1\n\n* Incomplete Code:\ndef argumentsLength(args: Array[Any]): Int =\n  {\n  [MASK]gs.length\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n  [MASK]gs.length\n  }"}
{"task_id": "Scala/11-0-span", "prompt": "\nobject Solution {\n  /**\n    * Calculate the total amount of water that can be trapped between the given heights.\n    *\n    * @param height An array representing the heights of each bar.\n    * @return The total amount of water that can be trapped.\n    *\n    * Example:\n    * trap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\n    * Output: 6\n    *\n    * Explanation:\n    * The heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n    */\n  def trap(height: Array[Int]): Int = ", "canonical_solution": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(trap(Array(1, 0, 2, 0, 1)) == 2)\n    assert(trap(Array(3, 2, 1, 0, 1, 2, 3)) == 9)\n    assert(trap(Array(2, 1, 4, 3, 1, 2)) == 2)\n\n    println(\"All tests passed\")\n  }\n}\n      ", "entry_point": "trap", "signature": "def trap(height: Array[Int]): Int =", "docstring": "Calculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n\n* Incomplete Code:\ndef trap(height: Array[Int]): Int =\n  {\n\n    val n = height.le[MASK]er\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = height.le[MASK]er\n  }"}
{"task_id": "Scala/11-1-span", "prompt": "\nobject Solution {\n  /**\n    * Calculate the total amount of water that can be trapped between the given heights.\n    *\n    * @param height An array representing the heights of each bar.\n    * @return The total amount of water that can be trapped.\n    *\n    * Example:\n    * trap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\n    * Output: 6\n    *\n    * Explanation:\n    * The heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n    */\n  def trap(height: Array[Int]): Int = ", "canonical_solution": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(trap(Array(1, 0, 2, 0, 1)) == 2)\n    assert(trap(Array(3, 2, 1, 0, 1, 2, 3)) == 9)\n    assert(trap(Array(2, 1, 4, 3, 1, 2)) == 2)\n\n    println(\"All tests passed\")\n  }\n}\n      ", "entry_point": "trap", "signature": "def trap(height: Array[Int]): Int =", "docstring": "Calculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n\n* Incomplete Code:\ndef trap(height: Array[Int]): Int =\n  {\n\n    va[MASK]- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    va[MASK]- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }"}
{"task_id": "Scala/12-0-span", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n  /**\n    * Remove the minimum number of invalid parentheses from the given string to make it valid.\n    *\n    * @param s The input string containing parentheses and letters.\n    * @return A list of all possible valid strings after removing invalid parentheses.\n    *\n    * Example:\n    * removeInvalidParentheses(\"()())()\")\n    * Output: List(\"(())()\", \"()()()\")\n    */\n  def removeInvalidParentheses(s: String): List[String] = ", "canonical_solution": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test 1\n    val result1 = removeInvalidParentheses(\"()())()\")\n    assert(result1.contains(\"(())()\"))\n    assert(result1.contains(\"()()()\"))\n\n    // Test 2\n    val result2 = removeInvalidParentheses(\"(a)())()\")\n    assert(result2.contains(\"(a())()\"))\n    assert(result2.contains(\"(a)()()\"))\n\n    // Test 3\n    val result3 = removeInvalidParentheses(\")(\")\n    assert(result3.contains(\"\"))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeInvalidParentheses", "signature": "def removeInvalidParentheses(s: String): List[String] =", "docstring": "Remove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")\n\n* Incomplete Code:\ndef removeInvalidParentheses(s: String): List[String] =\n  {\n    val result = ListBuffer[String]()\n    [MASK]ring, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val result = ListBuffer[String]()\n    [MASK]ring, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }"}
{"task_id": "Scala/12-1-span", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n  /**\n    * Remove the minimum number of invalid parentheses from the given string to make it valid.\n    *\n    * @param s The input string containing parentheses and letters.\n    * @return A list of all possible valid strings after removing invalid parentheses.\n    *\n    * Example:\n    * removeInvalidParentheses(\"()())()\")\n    * Output: List(\"(())()\", \"()()()\")\n    */\n  def removeInvalidParentheses(s: String): List[String] = ", "canonical_solution": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test 1\n    val result1 = removeInvalidParentheses(\"()())()\")\n    assert(result1.contains(\"(())()\"))\n    assert(result1.contains(\"()()()\"))\n\n    // Test 2\n    val result2 = removeInvalidParentheses(\"(a)())()\")\n    assert(result2.contains(\"(a())()\"))\n    assert(result2.contains(\"(a)()()\"))\n\n    // Test 3\n    val result3 = removeInvalidParentheses(\")(\")\n    assert(result3.contains(\"\"))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeInvalidParentheses", "signature": "def removeInvalidParentheses(s: String): List[String] =", "docstring": "Remove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")\n\n* Incomplete Code:\ndef removeInvalidParentheses(s: String): List[String] =\n  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += [MASK]  return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += [MASK]  return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }"}
{"task_id": "Scala/13-0-span", "prompt": "case class TreeNode(var value: Int, var left: Option[TreeNode] = None, var right: Option[TreeNode] = None)\nobject Solution {\n\n    /**\n     * Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n     *\n     * @param root The root node of the binary search tree.\n     * @return The minimum difference between any two different nodes values.\n     *\n     * Example:\n     * minDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\n     * Output: 1\n     */\n  def minDiffInBST(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val root = TreeNode(5, Some(TreeNode(3)), Some(TreeNode(7)))\n    root.left.get.left = Some(TreeNode(2))\n    root.left.get.right = Some(TreeNode(4))\n    root.right.get.left = Some(TreeNode(6))\n    root.right.get.right = Some(TreeNode(8))\n\n    assert(minDiffInBST(root) == 1)\n\n    val root2 = TreeNode(8, Some(TreeNode(4)), Some(TreeNode(12)))\n    root2.left.get.left = Some(TreeNode(2))\n    root2.left.get.right = Some(TreeNode(6))\n    root2.right.get.left = Some(TreeNode(10))\n    root2.right.get.right = Some(TreeNode(14))\n\n    assert(minDiffInBST(root2) == 2)\n\n    val root3 = TreeNode(1)\n    root3.right = Some(TreeNode(3))\n    root3.right.get.right = Some(TreeNode(6))\n    root3.right.get.right.get.left = Some(TreeNode(4))\n\n    assert(minDiffInBST(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minDiffInBST", "signature": "def minDiffInBST(root: TreeNode): Int =", "docstring": "Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1\n\n* Incomplete Code:\ndef minDiffInBST(root: TreeNode): Int =\n  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff =[MASK]updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff =[MASK]updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }"}
{"task_id": "Scala/13-1-span", "prompt": "case class TreeNode(var value: Int, var left: Option[TreeNode] = None, var right: Option[TreeNode] = None)\nobject Solution {\n\n    /**\n     * Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n     *\n     * @param root The root node of the binary search tree.\n     * @return The minimum difference between any two different nodes values.\n     *\n     * Example:\n     * minDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\n     * Output: 1\n     */\n  def minDiffInBST(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val root = TreeNode(5, Some(TreeNode(3)), Some(TreeNode(7)))\n    root.left.get.left = Some(TreeNode(2))\n    root.left.get.right = Some(TreeNode(4))\n    root.right.get.left = Some(TreeNode(6))\n    root.right.get.right = Some(TreeNode(8))\n\n    assert(minDiffInBST(root) == 1)\n\n    val root2 = TreeNode(8, Some(TreeNode(4)), Some(TreeNode(12)))\n    root2.left.get.left = Some(TreeNode(2))\n    root2.left.get.right = Some(TreeNode(6))\n    root2.right.get.left = Some(TreeNode(10))\n    root2.right.get.right = Some(TreeNode(14))\n\n    assert(minDiffInBST(root2) == 2)\n\n    val root3 = TreeNode(1)\n    root3.right = Some(TreeNode(3))\n    root3.right.get.right = Some(TreeNode(6))\n    root3.right.get.right.get.left = Some(TreeNode(4))\n\n    assert(minDiffInBST(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minDiffInBST", "signature": "def minDiffInBST(root: TreeNode): Int =", "docstring": "Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1\n\n* Incomplete Code:\ndef minDiffInBST(root: TreeNode): Int =\n  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], min[MASK]dDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], min[MASK]dDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }"}
{"task_id": "Scala/14-0-span", "prompt": "object Solution {\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n  /**\n    * Find the maximum depth of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The maximum depth of the binary tree.\n    *\n    * Example:\n    * maxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: 3\n    */\n  def maxDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    val root1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    val root2 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), null)))\n    val root3 = TreeNode(10, null, null)\n\n    assert(maxDepth(root1) == 3)\n    assert(maxDepth(root2) == 4)\n    assert(maxDepth(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxDepth", "signature": "def maxDepth(root: TreeNode): Int =", "docstring": "Find the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3\n\n* Incomplete Code:\ndef maxDepth(root: TreeNode): Int =\n  {\n\n    if ([MASK] rightDepth) + 1\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if ([MASK] rightDepth) + 1\n  }\n"}
{"task_id": "Scala/14-1-span", "prompt": "object Solution {\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n  /**\n    * Find the maximum depth of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The maximum depth of the binary tree.\n    *\n    * Example:\n    * maxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: 3\n    */\n  def maxDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    val root1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    val root2 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), null)))\n    val root3 = TreeNode(10, null, null)\n\n    assert(maxDepth(root1) == 3)\n    assert(maxDepth(root2) == 4)\n    assert(maxDepth(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxDepth", "signature": "def maxDepth(root: TreeNode): Int =", "docstring": "Find the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3\n\n* Incomplete Code:\ndef maxDepth(root: TreeNode): Int =\n  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.l[MASK]epth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.l[MASK]epth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n"}
{"task_id": "Scala/15-0-span", "prompt": "object Solution {\n    /**\n    * Check if a string is a k-palindrome.\n    *\n    * A k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n    *\n    * @param s The input string.\n    * @param k The maximum number of characters that can be removed.\n    * @return True if the string is a k-palindrome, otherwise false.\n    *\n    * Example:\n    * isKPalindrome(\"abcdeca\", 2)\n    * Output: true\n    *\n    * isKPalindrome(\"abbababa\", 1)\n    * Output: true\n    */\n  def isKPalindrome(s: String, k: Int): Boolean = ", "canonical_solution": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(isKPalindrome(\"abcdeca\", 2) == true)\n    assert(isKPalindrome(\"abbababa\", 1) == true)\n    assert(isKPalindrome(\"abcdefg\", 3) == false)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isKPalindrome", "signature": "def isKPalindrome(s: String, k: Int): Boolean =", "docstring": "Check if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true\n\n* Incomplete Code:\ndef isKPalindrome(s: String, k: Int): Boolean =\n  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.l[MASK] } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.l[MASK] } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }"}
{"task_id": "Scala/15-1-span", "prompt": "object Solution {\n    /**\n    * Check if a string is a k-palindrome.\n    *\n    * A k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n    *\n    * @param s The input string.\n    * @param k The maximum number of characters that can be removed.\n    * @return True if the string is a k-palindrome, otherwise false.\n    *\n    * Example:\n    * isKPalindrome(\"abcdeca\", 2)\n    * Output: true\n    *\n    * isKPalindrome(\"abbababa\", 1)\n    * Output: true\n    */\n  def isKPalindrome(s: String, k: Int): Boolean = ", "canonical_solution": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(isKPalindrome(\"abcdeca\", 2) == true)\n    assert(isKPalindrome(\"abbababa\", 1) == true)\n    assert(isKPalindrome(\"abcdefg\", 3) == false)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isKPalindrome", "signature": "def isKPalindrome(s: String, k: Int): Boolean =", "docstring": "Check if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true\n\n* Incomplete Code:\ndef isKPalindrome(s: String, k: Int): Boolean =\n  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <-[MASK] {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <-[MASK] {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }"}
{"task_id": "Scala/16-0-span", "prompt": "object Solution {\n\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n   /**\n    * Find the diameter of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The length of the longest path between any two nodes in the tree.\n    *\n    * Example:\n    * diameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\n    * Output: 3\n    *\n    * Note:\n    * The diameter of a binary tree is defined as the length of the longest path between any two nodes,\n    * which may or may not pass through the root.\n    * The length of a path is represented by the number of edges between two nodes.\n    * The given tree is guaranteed to have at most 104 nodes,\n    * and the values of the nodes in the tree are in the range [-100, 100].\n    */\n  def diameterOfBinaryTree(root: TreeNode): Int = ", "canonical_solution": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n    assert(diameterOfBinaryTree(root1) == 3)\n\n    // Test case 2\n    val root2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert(diameterOfBinaryTree(root2) == 3)\n\n    // Test case 3\n    val root3 = TreeNode(1, null, TreeNode(2, null, TreeNode(3, null, TreeNode(4))))\n    assert(diameterOfBinaryTree(root3) == 3)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "diameterOfBinaryTree", "signature": "def diameterOfBinaryTree(root: TreeNode): Int =", "docstring": "Find the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].\n\n* Incomplete Code:\ndef diameterOfBinaryTree(root: TreeNode): Int =\n  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else [MASK]= diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else [MASK]= diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }"}
{"task_id": "Scala/16-1-span", "prompt": "object Solution {\n\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n   /**\n    * Find the diameter of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The length of the longest path between any two nodes in the tree.\n    *\n    * Example:\n    * diameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\n    * Output: 3\n    *\n    * Note:\n    * The diameter of a binary tree is defined as the length of the longest path between any two nodes,\n    * which may or may not pass through the root.\n    * The length of a path is represented by the number of edges between two nodes.\n    * The given tree is guaranteed to have at most 104 nodes,\n    * and the values of the nodes in the tree are in the range [-100, 100].\n    */\n  def diameterOfBinaryTree(root: TreeNode): Int = ", "canonical_solution": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n    assert(diameterOfBinaryTree(root1) == 3)\n\n    // Test case 2\n    val root2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert(diameterOfBinaryTree(root2) == 3)\n\n    // Test case 3\n    val root3 = TreeNode(1, null, TreeNode(2, null, TreeNode(3, null, TreeNode(4))))\n    assert(diameterOfBinaryTree(root3) == 3)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "diameterOfBinaryTree", "signature": "def diameterOfBinaryTree(root: TreeNode): Int =", "docstring": "Find the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].\n\n* Incomplete Code:\ndef diameterOfBinaryTree(root: TreeNode): Int =\n  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node =[MASK]  math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node =[MASK]  math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }"}
{"task_id": "Scala/17-0-span", "prompt": "object Solution {\n\n    /**\n     * Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n     *\n     * @param date The date in the format \"YYYY-MM-DD\".\n     * @return The day of the year.\n     *\n     * Example:\n     * dayOfYear(\"2019-01-09\")\n     * Output: 9\n     *\n     * dayOfYear(\"2019-02-10\")\n     * Output: 41\n     */\n  def dayOfYear(date: String): Int = ", "canonical_solution": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(dayOfYear(\"2022-03-15\") == 74)\n    assert(dayOfYear(\"2023-11-30\") == 334)\n    assert(dayOfYear(\"2024-07-01\") == 183)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "dayOfYear", "signature": "def dayOfYear(date: String): Int =", "docstring": "Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41\n\n* Incomplete Code:\ndef dayOfYear(date: String): Int =\n  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year[MASK]OfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year[MASK]OfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }"}
{"task_id": "Scala/17-1-span", "prompt": "object Solution {\n\n    /**\n     * Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n     *\n     * @param date The date in the format \"YYYY-MM-DD\".\n     * @return The day of the year.\n     *\n     * Example:\n     * dayOfYear(\"2019-01-09\")\n     * Output: 9\n     *\n     * dayOfYear(\"2019-02-10\")\n     * Output: 41\n     */\n  def dayOfYear(date: String): Int = ", "canonical_solution": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(dayOfYear(\"2022-03-15\") == 74)\n    assert(dayOfYear(\"2023-11-30\") == 334)\n    assert(dayOfYear(\"2024-07-01\") == 183)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "dayOfYear", "signature": "def dayOfYear(date: String): Int =", "docstring": "Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41\n\n* Incomplete Code:\ndef dayOfYear(date: String): Int =\n  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, [MASK](i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, [MASK](i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }"}
{"task_id": "Scala/18-0-span", "prompt": "\nobject Solution {\n  /**\n    * Convert a non-negative integer to its English representation.\n    *\n    * @param num The number to be converted.\n    * @return The English representation of the number.\n    *\n    * Example:\n    * numberToWords(123)\n    * Output: \"One Hundred Twenty Three\"\n    *\n    * numberToWords(12345)\n    * Output: \"Twelve Thousand Three Hundred Forty Five\"\n    *\n    * numberToWords(1234567)\n    * Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n    */\n  def numberToWords(num: Int): String = ", "canonical_solution": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(numberToWords(567) == \"Five Hundred Sixty Seven\")\n    assert(numberToWords(123456) == \"One Hundred Twenty Three Thousand Four Hundred Fifty Six\")\n    assert(numberToWords(987654321) == \"Nine Hundred Eighty Seven Million Six Hundred Fifty Four Thousand Three Hundred Twenty One\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberToWords", "signature": "def numberToWords(num: Int): String =", "docstring": "Convert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nConvert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n* Incomplete Code:\ndef numberToWords(num: Int): String =\n  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n  [MASK]tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n  [MASK]tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n"}
{"task_id": "Scala/18-1-span", "prompt": "\nobject Solution {\n  /**\n    * Convert a non-negative integer to its English representation.\n    *\n    * @param num The number to be converted.\n    * @return The English representation of the number.\n    *\n    * Example:\n    * numberToWords(123)\n    * Output: \"One Hundred Twenty Three\"\n    *\n    * numberToWords(12345)\n    * Output: \"Twelve Thousand Three Hundred Forty Five\"\n    *\n    * numberToWords(1234567)\n    * Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n    */\n  def numberToWords(num: Int): String = ", "canonical_solution": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(numberToWords(567) == \"Five Hundred Sixty Seven\")\n    assert(numberToWords(123456) == \"One Hundred Twenty Three Thousand Four Hundred Fifty Six\")\n    assert(numberToWords(987654321) == \"Nine Hundred Eighty Seven Million Six Hundred Fifty Four Thousand Three Hundred Twenty One\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberToWords", "signature": "def numberToWords(num: Int): String =", "docstring": "Convert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nConvert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n* Incomplete Code:\ndef numberToWords(num: Int): String =\n  {\n\n      if (n[MASK] helper(num % 100, belowTwenty, tens)\n    }\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      if (n[MASK] helper(num % 100, belowTwenty, tens)\n    }\n  }\n"}
{"task_id": "Scala/19-0-span", "prompt": "\nobject Solution {\n  /**\n    * Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\n    * Calculate and return the total number of complete rows that can be formed.\n    *\n    * @param n The total number of coins.\n    * @return The total number of complete rows that can be formed.\n    *\n    * Example:\n    * arrangeCoins(5)\n    * Output: 2\n    * Explanation: The third row is incomplete, so return 2.\n    */\n  def arrangeCoins(n: Int): Int = ", "canonical_solution": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(arrangeCoins(8) == 3)\n    assert(arrangeCoins(15) == 5)\n    assert(arrangeCoins(20) == 5)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "arrangeCoins", "signature": "def arrangeCoins(n: Int): Int =", "docstring": "Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.\n\n* Incomplete Code:\ndef arrangeCoins(n: Int): Int =\n  {\n \n    var row = 1\n    var rem[MASK] 1\n    }\n    row - 1\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    var row = 1\n    var rem[MASK] 1\n    }\n    row - 1\n  }"}
{"task_id": "Scala/19-1-span", "prompt": "\nobject Solution {\n  /**\n    * Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\n    * Calculate and return the total number of complete rows that can be formed.\n    *\n    * @param n The total number of coins.\n    * @return The total number of complete rows that can be formed.\n    *\n    * Example:\n    * arrangeCoins(5)\n    * Output: 2\n    * Explanation: The third row is incomplete, so return 2.\n    */\n  def arrangeCoins(n: Int): Int = ", "canonical_solution": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(arrangeCoins(8) == 3)\n    assert(arrangeCoins(15) == 5)\n    assert(arrangeCoins(20) == 5)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "arrangeCoins", "signature": "def arrangeCoins(n: Int): Int =", "docstring": "Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.\n\n* Incomplete Code:\ndef arrangeCoins(n: Int): Int =\n  {\n \n    var row = 1\n    var remaining = n\n    while (rem[MASK]aining -= row\n      row += 1\n    }\n    row - 1\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    var row = 1\n    var remaining = n\n    while (rem[MASK]aining -= row\n      row += 1\n    }\n    row - 1\n  }"}
{"task_id": "Scala/20-0-span", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\nobject Solution {\n  /**\n   * Calculate the minimum depth of a binary tree.\n   *\n   * The minimum depth is the number of nodes along the shortest path from the root node to\n   * the nearest leaf node.\n   *\n   * @param root The root node of the binary tree.\n   * @return The minimum depth of the tree.\n   *\n   * Examples:\n   * minimumDepth([3,9,20,null,null,15,7])\n   * Output: 2\n   *\n   * minimumDepth([2,null,3,null,4,null,5,null,6])\n   * Output: 5\n   *\n   * Constraints:\n   * - The number of nodes in the tree is in the range [0, 10^5].\n   * - The value of each node is in the range [-1000, 1000].\n   */\n\n  def minimumDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = new TreeNode(3)\n    root1.left = new TreeNode(9)\n    root1.right = new TreeNode(20)\n    root1.right.left = new TreeNode(15)\n    root1.right.right = new TreeNode(7)\n    assert(minimumDepth(root1) == 2)\n    \n    // Test case 2\n    val root2 = new TreeNode(2)\n    root2.right = new TreeNode(3)\n    root2.right.right = new TreeNode(4)\n    root2.right.right.right = new TreeNode(5)\n    root2.right.right.right.right = new TreeNode(6)\n    assert(minimumDepth(root2) == 5)\n    \n    // Test case 3\n    val root3: TreeNode = null\n    assert(minimumDepth(root3) == 0)\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "minimumDepth", "signature": "def minimumDepth(root: TreeNode): Int =", "docstring": "Calculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].\n\n* Incomplete Code:\ndef minimumDepth(root: TreeNode): Int =\n  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(roo[MASK]= null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(roo[MASK]= null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  "}
{"task_id": "Scala/20-1-span", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\nobject Solution {\n  /**\n   * Calculate the minimum depth of a binary tree.\n   *\n   * The minimum depth is the number of nodes along the shortest path from the root node to\n   * the nearest leaf node.\n   *\n   * @param root The root node of the binary tree.\n   * @return The minimum depth of the tree.\n   *\n   * Examples:\n   * minimumDepth([3,9,20,null,null,15,7])\n   * Output: 2\n   *\n   * minimumDepth([2,null,3,null,4,null,5,null,6])\n   * Output: 5\n   *\n   * Constraints:\n   * - The number of nodes in the tree is in the range [0, 10^5].\n   * - The value of each node is in the range [-1000, 1000].\n   */\n\n  def minimumDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = new TreeNode(3)\n    root1.left = new TreeNode(9)\n    root1.right = new TreeNode(20)\n    root1.right.left = new TreeNode(15)\n    root1.right.right = new TreeNode(7)\n    assert(minimumDepth(root1) == 2)\n    \n    // Test case 2\n    val root2 = new TreeNode(2)\n    root2.right = new TreeNode(3)\n    root2.right.right = new TreeNode(4)\n    root2.right.right.right = new TreeNode(5)\n    root2.right.right.right.right = new TreeNode(6)\n    assert(minimumDepth(root2) == 5)\n    \n    // Test case 3\n    val root3: TreeNode = null\n    assert(minimumDepth(root3) == 0)\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "minimumDepth", "signature": "def minimumDepth(root: TreeNode): Int =", "docstring": "Calculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].\n\n* Incomplete Code:\ndef minimumDepth(root: TreeNode): Int =\n  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null)[MASK]nimumDepth(root.right)) + 1\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null)[MASK]nimumDepth(root.right)) + 1\n  }\n  "}
{"task_id": "Scala/21-0-span", "prompt": "\nobject Solution {\n  /**\n     * Given a string s, you need to split it into some substrings so that each substring is a palindrome.\n     * Return the minimum number of splits required.\n     *\n     * @param s The input string.\n     * @return The minimum number of splits required.\n     *\n     * Example:\n     * minCut(\"aab\")\n     * Output: 1\n     *\n     * Explanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n     *\n     * Constraints:\n     * - 1 <= s.length <= 2000\n     * - s consists only of lowercase English letters.\n     */\n  def minCut(s: String): Int = ", "canonical_solution": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(minCut(\"abcba\") == 0)\n    assert(minCut(\"aabba\") == 1)\n    assert(minCut(\"abbababa\") == 2)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minCut", "signature": "def minCut(s: String): Int =", "docstring": "Given a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.\n\n* Incomplete Code:\ndef minCut(s: String): Int =\n  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to [MASK]- j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to [MASK]- j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }"}
{"task_id": "Scala/21-1-span", "prompt": "\nobject Solution {\n  /**\n     * Given a string s, you need to split it into some substrings so that each substring is a palindrome.\n     * Return the minimum number of splits required.\n     *\n     * @param s The input string.\n     * @return The minimum number of splits required.\n     *\n     * Example:\n     * minCut(\"aab\")\n     * Output: 1\n     *\n     * Explanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n     *\n     * Constraints:\n     * - 1 <= s.length <= 2000\n     * - s consists only of lowercase English letters.\n     */\n  def minCut(s: String): Int = ", "canonical_solution": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(minCut(\"abcba\") == 0)\n    assert(minCut(\"aabba\") == 1)\n    assert(minCut(\"abbababa\") == 2)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minCut", "signature": "def minCut(s: String): Int =", "docstring": "Given a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.\n\n* Incomplete Code:\ndef minCut(s: String): Int =\n  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n   [MASK]= true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n   [MASK]= true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }"}
{"task_id": "Scala/22-0-span", "prompt": "class TreeNode(val value: Int, var left: TreeNode = null, var right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Check if a binary tree is symmetric.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is symmetric, False otherwise.\n    *\n    * Example:\n    * isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\n    * Output: true\n    */\n  def isSymmetric(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }", "test": "def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), new TreeNode(4)\n      ),\n      new TreeNode(2,\n        new TreeNode(4), new TreeNode(3)\n      )\n    )\n    assert(isSymmetric(root1))\n\n    // Test Case 2\n    val root2 = new TreeNode(1,\n      new TreeNode(2,\n        null, new TreeNode(3)\n      ),\n      new TreeNode(2,\n        null, new TreeNode(3)\n      )\n    )\n    assert(!isSymmetric(root2))\n\n    // Test Case 3\n    val root3 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), null\n      ),\n      new TreeNode(2,\n        new TreeNode(3), null\n      )\n    )\n    assert(!isSymmetric(root3))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isSymmetric", "signature": "def isSymmetric(root: TreeNode): Boolean =", "docstring": "Check if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true\n\n* Incomplete Code:\ndef isSymmetric(root: TreeNode): Boolean =\n  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n  [MASK]   true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n  [MASK]   true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }"}
{"task_id": "Scala/22-1-span", "prompt": "class TreeNode(val value: Int, var left: TreeNode = null, var right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Check if a binary tree is symmetric.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is symmetric, False otherwise.\n    *\n    * Example:\n    * isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\n    * Output: true\n    */\n  def isSymmetric(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }", "test": "def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), new TreeNode(4)\n      ),\n      new TreeNode(2,\n        new TreeNode(4), new TreeNode(3)\n      )\n    )\n    assert(isSymmetric(root1))\n\n    // Test Case 2\n    val root2 = new TreeNode(1,\n      new TreeNode(2,\n        null, new TreeNode(3)\n      ),\n      new TreeNode(2,\n        null, new TreeNode(3)\n      )\n    )\n    assert(!isSymmetric(root2))\n\n    // Test Case 3\n    val root3 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), null\n      ),\n      new TreeNode(2,\n        new TreeNode(3), null\n      )\n    )\n    assert(!isSymmetric(root3))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isSymmetric", "signature": "def isSymmetric(root: TreeNode): Boolean =", "docstring": "Check if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true\n\n* Incomplete Code:\ndef isSymmetric(root: TreeNode): Boolean =\n  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n [MASK]false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n [MASK]false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }"}
{"task_id": "Scala/23-0-span", "prompt": "object Solution {\n    /**\n     * Find the smallest positive integer b such that the product of all digits of b is equal to a.\n     *\n     * @param a The given integer.\n     * @return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\n     *         is not a 32-bit signed integer, return 0.\n     *\n     * Example:\n     * findSmallestInteger(48)\n     * Output: 68\n     *\n     * Example:\n     * findSmallestInteger(15)\n     * Output: 35\n     */\n  def findSmallestInteger(a: Int): Int = ", "canonical_solution": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(findSmallestInteger(48) == 68)\n    assert(findSmallestInteger(15) == 35)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findSmallestInteger", "signature": "def findSmallestInteger(a: Int): Int =", "docstring": "Find the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35\n\n* Incomplete Code:\ndef findSmallestInteger(a: Int): Int =\n  {\n\n    def getProductOfDigits(num: Int): Int = {\n      v[MASK]  n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      v[MASK]  n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }"}
{"task_id": "Scala/23-1-span", "prompt": "object Solution {\n    /**\n     * Find the smallest positive integer b such that the product of all digits of b is equal to a.\n     *\n     * @param a The given integer.\n     * @return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\n     *         is not a 32-bit signed integer, return 0.\n     *\n     * Example:\n     * findSmallestInteger(48)\n     * Output: 68\n     *\n     * Example:\n     * findSmallestInteger(15)\n     * Output: 35\n     */\n  def findSmallestInteger(a: Int): Int = ", "canonical_solution": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(findSmallestInteger(48) == 68)\n    assert(findSmallestInteger(15) == 35)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findSmallestInteger", "signature": "def findSmallestInteger(a: Int): Int =", "docstring": "Find the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nFind the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35\n\n* Incomplete Code:\ndef findSmallestInteger(a: Int): Int =\n  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val[MASK]lue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val[MASK]lue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }"}
{"task_id": "Scala/24-0-span", "prompt": "object Solution {\n    /**\n     * Calculate the sum of the digits in a number with assigned signs.\n     *\n     * @param n The input number.\n     * @return The sum of the digits with assigned signs.\n     *\n     * Example:\n     * signSum(521)\n     * Output: 4\n     */\n  def signSum(n: Int): Int = ", "canonical_solution": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(signSum(123) == 6)\n    assert(signSum(-456) == -15)\n    assert(signSum(789) == 24)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "signSum", "signature": "def signSum(n: Int): Int =", "docstring": "Calculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4\n\n* Incomplete Code:\ndef signSum(n: Int): Int =\n  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    [MASK]hile (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    [MASK]hile (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }"}
{"task_id": "Scala/24-1-span", "prompt": "object Solution {\n    /**\n     * Calculate the sum of the digits in a number with assigned signs.\n     *\n     * @param n The input number.\n     * @return The sum of the digits with assigned signs.\n     *\n     * Example:\n     * signSum(521)\n     * Output: 4\n     */\n  def signSum(n: Int): Int = ", "canonical_solution": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(signSum(123) == 6)\n    assert(signSum(-456) == -15)\n    assert(signSum(789) == 24)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "signSum", "signature": "def signSum(n: Int): Int =", "docstring": "Calculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4\n\n* Incomplete Code:\ndef signSum(n: Int): Int =\n  {\n\n    val sign = if[MASK] while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val sign = if[MASK] while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }"}
{"task_id": "Scala/25-0-span", "prompt": "\nobject Solution {\n    /**\n    * Returns the elements of the matrix in clockwise spiral order.\n    *\n    * @param matrix The input matrix.\n    * @return The elements of the matrix in spiral order.\n    *\n    * Example:\n    * spiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\n    * Output: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n    */\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = ", "canonical_solution": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val matrix1 = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))\n    val result1 = spiralOrder(matrix1)\n    assert(result1 == List(1, 2, 3, 6, 9, 8, 7, 4, 5))\n\n    val matrix2 = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12))\n    val result2 = spiralOrder(matrix2)\n    assert(result2 == List(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7))\n\n    val matrix3 = Array(Array(1, 2, 3, 4, 5), Array(6, 7, 8, 9, 10), Array(11, 12, 13, 14, 15))\n    val result3 = spiralOrder(matrix3)\n    assert(result3 == List(1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "spiralOrder", "signature": "def spiralOrder(matrix: Array[Array[Int]]): List[Int] =", "docstring": "Returns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n\n* Incomplete Code:\ndef spiralOrder(matrix: Array[Array[Int]]): List[Int] =\n  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = m[MASK]p)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = m[MASK]p)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/25-1-span", "prompt": "\nobject Solution {\n    /**\n    * Returns the elements of the matrix in clockwise spiral order.\n    *\n    * @param matrix The input matrix.\n    * @return The elements of the matrix in spiral order.\n    *\n    * Example:\n    * spiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\n    * Output: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n    */\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = ", "canonical_solution": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val matrix1 = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))\n    val result1 = spiralOrder(matrix1)\n    assert(result1 == List(1, 2, 3, 6, 9, 8, 7, 4, 5))\n\n    val matrix2 = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12))\n    val result2 = spiralOrder(matrix2)\n    assert(result2 == List(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7))\n\n    val matrix3 = Array(Array(1, 2, 3, 4, 5), Array(6, 7, 8, 9, 10), Array(11, 12, 13, 14, 15))\n    val result3 = spiralOrder(matrix3)\n    assert(result3 == List(1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "spiralOrder", "signature": "def spiralOrder(matrix: Array[Array[Int]]): List[Int] =", "docstring": "Returns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n\n* Incomplete Code:\ndef spiralOrder(matrix: Array[Array[Int]]): List[Int] =\n  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length[MASK]     top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length[MASK]     top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }"}
{"task_id": "Scala/26-0-span", "prompt": "class TreeNode(var value: Int, var left: TreeNode = null, var right: TreeNode = null)\nobject Solution {\n  /**\n    * Determine if a given binary tree is a univalued tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a univalued tree, False otherwise.\n    *\n    * Example:\n    * isUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\n    * Output: true\n    *\n    * isUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\n    * Output: false\n    */\n  def isUnivalTree(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val tree1 = new TreeNode(2)\n    tree1.left = new TreeNode(2)\n    tree1.left.left = new TreeNode(2)\n    tree1.left.left.left = new TreeNode(5)\n    tree1.left.left.right = new TreeNode(2)\n    assert(!isUnivalTree(tree1))  // Output: false\n\n    // Test Case 2\n    val tree2 = new TreeNode(1)\n    tree2.left = new TreeNode(1)\n    tree2.left.left = new TreeNode(1)\n    tree2.left.right = new TreeNode(1)\n    tree2.right = new TreeNode(1)\n    tree2.right.right = new TreeNode(1)\n    assert(isUnivalTree(tree2))  // Output: true\n\n    // Test Case 3\n    val tree3 = new TreeNode(3)\n    tree3.left = new TreeNode(3)\n    tree3.right = new TreeNode(3)\n    assert(isUnivalTree(tree3))  // Output: true\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "isUnivalTree", "signature": "def isUnivalTree(root: TreeNode): Boolean =", "docstring": "Determine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false\n\n* Incomplete Code:\ndef isUnivalTree(root: TreeNode): Boolean =\n  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      tru[MASK]     false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      tru[MASK]     false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }"}
{"task_id": "Scala/26-1-span", "prompt": "class TreeNode(var value: Int, var left: TreeNode = null, var right: TreeNode = null)\nobject Solution {\n  /**\n    * Determine if a given binary tree is a univalued tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a univalued tree, False otherwise.\n    *\n    * Example:\n    * isUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\n    * Output: true\n    *\n    * isUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\n    * Output: false\n    */\n  def isUnivalTree(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val tree1 = new TreeNode(2)\n    tree1.left = new TreeNode(2)\n    tree1.left.left = new TreeNode(2)\n    tree1.left.left.left = new TreeNode(5)\n    tree1.left.left.right = new TreeNode(2)\n    assert(!isUnivalTree(tree1))  // Output: false\n\n    // Test Case 2\n    val tree2 = new TreeNode(1)\n    tree2.left = new TreeNode(1)\n    tree2.left.left = new TreeNode(1)\n    tree2.left.right = new TreeNode(1)\n    tree2.right = new TreeNode(1)\n    tree2.right.right = new TreeNode(1)\n    assert(isUnivalTree(tree2))  // Output: true\n\n    // Test Case 3\n    val tree3 = new TreeNode(3)\n    tree3.left = new TreeNode(3)\n    tree3.right = new TreeNode(3)\n    assert(isUnivalTree(tree3))  // Output: true\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "isUnivalTree", "signature": "def isUnivalTree(root: TreeNode): Boolean =", "docstring": "Determine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nDetermine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false\n\n* Incomplete Code:\ndef isUnivalTree(root: TreeNode): Boolean =\n  {\n\n    if (root == null) {\n [MASK]= {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (root == null) {\n [MASK]= {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }"}
{"task_id": "Scala/27-0-span", "prompt": "object Solution {\n    /**\n     * Remove the trailing zeros from a given integer represented as a string.\n     *\n     * @param num The string representation of the integer.\n     * @return The integer with trailing zeros removed represented as a string.\n     *\n     * Example:\n     * removeTrailingZeros(\"51230100\")\n     * Output: \"512301\"\n     *\n     * removeTrailingZeros(\"123\")\n     * Output: \"123\"\n     */\n  def removeTrailingZeros(num: String): String = ", "canonical_solution": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(removeTrailingZeros(\"51230100\") == \"512301\")\n    assert(removeTrailingZeros(\"123\") == \"123\")\n    assert(removeTrailingZeros(\"1000010\") == \"100001\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeTrailingZeros", "signature": "def removeTrailingZeros(num: String): String =", "docstring": "Remove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"\n\n* Incomplete Code:\ndef removeTrailingZeros(num: String): String =\n  {\n\n    var index = nu[MASK]  index -= 1\n    }\n    num.substring(0, index + 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var index = nu[MASK]  index -= 1\n    }\n    num.substring(0, index + 1)\n  }"}
{"task_id": "Scala/27-1-span", "prompt": "object Solution {\n    /**\n     * Remove the trailing zeros from a given integer represented as a string.\n     *\n     * @param num The string representation of the integer.\n     * @return The integer with trailing zeros removed represented as a string.\n     *\n     * Example:\n     * removeTrailingZeros(\"51230100\")\n     * Output: \"512301\"\n     *\n     * removeTrailingZeros(\"123\")\n     * Output: \"123\"\n     */\n  def removeTrailingZeros(num: String): String = ", "canonical_solution": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(removeTrailingZeros(\"51230100\") == \"512301\")\n    assert(removeTrailingZeros(\"123\") == \"123\")\n    assert(removeTrailingZeros(\"1000010\") == \"100001\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeTrailingZeros", "signature": "def removeTrailingZeros(num: String): String =", "docstring": "Remove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"\n\n* Incomplete Code:\ndef removeTrailingZeros(num: String): String =\n  {\n\n    var index = [MASK] 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    var index = [MASK] 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }"}
{"task_id": "Scala/28-0-span", "prompt": "object Solution {\n  /**\n    * Check if the binary string contains at most one segment of consecutive '1's.\n    *\n    * @param s The input binary string.\n    * @return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n    *\n    * Example:\n    * checkOnesSegment(\"1001\")\n    * Output: false\n    *\n    * Example:\n    * checkOnesSegment(\"110\")\n    * Output: true\n    */\n  def checkOnesSegment(s: String): Boolean = ", "canonical_solution": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(checkOnesSegment(\"10101\") == true)\n    assert(checkOnesSegment(\"111000\") == false)\n    assert(checkOnesSegment(\"100111000\") == false)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "checkOnesSegment", "signature": "def checkOnesSegment(s: String): Boolean =", "docstring": "Check if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true\n\n* Incomplete Code:\ndef checkOnesSegment(s: String): Boolean =\n  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (cou[MASK]0\n      }\n    }\n    true\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (cou[MASK]0\n      }\n    }\n    true\n  }"}
{"task_id": "Scala/28-1-span", "prompt": "object Solution {\n  /**\n    * Check if the binary string contains at most one segment of consecutive '1's.\n    *\n    * @param s The input binary string.\n    * @return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n    *\n    * Example:\n    * checkOnesSegment(\"1001\")\n    * Output: false\n    *\n    * Example:\n    * checkOnesSegment(\"110\")\n    * Output: true\n    */\n  def checkOnesSegment(s: String): Boolean = ", "canonical_solution": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(checkOnesSegment(\"10101\") == true)\n    assert(checkOnesSegment(\"111000\") == false)\n    assert(checkOnesSegment(\"100111000\") == false)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "checkOnesSegment", "signature": "def checkOnesSegment(s: String): Boolean =", "docstring": "Check if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true\n\n* Incomplete Code:\ndef checkOnesSegment(s: String): Boolean =\n  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n     [MASK]e\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n     [MASK]e\n  }"}
{"task_id": "Scala/29-0-span", "prompt": "object Solution {\n/**\n * Computes the minimum cost of merging N piles of sand into one pile. \n * The cost of merging two adjacent piles is the sum of their sizes. \n * The function aims to find a merge strategy that minimizes the total cost.\n *\n * @param sandPiles An array of integers representing the sizes of each sand pile.\n * @return The minimum total cost of merging all piles into one.\n *\n * Example:\n * minMergeCost(Array(1, 3, 5, 2))\n * Output: 22\n * \n * Explanation:\n * Merging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9), \n * and finally merging the last two piles (cost = 11), results in a total cost of 22.\n */\n\ndef minMergeCost(sandPiles: Array[Int]): Int = ", "canonical_solution": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}", "test": "  def main(args: Array[String]): Unit = {\n    assert(minMergeCost(Array(1, 3, 5, 2)) == 22)\n    assert(minMergeCost(Array(4, 3, 3)) == 16)\n    assert(minMergeCost(Array(10, 20, 30)) == 90)\n    assert(minMergeCost(Array(3, 4, 3, 9, 6, 7, 8, 10 )) == 147)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minMergeCost", "signature": "def minMergeCost(sandPiles: Array[Int]): Int =", "docstring": "Computes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nComputes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.\n\n* Incomplete Code:\ndef minMergeCost(sandPiles: Array[Int]): Int =\n{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(le[MASK]0)(n - 1)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(le[MASK]0)(n - 1)\n}"}
{"task_id": "Scala/29-1-span", "prompt": "object Solution {\n/**\n * Computes the minimum cost of merging N piles of sand into one pile. \n * The cost of merging two adjacent piles is the sum of their sizes. \n * The function aims to find a merge strategy that minimizes the total cost.\n *\n * @param sandPiles An array of integers representing the sizes of each sand pile.\n * @return The minimum total cost of merging all piles into one.\n *\n * Example:\n * minMergeCost(Array(1, 3, 5, 2))\n * Output: 22\n * \n * Explanation:\n * Merging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9), \n * and finally merging the last two piles (cost = 11), results in a total cost of 22.\n */\n\ndef minMergeCost(sandPiles: Array[Int]): Int = ", "canonical_solution": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}", "test": "  def main(args: Array[String]): Unit = {\n    assert(minMergeCost(Array(1, 3, 5, 2)) == 22)\n    assert(minMergeCost(Array(4, 3, 3)) == 16)\n    assert(minMergeCost(Array(10, 20, 30)) == 90)\n    assert(minMergeCost(Array(3, 4, 3, 9, 6, 7, 8, 10 )) == 147)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minMergeCost", "signature": "def minMergeCost(sandPiles: Array[Int]): Int =", "docstring": "Computes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nComputes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.\n\n* Incomplete Code:\ndef minMergeCost(sandPiles: Array[Int]): Int =\n{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  fo[MASK]1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  fo[MASK]1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}"}
{"task_id": "Scala/30-0-span", "prompt": "/**\n * Sorts an array of names in alphabetical order.\n * This function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\n * It is assumed that each name is a non-empty string consisting of alphabetic characters.\n *\n * Example:\n * >>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\n * Array(\"Apple\", \"Green\", \"Jack\", \"Tom\")\n */\n object Solution {\n def sortNames(names: Array[String]): Array[String] = ", "canonical_solution": " {\n  names.sorted\n}", "test": "  def main(args: Array[String]): Unit = {\n    val names = Array(\"Apple\", \"Tom\", \"Green\", \"Jack\")\n    val sortedNames = sortNames(names)\n    assert(sortedNames.sameElements(Array(\"Apple\", \"Green\", \"Jack\", \"Tom\")))\n\n    val moreNames = Array(\"Banana\", \"Zebra\", \"Elephant\", \"Crocodile\")\n    val sortedMoreNames = sortNames(moreNames)\n    assert(sortedMoreNames.sameElements(Array(\"Banana\", \"Crocodile\", \"Elephant\", \"Zebra\")))\n }\n }", "entry_point": "sortNames", "signature": "def sortNames(names: Array[String]): Array[String] =", "docstring": "Sorts an array of names in alphabetical order.\nThis function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\nIt is assumed that each name is a non-empty string consisting of alphabetic characters.\n\nExample:\n>>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\nArray(\"Apple\", \"Green\", \"Jack\", \"Tom\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSorts an array of names in alphabetical order.\nThis function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\nIt is assumed that each name is a non-empty string consisting of alphabetic characters.\n\nExample:\n>>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\nArray(\"Apple\", \"Green\", \"Jack\", \"Tom\")\n\n* Incomplete Code:\ndef sortNames(names: Array[String]): Array[String] =\n {\n  n[MASK]sorted\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  n[MASK]sorted\n}"}
{"task_id": "Scala/30-1-span", "prompt": "/**\n * Sorts an array of names in alphabetical order.\n * This function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\n * It is assumed that each name is a non-empty string consisting of alphabetic characters.\n *\n * Example:\n * >>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\n * Array(\"Apple\", \"Green\", \"Jack\", \"Tom\")\n */\n object Solution {\n def sortNames(names: Array[String]): Array[String] = ", "canonical_solution": " {\n  names.sorted\n}", "test": "  def main(args: Array[String]): Unit = {\n    val names = Array(\"Apple\", \"Tom\", \"Green\", \"Jack\")\n    val sortedNames = sortNames(names)\n    assert(sortedNames.sameElements(Array(\"Apple\", \"Green\", \"Jack\", \"Tom\")))\n\n    val moreNames = Array(\"Banana\", \"Zebra\", \"Elephant\", \"Crocodile\")\n    val sortedMoreNames = sortNames(moreNames)\n    assert(sortedMoreNames.sameElements(Array(\"Banana\", \"Crocodile\", \"Elephant\", \"Zebra\")))\n }\n }", "entry_point": "sortNames", "signature": "def sortNames(names: Array[String]): Array[String] =", "docstring": "Sorts an array of names in alphabetical order.\nThis function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\nIt is assumed that each name is a non-empty string consisting of alphabetic characters.\n\nExample:\n>>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\nArray(\"Apple\", \"Green\", \"Jack\", \"Tom\")", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSorts an array of names in alphabetical order.\nThis function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\nIt is assumed that each name is a non-empty string consisting of alphabetic characters.\n\nExample:\n>>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\nArray(\"Apple\", \"Green\", \"Jack\", \"Tom\")\n\n* Incomplete Code:\ndef sortNames(names: Array[String]): Array[String] =\n {\n  name[MASK]ted\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": " {\n  name[MASK]ted\n}"}
{"task_id": "Scala/31-0-span", "prompt": "\nobject Solution {\n  /**\n  * Reverse the given string based on the following rules:\n  * - Keep all non-alphabetic characters in their original positions.\n  * - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  *\n  * @param s The input string.\n  * @return The reversed string.\n  *\n  * Example:\n  * reverseString(\"ab-cd\")\n  * Output: \"dc-ba\"\n  */\n  def reverseString(s: String): String = ", "canonical_solution": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"ab-cd\") == \"dc-ba\")\n    assert(reverseString(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String): String =", "docstring": "Reverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"\n\n* Incomplete Code:\ndef reverseString(s: String): String =\n  {\n \n    val stack = s.filter(_.isLetter).reverse\n   [MASK].map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n   [MASK].map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }"}
{"task_id": "Scala/31-1-span", "prompt": "\nobject Solution {\n  /**\n  * Reverse the given string based on the following rules:\n  * - Keep all non-alphabetic characters in their original positions.\n  * - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  *\n  * @param s The input string.\n  * @return The reversed string.\n  *\n  * Example:\n  * reverseString(\"ab-cd\")\n  * Output: \"dc-ba\"\n  */\n  def reverseString(s: String): String = ", "canonical_solution": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"ab-cd\") == \"dc-ba\")\n    assert(reverseString(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String): String =", "docstring": "Reverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"\n\n* Incomplete Code:\ndef reverseString(s: String): String =\n  {\n \n    val stack = s.f[MASK]l res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n \n    val stack = s.f[MASK]l res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }"}
{"task_id": "Scala/32-0-span", "prompt": "object Solution {\n    /**\n       * Calculate the maximum number of consecutive 1s in a binary array.\n       *\n       * @param nums The binary array.\n       * @return The maximum number of consecutive 1s.\n       *\n       * Example:\n       * findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\n       * Output: 3\n       */\n  def findMaxConsecutiveOnes(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    //test case 1\n    assert(findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1, 0, 0, 1, 1)) == 3)\n    \n    //test case 2\n    assert(findMaxConsecutiveOnes(Array(0, 0, 0)) == 0)\n    \n    //test case 3\n    assert(findMaxConsecutiveOnes(Array(1, 1, 1, 1, 1)) == 5)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findMaxConsecutiveOnes", "signature": "def findMaxConsecutiveOnes(nums: Array[Int]): Int =", "docstring": "Calculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3\n\n* Incomplete Code:\ndef findMaxConsecutiveOnes(nums: Array[Int]): Int =\n  {\n\n       var maxConsecutiveOnes = 0\n      var c[MASK]secutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var maxConsecutiveOnes = 0\n      var c[MASK]secutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n"}
{"task_id": "Scala/32-1-span", "prompt": "object Solution {\n    /**\n       * Calculate the maximum number of consecutive 1s in a binary array.\n       *\n       * @param nums The binary array.\n       * @return The maximum number of consecutive 1s.\n       *\n       * Example:\n       * findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\n       * Output: 3\n       */\n  def findMaxConsecutiveOnes(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    //test case 1\n    assert(findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1, 0, 0, 1, 1)) == 3)\n    \n    //test case 2\n    assert(findMaxConsecutiveOnes(Array(0, 0, 0)) == 0)\n    \n    //test case 3\n    assert(findMaxConsecutiveOnes(Array(1, 1, 1, 1, 1)) == 5)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findMaxConsecutiveOnes", "signature": "def findMaxConsecutiveOnes(nums: Array[Int]): Int =", "docstring": "Calculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3\n\n* Incomplete Code:\ndef findMaxConsecutiveOnes(nums: Array[Int]): Int =\n  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n        [MASK]currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n        [MASK]currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n"}
{"task_id": "Scala/33-0-span", "prompt": "object Solution {\n  /**\n     * Rearrange the numbers in the array to form the largest possible integer.\n     *\n     * @param nums An array of non-negative integers.\n     * @return The largest possible integer formed by rearranging the numbers.\n     *\n     * Example:\n     * largestNumber(Array(10, 2))\n     * Output: \"210\"\n     *\n     * largestNumber(Array(3, 30, 34, 5, 9))\n     * Output: \"9534330\"\n     */\n  def largestNumber(nums: Array[Int]): String = ", "canonical_solution": "  {\n    // Convert the integers to strings for comparison\n    val strNums = nums.map(_.toString)\n    // Define a custom sort function that compares two strings by concatenating them in different orders\n    val sortedNums = strNums.sortWith((a, b) => (a + b) > (b + a))\n    // Combine the sorted strings. If the highest number is '0', return '0' (to avoid leading zeros)\n    if (sortedNums.head == \"0\") \"0\" else sortedNums.mkString(\"\")\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(largestNumber(Array(10, 2)) == \"210\")\n    assert(largestNumber(Array(3, 30, 34, 5, 9)) == \"9534330\")\n    // additional test cases \n    assert(largestNumber(Array(1, 34, 3, 98, 9, 76, 45, 4)) == \"998764543431\")\n    assert(largestNumber(Array(54, 546, 548, 60)) == \"6054854654\")\n    assert(largestNumber(Array(1, 34, 3, 98, 34, 3, 667, 66)) == \"98667663434331\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "largestNumber", "signature": "def largestNumber(nums: Array[Int]): String =", "docstring": "Rearrange the numbers in the array to form the largest possible integer.\n\n@param nums An array of non-negative integers.\n@return The largest possible integer formed by rearranging the numbers.\n\nExample:\nlargestNumber(Array(10, 2))\nOutput: \"210\"\n\nlargestNumber(Array(3, 30, 34, 5, 9))\nOutput: \"9534330\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRearrange the numbers in the array to form the largest possible integer.\n\n@param nums An array of non-negative integers.\n@return The largest possible integer formed by rearranging the numbers.\n\nExample:\nlargestNumber(Array(10, 2))\nOutput: \"210\"\n\nlargestNumber(Array(3, 30, 34, 5, 9))\nOutput: \"9534330\"\n\n* Incomplete Code:\ndef largestNumber(nums: Array[Int]): String =\n  {\n    // Convert the integers to strings for comparison\n   [MASK]nums.map(_.toString)\n    // Define a custom sort function that compares two strings by concatenating them in different orders\n    val sortedNums = strNums.sortWith((a, b) => (a + b) > (b + a))\n    // Combine the sorted strings. If the highest number is '0', return '0' (to avoid leading zeros)\n    if (sortedNums.head == \"0\") \"0\" else sortedNums.mkString(\"\")\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    // Convert the integers to strings for comparison\n   [MASK]nums.map(_.toString)\n    // Define a custom sort function that compares two strings by concatenating them in different orders\n    val sortedNums = strNums.sortWith((a, b) => (a + b) > (b + a))\n    // Combine the sorted strings. If the highest number is '0', return '0' (to avoid leading zeros)\n    if (sortedNums.head == \"0\") \"0\" else sortedNums.mkString(\"\")\n  }"}
{"task_id": "Scala/33-1-span", "prompt": "object Solution {\n  /**\n     * Rearrange the numbers in the array to form the largest possible integer.\n     *\n     * @param nums An array of non-negative integers.\n     * @return The largest possible integer formed by rearranging the numbers.\n     *\n     * Example:\n     * largestNumber(Array(10, 2))\n     * Output: \"210\"\n     *\n     * largestNumber(Array(3, 30, 34, 5, 9))\n     * Output: \"9534330\"\n     */\n  def largestNumber(nums: Array[Int]): String = ", "canonical_solution": "  {\n    // Convert the integers to strings for comparison\n    val strNums = nums.map(_.toString)\n    // Define a custom sort function that compares two strings by concatenating them in different orders\n    val sortedNums = strNums.sortWith((a, b) => (a + b) > (b + a))\n    // Combine the sorted strings. If the highest number is '0', return '0' (to avoid leading zeros)\n    if (sortedNums.head == \"0\") \"0\" else sortedNums.mkString(\"\")\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(largestNumber(Array(10, 2)) == \"210\")\n    assert(largestNumber(Array(3, 30, 34, 5, 9)) == \"9534330\")\n    // additional test cases \n    assert(largestNumber(Array(1, 34, 3, 98, 9, 76, 45, 4)) == \"998764543431\")\n    assert(largestNumber(Array(54, 546, 548, 60)) == \"6054854654\")\n    assert(largestNumber(Array(1, 34, 3, 98, 34, 3, 667, 66)) == \"98667663434331\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "largestNumber", "signature": "def largestNumber(nums: Array[Int]): String =", "docstring": "Rearrange the numbers in the array to form the largest possible integer.\n\n@param nums An array of non-negative integers.\n@return The largest possible integer formed by rearranging the numbers.\n\nExample:\nlargestNumber(Array(10, 2))\nOutput: \"210\"\n\nlargestNumber(Array(3, 30, 34, 5, 9))\nOutput: \"9534330\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRearrange the numbers in the array to form the largest possible integer.\n\n@param nums An array of non-negative integers.\n@return The largest possible integer formed by rearranging the numbers.\n\nExample:\nlargestNumber(Array(10, 2))\nOutput: \"210\"\n\nlargestNumber(Array(3, 30, 34, 5, 9))\nOutput: \"9534330\"\n\n* Incomplete Code:\ndef largestNumber(nums: Array[Int]): String =\n  {\n    // Convert the integers to strings for comparison\n  [MASK] nums.map(_.toString)\n    // Define a custom sort function that compares two strings by concatenating them in different orders\n    val sortedNums = strNums.sortWith((a, b) => (a + b) > (b + a))\n    // Combine the sorted strings. If the highest number is '0', return '0' (to avoid leading zeros)\n    if (sortedNums.head == \"0\") \"0\" else sortedNums.mkString(\"\")\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    // Convert the integers to strings for comparison\n  [MASK] nums.map(_.toString)\n    // Define a custom sort function that compares two strings by concatenating them in different orders\n    val sortedNums = strNums.sortWith((a, b) => (a + b) > (b + a))\n    // Combine the sorted strings. If the highest number is '0', return '0' (to avoid leading zeros)\n    if (sortedNums.head == \"0\") \"0\" else sortedNums.mkString(\"\")\n  }"}
{"task_id": "Scala/34-0-span", "prompt": "\nobject Solution {\n    /**\n       * Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n       *\n       * @param nums An array of integers.\n       * @return None (In-place modification of the input array).\n       *\n       * Example:\n       * moveZeroes(Array(0, 1, 0, 3, 12))\n       * Output: Array(1, 3, 12, 0, 0)\n       */\n  def moveZeroes(nums: Array[Int]): Unit = ", "canonical_solution": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(1,0,2,0,3)\n    Solution.moveZeroes(nums1)\n    assert(nums1 sameElements Array(1,2,3,0,0))\n\n    val nums2 = Array(0,0,0,1,2)\n    Solution.moveZeroes(nums2)\n    assert(nums2 sameElements Array(1,2,0,0,0))\n\n    val nums3 = Array(1,2,3,0,0)\n    Solution.moveZeroes(nums3)\n    assert(nums3 sameElements Array(1,2,3,0,0))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveZeroes", "signature": "def moveZeroes(nums: Array[Int]): Unit =", "docstring": "Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)\n\n* Incomplete Code:\ndef moveZeroes(nums: Array[Int]): Unit =\n  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n   [MASK]= 0\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n   [MASK]= 0\n        }\n    }"}
{"task_id": "Scala/34-1-span", "prompt": "\nobject Solution {\n    /**\n       * Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n       *\n       * @param nums An array of integers.\n       * @return None (In-place modification of the input array).\n       *\n       * Example:\n       * moveZeroes(Array(0, 1, 0, 3, 12))\n       * Output: Array(1, 3, 12, 0, 0)\n       */\n  def moveZeroes(nums: Array[Int]): Unit = ", "canonical_solution": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(1,0,2,0,3)\n    Solution.moveZeroes(nums1)\n    assert(nums1 sameElements Array(1,2,3,0,0))\n\n    val nums2 = Array(0,0,0,1,2)\n    Solution.moveZeroes(nums2)\n    assert(nums2 sameElements Array(1,2,0,0,0))\n\n    val nums3 = Array(1,2,3,0,0)\n    Solution.moveZeroes(nums3)\n    assert(nums3 sameElements Array(1,2,3,0,0))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveZeroes", "signature": "def moveZeroes(nums: Array[Int]): Unit =", "docstring": "Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)\n\n* Incomplete Code:\ndef moveZeroes(nums: Array[Int]): Unit =\n  {\n\n       var position = [MASK] (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var position = [MASK] (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }"}
{"task_id": "Scala/35-0-span", "prompt": "object Solution {\n  /**\n    * Check if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n    *\n    * @param s The binary string.\n    * @param n The positive integer.\n    * @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n    *\n    * Example:\n    * queryString(\"0110\", 3)\n    * Output: true\n    */\n  def queryString(s: String, n: Int): Boolean = ", "canonical_solution": "  {\n\n       (1 to n).forall(i => s.contains(i.toBinaryString))\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(queryString(\"0110\", 3))\n    assert(!queryString(\"0110\", 4))\n    assert(queryString(\"1111000101\", 5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "queryString", "signature": "def queryString(s: String, n: Int): Boolean =", "docstring": "Check if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n\n @param s The binary string.\n @param n The positive integer.\n @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n\n Example:\n queryString(\"0110\", 3)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n\n @param s The binary string.\n @param n The positive integer.\n @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n\n Example:\n queryString(\"0110\", 3)\n Output: true\n\n* Incomplete Code:\ndef queryString(s: String, n: Int): Boolean =\n  {\n\n  [MASK] => s.contains(i.toBinaryString))\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n  [MASK] => s.contains(i.toBinaryString))\n  }"}
{"task_id": "Scala/35-1-span", "prompt": "object Solution {\n  /**\n    * Check if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n    *\n    * @param s The binary string.\n    * @param n The positive integer.\n    * @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n    *\n    * Example:\n    * queryString(\"0110\", 3)\n    * Output: true\n    */\n  def queryString(s: String, n: Int): Boolean = ", "canonical_solution": "  {\n\n       (1 to n).forall(i => s.contains(i.toBinaryString))\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(queryString(\"0110\", 3))\n    assert(!queryString(\"0110\", 4))\n    assert(queryString(\"1111000101\", 5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "queryString", "signature": "def queryString(s: String, n: Int): Boolean =", "docstring": "Check if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n\n @param s The binary string.\n @param n The positive integer.\n @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n\n Example:\n queryString(\"0110\", 3)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n\n @param s The binary string.\n @param n The positive integer.\n @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n\n Example:\n queryString(\"0110\", 3)\n Output: true\n\n* Incomplete Code:\ndef queryString(s: String, n: Int): Boolean =\n  {\n\n       (1 to n).fo[MASK].toBinaryString))\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       (1 to n).fo[MASK].toBinaryString))\n  }"}
{"task_id": "Scala/36-0-span", "prompt": "\nobject Solution {\n      /**\n       * Count the number of palindrome substrings in a given string.\n       *\n       * @param s The input string.\n       * @return The number of palindrome substrings.\n       *\n       * Example:\n       * countPalindromeSubstrings(\"abc\")\n       * Output: 3\n       *\n       * Example:\n       * countPalindromeSubstrings(\"aaa\")\n       * Output: 6\n       */\n  def countPalindromeSubstrings(s: String): Int = ", "canonical_solution": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countPalindromeSubstrings(\"abc\") == 3)\n    assert(countPalindromeSubstrings(\"aaa\") == 6)\n    assert(countPalindromeSubstrings(\"abba\") == 6)\n    assert(countPalindromeSubstrings(\"abcd\") == 4)\n    assert(countPalindromeSubstrings(\"aabbccd\") == 10)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPalindromeSubstrings", "signature": "def countPalindromeSubstrings(s: String): Int =", "docstring": "Count the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6\n\n* Incomplete Code:\ndef countPalindromeSubstrings(s: String): Int =\n  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += c[MASK]unt += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += c[MASK]unt += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }"}
{"task_id": "Scala/36-1-span", "prompt": "\nobject Solution {\n      /**\n       * Count the number of palindrome substrings in a given string.\n       *\n       * @param s The input string.\n       * @return The number of palindrome substrings.\n       *\n       * Example:\n       * countPalindromeSubstrings(\"abc\")\n       * Output: 3\n       *\n       * Example:\n       * countPalindromeSubstrings(\"aaa\")\n       * Output: 6\n       */\n  def countPalindromeSubstrings(s: String): Int = ", "canonical_solution": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countPalindromeSubstrings(\"abc\") == 3)\n    assert(countPalindromeSubstrings(\"aaa\") == 6)\n    assert(countPalindromeSubstrings(\"abba\") == 6)\n    assert(countPalindromeSubstrings(\"abcd\") == 4)\n    assert(countPalindromeSubstrings(\"aabbccd\") == 10)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPalindromeSubstrings", "signature": "def countPalindromeSubstrings(s: String): Int =", "docstring": "Count the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6\n\n* Incomplete Code:\ndef countPalindromeSubstrings(s: String): Int =\n  {\n\n       var count = 0\n      for(i <- 0 until[MASK]private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var count = 0\n      for(i <- 0 until[MASK]private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }"}
{"task_id": "Scala/37-0-span", "prompt": "object Solution {\n  case class ListNode(var value: Int, var next: ListNode = null)\n  /**\n    * Remove the nth node from the end of a linked list and return the head of the modified list.\n    *\n    * @param head The head of the linked list.\n    * @param n The position of the node to be removed from the end of the list.\n    * @return The head of the modified list.\n    *\n    * Example:\n    * removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n    * Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n    */\n  def removeNthFromEnd(head: ListNode, n: Int): ListNode = ", "canonical_solution": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }", "test": "  def main(args: Array[String]): Unit = {\n  // Test cases\n  val test1 = createList(Array(1, 2, 3, 4, 5))\n  assert(listToString(removeNthFromEnd(test1, 2)) == \"1->2->3->5\")\n\n  val test2 = createList(Array(1))\n  assert(listToString(removeNthFromEnd(test2, 1)) == \"\")\n\n  val test3 = createList(Array(1, 2))\n  assert(listToString(removeNthFromEnd(test3, 1)) == \"1\")\n\n  println(\"All tests passed\")}\n}", "entry_point": "removeNthFromEnd", "signature": "def removeNthFromEnd(head: ListNode, n: Int): ListNode =", "docstring": "Remove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n\n* Incomplete Code:\ndef removeNthFromEnd(head: ListNode, n: Int): ListNode =\n  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node[MASK]nt.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node[MASK]nt.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }"}
{"task_id": "Scala/37-1-span", "prompt": "object Solution {\n  case class ListNode(var value: Int, var next: ListNode = null)\n  /**\n    * Remove the nth node from the end of a linked list and return the head of the modified list.\n    *\n    * @param head The head of the linked list.\n    * @param n The position of the node to be removed from the end of the list.\n    * @return The head of the modified list.\n    *\n    * Example:\n    * removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n    * Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n    */\n  def removeNthFromEnd(head: ListNode, n: Int): ListNode = ", "canonical_solution": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }", "test": "  def main(args: Array[String]): Unit = {\n  // Test cases\n  val test1 = createList(Array(1, 2, 3, 4, 5))\n  assert(listToString(removeNthFromEnd(test1, 2)) == \"1->2->3->5\")\n\n  val test2 = createList(Array(1))\n  assert(listToString(removeNthFromEnd(test2, 1)) == \"\")\n\n  val test3 = createList(Array(1, 2))\n  assert(listToString(removeNthFromEnd(test3, 1)) == \"1\")\n\n  println(\"All tests passed\")}\n}", "entry_point": "removeNthFromEnd", "signature": "def removeNthFromEnd(head: ListNode, n: Int): ListNode =", "docstring": "Remove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nRemove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n\n* Incomplete Code:\ndef removeNthFromEnd(head: ListNode, n: Int): ListNode =\n  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null[MASK]e)\n      current = current.next\n    }\n    dummy.next\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null[MASK]e)\n      current = current.next\n    }\n    dummy.next\n  }"}
{"task_id": "Scala/38-0-span", "prompt": "\nobject Solution {\n/**\n  * Count the number of integers with unique digits from 0 to 10^n.\n  *\n  * @param n The number of digits.\n  * @return The count of integers with unique digits.\n  *\n  * Example:\n  * countNumbersWithUniqueDigits(2)\n  * Output: 91\n  *\n  * Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n  * The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n  *\n  * countNumbersWithUniqueDigits(0)\n  * Output: 1\n  *\n  * Explanation: When n is 0, there is only one number, which is 0 itself.\n  */\n  def countNumbersWithUniqueDigits(n: Int): Int = ", "canonical_solution": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countNumbersWithUniqueDigits(1) == 10, \"Test case 1 failed\")\n    assert(countNumbersWithUniqueDigits(3) == 739, \"Test case 2 failed\")\n    assert(countNumbersWithUniqueDigits(4) == 5275, \"Test case 3 failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countNumbersWithUniqueDigits", "signature": "def countNumbersWithUniqueDigits(n: Int): Int =", "docstring": "Count the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.\n\n* Incomplete Code:\ndef countNumbersWithUniqueDigits(n: Int): Int =\n  {\n\n    if (n == 0) return 1\n    var uniqueDi[MASK]  totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (n == 0) return 1\n    var uniqueDi[MASK]  totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }"}
{"task_id": "Scala/38-1-span", "prompt": "\nobject Solution {\n/**\n  * Count the number of integers with unique digits from 0 to 10^n.\n  *\n  * @param n The number of digits.\n  * @return The count of integers with unique digits.\n  *\n  * Example:\n  * countNumbersWithUniqueDigits(2)\n  * Output: 91\n  *\n  * Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n  * The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n  *\n  * countNumbersWithUniqueDigits(0)\n  * Output: 1\n  *\n  * Explanation: When n is 0, there is only one number, which is 0 itself.\n  */\n  def countNumbersWithUniqueDigits(n: Int): Int = ", "canonical_solution": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countNumbersWithUniqueDigits(1) == 10, \"Test case 1 failed\")\n    assert(countNumbersWithUniqueDigits(3) == 739, \"Test case 2 failed\")\n    assert(countNumbersWithUniqueDigits(4) == 5275, \"Test case 3 failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countNumbersWithUniqueDigits", "signature": "def countNumbersWithUniqueDigits(n: Int): Int =", "docstring": "Count the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.\n\n* Incomplete Code:\ndef countNumbersWithUniqueDigits(n: Int): Int =\n  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbe[MASK]alCount\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbe[MASK]alCount\n  }"}
{"task_id": "Scala/39-0-span", "prompt": "import scala.annotation.tailrec\n\nobject Solution {\n    class ListNode(var x: Int) {\n    var next: ListNode = null\n  }\n    /**\n      * Swap every two adjacent nodes in a linked list and return its head.\n      *\n      * @param head The head node of the linked list.\n      * @return The head node of the linked list after swapping adjacent nodes.\n      *\n      * Example:\n      * swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n      * swapPairs(null) should return null\n      * swapPairs(ListNode(1)) should return ListNode(1)\n      */\n  def swapPairs(head: ListNode): ListNode = ", "canonical_solution": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n", "test": "    def main(args: Array[String]): Unit = {\n    // Test cases\n    val test1 = createList(Array(5, 6, 7, 8))\n    assert(listToString(swapPairs(test1)) == \"6->5->8->7\")\n\n    val test2 = createList(Array())\n    assert(listToString(swapPairs(test2)) == \"\")\n\n    val test3 = createList(Array(9))\n    assert(listToString(swapPairs(test3)) == \"9\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "swapPairs", "signature": "def swapPairs(head: ListNode): ListNode =", "docstring": "Swap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSwap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)\n\n* Incomplete Code:\ndef swapPairs(head: ListNode): ListNode =\n  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n     [MASK]nt = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n     [MASK]nt = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n"}
{"task_id": "Scala/39-1-span", "prompt": "import scala.annotation.tailrec\n\nobject Solution {\n    class ListNode(var x: Int) {\n    var next: ListNode = null\n  }\n    /**\n      * Swap every two adjacent nodes in a linked list and return its head.\n      *\n      * @param head The head node of the linked list.\n      * @return The head node of the linked list after swapping adjacent nodes.\n      *\n      * Example:\n      * swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n      * swapPairs(null) should return null\n      * swapPairs(ListNode(1)) should return ListNode(1)\n      */\n  def swapPairs(head: ListNode): ListNode = ", "canonical_solution": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n", "test": "    def main(args: Array[String]): Unit = {\n    // Test cases\n    val test1 = createList(Array(5, 6, 7, 8))\n    assert(listToString(swapPairs(test1)) == \"6->5->8->7\")\n\n    val test2 = createList(Array())\n    assert(listToString(swapPairs(test2)) == \"\")\n\n    val test3 = createList(Array(9))\n    assert(listToString(swapPairs(test3)) == \"9\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "swapPairs", "signature": "def swapPairs(head: ListNode): ListNode =", "docstring": "Swap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nSwap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)\n\n* Incomplete Code:\ndef swapPairs(head: ListNode): ListNode =\n  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (cu[MASK] = current.next\n    }\n    sb.toString()\n  }\n\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (cu[MASK] = current.next\n    }\n    sb.toString()\n  }\n\n"}
{"task_id": "Scala/40-0-span", "prompt": "import scala.collection.mutable.{Queue, ListBuffer}\n\nclass TreeNode(var _value: Int) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n  /**\n    * Return the level order traversal of a binary tree.\n    *\n    \n    * @param root The root node of the binary tree.\n    * @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n    *\n    * Example:\n    * levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: List(List(3), List(9, 20), List(15, 7))\n    */\n  def levelOrder(root: TreeNode): List[List[Int]] = ", "canonical_solution": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val example1 = new TreeNode(1)\n    example1.left = new TreeNode(2)\n    example1.right = new TreeNode(3)\n\n    assert(levelOrder(example1) == List(List(1), List(2, 3)))\n\n    val example2 = new TreeNode(4)\n    example2.left = new TreeNode(2)\n    example2.right = new TreeNode(6)\n    example2.left.left = new TreeNode(1)\n    example2.left.right = new TreeNode(3)\n    example2.right.left = new TreeNode(5)\n    example2.right.right = new TreeNode(7)\n\n    assert(levelOrder(example2) == List(List(4), List(2, 6), List(1, 3, 5, 7)))\n    \n    val example3 = new TreeNode(8)\n\n    assert(levelOrder(example3) == List(List(8)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "levelOrder", "signature": "def levelOrder(root: TreeNode): List[List[Int]] =", "docstring": "Return the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturn the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))\n\n* Incomplete Code:\ndef levelOrder(root: TreeNode): List[List[Int]] =\n  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val [MASK]:+ level.toList\n    }\n    \n    result\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val [MASK]:+ level.toList\n    }\n    \n    result\n  }\n  "}
{"task_id": "Scala/40-1-span", "prompt": "import scala.collection.mutable.{Queue, ListBuffer}\n\nclass TreeNode(var _value: Int) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n  /**\n    * Return the level order traversal of a binary tree.\n    *\n    \n    * @param root The root node of the binary tree.\n    * @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n    *\n    * Example:\n    * levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: List(List(3), List(9, 20), List(15, 7))\n    */\n  def levelOrder(root: TreeNode): List[List[Int]] = ", "canonical_solution": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val example1 = new TreeNode(1)\n    example1.left = new TreeNode(2)\n    example1.right = new TreeNode(3)\n\n    assert(levelOrder(example1) == List(List(1), List(2, 3)))\n\n    val example2 = new TreeNode(4)\n    example2.left = new TreeNode(2)\n    example2.right = new TreeNode(6)\n    example2.left.left = new TreeNode(1)\n    example2.left.right = new TreeNode(3)\n    example2.right.left = new TreeNode(5)\n    example2.right.right = new TreeNode(7)\n\n    assert(levelOrder(example2) == List(List(4), List(2, 6), List(1, 3, 5, 7)))\n    \n    val example3 = new TreeNode(8)\n\n    assert(levelOrder(example3) == List(List(8)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "levelOrder", "signature": "def levelOrder(root: TreeNode): List[List[Int]] =", "docstring": "Return the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturn the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))\n\n* Incomplete Code:\ndef levelOrder(root: TreeNode): List[List[Int]] =\n  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if ([MASK]toList\n    }\n    \n    result\n  }\n  \n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if ([MASK]toList\n    }\n    \n    result\n  }\n  "}
{"task_id": "Scala/41-0-span", "prompt": "\nobject Solution {\n/**\n  * Count the number of prime numbers less than a non-negative integer n.\n  *\n  * @param n The non-negative integer.\n  * @return The number of prime numbers less than n.\n  *\n  * Example:\n  * countPrimes(10)\n  * Output: 4\n  *\n  * Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n  */\n  def countPrimes(n: Int): Int = ", "canonical_solution": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Additional test cases\n    assert(countPrimes(15) == 6)\n    assert(countPrimes(30) == 10)\n    assert(countPrimes(50) == 15)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrimes", "signature": "def countPrimes(n: Int): Int =", "docstring": "Count the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n\n* Incomplete Code:\ndef countPrimes(n: Int): Int =\n  {\n\n     i[MASK]     for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n     i[MASK]     for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }"}
{"task_id": "Scala/41-1-span", "prompt": "\nobject Solution {\n/**\n  * Count the number of prime numbers less than a non-negative integer n.\n  *\n  * @param n The non-negative integer.\n  * @return The number of prime numbers less than n.\n  *\n  * Example:\n  * countPrimes(10)\n  * Output: 4\n  *\n  * Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n  */\n  def countPrimes(n: Int): Int = ", "canonical_solution": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Additional test cases\n    assert(countPrimes(15) == 6)\n    assert(countPrimes(30) == 10)\n    assert(countPrimes(50) == 15)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrimes", "signature": "def countPrimes(n: Int): Int =", "docstring": "Count the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n\n* Incomplete Code:\ndef countPrimes(n: Int): Int =\n  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by[MASK] primes\n    }\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by[MASK] primes\n    }\n  }"}
{"task_id": "Scala/42-0-span", "prompt": "\nobject Solution {\n  /**\n    * Check if the binary representation of a positive integer has alternating bits.\n    *\n    * @param n The positive integer to check.\n    * @return True if the binary representation has alternating bits, false otherwise.\n    *\n    * Example:\n    * hasAlternatingBits(5)\n    * Output: true\n    */\n  def hasAlternatingBits(n: Int): Boolean = ", "canonical_solution": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hasAlternatingBits(10)) // Binary representation of 10 is 1010 which has alternating bits\n    assert(!hasAlternatingBits(7)) // Binary representation of 7 is 111 which does not have alternating bits\n    assert(hasAlternatingBits(21)) // Binary representation of 21 is 10101 which has alternating bits\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "hasAlternatingBits", "signature": "def hasAlternatingBits(n: Int): Boolean =", "docstring": "Check if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true\n\n* Incomplete Code:\ndef hasAlternatingBits(n: Int): Boolean =\n  {\n\n    val[MASK]e\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val[MASK]e\n  }"}
{"task_id": "Scala/42-1-span", "prompt": "\nobject Solution {\n  /**\n    * Check if the binary representation of a positive integer has alternating bits.\n    *\n    * @param n The positive integer to check.\n    * @return True if the binary representation has alternating bits, false otherwise.\n    *\n    * Example:\n    * hasAlternatingBits(5)\n    * Output: true\n    */\n  def hasAlternatingBits(n: Int): Boolean = ", "canonical_solution": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hasAlternatingBits(10)) // Binary representation of 10 is 1010 which has alternating bits\n    assert(!hasAlternatingBits(7)) // Binary representation of 7 is 111 which does not have alternating bits\n    assert(hasAlternatingBits(21)) // Binary representation of 21 is 10101 which has alternating bits\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "hasAlternatingBits", "signature": "def hasAlternatingBits(n: Int): Boolean =", "docstring": "Check if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCheck if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true\n\n* Incomplete Code:\ndef hasAlternatingBits(n: Int): Boolean =\n  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString[MASK]ue\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString[MASK]ue\n  }"}
{"task_id": "Scala/43-0-span", "prompt": "import scala.collection.mutable.ArrayBuffer\n\nobject Solution {\n  /**\n    * Move all even elements to the front of the array, followed by all odd elements.\n    *\n    * @param nums An array of integers.\n    * @return The modified array with even elements in the front and odd elements at the end.\n    *\n    * Example:\n    * moveEvenOdd(Array(3, 1, 2, 4))\n    * Output: Array(2, 4, 3, 1)\n    *\n    * Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n    */\n  def moveEvenOdd(nums: Array[Int]): Array[Int] = ", "canonical_solution": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(moveEvenOdd(Array(5, 8, 3, 6)).sameElements(Array(8, 6, 5, 3)))\n\n    // Test case 2\n    assert(moveEvenOdd(Array(7, 2)).sameElements(Array(2, 7)))\n\n    // Test case 3\n    assert(moveEvenOdd(Array(9, 1, 4, 7, 6)).sameElements(Array(4, 6, 9, 1, 7)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveEvenOdd", "signature": "def moveEvenOdd(nums: Array[Int]): Array[Int] =", "docstring": "Move all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n\n* Incomplete Code:\ndef moveEvenOdd(nums: Array[Int]): Array[Int] =\n  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    [MASK]ds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    [MASK]ds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }"}
{"task_id": "Scala/43-1-span", "prompt": "import scala.collection.mutable.ArrayBuffer\n\nobject Solution {\n  /**\n    * Move all even elements to the front of the array, followed by all odd elements.\n    *\n    * @param nums An array of integers.\n    * @return The modified array with even elements in the front and odd elements at the end.\n    *\n    * Example:\n    * moveEvenOdd(Array(3, 1, 2, 4))\n    * Output: Array(2, 4, 3, 1)\n    *\n    * Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n    */\n  def moveEvenOdd(nums: Array[Int]): Array[Int] = ", "canonical_solution": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(moveEvenOdd(Array(5, 8, 3, 6)).sameElements(Array(8, 6, 5, 3)))\n\n    // Test case 2\n    assert(moveEvenOdd(Array(7, 2)).sameElements(Array(2, 7)))\n\n    // Test case 3\n    assert(moveEvenOdd(Array(9, 1, 4, 7, 6)).sameElements(Array(4, 6, 9, 1, 7)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveEvenOdd", "signature": "def moveEvenOdd(nums: Array[Int]): Array[Int] =", "docstring": "Move all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nMove all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n\n* Incomplete Code:\ndef moveEvenOdd(nums: Array[Int]): Array[Int] =\n  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { nu[MASK] == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { nu[MASK] == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }"}
{"task_id": "Scala/44-0-span", "prompt": "// Necessary imports\nimport scala.annotation.tailrec\n\nobject Solution {\n  /**\n     * Returns the least common multiple of 2 and n.\n     *\n     * @param n A positive integer.\n     * @return The least common multiple of 2 and n.\n     *\n     * Example:\n     * leastCommonMultiple(5)\n     * Output: 10\n     *\n     * Example:\n     * leastCommonMultiple(6)\n     * Output: 6\n     */\n  def leastCommonMultiple(n: Int): Int = ", "canonical_solution": "  {\n\n    (2 * n) / gcd(2, n)\n  }\n\n  @tailrec\n  private def gcd(a: Int, b: Int): Int = {\n    if (b == 0) a else gcd(b, a % b)\n  }", "test": "    def main(args: Array[String]): Unit = {\n    // Unit tests for the leastCommonMultiple function\n    assert(leastCommonMultiple(3) == 6, \"Test case 1 failed\")\n    assert(leastCommonMultiple(7) == 14, \"Test case 2 failed\")\n    assert(leastCommonMultiple(10) == 10, \"Test case 3 failed\")\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "leastCommonMultiple", "signature": "def leastCommonMultiple(n: Int): Int =", "docstring": "Returns the least common multiple of 2 and n.\n\n @param n A positive integer.\n @return The least common multiple of 2 and n.\n\n Example:\n leastCommonMultiple(5)\n Output: 10\n\n Example:\n leastCommonMultiple(6)\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the least common multiple of 2 and n.\n\n @param n A positive integer.\n @return The least common multiple of 2 and n.\n\n Example:\n leastCommonMultiple(5)\n Output: 10\n\n Example:\n leastCommonMultiple(6)\n Output: 6\n\n* Incomplete Code:\ndef leastCommonMultiple(n: Int): Int =\n  {\n\n    (2 * n) / gcd(2, n)\n  }\n\n  @tailrec\n  [MASK]a: Int, b: Int): Int = {\n    if (b == 0) a else gcd(b, a % b)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    (2 * n) / gcd(2, n)\n  }\n\n  @tailrec\n  [MASK]a: Int, b: Int): Int = {\n    if (b == 0) a else gcd(b, a % b)\n  }"}
{"task_id": "Scala/44-1-span", "prompt": "// Necessary imports\nimport scala.annotation.tailrec\n\nobject Solution {\n  /**\n     * Returns the least common multiple of 2 and n.\n     *\n     * @param n A positive integer.\n     * @return The least common multiple of 2 and n.\n     *\n     * Example:\n     * leastCommonMultiple(5)\n     * Output: 10\n     *\n     * Example:\n     * leastCommonMultiple(6)\n     * Output: 6\n     */\n  def leastCommonMultiple(n: Int): Int = ", "canonical_solution": "  {\n\n    (2 * n) / gcd(2, n)\n  }\n\n  @tailrec\n  private def gcd(a: Int, b: Int): Int = {\n    if (b == 0) a else gcd(b, a % b)\n  }", "test": "    def main(args: Array[String]): Unit = {\n    // Unit tests for the leastCommonMultiple function\n    assert(leastCommonMultiple(3) == 6, \"Test case 1 failed\")\n    assert(leastCommonMultiple(7) == 14, \"Test case 2 failed\")\n    assert(leastCommonMultiple(10) == 10, \"Test case 3 failed\")\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "leastCommonMultiple", "signature": "def leastCommonMultiple(n: Int): Int =", "docstring": "Returns the least common multiple of 2 and n.\n\n @param n A positive integer.\n @return The least common multiple of 2 and n.\n\n Example:\n leastCommonMultiple(5)\n Output: 10\n\n Example:\n leastCommonMultiple(6)\n Output: 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReturns the least common multiple of 2 and n.\n\n @param n A positive integer.\n @return The least common multiple of 2 and n.\n\n Example:\n leastCommonMultiple(5)\n Output: 10\n\n Example:\n leastCommonMultiple(6)\n Output: 6\n\n* Incomplete Code:\ndef leastCommonMultiple(n: Int): Int =\n  {\n\n    (2 * n) / gcd(2, n)\n  }\n\n  @tailrec\n  private def gcd(a: Int, b: Int): Int = {\n    [MASK]else gcd(b, a % b)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    (2 * n) / gcd(2, n)\n  }\n\n  @tailrec\n  private def gcd(a: Int, b: Int): Int = {\n    [MASK]else gcd(b, a % b)\n  }"}
{"task_id": "Scala/45-0-span", "prompt": "object Solution {\n    /**\n       * Calculate the Hamming distance between two integers.\n       *\n       * @param x The first integer.\n       * @param y The second integer.\n       * @return The Hamming distance between x and y.\n       *\n       * Example:\n       * hammingDistance(1, 4)\n       * Output: 2\n       *\n       * hammingDistance(3, 1)\n       * Output: 1\n       */\n  def hammingDistance(x: Int, y: Int): Int = ", "canonical_solution": "  {\n\n      (x ^ y).toBinaryString.count(_ == '1')\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hammingDistance(5, 9) == 2) // 0101 vs 1001 -> 3 differences\n    assert(hammingDistance(10, 20) == 4) // 01010 vs 10100 -> 4 differences\n    assert(hammingDistance(17, 34) == 4) // 010001 vs 100010 -> 3 differences\n    println(\"All tests passed\")\n  }\n}", "entry_point": "hammingDistance", "signature": "def hammingDistance(x: Int, y: Int): Int =", "docstring": "Calculate the Hamming distance between two integers.\n\n @param x The first integer.\n @param y The second integer.\n @return The Hamming distance between x and y.\n\n Example:\n hammingDistance(1, 4)\n Output: 2\n\n hammingDistance(3, 1)\n Output: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the Hamming distance between two integers.\n\n @param x The first integer.\n @param y The second integer.\n @return The Hamming distance between x and y.\n\n Example:\n hammingDistance(1, 4)\n Output: 2\n\n hammingDistance(3, 1)\n Output: 1\n\n* Incomplete Code:\ndef hammingDistance(x: Int, y: Int): Int =\n  {\n\n      (x ^ y).[MASK]unt(_ == '1')\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      (x ^ y).[MASK]unt(_ == '1')\n  }"}
{"task_id": "Scala/45-1-span", "prompt": "object Solution {\n    /**\n       * Calculate the Hamming distance between two integers.\n       *\n       * @param x The first integer.\n       * @param y The second integer.\n       * @return The Hamming distance between x and y.\n       *\n       * Example:\n       * hammingDistance(1, 4)\n       * Output: 2\n       *\n       * hammingDistance(3, 1)\n       * Output: 1\n       */\n  def hammingDistance(x: Int, y: Int): Int = ", "canonical_solution": "  {\n\n      (x ^ y).toBinaryString.count(_ == '1')\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hammingDistance(5, 9) == 2) // 0101 vs 1001 -> 3 differences\n    assert(hammingDistance(10, 20) == 4) // 01010 vs 10100 -> 4 differences\n    assert(hammingDistance(17, 34) == 4) // 010001 vs 100010 -> 3 differences\n    println(\"All tests passed\")\n  }\n}", "entry_point": "hammingDistance", "signature": "def hammingDistance(x: Int, y: Int): Int =", "docstring": "Calculate the Hamming distance between two integers.\n\n @param x The first integer.\n @param y The second integer.\n @return The Hamming distance between x and y.\n\n Example:\n hammingDistance(1, 4)\n Output: 2\n\n hammingDistance(3, 1)\n Output: 1", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the Hamming distance between two integers.\n\n @param x The first integer.\n @param y The second integer.\n @return The Hamming distance between x and y.\n\n Example:\n hammingDistance(1, 4)\n Output: 2\n\n hammingDistance(3, 1)\n Output: 1\n\n* Incomplete Code:\ndef hammingDistance(x: Int, y: Int): Int =\n  {\n\n      (x [MASK]ng.count(_ == '1')\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n      (x [MASK]ng.count(_ == '1')\n  }"}
{"task_id": "Scala/46-0-span", "prompt": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n  /**\n  * Generate all unique permutations of a sequence of numbers.\n  *\n  * @param nums The sequence of numbers.\n  * @return A list of all unique permutations.\n  *\n  * Example:\n  * permute(Array(1, 1, 2))\n  * Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n  */\n  def permute(nums: Array[Int]): List[List[Int]] = ", "canonical_solution": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(permute(Array(2, 3, 5)).toSet == Set(\n      List(2, 3, 5), List(2, 5, 3), List(3, 2, 5),\n      List(3, 5, 2), List(5, 2, 3), List(5, 3, 2)\n    ))\n\n    // Test case 2\n    assert(permute(Array(0, -1, 1)).toSet == Set(\n      List(0, -1, 1), List(0, 1, -1), List(-1, 0, 1),\n      List(-1, 1, 0), List(1, 0, -1), List(1, -1, 0)\n    ))\n\n    // Test case 3\n    assert(permute(Array(1, 2)).toSet == Set(\n      List(1, 2), List(2, 1)\n    ))\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "permute", "signature": "def permute(nums: Array[Int]): List[List[Int]] =", "docstring": "Generate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n\n* Incomplete Code:\ndef permute(nums: Array[Int]): List[List[Int]] =\n  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = t[MASK]     backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = t[MASK]     backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n"}
{"task_id": "Scala/46-1-span", "prompt": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n  /**\n  * Generate all unique permutations of a sequence of numbers.\n  *\n  * @param nums The sequence of numbers.\n  * @return A list of all unique permutations.\n  *\n  * Example:\n  * permute(Array(1, 1, 2))\n  * Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n  */\n  def permute(nums: Array[Int]): List[List[Int]] = ", "canonical_solution": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(permute(Array(2, 3, 5)).toSet == Set(\n      List(2, 3, 5), List(2, 5, 3), List(3, 2, 5),\n      List(3, 5, 2), List(5, 2, 3), List(5, 3, 2)\n    ))\n\n    // Test case 2\n    assert(permute(Array(0, -1, 1)).toSet == Set(\n      List(0, -1, 1), List(0, 1, -1), List(-1, 0, 1),\n      List(-1, 1, 0), List(1, 0, -1), List(1, -1, 0)\n    ))\n\n    // Test case 3\n    assert(permute(Array(1, 2)).toSet == Set(\n      List(1, 2), List(2, 1)\n    ))\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "permute", "signature": "def permute(nums: Array[Int]): List[List[Int]] =", "docstring": "Generate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n\n* Incomplete Code:\ndef permute(nums: Array[Int]): List[List[Int]] =\n  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n      [MASK]i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n      [MASK]i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n"}
{"task_id": "Scala/47-0-span", "prompt": "\nobject Solution {\n      /**\n       * Reverse the first k characters of every 2k characters in the given string.\n       *\n       * @param s The input string.\n       * @param k The integer k.\n       * @return The modified string.\n       *\n       * Example:\n       * reverseString(\"abcdefg\", 2)\n       * Output: \"bacdfeg\"\n       *\n       * reverseString(\"abcd\", 2)\n       * Output: \"bacd\"\n       */\n  def reverseString(s: String, k: Int): String = ", "canonical_solution": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"example\", 3) == \"axemple\")\n    assert(reverseString(\"helloScala\", 4) == \"llehoScaal\")\n    assert(reverseString(\"scalaisfun\", 5) == \"alacsisfun\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String, k: Int): String =", "docstring": "Reverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"\n\n* Incomplete Code:\ndef reverseString(s: String, k: Int): String =\n  {\n\n    s.grouped(2 * k).map[MASK]ub.substring(k)\n    }.mkString\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    s.grouped(2 * k).map[MASK]ub.substring(k)\n    }.mkString\n  }"}
{"task_id": "Scala/47-1-span", "prompt": "\nobject Solution {\n      /**\n       * Reverse the first k characters of every 2k characters in the given string.\n       *\n       * @param s The input string.\n       * @param k The integer k.\n       * @return The modified string.\n       *\n       * Example:\n       * reverseString(\"abcdefg\", 2)\n       * Output: \"bacdfeg\"\n       *\n       * reverseString(\"abcd\", 2)\n       * Output: \"bacd\"\n       */\n  def reverseString(s: String, k: Int): String = ", "canonical_solution": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"example\", 3) == \"axemple\")\n    assert(reverseString(\"helloScala\", 4) == \"llehoScaal\")\n    assert(reverseString(\"scalaisfun\", 5) == \"alacsisfun\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String, k: Int): String =", "docstring": "Reverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nReverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"\n\n* Incomplete Code:\ndef reverseString(s: String, k: Int): String =\n  {\n\n    s.grou[MASK]mkString\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n\n    s.grou[MASK]mkString\n  }"}
{"task_id": "Scala/48-0-span", "prompt": "object Solution {\n  /**\n   * Calculate the time needed to obtain the reverse seating order.\n   * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n   * \n   * @param N the number of people\n   * @return the time needed in minutes\n   * \n   * Example:\n   * >>> calculateTimeNeeded(4)\n   * 2\n   * >>> calculateTimeNeeded(5)\n   * 4\n   * >>> calculateTimeNeeded(6)\n   * 6\n   */\n  def calculateTimeNeeded(N: Int): Int = ", "canonical_solution": "  {\n    N / 2\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test the function with different test cases\n    assert(calculateTimeNeeded(7) == 3)\n    assert(calculateTimeNeeded(8) == 4)\n    assert(calculateTimeNeeded(9) == 4)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "calculateTimeNeeded", "signature": "def calculateTimeNeeded(N: Int): Int =", "docstring": "Calculate the time needed to obtain the reverse seating order.\n For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n \n @param N the number of people\n @return the time needed in minutes\n \n Example:\n >>> calculateTimeNeeded(4)\n 2\n >>> calculateTimeNeeded(5)\n 4\n >>> calculateTimeNeeded(6)\n 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the time needed to obtain the reverse seating order.\n For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n \n @param N the number of people\n @return the time needed in minutes\n \n Example:\n >>> calculateTimeNeeded(4)\n 2\n >>> calculateTimeNeeded(5)\n 4\n >>> calculateTimeNeeded(6)\n 6\n\n* Incomplete Code:\ndef calculateTimeNeeded(N: Int): Int =\n  {\n [MASK]N / 2\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n [MASK]N / 2\n  }"}
{"task_id": "Scala/48-1-span", "prompt": "object Solution {\n  /**\n   * Calculate the time needed to obtain the reverse seating order.\n   * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n   * \n   * @param N the number of people\n   * @return the time needed in minutes\n   * \n   * Example:\n   * >>> calculateTimeNeeded(4)\n   * 2\n   * >>> calculateTimeNeeded(5)\n   * 4\n   * >>> calculateTimeNeeded(6)\n   * 6\n   */\n  def calculateTimeNeeded(N: Int): Int = ", "canonical_solution": "  {\n    N / 2\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test the function with different test cases\n    assert(calculateTimeNeeded(7) == 3)\n    assert(calculateTimeNeeded(8) == 4)\n    assert(calculateTimeNeeded(9) == 4)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "calculateTimeNeeded", "signature": "def calculateTimeNeeded(N: Int): Int =", "docstring": "Calculate the time needed to obtain the reverse seating order.\n For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n \n @param N the number of people\n @return the time needed in minutes\n \n Example:\n >>> calculateTimeNeeded(4)\n 2\n >>> calculateTimeNeeded(5)\n 4\n >>> calculateTimeNeeded(6)\n 6", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCalculate the time needed to obtain the reverse seating order.\n For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n \n @param N the number of people\n @return the time needed in minutes\n \n Example:\n >>> calculateTimeNeeded(4)\n 2\n >>> calculateTimeNeeded(5)\n 4\n >>> calculateTimeNeeded(6)\n 6\n\n* Incomplete Code:\ndef calculateTimeNeeded(N: Int): Int =\n  {\n   [MASK]/ 2\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n   [MASK]/ 2\n  }"}
{"task_id": "Scala/49-0-span", "prompt": "object Solution {\n  \n  /**\n   * Count the number of words in the given word list that have the given prefix.\n   *\n   * @param wordList a list of words\n   * @param prefix the prefix string\n   * @return the number of words with the given prefix\n   *\n   * Example:\n   *\n   * {{{\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n   * }}}\n   */\n  def countPrefixWords(wordList: List[String], prefix: String): Int = ", "canonical_solution": "  {\n    wordList.count(_.startsWith(prefix))\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test the function with different test cases\n    assert(countPrefixWords(List(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3)\n    assert(countPrefixWords(List(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4)\n    assert(countPrefixWords(List(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrefixWords", "signature": "def countPrefixWords(wordList: List[String], prefix: String): Int =", "docstring": "Count the number of words in the given word list that have the given prefix.\n\n @param wordList a list of words\n @param prefix the prefix string\n @return the number of words with the given prefix\n\n Example:\n\n {{{\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n }}}", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of words in the given word list that have the given prefix.\n\n @param wordList a list of words\n @param prefix the prefix string\n @return the number of words with the given prefix\n\n Example:\n\n {{{\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n }}}\n\n* Incomplete Code:\ndef countPrefixWords(wordList: List[String], prefix: String): Int =\n  {\n    wor[MASK]artsWith(prefix))\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    wor[MASK]artsWith(prefix))\n  }"}
{"task_id": "Scala/49-1-span", "prompt": "object Solution {\n  \n  /**\n   * Count the number of words in the given word list that have the given prefix.\n   *\n   * @param wordList a list of words\n   * @param prefix the prefix string\n   * @return the number of words with the given prefix\n   *\n   * Example:\n   *\n   * {{{\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n   * }}}\n   */\n  def countPrefixWords(wordList: List[String], prefix: String): Int = ", "canonical_solution": "  {\n    wordList.count(_.startsWith(prefix))\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test the function with different test cases\n    assert(countPrefixWords(List(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3)\n    assert(countPrefixWords(List(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4)\n    assert(countPrefixWords(List(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrefixWords", "signature": "def countPrefixWords(wordList: List[String], prefix: String): Int =", "docstring": "Count the number of words in the given word list that have the given prefix.\n\n @param wordList a list of words\n @param prefix the prefix string\n @return the number of words with the given prefix\n\n Example:\n\n {{{\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n }}}", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nCount the number of words in the given word list that have the given prefix.\n\n @param wordList a list of words\n @param prefix the prefix string\n @return the number of words with the given prefix\n\n Example:\n\n {{{\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n }}}\n\n* Incomplete Code:\ndef countPrefixWords(wordList: List[String], prefix: String): Int =\n  {\n [MASK]t(_.startsWith(prefix))\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n [MASK]t(_.startsWith(prefix))\n  }"}
{"task_id": "Scala/50-0-span", "prompt": "object Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  def minPerfectSquareSum(n: Int): Int = ", "canonical_solution": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(minPerfectSquareSum(26) == 2, \"Test case 1 failed\")\n    assert(minPerfectSquareSum(17) == 2, \"Test case 2 failed\")\n    assert(minPerfectSquareSum(99) == 3, \"Test case 3 failed\")\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "def minPerfectSquareSum(n: Int): Int =", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2\n\n* Incomplete Code:\ndef minPerfectSquareSum(n: Int): Int =\n  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n   [MASK]) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n   [MASK]) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }"}
{"task_id": "Scala/50-1-span", "prompt": "object Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  def minPerfectSquareSum(n: Int): Int = ", "canonical_solution": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(minPerfectSquareSum(26) == 2, \"Test case 1 failed\")\n    assert(minPerfectSquareSum(17) == 2, \"Test case 2 failed\")\n    assert(minPerfectSquareSum(99) == 3, \"Test case 3 failed\")\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "def minPerfectSquareSum(n: Int): Int =", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "instruction": "Below is a explanation of scala code and incomplete code implementation.\n\n* Docstring: \nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2\n\n* Incomplete Code:\ndef minPerfectSquareSum(n: Int): Int =\n  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n   [MASK]j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n   [MASK]j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }"}
