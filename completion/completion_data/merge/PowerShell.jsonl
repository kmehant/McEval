{"task_id": "PowerShell/1-0-single", "prompt": "function Has-CloseElements {\n<#\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n#> param (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "canonical_solution": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}", "test": "# Test cases\nfunction Check-CloseElements() {\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.3) -ne $true) { throw \"Test case 1 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.05) -ne $false) { throw \"Test case 2 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.95) -ne $true) { throw \"Test case 3 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.8) -ne $false) { throw \"Test case 4 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.0, 4.0, 5.0, 2.0)))) 0.1) -ne $true) { throw \"Test case 5 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 1.0) -ne $true) { throw \"Test case 6 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 0.5) -ne $false) { throw \"Test case 7 failed\" }\n}\n\nCheck-CloseElements", "entry_point": "Has-CloseElements", "signature": "function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunction Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)\n\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n[MASK]\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n[MASK]\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}"}
{"task_id": "PowerShell/1-1-single", "prompt": "function Has-CloseElements {\n<#\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n#> param (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "canonical_solution": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}", "test": "# Test cases\nfunction Check-CloseElements() {\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.3) -ne $true) { throw \"Test case 1 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.05) -ne $false) { throw \"Test case 2 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.95) -ne $true) { throw \"Test case 3 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.8) -ne $false) { throw \"Test case 4 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.0, 4.0, 5.0, 2.0)))) 0.1) -ne $true) { throw \"Test case 5 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 1.0) -ne $true) { throw \"Test case 6 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 0.5) -ne $false) { throw \"Test case 7 failed\" }\n}\n\nCheck-CloseElements", "entry_point": "Has-CloseElements", "signature": "function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunction Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)\n\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\n[MASK]\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\n[MASK]\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}"}
{"task_id": "PowerShell/2-0-single", "prompt": "function Remove-DuplicatesFromSortedArray {\n<#\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "canonical_solution": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}", "test": "function Check-RemoveDuplicatesFromSortedArray() {\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 2)) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(0,0,1,1,1,2,2,3,3,4)) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 2, 3)) -ne 3) { throw \"Test case 3 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(2, 2, 2)) -ne 1) { throw \"Test case 4 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1)) -ne 1) { throw \"Test case 5 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4)) -ne 4) { throw \"Test case 6 failed\" }\n}\n\nCheck-RemoveDuplicatesFromSortedArray", "entry_point": "Remove-DuplicatesFromSortedArray", "signature": "function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "docstring": "\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n\n\n* Incomplete Code:\nfunction Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)\nif ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\n[MASK]\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\n[MASK]\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}"}
{"task_id": "PowerShell/2-1-single", "prompt": "function Remove-DuplicatesFromSortedArray {\n<#\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "canonical_solution": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}", "test": "function Check-RemoveDuplicatesFromSortedArray() {\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 2)) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(0,0,1,1,1,2,2,3,3,4)) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 2, 3)) -ne 3) { throw \"Test case 3 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(2, 2, 2)) -ne 1) { throw \"Test case 4 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1)) -ne 1) { throw \"Test case 5 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4)) -ne 4) { throw \"Test case 6 failed\" }\n}\n\nCheck-RemoveDuplicatesFromSortedArray", "entry_point": "Remove-DuplicatesFromSortedArray", "signature": "function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "docstring": "\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n\n\n* Incomplete Code:\nfunction Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)\nif ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n[MASK]\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n[MASK]\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}"}
{"task_id": "PowerShell/3-0-single", "prompt": "function Get-LongestUniqueSubstringLength {\n<#\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}", "test": "function Check-LongestUniqueSubstringLength() {\nif ((Get-LongestUniqueSubstringLength \"abcabcbb\") -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-LongestUniqueSubstringLength \"bbbbb\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-LongestUniqueSubstringLength \"pwwkew\") -ne 3) { throw \"Test case 3 failed\" }\nif ((Get-LongestUniqueSubstringLength \" \") -ne 1) { throw \"Test case 4 failed\" }\nif ((Get-LongestUniqueSubstringLength \"dvdf\") -ne 3) { throw \"Test case 5 failed\" }\nif ((Get-LongestUniqueSubstringLength \"anviaj\") -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-LongestUniqueSubstringLength \"abba\") -ne 2) { throw \"Test case 7 failed\" }\n}\n\nCheck-LongestUniqueSubstringLength", "entry_point": "Get-LongestUniqueSubstringLength", "signature": "function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n\n\n* Incomplete Code:\nfunction Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$start = 0\n$maxLength = 0\n$charMap = @{}\n\n[MASK]\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\n[MASK]\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}"}
{"task_id": "PowerShell/3-1-single", "prompt": "function Get-LongestUniqueSubstringLength {\n<#\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}", "test": "function Check-LongestUniqueSubstringLength() {\nif ((Get-LongestUniqueSubstringLength \"abcabcbb\") -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-LongestUniqueSubstringLength \"bbbbb\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-LongestUniqueSubstringLength \"pwwkew\") -ne 3) { throw \"Test case 3 failed\" }\nif ((Get-LongestUniqueSubstringLength \" \") -ne 1) { throw \"Test case 4 failed\" }\nif ((Get-LongestUniqueSubstringLength \"dvdf\") -ne 3) { throw \"Test case 5 failed\" }\nif ((Get-LongestUniqueSubstringLength \"anviaj\") -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-LongestUniqueSubstringLength \"abba\") -ne 2) { throw \"Test case 7 failed\" }\n}\n\nCheck-LongestUniqueSubstringLength", "entry_point": "Get-LongestUniqueSubstringLength", "signature": "function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n\n\n* Incomplete Code:\nfunction Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$start = 0\n[MASK]\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$start = 0\n[MASK]\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}"}
{"task_id": "PowerShell/4-0-single", "prompt": "function Get-LongestPalindromicSubstring {\n<#\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}", "test": "function Check-LongestPalindromicSubstring() {\n$result1 = Get-LongestPalindromicSubstring \"babad\"\nif (-not ($result1 -eq \"bab\" -or $result1 -eq \"aba\")) { throw \"Test case 1 failed\" }\nif ((Get-LongestPalindromicSubstring \"cbbd\") -ne \"bb\") { throw \"Test case 2 failed\" }\nif ((Get-LongestPalindromicSubstring \"a\") -ne \"a\") { throw \"Test case 3 failed\" }\nif ((Get-LongestPalindromicSubstring \"racecar\") -ne \"racecar\") { throw \"Test case 4 failed\" }\nif ((Get-LongestPalindromicSubstring \"madam\") -ne \"madam\") { throw \"Test case 5 failed\" }\nif ((Get-LongestPalindromicSubstring \"abcdcba\") -ne \"abcdcba\") { throw \"Test case 6 failed\" }\n}\n\nCheck-LongestPalindromicSubstring", "entry_point": "Get-LongestPalindromicSubstring", "signature": "function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n\n\n* Incomplete Code:\nfunction Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\nif (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n[MASK]\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n[MASK]\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}"}
{"task_id": "PowerShell/4-1-single", "prompt": "function Get-LongestPalindromicSubstring {\n<#\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}", "test": "function Check-LongestPalindromicSubstring() {\n$result1 = Get-LongestPalindromicSubstring \"babad\"\nif (-not ($result1 -eq \"bab\" -or $result1 -eq \"aba\")) { throw \"Test case 1 failed\" }\nif ((Get-LongestPalindromicSubstring \"cbbd\") -ne \"bb\") { throw \"Test case 2 failed\" }\nif ((Get-LongestPalindromicSubstring \"a\") -ne \"a\") { throw \"Test case 3 failed\" }\nif ((Get-LongestPalindromicSubstring \"racecar\") -ne \"racecar\") { throw \"Test case 4 failed\" }\nif ((Get-LongestPalindromicSubstring \"madam\") -ne \"madam\") { throw \"Test case 5 failed\" }\nif ((Get-LongestPalindromicSubstring \"abcdcba\") -ne \"abcdcba\") { throw \"Test case 6 failed\" }\n}\n\nCheck-LongestPalindromicSubstring", "entry_point": "Get-LongestPalindromicSubstring", "signature": "function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n\n\n* Incomplete Code:\nfunction Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\nif (-not $s) { return \"\" }\n[MASK]\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "if (-not $s) { return \"\" }\n[MASK]\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}"}
{"task_id": "PowerShell/5-0-single", "prompt": "function MyAtoi {\n<#\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}", "test": "# Test cases\nfunction Check-MyAtoi() {\nif ((MyAtoi \"42\") -ne 42) { throw \"Test case 1 failed\" }\nif ((MyAtoi \" -42\") -ne -42) { throw \"Test case 2 failed\" }\nif ((MyAtoi \"4193 with words\") -ne 4193) { throw \"Test case 3 failed\" }\nif ((MyAtoi \"words and 987\") -ne 0) { throw \"Test case 4 failed\" }\n}\nCheck-MyAtoi", "entry_point": "MyAtoi", "signature": "function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n\n\n* Incomplete Code:\nfunction MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\n[MASK]\n}\n\n$i++\n}\n\nreturn $base * $sign\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\n[MASK]\n}\n\n$i++\n}\n\nreturn $base * $sign\n}"}
{"task_id": "PowerShell/5-1-single", "prompt": "function MyAtoi {\n<#\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}", "test": "# Test cases\nfunction Check-MyAtoi() {\nif ((MyAtoi \"42\") -ne 42) { throw \"Test case 1 failed\" }\nif ((MyAtoi \" -42\") -ne -42) { throw \"Test case 2 failed\" }\nif ((MyAtoi \"4193 with words\") -ne 4193) { throw \"Test case 3 failed\" }\nif ((MyAtoi \"words and 987\") -ne 0) { throw \"Test case 4 failed\" }\n}\nCheck-MyAtoi", "entry_point": "MyAtoi", "signature": "function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n\n\n* Incomplete Code:\nfunction MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\n[MASK]\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\n[MASK]\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}"}
{"task_id": "PowerShell/6-0-single", "prompt": "function FindLongestCommonPrefix {\n<#\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "canonical_solution": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}", "test": "function Check-FindLongestCommonPrefix() {\nif ((FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")) -ne \"fl\") { throw \"Test case 1 failed\" }\nif ((FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")) -ne \"\") { throw \"Test case 2 failed\" }\nif ((FindLongestCommonPrefix @(\"interspecies\",\"interstellar\",\"interstate\")) -ne \"inters\") { throw \"Test case 3 failed\" }\nif ((FindLongestCommonPrefix @(\"throne\",\"throne\")) -ne \"throne\") { throw \"Test case 4 failed\" }\nif ((FindLongestCommonPrefix @(\"a\",\"ab\")) -ne \"a\") { throw \"Test case 5 failed\" }\nif ((FindLongestCommonPrefix @(\"abc\",\"abcd\",\"ab\")) -ne \"ab\") { throw \"Test case 6 failed\" }\nif ((FindLongestCommonPrefix @(\"complete\",\"compliment\",\"complex\")) -ne \"compl\") { throw \"Test case 7 failed\" }\nif ((FindLongestCommonPrefix @(\"nomatch\",\"nomadic\",\"noir\")) -ne \"no\") { throw \"Test case 8 failed\" }\n}\n\nCheck-FindLongestCommonPrefix", "entry_point": "FindLongestCommonPrefix", "signature": "function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "docstring": "\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n\n\n* Incomplete Code:\nfunction FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)\nif ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/6-1-single", "prompt": "function FindLongestCommonPrefix {\n<#\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "canonical_solution": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}", "test": "function Check-FindLongestCommonPrefix() {\nif ((FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")) -ne \"fl\") { throw \"Test case 1 failed\" }\nif ((FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")) -ne \"\") { throw \"Test case 2 failed\" }\nif ((FindLongestCommonPrefix @(\"interspecies\",\"interstellar\",\"interstate\")) -ne \"inters\") { throw \"Test case 3 failed\" }\nif ((FindLongestCommonPrefix @(\"throne\",\"throne\")) -ne \"throne\") { throw \"Test case 4 failed\" }\nif ((FindLongestCommonPrefix @(\"a\",\"ab\")) -ne \"a\") { throw \"Test case 5 failed\" }\nif ((FindLongestCommonPrefix @(\"abc\",\"abcd\",\"ab\")) -ne \"ab\") { throw \"Test case 6 failed\" }\nif ((FindLongestCommonPrefix @(\"complete\",\"compliment\",\"complex\")) -ne \"compl\") { throw \"Test case 7 failed\" }\nif ((FindLongestCommonPrefix @(\"nomatch\",\"nomadic\",\"noir\")) -ne \"no\") { throw \"Test case 8 failed\" }\n}\n\nCheck-FindLongestCommonPrefix", "entry_point": "FindLongestCommonPrefix", "signature": "function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "docstring": "\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n\n\n* Incomplete Code:\nfunction FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)\nif ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\n[MASK]\n}\n}\n\nreturn $prefix\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\n[MASK]\n}\n}\n\nreturn $prefix\n}"}
{"task_id": "PowerShell/8-0-single", "prompt": "function Find-ConcatenatedSubstrings {\n<#\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "canonical_solution": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}", "test": "function Check-ConcatenatedSubstrings() {\n$result = Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\nif (($result -join ',') -ne '0,9') { throw \"Test case 1 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\nif (($result -join ',') -ne '') { throw \"Test case 2 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcabcabc\" @(\"abc\",\"abc\")\nif (($result -join ',') -ne '0,3') { throw \"Test case 3 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"ab\",\"cd\")\nif (($result -join ',') -ne '0') { throw \"Test case 4 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"cd\",\"ab\")\nif (($result -join ',') -ne '0') { throw \"Test case 5 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abababab\" @(\"ab\",\"ba\")\nif (($result -join ',') -ne '') { throw \"Test case 6 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcdef\" @(\"gh\",\"ij\")\nif (($result -join ',') -ne '') { throw \"Test case 7 failed\" }\n}\n\nCheck-ConcatenatedSubstrings", "entry_point": "Find-ConcatenatedSubstrings", "signature": "function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "docstring": "\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n\n\n* Incomplete Code:\nfunction Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)\n$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n[MASK]\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n[MASK]\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/8-1-single", "prompt": "function Find-ConcatenatedSubstrings {\n<#\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "canonical_solution": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}", "test": "function Check-ConcatenatedSubstrings() {\n$result = Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\nif (($result -join ',') -ne '0,9') { throw \"Test case 1 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\nif (($result -join ',') -ne '') { throw \"Test case 2 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcabcabc\" @(\"abc\",\"abc\")\nif (($result -join ',') -ne '0,3') { throw \"Test case 3 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"ab\",\"cd\")\nif (($result -join ',') -ne '0') { throw \"Test case 4 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"cd\",\"ab\")\nif (($result -join ',') -ne '0') { throw \"Test case 5 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abababab\" @(\"ab\",\"ba\")\nif (($result -join ',') -ne '') { throw \"Test case 6 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcdef\" @(\"gh\",\"ij\")\nif (($result -join ',') -ne '') { throw \"Test case 7 failed\" }\n}\n\nCheck-ConcatenatedSubstrings", "entry_point": "Find-ConcatenatedSubstrings", "signature": "function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "docstring": "\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n\n\n* Incomplete Code:\nfunction Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)\n$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\n[MASK]\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\n[MASK]\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/9-0-single", "prompt": "function Find-MedianOfTwoSortedArrays {\n<#\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "canonical_solution": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}", "test": "function Check-MedianOfTwoSortedArrays() {\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))) -ne 2.0) { throw \"Test case 1 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))) -ne 2.5) { throw \"Test case 2 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5, 7)) @([int[]](2, 4, 6, 8))) -ne 4.5) { throw \"Test case 3 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1)) @([int[]](1))) -ne 1.0) { throw \"Test case 4 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5)) @([int[]](2))) -ne 2.5) { throw \"Test case 5 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](10, 20, 30, 40, 50)) @([int[]](5, 15, 25, 35, 45))) -ne 27.5) { throw \"Test case 6 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 12, 15, 26, 38)) @([int[]](2, 13, 17, 30, 45, 50))) -ne 17.0) { throw \"Test case 7 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 4, 5)) @([int[]](2, 3, 6, 7, 8))) -ne 4.5) { throw \"Test case 8 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 1, 1)) @([int[]](1, 1, 1, 1))) -ne 1.0) { throw \"Test case 10 failed\" }\n}\n\nCheck-MedianOfTwoSortedArrays", "entry_point": "Find-MedianOfTwoSortedArrays", "signature": "function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "docstring": "\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n\n\n* Incomplete Code:\nfunction Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)\n$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\n[MASK]\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\n[MASK]\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}"}
{"task_id": "PowerShell/9-1-single", "prompt": "function Find-MedianOfTwoSortedArrays {\n<#\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "canonical_solution": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}", "test": "function Check-MedianOfTwoSortedArrays() {\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))) -ne 2.0) { throw \"Test case 1 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))) -ne 2.5) { throw \"Test case 2 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5, 7)) @([int[]](2, 4, 6, 8))) -ne 4.5) { throw \"Test case 3 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1)) @([int[]](1))) -ne 1.0) { throw \"Test case 4 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5)) @([int[]](2))) -ne 2.5) { throw \"Test case 5 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](10, 20, 30, 40, 50)) @([int[]](5, 15, 25, 35, 45))) -ne 27.5) { throw \"Test case 6 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 12, 15, 26, 38)) @([int[]](2, 13, 17, 30, 45, 50))) -ne 17.0) { throw \"Test case 7 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 4, 5)) @([int[]](2, 3, 6, 7, 8))) -ne 4.5) { throw \"Test case 8 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 1, 1)) @([int[]](1, 1, 1, 1))) -ne 1.0) { throw \"Test case 10 failed\" }\n}\n\nCheck-MedianOfTwoSortedArrays", "entry_point": "Find-MedianOfTwoSortedArrays", "signature": "function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "docstring": "\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n\n\n* Incomplete Code:\nfunction Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)\n$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n[MASK]\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n[MASK]\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}"}
{"task_id": "PowerShell/10-0-single", "prompt": "function Reverse-Integer {\n<#\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}", "test": "function Check-ReverseInteger() {\nif ((Reverse-Integer 123) -ne 321) { throw \"Test case 1 failed\" }\nif ((Reverse-Integer -123) -ne -321) { throw \"Test case 2 failed\" }\nif ((Reverse-Integer 120) -ne 21) { throw \"Test case 3 failed\" }\nif ((Reverse-Integer 0) -ne 0) { throw \"Test case 4 failed\" }\nif ((Reverse-Integer 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Reverse-Integer -10) -ne -1) { throw \"Test case 6 failed\" }\n\n}\n\nCheck-ReverseInteger", "entry_point": "Reverse-Integer", "signature": "function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n\n\n* Incomplete Code:\nfunction Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\n\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\n[MASK]\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\n[MASK]\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}"}
{"task_id": "PowerShell/10-1-single", "prompt": "function Reverse-Integer {\n<#\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}", "test": "function Check-ReverseInteger() {\nif ((Reverse-Integer 123) -ne 321) { throw \"Test case 1 failed\" }\nif ((Reverse-Integer -123) -ne -321) { throw \"Test case 2 failed\" }\nif ((Reverse-Integer 120) -ne 21) { throw \"Test case 3 failed\" }\nif ((Reverse-Integer 0) -ne 0) { throw \"Test case 4 failed\" }\nif ((Reverse-Integer 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Reverse-Integer -10) -ne -1) { throw \"Test case 6 failed\" }\n\n}\n\nCheck-ReverseInteger", "entry_point": "Reverse-Integer", "signature": "function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n\n\n* Incomplete Code:\nfunction Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\n\n$isNegative = $x -lt 0\nif ($isNegative) {\n[MASK]\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n[MASK]\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}"}
{"task_id": "PowerShell/11-0-single", "prompt": "function Is-PalindromeNumber {\n<#\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}", "test": "function Check-PalindromeNumber() {\nif ((Is-PalindromeNumber 121) -ne $true) { throw \"Test case 1 failed\" }\nif ((Is-PalindromeNumber -121) -ne $false) { throw \"Test case 2 failed\" }\nif ((Is-PalindromeNumber 10) -ne $false) { throw \"Test case 3 failed\" }\nif ((Is-PalindromeNumber 1221) -ne $true) { throw \"Test case 4 failed\" }\nif ((Is-PalindromeNumber 12321) -ne $true) { throw \"Test case 5 failed\" }\nif ((Is-PalindromeNumber 123321) -ne $true) { throw \"Test case 6 failed\" }\nif ((Is-PalindromeNumber 0) -ne $true) { throw \"Test case 7 failed\" }\nif ((Is-PalindromeNumber 123) -ne $false) { throw \"Test case 8 failed\" }\nif ((Is-PalindromeNumber 1) -ne $true) { throw \"Test case 9 failed\" }\nif ((Is-PalindromeNumber 1000021) -ne $false) { throw \"Test case 10 failed\" }\n}\n\nCheck-PalindromeNumber", "entry_point": "Is-PalindromeNumber", "signature": "function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n\n\n* Incomplete Code:\nfunction Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\nif ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\n[MASK]\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\n[MASK]\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}"}
{"task_id": "PowerShell/11-1-single", "prompt": "function Is-PalindromeNumber {\n<#\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}", "test": "function Check-PalindromeNumber() {\nif ((Is-PalindromeNumber 121) -ne $true) { throw \"Test case 1 failed\" }\nif ((Is-PalindromeNumber -121) -ne $false) { throw \"Test case 2 failed\" }\nif ((Is-PalindromeNumber 10) -ne $false) { throw \"Test case 3 failed\" }\nif ((Is-PalindromeNumber 1221) -ne $true) { throw \"Test case 4 failed\" }\nif ((Is-PalindromeNumber 12321) -ne $true) { throw \"Test case 5 failed\" }\nif ((Is-PalindromeNumber 123321) -ne $true) { throw \"Test case 6 failed\" }\nif ((Is-PalindromeNumber 0) -ne $true) { throw \"Test case 7 failed\" }\nif ((Is-PalindromeNumber 123) -ne $false) { throw \"Test case 8 failed\" }\nif ((Is-PalindromeNumber 1) -ne $true) { throw \"Test case 9 failed\" }\nif ((Is-PalindromeNumber 1000021) -ne $false) { throw \"Test case 10 failed\" }\n}\n\nCheck-PalindromeNumber", "entry_point": "Is-PalindromeNumber", "signature": "function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n\n\n* Incomplete Code:\nfunction Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\n[MASK]\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}"}
{"task_id": "PowerShell/12-0-single", "prompt": "function Max-WaterContainer {\n<#\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "canonical_solution": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}", "test": "function Check-MaxWaterContainer() {\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))) -ne 49) { throw \"Test case 1 failed\" }\nif ((Max-WaterContainer @([int[]](1, 1))) -ne 1) { throw \"Test case 2 failed\" }\nif ((Max-WaterContainer @([int[]](4, 3, 2, 1, 4))) -ne 16) { throw \"Test case 3 failed\" }\nif ((Max-WaterContainer @([int[]](1, 2, 4, 3))) -ne 4) { throw \"Test case 4 failed\" }\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 25, 7))) -ne 49) { throw \"Test case 5 failed\" }\nif ((Max-WaterContainer @([int[]](1, 3, 2, 5, 25, 24, 5))) -ne 24) { throw \"Test case 6 failed\" }\n}\n\nCheck-MaxWaterContainer", "entry_point": "Max-WaterContainer", "signature": "function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "docstring": "\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n\n\n* Incomplete Code:\nfunction Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)\n$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n[MASK]\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n[MASK]\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}"}
{"task_id": "PowerShell/12-1-single", "prompt": "function Max-WaterContainer {\n<#\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "canonical_solution": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}", "test": "function Check-MaxWaterContainer() {\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))) -ne 49) { throw \"Test case 1 failed\" }\nif ((Max-WaterContainer @([int[]](1, 1))) -ne 1) { throw \"Test case 2 failed\" }\nif ((Max-WaterContainer @([int[]](4, 3, 2, 1, 4))) -ne 16) { throw \"Test case 3 failed\" }\nif ((Max-WaterContainer @([int[]](1, 2, 4, 3))) -ne 4) { throw \"Test case 4 failed\" }\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 25, 7))) -ne 49) { throw \"Test case 5 failed\" }\nif ((Max-WaterContainer @([int[]](1, 3, 2, 5, 25, 24, 5))) -ne 24) { throw \"Test case 6 failed\" }\n}\n\nCheck-MaxWaterContainer", "entry_point": "Max-WaterContainer", "signature": "function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "docstring": "\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n\n\n* Incomplete Code:\nfunction Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)\n$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/13-0-single", "prompt": "function Remove-Element {\n<#\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "canonical_solution": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}", "test": "function Check-RemoveElement() {\n#if ((Remove-Element @(3, 2, 2, 3) 3) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-Element @(1, 2, 3, 4, 5) 6) -ne 5) { throw \"Test case 3 failed\" }\nif ((Remove-Element @(1, 1, 1) 1) -ne 0) { throw \"Test case 4 failed\" }\nif ((Remove-Element @(2, 2, 3, 3) 2) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nCheck-RemoveElement", "entry_point": "Remove-Element", "signature": "function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "docstring": "\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n\n\n* Incomplete Code:\nfunction Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)\n$i = 0\n[MASK]\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$i = 0\n[MASK]\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}"}
{"task_id": "PowerShell/13-1-single", "prompt": "function Remove-Element {\n<#\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "canonical_solution": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}", "test": "function Check-RemoveElement() {\n#if ((Remove-Element @(3, 2, 2, 3) 3) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-Element @(1, 2, 3, 4, 5) 6) -ne 5) { throw \"Test case 3 failed\" }\nif ((Remove-Element @(1, 1, 1) 1) -ne 0) { throw \"Test case 4 failed\" }\nif ((Remove-Element @(2, 2, 3, 3) 2) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nCheck-RemoveElement", "entry_point": "Remove-Element", "signature": "function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "docstring": "\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n\n\n* Incomplete Code:\nfunction Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)\n$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\n[MASK]\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\n[MASK]\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}"}
{"task_id": "PowerShell/14-0-single", "prompt": "function Count-GoodIntegers {\n<#\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "canonical_solution": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}", "test": "function Check-GoodIntegers() {\nif ((Count-GoodIntegers \"25\" \"30\" 7 5) -ne 1) { throw \"Test case 1 failed\" }\nif ((Count-GoodIntegers \"1\" \"12\" 8 1) -ne 11) { throw \"Test case 2 failed\" }\nif ((Count-GoodIntegers \"1\" \"5\" 5 1) -ne 5) { throw \"Test case 3 failed\" }\n}\n\nCheck-GoodIntegers", "entry_point": "Count-GoodIntegers", "signature": "function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "docstring": "\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n\n\n* Incomplete Code:\nfunction Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)\n$mod = 1000000007\n[MASK]\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$mod = 1000000007\n[MASK]\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}"}
{"task_id": "PowerShell/14-1-single", "prompt": "function Count-GoodIntegers {\n<#\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "canonical_solution": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}", "test": "function Check-GoodIntegers() {\nif ((Count-GoodIntegers \"25\" \"30\" 7 5) -ne 1) { throw \"Test case 1 failed\" }\nif ((Count-GoodIntegers \"1\" \"12\" 8 1) -ne 11) { throw \"Test case 2 failed\" }\nif ((Count-GoodIntegers \"1\" \"5\" 5 1) -ne 5) { throw \"Test case 3 failed\" }\n}\n\nCheck-GoodIntegers", "entry_point": "Count-GoodIntegers", "signature": "function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "docstring": "\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n\n\n* Incomplete Code:\nfunction Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)\n$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\n[MASK]\n$count++\n}\n}\n\nreturn $count % $mod\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\n[MASK]\n$count++\n}\n}\n\nreturn $count % $mod\n}"}
{"task_id": "PowerShell/15-0-single", "prompt": "function Count-WordFrequency {\n<# Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"#>", "canonical_solution": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}", "test": "function Test-CountWordFrequency {\n# Test function for Count-WordFrequency\n# Create a sample frequency.txt file\n\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n\n# Expected output\n$expected_output = \"apple 3\\nbanana 3\" -split \"\\n\"\n\n# Actual output from the function\n$actual_output = Count-WordFrequency\n\n# Compare actual output to expected output\nif ($actual_output -join \"`n\" -eq $expected_output -join \"`n\") {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item frequency.txt\n}\n\n# Call the test function\nTest-CountWordFrequency", "entry_point": "Count-WordFrequency", "signature": "function Count-WordFrequency {\n", "docstring": " Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"\n\n* Incomplete Code:\nfunction Count-WordFrequency {\n\n$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\n[MASK]\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\n[MASK]\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}"}
{"task_id": "PowerShell/15-1-single", "prompt": "function Count-WordFrequency {\n<# Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"#>", "canonical_solution": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}", "test": "function Test-CountWordFrequency {\n# Test function for Count-WordFrequency\n# Create a sample frequency.txt file\n\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n\n# Expected output\n$expected_output = \"apple 3\\nbanana 3\" -split \"\\n\"\n\n# Actual output from the function\n$actual_output = Count-WordFrequency\n\n# Compare actual output to expected output\nif ($actual_output -join \"`n\" -eq $expected_output -join \"`n\") {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item frequency.txt\n}\n\n# Call the test function\nTest-CountWordFrequency", "entry_point": "Count-WordFrequency", "signature": "function Count-WordFrequency {\n", "docstring": " Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"\n\n* Incomplete Code:\nfunction Count-WordFrequency {\n\n$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n[MASK]\n\"$($_.Key) $($_.Value)\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n[MASK]\n\"$($_.Key) $($_.Value)\"\n}\n}"}
{"task_id": "PowerShell/17-0-single", "prompt": "function Transpose-File {\n<# Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"#>", "canonical_solution": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}", "test": "function Test-TransposeFile {\n# Test function for Transpose-File\n# Create a sample file.txt file\n\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n# Actual output from the function\n$actual_output = Transpose-File\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-TransposeFile", "entry_point": "Transpose-File", "signature": "function Transpose-File {\n", "docstring": " Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n* Incomplete Code:\nfunction Transpose-File {\n\n[MASK]\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}"}
{"task_id": "PowerShell/17-1-single", "prompt": "function Transpose-File {\n<# Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"#>", "canonical_solution": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}", "test": "function Test-TransposeFile {\n# Test function for Transpose-File\n# Create a sample file.txt file\n\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n# Actual output from the function\n$actual_output = Transpose-File\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-TransposeFile", "entry_point": "Transpose-File", "signature": "function Transpose-File {\n", "docstring": " Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n* Incomplete Code:\nfunction Transpose-File {\n\n$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n[MASK]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n[MASK]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}"}
{"task_id": "PowerShell/19-0-single", "prompt": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n<#\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n#>", "canonical_solution": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}", "test": "function Test-TotalCoins() {\nif ((Get-TotalCoins -days 7) -ne 18) { throw \"Test case 1 failed\" }\nif ((Get-TotalCoins -days 10) -ne 30) { throw \"Test case 2 failed\" }\nif ((Get-TotalCoins -days 15) -ne 55) { throw \"Test case 3 failed\" }\nif ((Get-TotalCoins -days 20) -ne 85) { throw \"Test case 4 failed\" }\nif ((Get-TotalCoins -days 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Get-TotalCoins -days 3) -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-TotalCoins -days 5) -ne 11) { throw \"Test case 7 failed\" }\n}\n\nTest-TotalCoins", "entry_point": "Get-TotalCoins", "signature": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n", "docstring": "\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n\n\n* Incomplete Code:\nfunction Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n\n$totalCoins = 0\n[MASK]\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$totalCoins = 0\n[MASK]\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}"}
{"task_id": "PowerShell/19-1-single", "prompt": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n<#\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n#>", "canonical_solution": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}", "test": "function Test-TotalCoins() {\nif ((Get-TotalCoins -days 7) -ne 18) { throw \"Test case 1 failed\" }\nif ((Get-TotalCoins -days 10) -ne 30) { throw \"Test case 2 failed\" }\nif ((Get-TotalCoins -days 15) -ne 55) { throw \"Test case 3 failed\" }\nif ((Get-TotalCoins -days 20) -ne 85) { throw \"Test case 4 failed\" }\nif ((Get-TotalCoins -days 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Get-TotalCoins -days 3) -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-TotalCoins -days 5) -ne 11) { throw \"Test case 7 failed\" }\n}\n\nTest-TotalCoins", "entry_point": "Get-TotalCoins", "signature": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n", "docstring": "\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n\n\n* Incomplete Code:\nfunction Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n\n$totalCoins = 0\n$currentCoins = 1\n[MASK]\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$totalCoins = 0\n$currentCoins = 1\n[MASK]\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}"}
{"task_id": "PowerShell/20-0-single", "prompt": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n<#\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n#>", "canonical_solution": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}", "test": "# Test cases\nfunction Test-MinesweeperGrid() {\n$test1 = Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n$expected1 = @(\"*10\", \"221\", \"1*1\")\n\n$test2 = Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n$expected2 = @(\"2*1\", \"*21\")\n\nif (Compare-Object $test1 $expected1) { throw \"Test case 1 failed\" }\nif (Compare-Object $test2 $expected2) { throw \"Test case 2 failed\" }\n}\n\nTest-MinesweeperGrid", "entry_point": "Get-MinesweeperGrid", "signature": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n", "docstring": "\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n\n\n* Incomplete Code:\nfunction Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n\n$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\n[MASK]\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\n[MASK]\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}"}
{"task_id": "PowerShell/20-1-single", "prompt": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n<#\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n#>", "canonical_solution": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}", "test": "# Test cases\nfunction Test-MinesweeperGrid() {\n$test1 = Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n$expected1 = @(\"*10\", \"221\", \"1*1\")\n\n$test2 = Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n$expected2 = @(\"2*1\", \"*21\")\n\nif (Compare-Object $test1 $expected1) { throw \"Test case 1 failed\" }\nif (Compare-Object $test2 $expected2) { throw \"Test case 2 failed\" }\n}\n\nTest-MinesweeperGrid", "entry_point": "Get-MinesweeperGrid", "signature": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n", "docstring": "\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n\n\n* Incomplete Code:\nfunction Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n\n$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n[MASK]\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n[MASK]\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}"}
{"task_id": "PowerShell/21-0-single", "prompt": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n<#\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n#>", "canonical_solution": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}", "test": "function Test-MinimumCowsForHeight() {\nif ((Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5))))) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18))))) -ne 3) { throw \"Test case 2 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 45 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](9, 15, 8, 17, 6))))) -ne 4) { throw \"Test case 3 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 70 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](22, 27, 15, 10, 18))))) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MinimumCowsForHeight", "entry_point": "Get-MinimumCowsForHeight", "signature": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n", "docstring": "\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n\n\n* Incomplete Code:\nfunction Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n\n$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/21-1-single", "prompt": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n<#\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n#>", "canonical_solution": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}", "test": "function Test-MinimumCowsForHeight() {\nif ((Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5))))) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18))))) -ne 3) { throw \"Test case 2 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 45 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](9, 15, 8, 17, 6))))) -ne 4) { throw \"Test case 3 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 70 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](22, 27, 15, 10, 18))))) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MinimumCowsForHeight", "entry_point": "Get-MinimumCowsForHeight", "signature": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n", "docstring": "\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n\n\n* Incomplete Code:\nfunction Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n\n[MASK]\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}"}
{"task_id": "PowerShell/22-0-single", "prompt": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n<#\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n#>", "canonical_solution": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}", "test": "# Test cases\nfunction Test-MaximumScore() {\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 200) -ne 1400) { throw \"Test case 1 failed\" }\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 300) -ne 1600) { throw \"Test case 2 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 150 -scoreBlueInBlue 200 -scoreCrossColor 100) -ne 850) { throw \"Test case 3 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 3 -scoreRedInRed 150 -scoreBlueInBlue 300 -scoreCrossColor 200) -ne 1350) { throw \"Test case 4 failed\" }\n}\n\nTest-MaximumScore", "entry_point": "Get-MaximumScore", "signature": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n", "docstring": "\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n\n\n* Incomplete Code:\nfunction Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n\n[MASK]\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}"}
{"task_id": "PowerShell/22-1-single", "prompt": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n<#\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n#>", "canonical_solution": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}", "test": "# Test cases\nfunction Test-MaximumScore() {\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 200) -ne 1400) { throw \"Test case 1 failed\" }\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 300) -ne 1600) { throw \"Test case 2 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 150 -scoreBlueInBlue 200 -scoreCrossColor 100) -ne 850) { throw \"Test case 3 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 3 -scoreRedInRed 150 -scoreBlueInBlue 300 -scoreCrossColor 200) -ne 1350) { throw \"Test case 4 failed\" }\n}\n\nTest-MaximumScore", "entry_point": "Get-MaximumScore", "signature": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n", "docstring": "\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n\n\n* Incomplete Code:\nfunction Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n\n$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n[MASK]\n\nreturn $maxScore\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n[MASK]\n\nreturn $maxScore\n}"}
{"task_id": "PowerShell/23-0-single", "prompt": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n<#\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n#>", "canonical_solution": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}", "test": "function Test-MostFrequentDiceSum() {\nif ((Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3) -ne 5) { throw \"Test case 1 failed\" }\nif ((Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6) -ne 8) { throw \"Test case 2 failed\" }\nif ((Get-MostFrequentDiceSum -s1 6 -s2 6 -s3 6) -ne 10) { throw \"Test case 3 failed\" }\nif ((Get-MostFrequentDiceSum -s1 2 -s2 2 -s3 2) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MostFrequentDiceSum", "entry_point": "Get-MostFrequentDiceSum", "signature": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n", "docstring": "\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n\n\n* Incomplete Code:\nfunction Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n\n$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/23-1-single", "prompt": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n<#\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n#>", "canonical_solution": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}", "test": "function Test-MostFrequentDiceSum() {\nif ((Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3) -ne 5) { throw \"Test case 1 failed\" }\nif ((Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6) -ne 8) { throw \"Test case 2 failed\" }\nif ((Get-MostFrequentDiceSum -s1 6 -s2 6 -s3 6) -ne 10) { throw \"Test case 3 failed\" }\nif ((Get-MostFrequentDiceSum -s1 2 -s2 2 -s3 2) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MostFrequentDiceSum", "entry_point": "Get-MostFrequentDiceSum", "signature": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n", "docstring": "\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n\n\n* Incomplete Code:\nfunction Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n\n$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n[MASK]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n[MASK]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}"}
{"task_id": "PowerShell/24-0-single", "prompt": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n<#\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n#>", "canonical_solution": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}", "test": "function Test-DetermineParity() {\n$result1 = Determine-Parity @(\"1024\", \"5931\")\n\nif (Compare-Object $result1 @(\"even\", \"odd\")) { throw \"Test case 1 failed\" }\n\n$result2 = Determine-Parity @(\"123456789012345678901234567890\", \"123456789012345678901234567891\")\nif (Compare-Object $result2 @(\"even\", \"odd\")) { throw \"Test case 2 failed\" }\n}\n\nTest-DetermineParity", "entry_point": "Determine-Parity", "signature": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n", "docstring": "\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n\n\n* Incomplete Code:\nfunction Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n\n$result = @()\n\nforeach ($number in $numbers) {\n[MASK]\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = @()\n\nforeach ($number in $numbers) {\n[MASK]\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/24-1-single", "prompt": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n<#\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n#>", "canonical_solution": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}", "test": "function Test-DetermineParity() {\n$result1 = Determine-Parity @(\"1024\", \"5931\")\n\nif (Compare-Object $result1 @(\"even\", \"odd\")) { throw \"Test case 1 failed\" }\n\n$result2 = Determine-Parity @(\"123456789012345678901234567890\", \"123456789012345678901234567891\")\nif (Compare-Object $result2 @(\"even\", \"odd\")) { throw \"Test case 2 failed\" }\n}\n\nTest-DetermineParity", "entry_point": "Determine-Parity", "signature": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n", "docstring": "\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n\n\n* Incomplete Code:\nfunction Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n\n$result = @()\n\n[MASK]\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = @()\n\n[MASK]\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/25-0-single", "prompt": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n<#\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n#>", "canonical_solution": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\nreturn $results\n}", "test": "function Test-StudentIDsByOrder() {\n$result1 = Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\nif (Compare-Object $result1 @(1, 8, 5)) { throw \"Test case 1 failed\" }\n\n$result2 = Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\nif (Compare-Object $result2 @(15, 22)) { throw \"Test case 2 failed\" }\n}\n\nTest-StudentIDsByOrder", "entry_point": "Get-StudentIDsByOrder", "signature": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n", "docstring": "\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n\n\n* Incomplete Code:\nfunction Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n\n$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/25-1-single", "prompt": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n<#\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n#>", "canonical_solution": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\nreturn $results\n}", "test": "function Test-StudentIDsByOrder() {\n$result1 = Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\nif (Compare-Object $result1 @(1, 8, 5)) { throw \"Test case 1 failed\" }\n\n$result2 = Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\nif (Compare-Object $result2 @(15, 22)) { throw \"Test case 2 failed\" }\n}\n\nTest-StudentIDsByOrder", "entry_point": "Get-StudentIDsByOrder", "signature": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n", "docstring": "\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n\n\n* Incomplete Code:\nfunction Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n\n$results = @()\n\nforeach ($query in $queries) {\n[MASK]\n}\n\nreturn $results\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$results = @()\n\nforeach ($query in $queries) {\n[MASK]\n}\n\nreturn $results\n}"}
{"task_id": "PowerShell/26-0-single", "prompt": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n<#\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n#>", "canonical_solution": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\nreturn $vkCount\n}", "test": "function Test-MaximizeVKOccurrences() {\nif ((Maximize-VKOccurrences -inputString \"VK\") -ne 1) { throw \"Test case 1 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VV\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Maximize-VKOccurrences -inputString \"V\") -ne 0) { throw \"Test case 3 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\") -ne 3) { throw \"Test case 4 failed\" }\nif ((Maximize-VKOccurrences -inputString \"KVKV\") -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-MaximizeVKOccurrences", "entry_point": "Maximize-VKOccurrences", "signature": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n", "docstring": "\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n\n\n* Incomplete Code:\nfunction Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n\n$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n[MASK]\n}\n\nreturn $vkCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n[MASK]\n}\n\nreturn $vkCount\n}"}
{"task_id": "PowerShell/26-1-single", "prompt": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n<#\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n#>", "canonical_solution": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\nreturn $vkCount\n}", "test": "function Test-MaximizeVKOccurrences() {\nif ((Maximize-VKOccurrences -inputString \"VK\") -ne 1) { throw \"Test case 1 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VV\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Maximize-VKOccurrences -inputString \"V\") -ne 0) { throw \"Test case 3 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\") -ne 3) { throw \"Test case 4 failed\" }\nif ((Maximize-VKOccurrences -inputString \"KVKV\") -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-MaximizeVKOccurrences", "entry_point": "Maximize-VKOccurrences", "signature": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n", "docstring": "\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n\n\n* Incomplete Code:\nfunction Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n\n$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/29-0-single", "prompt": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n<#\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n#>", "canonical_solution": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}", "test": "function Test-MinimumSegments() {\nif ((Get-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumSegments -numbers @(1, 2, 3, 4, 5) -maxSum 10) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MinimumSegments -numbers @(10, 10, 10) -maxSum 10) -ne 3) { throw \"Test case 3 failed\" }\n}\n\nTest-MinimumSegments", "entry_point": "Get-MinimumSegments", "signature": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n", "docstring": "\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n\n\n* Incomplete Code:\nfunction Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n\n$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\n[MASK]\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\n[MASK]\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}"}
{"task_id": "PowerShell/29-1-single", "prompt": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n<#\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n#>", "canonical_solution": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}", "test": "function Test-MinimumSegments() {\nif ((Get-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumSegments -numbers @(1, 2, 3, 4, 5) -maxSum 10) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MinimumSegments -numbers @(10, 10, 10) -maxSum 10) -ne 3) { throw \"Test case 3 failed\" }\n}\n\nTest-MinimumSegments", "entry_point": "Get-MinimumSegments", "signature": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n", "docstring": "\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n\n\n* Incomplete Code:\nfunction Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n\n$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n[MASK]\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n[MASK]\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}"}
{"task_id": "PowerShell/30-0-single", "prompt": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n<#\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n#>", "canonical_solution": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}", "test": "function Test-MaxDaysTogether() {\nif ((Get-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")) -ne 1) { throw \"Test case 1 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Park\", \"Mall\") -herLocations @(\"Park\", \"School\", \"Mall\", \"Home\")) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Library\", \"Cafe\") -herLocations @(\"Home\", \"School\", \"Gym\")) -ne 0) { throw \"Test case 3 failed\" }\n}\n\nTest-MaxDaysTogether", "entry_point": "Get-MaxDaysTogether", "signature": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n", "docstring": "\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n\n\n* Incomplete Code:\nfunction Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n\n$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\n[MASK]\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\n[MASK]\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}"}
{"task_id": "PowerShell/30-1-single", "prompt": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n<#\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n#>", "canonical_solution": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}", "test": "function Test-MaxDaysTogether() {\nif ((Get-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")) -ne 1) { throw \"Test case 1 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Park\", \"Mall\") -herLocations @(\"Park\", \"School\", \"Mall\", \"Home\")) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Library\", \"Cafe\") -herLocations @(\"Home\", \"School\", \"Gym\")) -ne 0) { throw \"Test case 3 failed\" }\n}\n\nTest-MaxDaysTogether", "entry_point": "Get-MaxDaysTogether", "signature": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n", "docstring": "\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n\n\n* Incomplete Code:\nfunction Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n\n$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/31-0-single", "prompt": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n<#\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n#>", "canonical_solution": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}", "test": "function Test-ModelSurfaceArea {\nif ((Calculate-ModelSurfaceArea 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))) -ne 38) { throw \"Test case 1 failed\" }\nif ((Calculate-ModelSurfaceArea 2 2 @(@(1,0), @(0,1))) -ne 12) { throw \"Test case 2 failed\" }\nif ((Calculate-ModelSurfaceArea 2 3 @(@(2,3,2), @(1,0,1))) -ne 34) { throw \"Test case 3 failed\" }\nif ((Calculate-ModelSurfaceArea 4 4 @(@(0,0,0,0), @(0,2,2,0), @(0,2,2,0), @(0,0,0,0))) -ne 24) { throw \"Test case 4 failed\" }\n}\n\nTest-ModelSurfaceArea", "entry_point": "Calculate-ModelSurfaceArea", "signature": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n", "docstring": "\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n\n\n* Incomplete Code:\nfunction Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n\n$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n[MASK]\n}\n}\n}\n\nreturn $totalArea\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n[MASK]\n}\n}\n}\n\nreturn $totalArea\n}"}
{"task_id": "PowerShell/31-1-single", "prompt": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n<#\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n#>", "canonical_solution": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}", "test": "function Test-ModelSurfaceArea {\nif ((Calculate-ModelSurfaceArea 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))) -ne 38) { throw \"Test case 1 failed\" }\nif ((Calculate-ModelSurfaceArea 2 2 @(@(1,0), @(0,1))) -ne 12) { throw \"Test case 2 failed\" }\nif ((Calculate-ModelSurfaceArea 2 3 @(@(2,3,2), @(1,0,1))) -ne 34) { throw \"Test case 3 failed\" }\nif ((Calculate-ModelSurfaceArea 4 4 @(@(0,0,0,0), @(0,2,2,0), @(0,2,2,0), @(0,0,0,0))) -ne 24) { throw \"Test case 4 failed\" }\n}\n\nTest-ModelSurfaceArea", "entry_point": "Calculate-ModelSurfaceArea", "signature": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n", "docstring": "\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n\n\n* Incomplete Code:\nfunction Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n\n$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\n[MASK]\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\n[MASK]\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}"}
{"task_id": "PowerShell/32-0-single", "prompt": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n<#\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n#>", "canonical_solution": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}", "test": "function Test-WaterCollectionTime {\nif ((Calculate-WaterCollectionTime 4 2 @(3, 3, 4, 4)) -ne 7) { throw \"Test case 1 failed\" }\nif ((Calculate-WaterCollectionTime 3 1 @(2, 3, 4)) -ne 9) { throw \"Test case 2 failed\" }\nif ((Calculate-WaterCollectionTime 6 3 @(1, 2, 2, 3, 1, 4)) -ne 6) { throw \"Test case 3 failed\" }\nif ((Calculate-WaterCollectionTime 2 2 @(5, 6)) -ne 6) { throw \"Test case 4 failed\" }\nif ((Calculate-WaterCollectionTime 5 3 @(1, 1, 1, 1, 1)) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nTest-WaterCollectionTime", "entry_point": "Calculate-WaterCollectionTime", "signature": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n", "docstring": "\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n\n\n* Incomplete Code:\nfunction Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n\n$queue = New-Object System.Collections.Queue\n$totalTime = 0\n[MASK]\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n[MASK]\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}"}
{"task_id": "PowerShell/32-1-single", "prompt": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n<#\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n#>", "canonical_solution": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}", "test": "function Test-WaterCollectionTime {\nif ((Calculate-WaterCollectionTime 4 2 @(3, 3, 4, 4)) -ne 7) { throw \"Test case 1 failed\" }\nif ((Calculate-WaterCollectionTime 3 1 @(2, 3, 4)) -ne 9) { throw \"Test case 2 failed\" }\nif ((Calculate-WaterCollectionTime 6 3 @(1, 2, 2, 3, 1, 4)) -ne 6) { throw \"Test case 3 failed\" }\nif ((Calculate-WaterCollectionTime 2 2 @(5, 6)) -ne 6) { throw \"Test case 4 failed\" }\nif ((Calculate-WaterCollectionTime 5 3 @(1, 1, 1, 1, 1)) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nTest-WaterCollectionTime", "entry_point": "Calculate-WaterCollectionTime", "signature": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n", "docstring": "\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n\n\n* Incomplete Code:\nfunction Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n\n$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n[MASK]\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n[MASK]\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}"}
{"task_id": "PowerShell/33-0-single", "prompt": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n<#\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n#>", "canonical_solution": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}", "test": "# Test cases\nfunction Test-WaysToClimb {\nif ((Calculate-WaysToClimb 4 2) -ne 5) { throw \"Test case 1 failed\" }\nif ((Calculate-WaysToClimb 3 3) -ne 4) { throw \"Test case 2 failed\" }\nif ((Calculate-WaysToClimb 6 3) -ne 24) { throw \"Test case 3 failed\" }\nif ((Calculate-WaysToClimb 7 4) -ne 56) { throw \"Test case 4 failed\" }\nif ((Calculate-WaysToClimb 10 5) -ne 464) { throw \"Test case 5 failed\" }\n}\n\nTest-WaysToClimb", "entry_point": "Calculate-WaysToClimb", "signature": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n", "docstring": "\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n\n\n* Incomplete Code:\nfunction Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n\n$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\n[MASK]\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\n[MASK]\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}"}
{"task_id": "PowerShell/33-1-single", "prompt": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n<#\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n#>", "canonical_solution": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}", "test": "# Test cases\nfunction Test-WaysToClimb {\nif ((Calculate-WaysToClimb 4 2) -ne 5) { throw \"Test case 1 failed\" }\nif ((Calculate-WaysToClimb 3 3) -ne 4) { throw \"Test case 2 failed\" }\nif ((Calculate-WaysToClimb 6 3) -ne 24) { throw \"Test case 3 failed\" }\nif ((Calculate-WaysToClimb 7 4) -ne 56) { throw \"Test case 4 failed\" }\nif ((Calculate-WaysToClimb 10 5) -ne 464) { throw \"Test case 5 failed\" }\n}\n\nTest-WaysToClimb", "entry_point": "Calculate-WaysToClimb", "signature": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n", "docstring": "\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n\n\n* Incomplete Code:\nfunction Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n\n$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n[MASK]\n}\n}\n}\n\nreturn $ways[$N]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n[MASK]\n}\n}\n}\n\nreturn $ways[$N]\n}"}
{"task_id": "PowerShell/34-0-single", "prompt": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n<#\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n#>", "canonical_solution": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}", "test": "function Test-MinimumMilkCost() {\n$farmers1 = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n$result1 = Get-MinimumMilkCost 100 $farmers1\nGet-MinimumMilkCost 100 $farmers1\nif ($result1 -ne 570) { throw \"Test case 1 failed: Expected 580, got $result1\" }\n\n$farmers2 = @([PSCustomObject]@{price=10; quantity=30}, [PSCustomObject]@{price=7; quantity=60}, [PSCustomObject]@{price=2; quantity=40})\n$result2 = Get-MinimumMilkCost 50 $farmers2\nif ($result2 -ne 150) { throw \"Test case 2 failed: Expected 140, got $result2\" }\n\n$farmers3 = @([PSCustomObject]@{price=8; quantity=25}, [PSCustomObject]@{price=5; quantity=55}, [PSCustomObject]@{price=6; quantity=20})\n$result3 = Get-MinimumMilkCost 75 $farmers3\nif ($result3 -ne 395) { throw \"Test case 3 failed: Expected 430, got $result3\" }\n}\n\nTest-MinimumMilkCost", "entry_point": "Get-MinimumMilkCost", "signature": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n", "docstring": "\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n\n\n* Incomplete Code:\nfunction Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n\n[MASK]\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}"}
{"task_id": "PowerShell/34-1-single", "prompt": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n<#\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n#>", "canonical_solution": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}", "test": "function Test-MinimumMilkCost() {\n$farmers1 = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n$result1 = Get-MinimumMilkCost 100 $farmers1\nGet-MinimumMilkCost 100 $farmers1\nif ($result1 -ne 570) { throw \"Test case 1 failed: Expected 580, got $result1\" }\n\n$farmers2 = @([PSCustomObject]@{price=10; quantity=30}, [PSCustomObject]@{price=7; quantity=60}, [PSCustomObject]@{price=2; quantity=40})\n$result2 = Get-MinimumMilkCost 50 $farmers2\nif ($result2 -ne 150) { throw \"Test case 2 failed: Expected 140, got $result2\" }\n\n$farmers3 = @([PSCustomObject]@{price=8; quantity=25}, [PSCustomObject]@{price=5; quantity=55}, [PSCustomObject]@{price=6; quantity=20})\n$result3 = Get-MinimumMilkCost 75 $farmers3\nif ($result3 -ne 395) { throw \"Test case 3 failed: Expected 430, got $result3\" }\n}\n\nTest-MinimumMilkCost", "entry_point": "Get-MinimumMilkCost", "signature": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n", "docstring": "\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n\n\n* Incomplete Code:\nfunction Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n\n$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\n[MASK]\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\n[MASK]\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}"}
{"task_id": "PowerShell/35-0-single", "prompt": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n<#\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n#>", "canonical_solution": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}", "test": "function Test-MaxPathSum() {\n$pyramid1 = @( @(3), @(7, 4), @(2, 4, 6), @(8, 5, 9, 3) )\n$result1 = Get-MaxPathSum $pyramid1\nif ($result1 -ne 23) { throw \"Test case 1 failed: Expected 23, got $result1\" }\n\n$pyramid2 = @( @(1), @(2, 1), @(1, 2, 1) )\n$result2 = Get-MaxPathSum $pyramid2\nif ($result2 -ne 5) { throw \"Test case 2 failed: Expected 4, got $result2\" }\n\n$pyramid3 = @( @(1) )\n$result3 = Get-MaxPathSum $pyramid3\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 1, got $result3\" }\n}\n\nTest-MaxPathSum", "entry_point": "Get-MaxPathSum", "signature": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n", "docstring": "\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n\n\n* Incomplete Code:\nfunction Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n\n\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n[MASK]\n}\n}\n\nreturn $pyramid[0][0]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n[MASK]\n}\n}\n\nreturn $pyramid[0][0]\n}"}
{"task_id": "PowerShell/35-1-single", "prompt": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n<#\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n#>", "canonical_solution": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}", "test": "function Test-MaxPathSum() {\n$pyramid1 = @( @(3), @(7, 4), @(2, 4, 6), @(8, 5, 9, 3) )\n$result1 = Get-MaxPathSum $pyramid1\nif ($result1 -ne 23) { throw \"Test case 1 failed: Expected 23, got $result1\" }\n\n$pyramid2 = @( @(1), @(2, 1), @(1, 2, 1) )\n$result2 = Get-MaxPathSum $pyramid2\nif ($result2 -ne 5) { throw \"Test case 2 failed: Expected 4, got $result2\" }\n\n$pyramid3 = @( @(1) )\n$result3 = Get-MaxPathSum $pyramid3\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 1, got $result3\" }\n}\n\nTest-MaxPathSum", "entry_point": "Get-MaxPathSum", "signature": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n", "docstring": "\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n\n\n* Incomplete Code:\nfunction Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n\n\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\n[MASK]\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\n[MASK]\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}"}
{"task_id": "PowerShell/36-0-single", "prompt": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n<#\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n#>", "canonical_solution": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}", "test": "function Test-OptimalQueueOrder() {\n$result1 = Get-OptimalQueueOrder @(20, 10, 30)\nif ((Compare-Object $result1 @(1, 0, 2))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-OptimalQueueOrder @(5, 3, 8)\nif ((Compare-Object $result2 @(1, 0, 2))) { throw \"Test case 2 failed\" }\n\n$result3 = Get-OptimalQueueOrder @(15, 5, 3, 7)\nif ((Compare-Object $result3 @(2, 1, 3, 0))) { throw \"Test case 3 failed\" }\n}\n\nTest-OptimalQueueOrder", "entry_point": "Get-OptimalQueueOrder", "signature": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n", "docstring": "\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n\n\n* Incomplete Code:\nfunction Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n\n$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n[MASK]\n}\n\nreturn $sortedIndices\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n[MASK]\n}\n\nreturn $sortedIndices\n}"}
{"task_id": "PowerShell/36-1-single", "prompt": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n<#\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n#>", "canonical_solution": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}", "test": "function Test-OptimalQueueOrder() {\n$result1 = Get-OptimalQueueOrder @(20, 10, 30)\nif ((Compare-Object $result1 @(1, 0, 2))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-OptimalQueueOrder @(5, 3, 8)\nif ((Compare-Object $result2 @(1, 0, 2))) { throw \"Test case 2 failed\" }\n\n$result3 = Get-OptimalQueueOrder @(15, 5, 3, 7)\nif ((Compare-Object $result3 @(2, 1, 3, 0))) { throw \"Test case 3 failed\" }\n}\n\nTest-OptimalQueueOrder", "entry_point": "Get-OptimalQueueOrder", "signature": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n", "docstring": "\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n\n\n* Incomplete Code:\nfunction Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n\n$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n[MASK]\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n[MASK]\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}"}
{"task_id": "PowerShell/37-0-single", "prompt": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n<#\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n#>", "canonical_solution": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}", "test": "function Test-SpecialPrimes() {\n$result1 = Get-SpecialPrimes 2\nif (-not (Compare-Object $result1 @(23, 29, 31, 37, 53, 59, 71, 73, 79, 97))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-SpecialPrimes 3\nif ($result2.Count -eq 0) { throw \"Test case 2 failed: No special primes found\" }\n}\n\nTest-SpecialPrimes", "entry_point": "Get-SpecialPrimes", "signature": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n", "docstring": "\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n\n\n* Incomplete Code:\nfunction Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n\nfunction Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\n[MASK]\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\n[MASK]\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}"}
{"task_id": "PowerShell/37-1-single", "prompt": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n<#\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n#>", "canonical_solution": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}", "test": "function Test-SpecialPrimes() {\n$result1 = Get-SpecialPrimes 2\nif (-not (Compare-Object $result1 @(23, 29, 31, 37, 53, 59, 71, 73, 79, 97))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-SpecialPrimes 3\nif ($result2.Count -eq 0) { throw \"Test case 2 failed: No special primes found\" }\n}\n\nTest-SpecialPrimes", "entry_point": "Get-SpecialPrimes", "signature": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n", "docstring": "\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n\n\n* Incomplete Code:\nfunction Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n\nfunction Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\n[MASK]\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\n[MASK]\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}"}
{"task_id": "PowerShell/38-0-single", "prompt": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n<#\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n#>", "canonical_solution": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}", "test": "function Test-ModPower() {\n$result1 = Calculate-ModPower 2 10 9\nif ($result1 -ne 7) { throw \"Test case 1 failed: Expected 2^10 mod 9=7, got $result1\" }\n\n$result2 = Calculate-ModPower 3 7 5\nif ($result2 -ne 2) { throw \"Test case 2 failed: Expected 3^7 mod 5=2, got $result2\" }\n\n$result3 = Calculate-ModPower 5 3 4\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 5^3 mod 4=1, got $result3\" }\n}\n\nTest-ModPower", "entry_point": "Calculate-ModPower", "signature": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n", "docstring": "\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n\n\n* Incomplete Code:\nfunction Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n\n$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/38-1-single", "prompt": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n<#\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n#>", "canonical_solution": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}", "test": "function Test-ModPower() {\n$result1 = Calculate-ModPower 2 10 9\nif ($result1 -ne 7) { throw \"Test case 1 failed: Expected 2^10 mod 9=7, got $result1\" }\n\n$result2 = Calculate-ModPower 3 7 5\nif ($result2 -ne 2) { throw \"Test case 2 failed: Expected 3^7 mod 5=2, got $result2\" }\n\n$result3 = Calculate-ModPower 5 3 4\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 5^3 mod 4=1, got $result3\" }\n}\n\nTest-ModPower", "entry_point": "Calculate-ModPower", "signature": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n", "docstring": "\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n\n\n* Incomplete Code:\nfunction Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n\n$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\n[MASK]\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\n[MASK]\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/39-0-single", "prompt": "function Find-MinimumSeriesSum {\n    <#\n    This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\n    The function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\n    Example:\n    >>> Find-MinimumSeriesSum -k 2\n    Returns the value of n for which the sum S_n exceeds 2.\n\n    >>> Find-MinimumSeriesSum -k 3\n    Returns the value of n for which the sum S_n exceeds 3.\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}", "test": "function Test-FindMinimumSeriesSum {\n    if ((Find-MinimumSeriesSum -k 2) -ne 4) { throw \"Test case 1 failed\" }\n    if ((Find-MinimumSeriesSum -k 3) -ne 11) { throw \"Test case 2 failed\" }\n    if ((Find-MinimumSeriesSum -k 4) -ne 31) { throw \"Test case 3 failed\" }\n    if ((Find-MinimumSeriesSum -k 5) -ne 83) { throw \"Test case 4 failed\" }\n    if ((Find-MinimumSeriesSum -k 6) -ne 227) { throw \"Test case 5 failed\" }\n}\n\nTest-FindMinimumSeriesSum", "entry_point": "Find-MinimumSeriesSum", "signature": "function Find-MinimumSeriesSum {", "docstring": "This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.\n\n* Incomplete Code:\nfunction Find-MinimumSeriesSum {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n[MASK]\n}"}
{"task_id": "PowerShell/39-1-single", "prompt": "function Find-MinimumSeriesSum {\n    <#\n    This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\n    The function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\n    Example:\n    >>> Find-MinimumSeriesSum -k 2\n    Returns the value of n for which the sum S_n exceeds 2.\n\n    >>> Find-MinimumSeriesSum -k 3\n    Returns the value of n for which the sum S_n exceeds 3.\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}", "test": "function Test-FindMinimumSeriesSum {\n    if ((Find-MinimumSeriesSum -k 2) -ne 4) { throw \"Test case 1 failed\" }\n    if ((Find-MinimumSeriesSum -k 3) -ne 11) { throw \"Test case 2 failed\" }\n    if ((Find-MinimumSeriesSum -k 4) -ne 31) { throw \"Test case 3 failed\" }\n    if ((Find-MinimumSeriesSum -k 5) -ne 83) { throw \"Test case 4 failed\" }\n    if ((Find-MinimumSeriesSum -k 6) -ne 227) { throw \"Test case 5 failed\" }\n}\n\nTest-FindMinimumSeriesSum", "entry_point": "Find-MinimumSeriesSum", "signature": "function Find-MinimumSeriesSum {", "docstring": "This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.\n\n* Incomplete Code:\nfunction Find-MinimumSeriesSum {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}"}
{"task_id": "PowerShell/40-0-single", "prompt": "function Get-MaxPens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}", "test": "function Test-GetMaxPens {\n    if ((Get-MaxPens -a 10 -b 3) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-MaxPens -a 20 -b 5) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-MaxPens -a 5 -b 9) -ne 3) { throw \"Test case 3 failed\" }\n    if ((Get-MaxPens -a 0 -b 19) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Get-MaxPens -a 7 -b 2) -ne 3) { throw \"Test case 5 failed\" }\n}\n\nTest-GetMaxPens", "entry_point": "Get-MaxPens", "signature": "function Get-MaxPens {", "docstring": "# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n\n* Incomplete Code:\nfunction Get-MaxPens {\n    param (\n[MASK]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    param (\n[MASK]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}"}
{"task_id": "PowerShell/40-1-single", "prompt": "function Get-MaxPens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}", "test": "function Test-GetMaxPens {\n    if ((Get-MaxPens -a 10 -b 3) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-MaxPens -a 20 -b 5) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-MaxPens -a 5 -b 9) -ne 3) { throw \"Test case 3 failed\" }\n    if ((Get-MaxPens -a 0 -b 19) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Get-MaxPens -a 7 -b 2) -ne 3) { throw \"Test case 5 failed\" }\n}\n\nTest-GetMaxPens", "entry_point": "Get-MaxPens", "signature": "function Get-MaxPens {", "docstring": "# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n\n* Incomplete Code:\nfunction Get-MaxPens {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}"}
{"task_id": "PowerShell/41-0-single", "prompt": "function Get-AbsoluteValue {\n    <#\n    This function takes an integer as input and returns its absolute value.\n\n    >>> Get-AbsoluteValue -n 5\n    5\n    >>> Get-AbsoluteValue -n -10\n    10\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}", "test": "function Test-GetAbsoluteValue {\n    if ((Get-AbsoluteValue -n 5) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-AbsoluteValue -n -10) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-AbsoluteValue -n 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Get-AbsoluteValue -n -20000) -ne 20000) { throw \"Test case 4 failed\" }\n    if ((Get-AbsoluteValue -n 10000) -ne 10000) { throw \"Test case 5 failed\" }\n}\n\nTest-GetAbsoluteValue", "entry_point": "Get-AbsoluteValue", "signature": "function Get-AbsoluteValue {", "docstring": "This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10\n\n* Incomplete Code:\nfunction Get-AbsoluteValue {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}"}
{"task_id": "PowerShell/41-1-single", "prompt": "function Get-AbsoluteValue {\n    <#\n    This function takes an integer as input and returns its absolute value.\n\n    >>> Get-AbsoluteValue -n 5\n    5\n    >>> Get-AbsoluteValue -n -10\n    10\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}", "test": "function Test-GetAbsoluteValue {\n    if ((Get-AbsoluteValue -n 5) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-AbsoluteValue -n -10) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-AbsoluteValue -n 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Get-AbsoluteValue -n -20000) -ne 20000) { throw \"Test case 4 failed\" }\n    if ((Get-AbsoluteValue -n 10000) -ne 10000) { throw \"Test case 5 failed\" }\n}\n\nTest-GetAbsoluteValue", "entry_point": "Get-AbsoluteValue", "signature": "function Get-AbsoluteValue {", "docstring": "This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10\n\n* Incomplete Code:\nfunction Get-AbsoluteValue {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n        return -$n\n    } else {\n        return $n\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n        return -$n\n    } else {\n        return $n\n    }\n}"}
{"task_id": "PowerShell/42-0-single", "prompt": "function Test-NumberSign {\n    <#\n    This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n    >>> Test-NumberSign -n 5\n    positive\n    >>> Test-NumberSign -n -10\n    negative\n    >>> Test-NumberSign -n 0\n    zero\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}", "test": "function Test-TestNumberSign {\n    if ((Test-NumberSign -n 5) -ne \"positive\") { throw \"Test case 1 failed\" }\n    if ((Test-NumberSign -n -10) -ne \"negative\") { throw \"Test case 2 failed\" }\n    if ((Test-NumberSign -n 0) -ne \"zero\") { throw \"Test case 3 failed\" }\n    if ((Test-NumberSign -n 1000000000) -ne \"positive\") { throw \"Test case 4 failed\" }\n    if ((Test-NumberSign -n -1000000000) -ne \"negative\") { throw \"Test case 5 failed\" }\n}\n\nTest-TestNumberSign", "entry_point": "Test-NumberSign", "signature": "function Test-NumberSign {", "docstring": "This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero\n\n* Incomplete Code:\nfunction Test-NumberSign {\n    param (\n[MASK]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}"}
{"task_id": "PowerShell/42-1-single", "prompt": "function Test-NumberSign {\n    <#\n    This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n    >>> Test-NumberSign -n 5\n    positive\n    >>> Test-NumberSign -n -10\n    negative\n    >>> Test-NumberSign -n 0\n    zero\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}", "test": "function Test-TestNumberSign {\n    if ((Test-NumberSign -n 5) -ne \"positive\") { throw \"Test case 1 failed\" }\n    if ((Test-NumberSign -n -10) -ne \"negative\") { throw \"Test case 2 failed\" }\n    if ((Test-NumberSign -n 0) -ne \"zero\") { throw \"Test case 3 failed\" }\n    if ((Test-NumberSign -n 1000000000) -ne \"positive\") { throw \"Test case 4 failed\" }\n    if ((Test-NumberSign -n -1000000000) -ne \"negative\") { throw \"Test case 5 failed\" }\n}\n\nTest-TestNumberSign", "entry_point": "Test-NumberSign", "signature": "function Test-NumberSign {", "docstring": "This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero\n\n* Incomplete Code:\nfunction Test-NumberSign {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n[MASK]\n    } else {\n        return \"zero\"\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n[MASK]\n    } else {\n        return \"zero\"\n    }\n}"}
{"task_id": "PowerShell/43-0-single", "prompt": "function Get-PowerOfTwo {\n    <#\n    This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n    >>> Get-PowerOfTwo -n 3\n    8\n    >>> Get-PowerOfTwo -n 0\n    1\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}", "test": "function Test-GetPowerOfTwo {\n    if ((Get-PowerOfTwo -n 3) -ne 8) { throw \"Test case 1 failed\" }\n    if ((Get-PowerOfTwo -n 0) -ne 1) { throw \"Test case 2 failed\" }\n    if ((Get-PowerOfTwo -n 10) -ne 1024) { throw \"Test case 3 failed\" }\n    if ((Get-PowerOfTwo -n 15) -ne 32768) { throw \"Test case 4 failed\" }\n    if ((Get-PowerOfTwo -n 20) -ne 1048576) { throw \"Test case 5 failed\" }\n}\n\nTest-GetPowerOfTwo", "entry_point": "Get-PowerOfTwo", "signature": "function Get-PowerOfTwo {", "docstring": "This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1\n\n* Incomplete Code:\nfunction Get-PowerOfTwo {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n}"}
{"task_id": "PowerShell/43-1-single", "prompt": "function Get-PowerOfTwo {\n    <#\n    This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n    >>> Get-PowerOfTwo -n 3\n    8\n    >>> Get-PowerOfTwo -n 0\n    1\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}", "test": "function Test-GetPowerOfTwo {\n    if ((Get-PowerOfTwo -n 3) -ne 8) { throw \"Test case 1 failed\" }\n    if ((Get-PowerOfTwo -n 0) -ne 1) { throw \"Test case 2 failed\" }\n    if ((Get-PowerOfTwo -n 10) -ne 1024) { throw \"Test case 3 failed\" }\n    if ((Get-PowerOfTwo -n 15) -ne 32768) { throw \"Test case 4 failed\" }\n    if ((Get-PowerOfTwo -n 20) -ne 1048576) { throw \"Test case 5 failed\" }\n}\n\nTest-GetPowerOfTwo", "entry_point": "Get-PowerOfTwo", "signature": "function Get-PowerOfTwo {", "docstring": "This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1\n\n* Incomplete Code:\nfunction Get-PowerOfTwo {\n    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [Math]::Pow(2, $n)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [Math]::Pow(2, $n)\n}"}
{"task_id": "PowerShell/44-0-single", "prompt": "function Multiply-TwoNumbers {\n    <#\n    This function takes two positive integers as input and returns their product.\n\n    >>> Multiply-TwoNumbers -A 3 -B 4\n    12\n    >>> Multiply-TwoNumbers -A 10 -B 20\n    200\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}", "test": "function Test-MultiplyTwoNumbers {\n    if ((Multiply-TwoNumbers -A 3 -B 4) -ne 12) { throw \"Test case 1 failed\" }\n    if ((Multiply-TwoNumbers -A 10 -B 20) -ne 200) { throw \"Test case 2 failed\" }\n    if ((Multiply-TwoNumbers -A 50000 -B 1) -ne 50000) { throw \"Test case 3 failed\" }\n    if ((Multiply-TwoNumbers -A 1 -B 50000) -ne 50000) { throw \"Test case 4 failed\" }\n    if ((Multiply-TwoNumbers -A 25000 -B 2) -ne 50000) { throw \"Test case 5 failed\" }\n}\n\nTest-MultiplyTwoNumbers", "entry_point": "Multiply-TwoNumbers", "signature": "function Multiply-TwoNumbers {", "docstring": "This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200\n\n* Incomplete Code:\nfunction Multiply-TwoNumbers {\n    param (\n[MASK]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}"}
{"task_id": "PowerShell/44-1-single", "prompt": "function Multiply-TwoNumbers {\n    <#\n    This function takes two positive integers as input and returns their product.\n\n    >>> Multiply-TwoNumbers -A 3 -B 4\n    12\n    >>> Multiply-TwoNumbers -A 10 -B 20\n    200\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}", "test": "function Test-MultiplyTwoNumbers {\n    if ((Multiply-TwoNumbers -A 3 -B 4) -ne 12) { throw \"Test case 1 failed\" }\n    if ((Multiply-TwoNumbers -A 10 -B 20) -ne 200) { throw \"Test case 2 failed\" }\n    if ((Multiply-TwoNumbers -A 50000 -B 1) -ne 50000) { throw \"Test case 3 failed\" }\n    if ((Multiply-TwoNumbers -A 1 -B 50000) -ne 50000) { throw \"Test case 4 failed\" }\n    if ((Multiply-TwoNumbers -A 25000 -B 2) -ne 50000) { throw \"Test case 5 failed\" }\n}\n\nTest-MultiplyTwoNumbers", "entry_point": "Multiply-TwoNumbers", "signature": "function Multiply-TwoNumbers {", "docstring": "This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200\n\n* Incomplete Code:\nfunction Multiply-TwoNumbers {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return $A * $B\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return $A * $B\n}"}
{"task_id": "PowerShell/45-0-single", "prompt": "function Get-ArithmeticSeriesTerm {\n    <#\n    This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n    >>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n    298\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}", "test": "function Test-GetArithmeticSeriesTerm {\n    if ((Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100) -ne 298) { throw \"Test case 1 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 5 -a2 10 -n 50) -ne 250) { throw \"Test case 2 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 100 -a2 99 -n 50) -ne 51) { throw \"Test case 3 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 0 -a2 0 -n 1000) -ne 0) { throw \"Test case 4 failed\" }\n}\n\nTest-GetArithmeticSeriesTerm", "entry_point": "Get-ArithmeticSeriesTerm", "signature": "function Get-ArithmeticSeriesTerm {", "docstring": "This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298\n\n* Incomplete Code:\nfunction Get-ArithmeticSeriesTerm {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n[MASK]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n[MASK]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}"}
{"task_id": "PowerShell/45-1-single", "prompt": "function Get-ArithmeticSeriesTerm {\n    <#\n    This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n    >>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n    298\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}", "test": "function Test-GetArithmeticSeriesTerm {\n    if ((Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100) -ne 298) { throw \"Test case 1 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 5 -a2 10 -n 50) -ne 250) { throw \"Test case 2 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 100 -a2 99 -n 50) -ne 51) { throw \"Test case 3 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 0 -a2 0 -n 1000) -ne 0) { throw \"Test case 4 failed\" }\n}\n\nTest-GetArithmeticSeriesTerm", "entry_point": "Get-ArithmeticSeriesTerm", "signature": "function Get-ArithmeticSeriesTerm {", "docstring": "This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298\n\n* Incomplete Code:\nfunction Get-ArithmeticSeriesTerm {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n[MASK]\n}"}
{"task_id": "PowerShell/46-0-single", "prompt": "function Reverse-ThreeDigitNumber {\n<#\nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n#>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}", "test": "function Test-ReverseThreeDigitNumber {\n    if ((Reverse-ThreeDigitNumber -n 100) -ne 001) { throw \"Test case 1 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 678) -ne 876) { throw \"Test case 2 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 987) -ne 789) { throw \"Test case 3 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 321) -ne 123) { throw \"Test case 4 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 123) -ne 321) { throw \"Test case 5 failed\" }\n}\n\nTest-ReverseThreeDigitNumber", "entry_point": "Reverse-ThreeDigitNumber", "signature": "function Reverse-ThreeDigitNumber {", "docstring": "This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n\n* Incomplete Code:\nfunction Reverse-ThreeDigitNumber {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n[MASK]\n    }\n\n    return [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n[MASK]\n    }\n\n    return [int]$reversed\n}"}
{"task_id": "PowerShell/46-1-single", "prompt": "function Reverse-ThreeDigitNumber {\n<#\nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n#>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}", "test": "function Test-ReverseThreeDigitNumber {\n    if ((Reverse-ThreeDigitNumber -n 100) -ne 001) { throw \"Test case 1 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 678) -ne 876) { throw \"Test case 2 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 987) -ne 789) { throw \"Test case 3 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 321) -ne 123) { throw \"Test case 4 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 123) -ne 321) { throw \"Test case 5 failed\" }\n}\n\nTest-ReverseThreeDigitNumber", "entry_point": "Reverse-ThreeDigitNumber", "signature": "function Reverse-ThreeDigitNumber {", "docstring": "This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n\n* Incomplete Code:\nfunction Reverse-ThreeDigitNumber {\n    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}"}
{"task_id": "PowerShell/47-0-single", "prompt": "function Convert-IntToBoolAndBack {\n    <#\n    This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n    >>> Convert-IntToBoolAndBack -intValue 3\n    1\n    >>> Convert-IntToBoolAndBack -intValue 0\n    0\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}", "test": "function Test-ConvertIntToBoolAndBack {\n    if ((Convert-IntToBoolAndBack -intValue 3) -ne 1) { throw \"Test case 1 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 0) -ne 0) { throw \"Test case 2 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 1) -ne 1) { throw \"Test case 3 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue -1) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 100) -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-ConvertIntToBoolAndBack", "entry_point": "Convert-IntToBoolAndBack", "signature": "function Convert-IntToBoolAndBack {", "docstring": "This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0\n\n* Incomplete Code:\nfunction Convert-IntToBoolAndBack {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n[MASK]\n}"}
{"task_id": "PowerShell/47-1-single", "prompt": "function Convert-IntToBoolAndBack {\n    <#\n    This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n    >>> Convert-IntToBoolAndBack -intValue 3\n    1\n    >>> Convert-IntToBoolAndBack -intValue 0\n    0\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}", "test": "function Test-ConvertIntToBoolAndBack {\n    if ((Convert-IntToBoolAndBack -intValue 3) -ne 1) { throw \"Test case 1 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 0) -ne 0) { throw \"Test case 2 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 1) -ne 1) { throw \"Test case 3 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue -1) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 100) -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-ConvertIntToBoolAndBack", "entry_point": "Convert-IntToBoolAndBack", "signature": "function Convert-IntToBoolAndBack {", "docstring": "This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0\n\n* Incomplete Code:\nfunction Convert-IntToBoolAndBack {\n    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}"}
{"task_id": "PowerShell/48-0-single", "prompt": "function Get-ASCIIChar {\n    <#\n    This function takes an ASCII code as input and returns the corresponding character.\n\n    >>> Get-ASCIIChar -asciiCode 65\n    A\n    >>> Get-ASCIIChar -asciiCode 97\n    a\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}", "test": "function Test-GetASCIIChar {\n    if ((Get-ASCIIChar -asciiCode 65) -ne 'A') { throw \"Test case 1 failed\" }\n    if ((Get-ASCIIChar -asciiCode 97) -ne 'a') { throw \"Test case 2 failed\" }\n    if ((Get-ASCIIChar -asciiCode 48) -ne '0') { throw \"Test case 3 failed\" }\n    if ((Get-ASCIIChar -asciiCode 33) -ne '!') { throw \"Test case 4 failed\" }\n    if ((Get-ASCIIChar -asciiCode 126) -ne '~') { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIIChar", "entry_point": "Get-ASCIIChar", "signature": "function Get-ASCIIChar {", "docstring": "This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na\n\n* Incomplete Code:\nfunction Get-ASCIIChar {\n    param (\n[MASK]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}"}
{"task_id": "PowerShell/48-1-single", "prompt": "function Get-ASCIIChar {\n    <#\n    This function takes an ASCII code as input and returns the corresponding character.\n\n    >>> Get-ASCIIChar -asciiCode 65\n    A\n    >>> Get-ASCIIChar -asciiCode 97\n    a\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}", "test": "function Test-GetASCIIChar {\n    if ((Get-ASCIIChar -asciiCode 65) -ne 'A') { throw \"Test case 1 failed\" }\n    if ((Get-ASCIIChar -asciiCode 97) -ne 'a') { throw \"Test case 2 failed\" }\n    if ((Get-ASCIIChar -asciiCode 48) -ne '0') { throw \"Test case 3 failed\" }\n    if ((Get-ASCIIChar -asciiCode 33) -ne '!') { throw \"Test case 4 failed\" }\n    if ((Get-ASCIIChar -asciiCode 126) -ne '~') { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIIChar", "entry_point": "Get-ASCIIChar", "signature": "function Get-ASCIIChar {", "docstring": "This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na\n\n* Incomplete Code:\nfunction Get-ASCIIChar {\n    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [char]$asciiCode\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [char]$asciiCode\n}"}
{"task_id": "PowerShell/49-0-single", "prompt": "function Get-ASCIICode {\n    <#\n    This function takes a character as input and returns its ASCII code.\n\n    >>> Get-ASCIICode -char 'A'\n    65\n    >>> Get-ASCIICode -char 'a'\n    97\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}", "test": "function Test-GetASCIICode {\n    if ((Get-ASCIICode -char 'A') -ne 65) { throw \"Test case 1 failed\" }\n    if ((Get-ASCIICode -char 'a') -ne 97) { throw \"Test case 2 failed\" }\n    if ((Get-ASCIICode -char '0') -ne 48) { throw \"Test case 3 failed\" }\n    if ((Get-ASCIICode -char '!') -ne 33) { throw \"Test case 4 failed\" }\n    if ((Get-ASCIICode -char '~') -ne 126) { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIICode", "entry_point": "Get-ASCIICode", "signature": "function Get-ASCIICode {", "docstring": "This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97\n\n* Incomplete Code:\nfunction Get-ASCIICode {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}"}
{"task_id": "PowerShell/49-1-single", "prompt": "function Get-ASCIICode {\n    <#\n    This function takes a character as input and returns its ASCII code.\n\n    >>> Get-ASCIICode -char 'A'\n    65\n    >>> Get-ASCIICode -char 'a'\n    97\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}", "test": "function Test-GetASCIICode {\n    if ((Get-ASCIICode -char 'A') -ne 65) { throw \"Test case 1 failed\" }\n    if ((Get-ASCIICode -char 'a') -ne 97) { throw \"Test case 2 failed\" }\n    if ((Get-ASCIICode -char '0') -ne 48) { throw \"Test case 3 failed\" }\n    if ((Get-ASCIICode -char '!') -ne 33) { throw \"Test case 4 failed\" }\n    if ((Get-ASCIICode -char '~') -ne 126) { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIICode", "entry_point": "Get-ASCIICode", "signature": "function Get-ASCIICode {", "docstring": "This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97\n\n* Incomplete Code:\nfunction Get-ASCIICode {\n    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n[MASK]\n}"}
{"task_id": "PowerShell/50-0-single", "prompt": "function Calculate-Expression {\n    <#\n    This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n    >>> Calculate-Expression -a 2 -b 3 -c 5\n    25\n    >>> Calculate-Expression -a 1 -b 1 -c 1\n    2\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}", "test": "function Test-CalculateExpression {\n    if ((Calculate-Expression -a 2 -b 3 -c 5) -ne 25) { throw \"Test case 1 failed\" }\n    if ((Calculate-Expression -a 1 -b 1 -c 1) -ne 2) { throw \"Test case 2 failed\" }\n    if ((Calculate-Expression -a 0 -b 0 -c 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Calculate-Expression -a -1 -b -1 -c -1) -ne 2) { throw \"Test case 4 failed\" }\n    if ((Calculate-Expression -a 10000 -b 10000 -c 10000) -ne 200000000) { throw \"Test case 5 failed\" }\n    if ((Calculate-Expression -a -10000 -b -10000 -c -10000) -ne 200000000) { throw \"Test case 6 failed\" }\n}", "entry_point": "Calculate-Expression", "signature": "function Calculate-Expression {", "docstring": "This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2\n\n* Incomplete Code:\nfunction Calculate-Expression {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}"}
{"task_id": "PowerShell/50-1-single", "prompt": "function Calculate-Expression {\n    <#\n    This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n    >>> Calculate-Expression -a 2 -b 3 -c 5\n    25\n    >>> Calculate-Expression -a 1 -b 1 -c 1\n    2\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}", "test": "function Test-CalculateExpression {\n    if ((Calculate-Expression -a 2 -b 3 -c 5) -ne 25) { throw \"Test case 1 failed\" }\n    if ((Calculate-Expression -a 1 -b 1 -c 1) -ne 2) { throw \"Test case 2 failed\" }\n    if ((Calculate-Expression -a 0 -b 0 -c 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Calculate-Expression -a -1 -b -1 -c -1) -ne 2) { throw \"Test case 4 failed\" }\n    if ((Calculate-Expression -a 10000 -b 10000 -c 10000) -ne 200000000) { throw \"Test case 5 failed\" }\n    if ((Calculate-Expression -a -10000 -b -10000 -c -10000) -ne 200000000) { throw \"Test case 6 failed\" }\n}", "entry_point": "Calculate-Expression", "signature": "function Calculate-Expression {", "docstring": "This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2\n\n* Incomplete Code:\nfunction Calculate-Expression {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}"}
{"task_id": "PowerShell/1-0-multi", "prompt": "function Has-CloseElements {\n<#\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n#> param (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "canonical_solution": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}", "test": "# Test cases\nfunction Check-CloseElements() {\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.3) -ne $true) { throw \"Test case 1 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.05) -ne $false) { throw \"Test case 2 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.95) -ne $true) { throw \"Test case 3 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.8) -ne $false) { throw \"Test case 4 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.0, 4.0, 5.0, 2.0)))) 0.1) -ne $true) { throw \"Test case 5 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 1.0) -ne $true) { throw \"Test case 6 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 0.5) -ne $false) { throw \"Test case 7 failed\" }\n}\n\nCheck-CloseElements", "entry_point": "Has-CloseElements", "signature": "function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunction Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)\n\n\n[MASK]\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\n[MASK]\n}\n}\n}\n}\n\nreturn $false\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\n\n[MASK]\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\n[MASK]\n}\n}\n}\n}\n\nreturn $false\n}"}
{"task_id": "PowerShell/1-1-multi", "prompt": "function Has-CloseElements {\n<#\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n#> param (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "canonical_solution": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}", "test": "# Test cases\nfunction Check-CloseElements() {\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.3) -ne $true) { throw \"Test case 1 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.05) -ne $false) { throw \"Test case 2 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.95) -ne $true) { throw \"Test case 3 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.8) -ne $false) { throw \"Test case 4 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.0, 4.0, 5.0, 2.0)))) 0.1) -ne $true) { throw \"Test case 5 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 1.0) -ne $true) { throw \"Test case 6 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 0.5) -ne $false) { throw \"Test case 7 failed\" }\n}\n\nCheck-CloseElements", "entry_point": "Has-CloseElements", "signature": "function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunction Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)\n\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\n[MASK]\n[MASK]\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\n[MASK]\n}\n}\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\n[MASK]\n[MASK]\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\n[MASK]\n}\n}\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/2-0-multi", "prompt": "function Remove-DuplicatesFromSortedArray {\n<#\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "canonical_solution": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}", "test": "function Check-RemoveDuplicatesFromSortedArray() {\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 2)) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(0,0,1,1,1,2,2,3,3,4)) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 2, 3)) -ne 3) { throw \"Test case 3 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(2, 2, 2)) -ne 1) { throw \"Test case 4 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1)) -ne 1) { throw \"Test case 5 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4)) -ne 4) { throw \"Test case 6 failed\" }\n}\n\nCheck-RemoveDuplicatesFromSortedArray", "entry_point": "Remove-DuplicatesFromSortedArray", "signature": "function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "docstring": "\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n\n\n* Incomplete Code:\nfunction Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)\nif ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n[MASK]\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n[MASK]\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/2-1-multi", "prompt": "function Remove-DuplicatesFromSortedArray {\n<#\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "canonical_solution": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}", "test": "function Check-RemoveDuplicatesFromSortedArray() {\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 2)) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(0,0,1,1,1,2,2,3,3,4)) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 2, 3)) -ne 3) { throw \"Test case 3 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(2, 2, 2)) -ne 1) { throw \"Test case 4 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1)) -ne 1) { throw \"Test case 5 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4)) -ne 4) { throw \"Test case 6 failed\" }\n}\n\nCheck-RemoveDuplicatesFromSortedArray", "entry_point": "Remove-DuplicatesFromSortedArray", "signature": "function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "docstring": "\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n\n\n* Incomplete Code:\nfunction Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)\n[MASK]\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\nreturn $i + 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\nreturn $i + 1\n}"}
{"task_id": "PowerShell/3-0-multi", "prompt": "function Get-LongestUniqueSubstringLength {\n<#\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}", "test": "function Check-LongestUniqueSubstringLength() {\nif ((Get-LongestUniqueSubstringLength \"abcabcbb\") -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-LongestUniqueSubstringLength \"bbbbb\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-LongestUniqueSubstringLength \"pwwkew\") -ne 3) { throw \"Test case 3 failed\" }\nif ((Get-LongestUniqueSubstringLength \" \") -ne 1) { throw \"Test case 4 failed\" }\nif ((Get-LongestUniqueSubstringLength \"dvdf\") -ne 3) { throw \"Test case 5 failed\" }\nif ((Get-LongestUniqueSubstringLength \"anviaj\") -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-LongestUniqueSubstringLength \"abba\") -ne 2) { throw \"Test case 7 failed\" }\n}\n\nCheck-LongestUniqueSubstringLength", "entry_point": "Get-LongestUniqueSubstringLength", "signature": "function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n\n\n* Incomplete Code:\nfunction Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$start = 0\n[MASK]\n[MASK]\n\n[MASK]\nif ($charMap.ContainsKey($s[$end])) {\n[MASK]\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$start = 0\n[MASK]\n[MASK]\n\n[MASK]\nif ($charMap.ContainsKey($s[$end])) {\n[MASK]\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}"}
{"task_id": "PowerShell/3-1-multi", "prompt": "function Get-LongestUniqueSubstringLength {\n<#\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}", "test": "function Check-LongestUniqueSubstringLength() {\nif ((Get-LongestUniqueSubstringLength \"abcabcbb\") -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-LongestUniqueSubstringLength \"bbbbb\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-LongestUniqueSubstringLength \"pwwkew\") -ne 3) { throw \"Test case 3 failed\" }\nif ((Get-LongestUniqueSubstringLength \" \") -ne 1) { throw \"Test case 4 failed\" }\nif ((Get-LongestUniqueSubstringLength \"dvdf\") -ne 3) { throw \"Test case 5 failed\" }\nif ((Get-LongestUniqueSubstringLength \"anviaj\") -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-LongestUniqueSubstringLength \"abba\") -ne 2) { throw \"Test case 7 failed\" }\n}\n\nCheck-LongestUniqueSubstringLength", "entry_point": "Get-LongestUniqueSubstringLength", "signature": "function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n\n\n* Incomplete Code:\nfunction Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n[MASK]\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n[MASK]\n}\n\n$charMap[$s[$end]] = $end\n[MASK]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n[MASK]\n}\n\n$charMap[$s[$end]] = $end\n[MASK]\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/4-0-multi", "prompt": "function Get-LongestPalindromicSubstring {\n<#\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}", "test": "function Check-LongestPalindromicSubstring() {\n$result1 = Get-LongestPalindromicSubstring \"babad\"\nif (-not ($result1 -eq \"bab\" -or $result1 -eq \"aba\")) { throw \"Test case 1 failed\" }\nif ((Get-LongestPalindromicSubstring \"cbbd\") -ne \"bb\") { throw \"Test case 2 failed\" }\nif ((Get-LongestPalindromicSubstring \"a\") -ne \"a\") { throw \"Test case 3 failed\" }\nif ((Get-LongestPalindromicSubstring \"racecar\") -ne \"racecar\") { throw \"Test case 4 failed\" }\nif ((Get-LongestPalindromicSubstring \"madam\") -ne \"madam\") { throw \"Test case 5 failed\" }\nif ((Get-LongestPalindromicSubstring \"abcdcba\") -ne \"abcdcba\") { throw \"Test case 6 failed\" }\n}\n\nCheck-LongestPalindromicSubstring", "entry_point": "Get-LongestPalindromicSubstring", "signature": "function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n\n\n* Incomplete Code:\nfunction Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\nif (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n[MASK]\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n[MASK]\n} else {\n[MASK]\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n[MASK]\n$right++\n}\n\nreturn $right - $left - 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n[MASK]\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n[MASK]\n} else {\n[MASK]\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n[MASK]\n$right++\n}\n\nreturn $right - $left - 1\n}"}
{"task_id": "PowerShell/4-1-multi", "prompt": "function Get-LongestPalindromicSubstring {\n<#\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}", "test": "function Check-LongestPalindromicSubstring() {\n$result1 = Get-LongestPalindromicSubstring \"babad\"\nif (-not ($result1 -eq \"bab\" -or $result1 -eq \"aba\")) { throw \"Test case 1 failed\" }\nif ((Get-LongestPalindromicSubstring \"cbbd\") -ne \"bb\") { throw \"Test case 2 failed\" }\nif ((Get-LongestPalindromicSubstring \"a\") -ne \"a\") { throw \"Test case 3 failed\" }\nif ((Get-LongestPalindromicSubstring \"racecar\") -ne \"racecar\") { throw \"Test case 4 failed\" }\nif ((Get-LongestPalindromicSubstring \"madam\") -ne \"madam\") { throw \"Test case 5 failed\" }\nif ((Get-LongestPalindromicSubstring \"abcdcba\") -ne \"abcdcba\") { throw \"Test case 6 failed\" }\n}\n\nCheck-LongestPalindromicSubstring", "entry_point": "Get-LongestPalindromicSubstring", "signature": "function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n\n\n* Incomplete Code:\nfunction Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n[MASK]\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n[MASK]\n[MASK]\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n[MASK]\n[MASK]\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}"}
{"task_id": "PowerShell/5-0-multi", "prompt": "function MyAtoi {\n<#\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}", "test": "# Test cases\nfunction Check-MyAtoi() {\nif ((MyAtoi \"42\") -ne 42) { throw \"Test case 1 failed\" }\nif ((MyAtoi \" -42\") -ne -42) { throw \"Test case 2 failed\" }\nif ((MyAtoi \"4193 with words\") -ne 4193) { throw \"Test case 3 failed\" }\nif ((MyAtoi \"words and 987\") -ne 0) { throw \"Test case 4 failed\" }\n}\nCheck-MyAtoi", "entry_point": "MyAtoi", "signature": "function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n\n\n* Incomplete Code:\nfunction MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$s = $s.Trim()\n[MASK]\n\n$sign = 1\n[MASK]\n$i = 0\n\n[MASK]\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\n[MASK]\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$s = $s.Trim()\n[MASK]\n\n$sign = 1\n[MASK]\n$i = 0\n\n[MASK]\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\n[MASK]\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}"}
{"task_id": "PowerShell/5-1-multi", "prompt": "function MyAtoi {\n<#\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}", "test": "# Test cases\nfunction Check-MyAtoi() {\nif ((MyAtoi \"42\") -ne 42) { throw \"Test case 1 failed\" }\nif ((MyAtoi \" -42\") -ne -42) { throw \"Test case 2 failed\" }\nif ((MyAtoi \"4193 with words\") -ne 4193) { throw \"Test case 3 failed\" }\nif ((MyAtoi \"words and 987\") -ne 0) { throw \"Test case 4 failed\" }\n}\nCheck-MyAtoi", "entry_point": "MyAtoi", "signature": "function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n\n\n* Incomplete Code:\nfunction MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$s = $s.Trim()\n[MASK]\n\n[MASK]\n$base = 0\n[MASK]\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\n[MASK]\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\n[MASK]\n}\n\n$i++\n}\n\nreturn $base * $sign\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$s = $s.Trim()\n[MASK]\n\n[MASK]\n$base = 0\n[MASK]\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\n[MASK]\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\n[MASK]\n}\n\n$i++\n}\n\nreturn $base * $sign\n}"}
{"task_id": "PowerShell/6-0-multi", "prompt": "function FindLongestCommonPrefix {\n<#\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "canonical_solution": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}", "test": "function Check-FindLongestCommonPrefix() {\nif ((FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")) -ne \"fl\") { throw \"Test case 1 failed\" }\nif ((FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")) -ne \"\") { throw \"Test case 2 failed\" }\nif ((FindLongestCommonPrefix @(\"interspecies\",\"interstellar\",\"interstate\")) -ne \"inters\") { throw \"Test case 3 failed\" }\nif ((FindLongestCommonPrefix @(\"throne\",\"throne\")) -ne \"throne\") { throw \"Test case 4 failed\" }\nif ((FindLongestCommonPrefix @(\"a\",\"ab\")) -ne \"a\") { throw \"Test case 5 failed\" }\nif ((FindLongestCommonPrefix @(\"abc\",\"abcd\",\"ab\")) -ne \"ab\") { throw \"Test case 6 failed\" }\nif ((FindLongestCommonPrefix @(\"complete\",\"compliment\",\"complex\")) -ne \"compl\") { throw \"Test case 7 failed\" }\nif ((FindLongestCommonPrefix @(\"nomatch\",\"nomadic\",\"noir\")) -ne \"no\") { throw \"Test case 8 failed\" }\n}\n\nCheck-FindLongestCommonPrefix", "entry_point": "FindLongestCommonPrefix", "signature": "function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "docstring": "\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n\n\n* Incomplete Code:\nfunction FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)\nif ($strs.Length -eq 0) { return \"\" }\n[MASK]\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\nreturn $prefix\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "if ($strs.Length -eq 0) { return \"\" }\n[MASK]\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\nreturn $prefix\n}"}
{"task_id": "PowerShell/6-1-multi", "prompt": "function FindLongestCommonPrefix {\n<#\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "canonical_solution": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}", "test": "function Check-FindLongestCommonPrefix() {\nif ((FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")) -ne \"fl\") { throw \"Test case 1 failed\" }\nif ((FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")) -ne \"\") { throw \"Test case 2 failed\" }\nif ((FindLongestCommonPrefix @(\"interspecies\",\"interstellar\",\"interstate\")) -ne \"inters\") { throw \"Test case 3 failed\" }\nif ((FindLongestCommonPrefix @(\"throne\",\"throne\")) -ne \"throne\") { throw \"Test case 4 failed\" }\nif ((FindLongestCommonPrefix @(\"a\",\"ab\")) -ne \"a\") { throw \"Test case 5 failed\" }\nif ((FindLongestCommonPrefix @(\"abc\",\"abcd\",\"ab\")) -ne \"ab\") { throw \"Test case 6 failed\" }\nif ((FindLongestCommonPrefix @(\"complete\",\"compliment\",\"complex\")) -ne \"compl\") { throw \"Test case 7 failed\" }\nif ((FindLongestCommonPrefix @(\"nomatch\",\"nomadic\",\"noir\")) -ne \"no\") { throw \"Test case 8 failed\" }\n}\n\nCheck-FindLongestCommonPrefix", "entry_point": "FindLongestCommonPrefix", "signature": "function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "docstring": "\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n\n\n* Incomplete Code:\nfunction FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)\nif ($strs.Length -eq 0) { return \"\" }\n[MASK]\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n[MASK]\n\n[MASK]\n[MASK]\n[MASK]\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "if ($strs.Length -eq 0) { return \"\" }\n[MASK]\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n[MASK]\n\n[MASK]\n[MASK]\n[MASK]\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}"}
{"task_id": "PowerShell/8-0-multi", "prompt": "function Find-ConcatenatedSubstrings {\n<#\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "canonical_solution": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}", "test": "function Check-ConcatenatedSubstrings() {\n$result = Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\nif (($result -join ',') -ne '0,9') { throw \"Test case 1 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\nif (($result -join ',') -ne '') { throw \"Test case 2 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcabcabc\" @(\"abc\",\"abc\")\nif (($result -join ',') -ne '0,3') { throw \"Test case 3 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"ab\",\"cd\")\nif (($result -join ',') -ne '0') { throw \"Test case 4 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"cd\",\"ab\")\nif (($result -join ',') -ne '0') { throw \"Test case 5 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abababab\" @(\"ab\",\"ba\")\nif (($result -join ',') -ne '') { throw \"Test case 6 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcdef\" @(\"gh\",\"ij\")\nif (($result -join ',') -ne '') { throw \"Test case 7 failed\" }\n}\n\nCheck-ConcatenatedSubstrings", "entry_point": "Find-ConcatenatedSubstrings", "signature": "function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "docstring": "\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n\n\n* Incomplete Code:\nfunction Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)\n[MASK]\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\n[MASK]\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n[MASK]\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\n[MASK]\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n[MASK]\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/8-1-multi", "prompt": "function Find-ConcatenatedSubstrings {\n<#\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "canonical_solution": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}", "test": "function Check-ConcatenatedSubstrings() {\n$result = Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\nif (($result -join ',') -ne '0,9') { throw \"Test case 1 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\nif (($result -join ',') -ne '') { throw \"Test case 2 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcabcabc\" @(\"abc\",\"abc\")\nif (($result -join ',') -ne '0,3') { throw \"Test case 3 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"ab\",\"cd\")\nif (($result -join ',') -ne '0') { throw \"Test case 4 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"cd\",\"ab\")\nif (($result -join ',') -ne '0') { throw \"Test case 5 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abababab\" @(\"ab\",\"ba\")\nif (($result -join ',') -ne '') { throw \"Test case 6 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcdef\" @(\"gh\",\"ij\")\nif (($result -join ',') -ne '') { throw \"Test case 7 failed\" }\n}\n\nCheck-ConcatenatedSubstrings", "entry_point": "Find-ConcatenatedSubstrings", "signature": "function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "docstring": "\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n\n\n* Incomplete Code:\nfunction Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)\n$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n[MASK]\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\n[MASK]\n[MASK]\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n[MASK]\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\n[MASK]\n[MASK]\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/9-0-multi", "prompt": "function Find-MedianOfTwoSortedArrays {\n<#\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "canonical_solution": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}", "test": "function Check-MedianOfTwoSortedArrays() {\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))) -ne 2.0) { throw \"Test case 1 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))) -ne 2.5) { throw \"Test case 2 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5, 7)) @([int[]](2, 4, 6, 8))) -ne 4.5) { throw \"Test case 3 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1)) @([int[]](1))) -ne 1.0) { throw \"Test case 4 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5)) @([int[]](2))) -ne 2.5) { throw \"Test case 5 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](10, 20, 30, 40, 50)) @([int[]](5, 15, 25, 35, 45))) -ne 27.5) { throw \"Test case 6 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 12, 15, 26, 38)) @([int[]](2, 13, 17, 30, 45, 50))) -ne 17.0) { throw \"Test case 7 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 4, 5)) @([int[]](2, 3, 6, 7, 8))) -ne 4.5) { throw \"Test case 8 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 1, 1)) @([int[]](1, 1, 1, 1))) -ne 1.0) { throw \"Test case 10 failed\" }\n}\n\nCheck-MedianOfTwoSortedArrays", "entry_point": "Find-MedianOfTwoSortedArrays", "signature": "function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "docstring": "\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n\n\n* Incomplete Code:\nfunction Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)\n$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n[MASK]\n[MASK]\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n[MASK]\n[MASK]\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}"}
{"task_id": "PowerShell/9-1-multi", "prompt": "function Find-MedianOfTwoSortedArrays {\n<#\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "canonical_solution": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}", "test": "function Check-MedianOfTwoSortedArrays() {\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))) -ne 2.0) { throw \"Test case 1 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))) -ne 2.5) { throw \"Test case 2 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5, 7)) @([int[]](2, 4, 6, 8))) -ne 4.5) { throw \"Test case 3 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1)) @([int[]](1))) -ne 1.0) { throw \"Test case 4 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5)) @([int[]](2))) -ne 2.5) { throw \"Test case 5 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](10, 20, 30, 40, 50)) @([int[]](5, 15, 25, 35, 45))) -ne 27.5) { throw \"Test case 6 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 12, 15, 26, 38)) @([int[]](2, 13, 17, 30, 45, 50))) -ne 17.0) { throw \"Test case 7 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 4, 5)) @([int[]](2, 3, 6, 7, 8))) -ne 4.5) { throw \"Test case 8 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 1, 1)) @([int[]](1, 1, 1, 1))) -ne 1.0) { throw \"Test case 10 failed\" }\n}\n\nCheck-MedianOfTwoSortedArrays", "entry_point": "Find-MedianOfTwoSortedArrays", "signature": "function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "docstring": "\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n\n\n* Incomplete Code:\nfunction Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)\n[MASK]\n$merged.AddRange($nums1)\n[MASK]\n$merged.Sort()\n\n$count = $merged.Count\n[MASK]\n[MASK]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n$merged.AddRange($nums1)\n[MASK]\n$merged.Sort()\n\n$count = $merged.Count\n[MASK]\n[MASK]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}"}
{"task_id": "PowerShell/10-0-multi", "prompt": "function Reverse-Integer {\n<#\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}", "test": "function Check-ReverseInteger() {\nif ((Reverse-Integer 123) -ne 321) { throw \"Test case 1 failed\" }\nif ((Reverse-Integer -123) -ne -321) { throw \"Test case 2 failed\" }\nif ((Reverse-Integer 120) -ne 21) { throw \"Test case 3 failed\" }\nif ((Reverse-Integer 0) -ne 0) { throw \"Test case 4 failed\" }\nif ((Reverse-Integer 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Reverse-Integer -10) -ne -1) { throw \"Test case 6 failed\" }\n\n}\n\nCheck-ReverseInteger", "entry_point": "Reverse-Integer", "signature": "function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n\n\n* Incomplete Code:\nfunction Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\n\n[MASK]\n[MASK]\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n[MASK]\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "\n[MASK]\n[MASK]\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n[MASK]\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/10-1-multi", "prompt": "function Reverse-Integer {\n<#\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}", "test": "function Check-ReverseInteger() {\nif ((Reverse-Integer 123) -ne 321) { throw \"Test case 1 failed\" }\nif ((Reverse-Integer -123) -ne -321) { throw \"Test case 2 failed\" }\nif ((Reverse-Integer 120) -ne 21) { throw \"Test case 3 failed\" }\nif ((Reverse-Integer 0) -ne 0) { throw \"Test case 4 failed\" }\nif ((Reverse-Integer 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Reverse-Integer -10) -ne -1) { throw \"Test case 6 failed\" }\n\n}\n\nCheck-ReverseInteger", "entry_point": "Reverse-Integer", "signature": "function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n\n\n* Incomplete Code:\nfunction Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\n\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[MASK]\n\n[MASK]\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[MASK]\n\n[MASK]\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}"}
{"task_id": "PowerShell/11-0-multi", "prompt": "function Is-PalindromeNumber {\n<#\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}", "test": "function Check-PalindromeNumber() {\nif ((Is-PalindromeNumber 121) -ne $true) { throw \"Test case 1 failed\" }\nif ((Is-PalindromeNumber -121) -ne $false) { throw \"Test case 2 failed\" }\nif ((Is-PalindromeNumber 10) -ne $false) { throw \"Test case 3 failed\" }\nif ((Is-PalindromeNumber 1221) -ne $true) { throw \"Test case 4 failed\" }\nif ((Is-PalindromeNumber 12321) -ne $true) { throw \"Test case 5 failed\" }\nif ((Is-PalindromeNumber 123321) -ne $true) { throw \"Test case 6 failed\" }\nif ((Is-PalindromeNumber 0) -ne $true) { throw \"Test case 7 failed\" }\nif ((Is-PalindromeNumber 123) -ne $false) { throw \"Test case 8 failed\" }\nif ((Is-PalindromeNumber 1) -ne $true) { throw \"Test case 9 failed\" }\nif ((Is-PalindromeNumber 1000021) -ne $false) { throw \"Test case 10 failed\" }\n}\n\nCheck-PalindromeNumber", "entry_point": "Is-PalindromeNumber", "signature": "function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n\n\n* Incomplete Code:\nfunction Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\nif ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\n[MASK]\n}\n\n[int]$reversed = 0\n[MASK]\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\n[MASK]\n}\n\n[int]$reversed = 0\n[MASK]\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/11-1-multi", "prompt": "function Is-PalindromeNumber {\n<#\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}", "test": "function Check-PalindromeNumber() {\nif ((Is-PalindromeNumber 121) -ne $true) { throw \"Test case 1 failed\" }\nif ((Is-PalindromeNumber -121) -ne $false) { throw \"Test case 2 failed\" }\nif ((Is-PalindromeNumber 10) -ne $false) { throw \"Test case 3 failed\" }\nif ((Is-PalindromeNumber 1221) -ne $true) { throw \"Test case 4 failed\" }\nif ((Is-PalindromeNumber 12321) -ne $true) { throw \"Test case 5 failed\" }\nif ((Is-PalindromeNumber 123321) -ne $true) { throw \"Test case 6 failed\" }\nif ((Is-PalindromeNumber 0) -ne $true) { throw \"Test case 7 failed\" }\nif ((Is-PalindromeNumber 123) -ne $false) { throw \"Test case 8 failed\" }\nif ((Is-PalindromeNumber 1) -ne $true) { throw \"Test case 9 failed\" }\nif ((Is-PalindromeNumber 1000021) -ne $false) { throw \"Test case 10 failed\" }\n}\n\nCheck-PalindromeNumber", "entry_point": "Is-PalindromeNumber", "signature": "function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n\n\n* Incomplete Code:\nfunction Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\nif ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\n[MASK]\n}\n\n[MASK]\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\n[MASK]\n}\n\n[MASK]\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}"}
{"task_id": "PowerShell/12-0-multi", "prompt": "function Max-WaterContainer {\n<#\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "canonical_solution": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}", "test": "function Check-MaxWaterContainer() {\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))) -ne 49) { throw \"Test case 1 failed\" }\nif ((Max-WaterContainer @([int[]](1, 1))) -ne 1) { throw \"Test case 2 failed\" }\nif ((Max-WaterContainer @([int[]](4, 3, 2, 1, 4))) -ne 16) { throw \"Test case 3 failed\" }\nif ((Max-WaterContainer @([int[]](1, 2, 4, 3))) -ne 4) { throw \"Test case 4 failed\" }\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 25, 7))) -ne 49) { throw \"Test case 5 failed\" }\nif ((Max-WaterContainer @([int[]](1, 3, 2, 5, 25, 24, 5))) -ne 24) { throw \"Test case 6 failed\" }\n}\n\nCheck-MaxWaterContainer", "entry_point": "Max-WaterContainer", "signature": "function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "docstring": "\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n\n\n* Incomplete Code:\nfunction Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)\n$left = 0\n$right = $height.Count - 1\n[MASK]\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\n[MASK]\n$left++\n[MASK]\n$right--\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$left = 0\n$right = $height.Count - 1\n[MASK]\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\n[MASK]\n$left++\n[MASK]\n$right--\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/12-1-multi", "prompt": "function Max-WaterContainer {\n<#\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "canonical_solution": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}", "test": "function Check-MaxWaterContainer() {\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))) -ne 49) { throw \"Test case 1 failed\" }\nif ((Max-WaterContainer @([int[]](1, 1))) -ne 1) { throw \"Test case 2 failed\" }\nif ((Max-WaterContainer @([int[]](4, 3, 2, 1, 4))) -ne 16) { throw \"Test case 3 failed\" }\nif ((Max-WaterContainer @([int[]](1, 2, 4, 3))) -ne 4) { throw \"Test case 4 failed\" }\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 25, 7))) -ne 49) { throw \"Test case 5 failed\" }\nif ((Max-WaterContainer @([int[]](1, 3, 2, 5, 25, 24, 5))) -ne 24) { throw \"Test case 6 failed\" }\n}\n\nCheck-MaxWaterContainer", "entry_point": "Max-WaterContainer", "signature": "function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "docstring": "\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n\n\n* Incomplete Code:\nfunction Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)\n$left = 0\n[MASK]\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\n[MASK]\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$left = 0\n[MASK]\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\n[MASK]\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}"}
{"task_id": "PowerShell/13-0-multi", "prompt": "function Remove-Element {\n<#\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "canonical_solution": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}", "test": "function Check-RemoveElement() {\n#if ((Remove-Element @(3, 2, 2, 3) 3) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-Element @(1, 2, 3, 4, 5) 6) -ne 5) { throw \"Test case 3 failed\" }\nif ((Remove-Element @(1, 1, 1) 1) -ne 0) { throw \"Test case 4 failed\" }\nif ((Remove-Element @(2, 2, 3, 3) 2) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nCheck-RemoveElement", "entry_point": "Remove-Element", "signature": "function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "docstring": "\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n\n\n* Incomplete Code:\nfunction Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)\n$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n[MASK]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n[MASK]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\n[MASK]\n}"}
{"task_id": "PowerShell/13-1-multi", "prompt": "function Remove-Element {\n<#\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "canonical_solution": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}", "test": "function Check-RemoveElement() {\n#if ((Remove-Element @(3, 2, 2, 3) 3) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-Element @(1, 2, 3, 4, 5) 6) -ne 5) { throw \"Test case 3 failed\" }\nif ((Remove-Element @(1, 1, 1) 1) -ne 0) { throw \"Test case 4 failed\" }\nif ((Remove-Element @(2, 2, 3, 3) 2) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nCheck-RemoveElement", "entry_point": "Remove-Element", "signature": "function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "docstring": "\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n\n\n* Incomplete Code:\nfunction Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)\n$i = 0\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$i = 0\n[MASK]\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}"}
{"task_id": "PowerShell/14-0-multi", "prompt": "function Count-GoodIntegers {\n<#\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "canonical_solution": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}", "test": "function Check-GoodIntegers() {\nif ((Count-GoodIntegers \"25\" \"30\" 7 5) -ne 1) { throw \"Test case 1 failed\" }\nif ((Count-GoodIntegers \"1\" \"12\" 8 1) -ne 11) { throw \"Test case 2 failed\" }\nif ((Count-GoodIntegers \"1\" \"5\" 5 1) -ne 5) { throw \"Test case 3 failed\" }\n}\n\nCheck-GoodIntegers", "entry_point": "Count-GoodIntegers", "signature": "function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "docstring": "\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n\n\n* Incomplete Code:\nfunction Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)\n$mod = 1000000007\n[MASK]\n\n[MASK]\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\n[MASK]\n[MASK]\n}\n}\n\nreturn $count % $mod\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$mod = 1000000007\n[MASK]\n\n[MASK]\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\n[MASK]\n[MASK]\n}\n}\n\nreturn $count % $mod\n}"}
{"task_id": "PowerShell/14-1-multi", "prompt": "function Count-GoodIntegers {\n<#\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "canonical_solution": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}", "test": "function Check-GoodIntegers() {\nif ((Count-GoodIntegers \"25\" \"30\" 7 5) -ne 1) { throw \"Test case 1 failed\" }\nif ((Count-GoodIntegers \"1\" \"12\" 8 1) -ne 11) { throw \"Test case 2 failed\" }\nif ((Count-GoodIntegers \"1\" \"5\" 5 1) -ne 5) { throw \"Test case 3 failed\" }\n}\n\nCheck-GoodIntegers", "entry_point": "Count-GoodIntegers", "signature": "function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "docstring": "\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n\n\n* Incomplete Code:\nfunction Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)\n[MASK]\n[MASK]\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\n[MASK]\n[MASK]\n}\n}\n\nreturn $count % $mod\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\n[MASK]\n[MASK]\n}\n}\n\nreturn $count % $mod\n}"}
{"task_id": "PowerShell/15-0-multi", "prompt": "function Count-WordFrequency {\n<# Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"#>", "canonical_solution": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}", "test": "function Test-CountWordFrequency {\n# Test function for Count-WordFrequency\n# Create a sample frequency.txt file\n\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n\n# Expected output\n$expected_output = \"apple 3\\nbanana 3\" -split \"\\n\"\n\n# Actual output from the function\n$actual_output = Count-WordFrequency\n\n# Compare actual output to expected output\nif ($actual_output -join \"`n\" -eq $expected_output -join \"`n\") {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item frequency.txt\n}\n\n# Call the test function\nTest-CountWordFrequency", "entry_point": "Count-WordFrequency", "signature": "function Count-WordFrequency {\n", "docstring": " Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"\n\n* Incomplete Code:\nfunction Count-WordFrequency {\n\n[MASK]\n$wordCount = @{}\n\nforeach ($word in $words) {\n[MASK]\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n[MASK]\n\"$($_.Key) $($_.Value)\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n$wordCount = @{}\n\nforeach ($word in $words) {\n[MASK]\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n[MASK]\n\"$($_.Key) $($_.Value)\"\n}\n}"}
{"task_id": "PowerShell/15-1-multi", "prompt": "function Count-WordFrequency {\n<# Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"#>", "canonical_solution": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}", "test": "function Test-CountWordFrequency {\n# Test function for Count-WordFrequency\n# Create a sample frequency.txt file\n\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n\n# Expected output\n$expected_output = \"apple 3\\nbanana 3\" -split \"\\n\"\n\n# Actual output from the function\n$actual_output = Count-WordFrequency\n\n# Compare actual output to expected output\nif ($actual_output -join \"`n\" -eq $expected_output -join \"`n\") {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item frequency.txt\n}\n\n# Call the test function\nTest-CountWordFrequency", "entry_point": "Count-WordFrequency", "signature": "function Count-WordFrequency {\n", "docstring": " Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"\n\n* Incomplete Code:\nfunction Count-WordFrequency {\n\n$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\n[MASK]\nif (!$word) { continue }\n[MASK]\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\n[MASK]\nif (!$word) { continue }\n[MASK]\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}"}
{"task_id": "PowerShell/17-0-multi", "prompt": "function Transpose-File {\n<# Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"#>", "canonical_solution": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}", "test": "function Test-TransposeFile {\n# Test function for Transpose-File\n# Create a sample file.txt file\n\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n# Actual output from the function\n$actual_output = Transpose-File\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-TransposeFile", "entry_point": "Transpose-File", "signature": "function Transpose-File {\n", "docstring": " Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n* Incomplete Code:\nfunction Transpose-File {\n\n[MASK]\n[MASK]\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n[MASK]\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}"}
{"task_id": "PowerShell/17-1-multi", "prompt": "function Transpose-File {\n<# Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"#>", "canonical_solution": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}", "test": "function Test-TransposeFile {\n# Test function for Transpose-File\n# Create a sample file.txt file\n\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n# Actual output from the function\n$actual_output = Transpose-File\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-TransposeFile", "entry_point": "Transpose-File", "signature": "function Transpose-File {\n", "docstring": " Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n* Incomplete Code:\nfunction Transpose-File {\n\n$lines = Get-Content file.txt\n[MASK]\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n[MASK]\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$lines = Get-Content file.txt\n[MASK]\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n[MASK]\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}"}
{"task_id": "PowerShell/19-0-multi", "prompt": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n<#\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n#>", "canonical_solution": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}", "test": "function Test-TotalCoins() {\nif ((Get-TotalCoins -days 7) -ne 18) { throw \"Test case 1 failed\" }\nif ((Get-TotalCoins -days 10) -ne 30) { throw \"Test case 2 failed\" }\nif ((Get-TotalCoins -days 15) -ne 55) { throw \"Test case 3 failed\" }\nif ((Get-TotalCoins -days 20) -ne 85) { throw \"Test case 4 failed\" }\nif ((Get-TotalCoins -days 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Get-TotalCoins -days 3) -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-TotalCoins -days 5) -ne 11) { throw \"Test case 7 failed\" }\n}\n\nTest-TotalCoins", "entry_point": "Get-TotalCoins", "signature": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n", "docstring": "\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n\n\n* Incomplete Code:\nfunction Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n\n[MASK]\n$currentCoins = 1\n[MASK]\n\nfor ($i = 1; $i -le $days; $i++) {\n[MASK]\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n$currentCoins = 1\n[MASK]\n\nfor ($i = 1; $i -le $days; $i++) {\n[MASK]\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}"}
{"task_id": "PowerShell/19-1-multi", "prompt": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n<#\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n#>", "canonical_solution": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}", "test": "function Test-TotalCoins() {\nif ((Get-TotalCoins -days 7) -ne 18) { throw \"Test case 1 failed\" }\nif ((Get-TotalCoins -days 10) -ne 30) { throw \"Test case 2 failed\" }\nif ((Get-TotalCoins -days 15) -ne 55) { throw \"Test case 3 failed\" }\nif ((Get-TotalCoins -days 20) -ne 85) { throw \"Test case 4 failed\" }\nif ((Get-TotalCoins -days 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Get-TotalCoins -days 3) -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-TotalCoins -days 5) -ne 11) { throw \"Test case 7 failed\" }\n}\n\nTest-TotalCoins", "entry_point": "Get-TotalCoins", "signature": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n", "docstring": "\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n\n\n* Incomplete Code:\nfunction Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n\n$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\n[MASK]\n$totalCoins += $currentCoins\n[MASK]\n\n[MASK]\n[MASK]\n$currentDayCount = 0\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\n[MASK]\n$totalCoins += $currentCoins\n[MASK]\n\n[MASK]\n[MASK]\n$currentDayCount = 0\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/20-0-multi", "prompt": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n<#\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n#>", "canonical_solution": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}", "test": "# Test cases\nfunction Test-MinesweeperGrid() {\n$test1 = Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n$expected1 = @(\"*10\", \"221\", \"1*1\")\n\n$test2 = Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n$expected2 = @(\"2*1\", \"*21\")\n\nif (Compare-Object $test1 $expected1) { throw \"Test case 1 failed\" }\nif (Compare-Object $test2 $expected2) { throw \"Test case 2 failed\" }\n}\n\nTest-MinesweeperGrid", "entry_point": "Get-MinesweeperGrid", "signature": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n", "docstring": "\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n\n\n* Incomplete Code:\nfunction Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n\n$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\n[MASK]\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n[MASK]\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\n[MASK]\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n[MASK]\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/20-1-multi", "prompt": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n<#\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n#>", "canonical_solution": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}", "test": "# Test cases\nfunction Test-MinesweeperGrid() {\n$test1 = Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n$expected1 = @(\"*10\", \"221\", \"1*1\")\n\n$test2 = Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n$expected2 = @(\"2*1\", \"*21\")\n\nif (Compare-Object $test1 $expected1) { throw \"Test case 1 failed\" }\nif (Compare-Object $test2 $expected2) { throw \"Test case 2 failed\" }\n}\n\nTest-MinesweeperGrid", "entry_point": "Get-MinesweeperGrid", "signature": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n", "docstring": "\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n\n\n* Incomplete Code:\nfunction Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n\n$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\n[MASK]\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\n[MASK]\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n[MASK]\n}\n\n$outputGrid[$row] = $outputRow\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\n[MASK]\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\n[MASK]\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n[MASK]\n}\n\n$outputGrid[$row] = $outputRow\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/21-0-multi", "prompt": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n<#\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n#>", "canonical_solution": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}", "test": "function Test-MinimumCowsForHeight() {\nif ((Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5))))) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18))))) -ne 3) { throw \"Test case 2 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 45 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](9, 15, 8, 17, 6))))) -ne 4) { throw \"Test case 3 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 70 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](22, 27, 15, 10, 18))))) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MinimumCowsForHeight", "entry_point": "Get-MinimumCowsForHeight", "signature": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n", "docstring": "\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n\n\n* Incomplete Code:\nfunction Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n\n[MASK]\n$totalHeight = 0\n[MASK]\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n[MASK]\n[MASK]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n$totalHeight = 0\n[MASK]\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n[MASK]\n[MASK]\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/21-1-multi", "prompt": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n<#\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n#>", "canonical_solution": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}", "test": "function Test-MinimumCowsForHeight() {\nif ((Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5))))) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18))))) -ne 3) { throw \"Test case 2 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 45 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](9, 15, 8, 17, 6))))) -ne 4) { throw \"Test case 3 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 70 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](22, 27, 15, 10, 18))))) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MinimumCowsForHeight", "entry_point": "Get-MinimumCowsForHeight", "signature": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n", "docstring": "\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n\n\n* Incomplete Code:\nfunction Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n\n[MASK]\n[MASK]\n[MASK]\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n[MASK]\n[MASK]\n}\n\nreturn $cowCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n[MASK]\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n[MASK]\n[MASK]\n}\n\nreturn $cowCount\n}"}
{"task_id": "PowerShell/22-0-multi", "prompt": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n<#\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n#>", "canonical_solution": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}", "test": "# Test cases\nfunction Test-MaximumScore() {\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 200) -ne 1400) { throw \"Test case 1 failed\" }\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 300) -ne 1600) { throw \"Test case 2 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 150 -scoreBlueInBlue 200 -scoreCrossColor 100) -ne 850) { throw \"Test case 3 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 3 -scoreRedInRed 150 -scoreBlueInBlue 300 -scoreCrossColor 200) -ne 1350) { throw \"Test case 4 failed\" }\n}\n\nTest-MaximumScore", "entry_point": "Get-MaximumScore", "signature": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n", "docstring": "\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n\n\n* Incomplete Code:\nfunction Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n\n$maxScore = 0\n\n# 计算同色放置得分\n[MASK]\n# 计算交叉放置得分\n[MASK]\n[MASK]\n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n[MASK]\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$maxScore = 0\n\n# 计算同色放置得分\n[MASK]\n# 计算交叉放置得分\n[MASK]\n[MASK]\n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n[MASK]\n\n[MASK]\n}"}
{"task_id": "PowerShell/22-1-multi", "prompt": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n<#\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n#>", "canonical_solution": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}", "test": "# Test cases\nfunction Test-MaximumScore() {\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 200) -ne 1400) { throw \"Test case 1 failed\" }\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 300) -ne 1600) { throw \"Test case 2 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 150 -scoreBlueInBlue 200 -scoreCrossColor 100) -ne 850) { throw \"Test case 3 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 3 -scoreRedInRed 150 -scoreBlueInBlue 300 -scoreCrossColor 200) -ne 1350) { throw \"Test case 4 failed\" }\n}\n\nTest-MaximumScore", "entry_point": "Get-MaximumScore", "signature": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n", "docstring": "\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n\n\n* Incomplete Code:\nfunction Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n\n[MASK]\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n[MASK]\n\nreturn $maxScore\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n[MASK]\n\nreturn $maxScore\n}"}
{"task_id": "PowerShell/23-0-multi", "prompt": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n<#\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n#>", "canonical_solution": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}", "test": "function Test-MostFrequentDiceSum() {\nif ((Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3) -ne 5) { throw \"Test case 1 failed\" }\nif ((Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6) -ne 8) { throw \"Test case 2 failed\" }\nif ((Get-MostFrequentDiceSum -s1 6 -s2 6 -s3 6) -ne 10) { throw \"Test case 3 failed\" }\nif ((Get-MostFrequentDiceSum -s1 2 -s2 2 -s3 2) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MostFrequentDiceSum", "entry_point": "Get-MostFrequentDiceSum", "signature": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n", "docstring": "\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n\n\n* Incomplete Code:\nfunction Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n\n$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n[MASK]\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n[MASK]\n}\n}\n\nreturn $resultSum\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n[MASK]\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n[MASK]\n}\n}\n\nreturn $resultSum\n}"}
{"task_id": "PowerShell/23-1-multi", "prompt": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n<#\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n#>", "canonical_solution": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}", "test": "function Test-MostFrequentDiceSum() {\nif ((Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3) -ne 5) { throw \"Test case 1 failed\" }\nif ((Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6) -ne 8) { throw \"Test case 2 failed\" }\nif ((Get-MostFrequentDiceSum -s1 6 -s2 6 -s3 6) -ne 10) { throw \"Test case 3 failed\" }\nif ((Get-MostFrequentDiceSum -s1 2 -s2 2 -s3 2) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MostFrequentDiceSum", "entry_point": "Get-MostFrequentDiceSum", "signature": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n", "docstring": "\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n\n\n* Incomplete Code:\nfunction Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n\n$sumFrequency = @{}\n\n[MASK]\nfor ($j = 1; $j -le $s2; $j++) {\n[MASK]\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$sumFrequency = @{}\n\n[MASK]\nfor ($j = 1; $j -le $s2; $j++) {\n[MASK]\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}"}
{"task_id": "PowerShell/24-0-multi", "prompt": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n<#\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n#>", "canonical_solution": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}", "test": "function Test-DetermineParity() {\n$result1 = Determine-Parity @(\"1024\", \"5931\")\n\nif (Compare-Object $result1 @(\"even\", \"odd\")) { throw \"Test case 1 failed\" }\n\n$result2 = Determine-Parity @(\"123456789012345678901234567890\", \"123456789012345678901234567891\")\nif (Compare-Object $result2 @(\"even\", \"odd\")) { throw \"Test case 2 failed\" }\n}\n\nTest-DetermineParity", "entry_point": "Determine-Parity", "signature": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n", "docstring": "\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n\n\n* Incomplete Code:\nfunction Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n\n[MASK]\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n[MASK]\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n[MASK]\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/24-1-multi", "prompt": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n<#\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n#>", "canonical_solution": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}", "test": "function Test-DetermineParity() {\n$result1 = Determine-Parity @(\"1024\", \"5931\")\n\nif (Compare-Object $result1 @(\"even\", \"odd\")) { throw \"Test case 1 failed\" }\n\n$result2 = Determine-Parity @(\"123456789012345678901234567890\", \"123456789012345678901234567891\")\nif (Compare-Object $result2 @(\"even\", \"odd\")) { throw \"Test case 2 failed\" }\n}\n\nTest-DetermineParity", "entry_point": "Determine-Parity", "signature": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n", "docstring": "\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n\n\n* Incomplete Code:\nfunction Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n\n$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n[MASK]\n} else {\n[MASK]\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n[MASK]\n} else {\n[MASK]\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/25-0-multi", "prompt": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n<#\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n#>", "canonical_solution": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\nreturn $results\n}", "test": "function Test-StudentIDsByOrder() {\n$result1 = Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\nif (Compare-Object $result1 @(1, 8, 5)) { throw \"Test case 1 failed\" }\n\n$result2 = Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\nif (Compare-Object $result2 @(15, 22)) { throw \"Test case 2 failed\" }\n}\n\nTest-StudentIDsByOrder", "entry_point": "Get-StudentIDsByOrder", "signature": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n", "docstring": "\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n\n\n* Incomplete Code:\nfunction Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n\n[MASK]\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/25-1-multi", "prompt": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n<#\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n#>", "canonical_solution": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\nreturn $results\n}", "test": "function Test-StudentIDsByOrder() {\n$result1 = Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\nif (Compare-Object $result1 @(1, 8, 5)) { throw \"Test case 1 failed\" }\n\n$result2 = Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\nif (Compare-Object $result2 @(15, 22)) { throw \"Test case 2 failed\" }\n}\n\nTest-StudentIDsByOrder", "entry_point": "Get-StudentIDsByOrder", "signature": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n", "docstring": "\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n\n\n* Incomplete Code:\nfunction Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n\n$results = @()\n\nforeach ($query in $queries) {\n[MASK]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$results = @()\n\nforeach ($query in $queries) {\n[MASK]\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/26-0-multi", "prompt": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n<#\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n#>", "canonical_solution": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\nreturn $vkCount\n}", "test": "function Test-MaximizeVKOccurrences() {\nif ((Maximize-VKOccurrences -inputString \"VK\") -ne 1) { throw \"Test case 1 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VV\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Maximize-VKOccurrences -inputString \"V\") -ne 0) { throw \"Test case 3 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\") -ne 3) { throw \"Test case 4 failed\" }\nif ((Maximize-VKOccurrences -inputString \"KVKV\") -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-MaximizeVKOccurrences", "entry_point": "Maximize-VKOccurrences", "signature": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n", "docstring": "\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n\n\n* Incomplete Code:\nfunction Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n\n$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\n[MASK]\n[MASK]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\n[MASK]\n[MASK]\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/26-1-multi", "prompt": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n<#\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n#>", "canonical_solution": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\nreturn $vkCount\n}", "test": "function Test-MaximizeVKOccurrences() {\nif ((Maximize-VKOccurrences -inputString \"VK\") -ne 1) { throw \"Test case 1 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VV\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Maximize-VKOccurrences -inputString \"V\") -ne 0) { throw \"Test case 3 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\") -ne 3) { throw \"Test case 4 failed\" }\nif ((Maximize-VKOccurrences -inputString \"KVKV\") -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-MaximizeVKOccurrences", "entry_point": "Maximize-VKOccurrences", "signature": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n", "docstring": "\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n\n\n* Incomplete Code:\nfunction Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n\n[MASK]\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\n[MASK]\n[MASK]\n}\n\nreturn $vkCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\n[MASK]\n[MASK]\n}\n\nreturn $vkCount\n}"}
{"task_id": "PowerShell/29-0-multi", "prompt": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n<#\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n#>", "canonical_solution": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}", "test": "function Test-MinimumSegments() {\nif ((Get-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumSegments -numbers @(1, 2, 3, 4, 5) -maxSum 10) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MinimumSegments -numbers @(10, 10, 10) -maxSum 10) -ne 3) { throw \"Test case 3 failed\" }\n}\n\nTest-MinimumSegments", "entry_point": "Get-MinimumSegments", "signature": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n", "docstring": "\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n\n\n* Incomplete Code:\nfunction Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n\n[MASK]\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n[MASK]\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n[MASK]\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}"}
{"task_id": "PowerShell/29-1-multi", "prompt": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n<#\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n#>", "canonical_solution": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}", "test": "function Test-MinimumSegments() {\nif ((Get-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumSegments -numbers @(1, 2, 3, 4, 5) -maxSum 10) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MinimumSegments -numbers @(10, 10, 10) -maxSum 10) -ne 3) { throw \"Test case 3 failed\" }\n}\n\nTest-MinimumSegments", "entry_point": "Get-MinimumSegments", "signature": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n", "docstring": "\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n\n\n* Incomplete Code:\nfunction Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n\n$segmentCount = 0\n[MASK]\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n[MASK]\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$segmentCount = 0\n[MASK]\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n[MASK]\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}"}
{"task_id": "PowerShell/30-0-multi", "prompt": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n<#\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n#>", "canonical_solution": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}", "test": "function Test-MaxDaysTogether() {\nif ((Get-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")) -ne 1) { throw \"Test case 1 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Park\", \"Mall\") -herLocations @(\"Park\", \"School\", \"Mall\", \"Home\")) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Library\", \"Cafe\") -herLocations @(\"Home\", \"School\", \"Gym\")) -ne 0) { throw \"Test case 3 failed\" }\n}\n\nTest-MaxDaysTogether", "entry_point": "Get-MaxDaysTogether", "signature": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n", "docstring": "\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n\n\n* Incomplete Code:\nfunction Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n\n$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\nreturn $daysTogether\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\n[MASK]\n[MASK]\n[MASK]\n}\n}\n\nreturn $daysTogether\n}"}
{"task_id": "PowerShell/30-1-multi", "prompt": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n<#\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n#>", "canonical_solution": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}", "test": "function Test-MaxDaysTogether() {\nif ((Get-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")) -ne 1) { throw \"Test case 1 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Park\", \"Mall\") -herLocations @(\"Park\", \"School\", \"Mall\", \"Home\")) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Library\", \"Cafe\") -herLocations @(\"Home\", \"School\", \"Gym\")) -ne 0) { throw \"Test case 3 failed\" }\n}\n\nTest-MaxDaysTogether", "entry_point": "Get-MaxDaysTogether", "signature": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n", "docstring": "\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n\n\n* Incomplete Code:\nfunction Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n\n[MASK]\n[MASK]\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}"}
{"task_id": "PowerShell/31-0-multi", "prompt": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n<#\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n#>", "canonical_solution": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}", "test": "function Test-ModelSurfaceArea {\nif ((Calculate-ModelSurfaceArea 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))) -ne 38) { throw \"Test case 1 failed\" }\nif ((Calculate-ModelSurfaceArea 2 2 @(@(1,0), @(0,1))) -ne 12) { throw \"Test case 2 failed\" }\nif ((Calculate-ModelSurfaceArea 2 3 @(@(2,3,2), @(1,0,1))) -ne 34) { throw \"Test case 3 failed\" }\nif ((Calculate-ModelSurfaceArea 4 4 @(@(0,0,0,0), @(0,2,2,0), @(0,2,2,0), @(0,0,0,0))) -ne 24) { throw \"Test case 4 failed\" }\n}\n\nTest-ModelSurfaceArea", "entry_point": "Calculate-ModelSurfaceArea", "signature": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n", "docstring": "\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n\n\n* Incomplete Code:\nfunction Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n\n[MASK]\n\n[MASK]\n[MASK]\n[MASK]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n[MASK]\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n\n[MASK]\n[MASK]\n[MASK]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n[MASK]\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}"}
{"task_id": "PowerShell/31-1-multi", "prompt": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n<#\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n#>", "canonical_solution": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}", "test": "function Test-ModelSurfaceArea {\nif ((Calculate-ModelSurfaceArea 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))) -ne 38) { throw \"Test case 1 failed\" }\nif ((Calculate-ModelSurfaceArea 2 2 @(@(1,0), @(0,1))) -ne 12) { throw \"Test case 2 failed\" }\nif ((Calculate-ModelSurfaceArea 2 3 @(@(2,3,2), @(1,0,1))) -ne 34) { throw \"Test case 3 failed\" }\nif ((Calculate-ModelSurfaceArea 4 4 @(@(0,0,0,0), @(0,2,2,0), @(0,2,2,0), @(0,0,0,0))) -ne 24) { throw \"Test case 4 failed\" }\n}\n\nTest-ModelSurfaceArea", "entry_point": "Calculate-ModelSurfaceArea", "signature": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n", "docstring": "\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n\n\n* Incomplete Code:\nfunction Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n\n$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n[MASK]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n[MASK]\n}\n}\n}\n\nreturn $totalArea\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n[MASK]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n[MASK]\n}\n}\n}\n\nreturn $totalArea\n}"}
{"task_id": "PowerShell/32-0-multi", "prompt": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n<#\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n#>", "canonical_solution": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}", "test": "function Test-WaterCollectionTime {\nif ((Calculate-WaterCollectionTime 4 2 @(3, 3, 4, 4)) -ne 7) { throw \"Test case 1 failed\" }\nif ((Calculate-WaterCollectionTime 3 1 @(2, 3, 4)) -ne 9) { throw \"Test case 2 failed\" }\nif ((Calculate-WaterCollectionTime 6 3 @(1, 2, 2, 3, 1, 4)) -ne 6) { throw \"Test case 3 failed\" }\nif ((Calculate-WaterCollectionTime 2 2 @(5, 6)) -ne 6) { throw \"Test case 4 failed\" }\nif ((Calculate-WaterCollectionTime 5 3 @(1, 1, 1, 1, 1)) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nTest-WaterCollectionTime", "entry_point": "Calculate-WaterCollectionTime", "signature": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n", "docstring": "\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n\n\n* Incomplete Code:\nfunction Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n\n[MASK]\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n[MASK]\n}\n\nwhile ($queue.Count -gt 0) {\n[MASK]\n$activeTaps = [Math]::Min($m, $queue.Count)\n[MASK]\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n[MASK]\n}\n\nwhile ($queue.Count -gt 0) {\n[MASK]\n$activeTaps = [Math]::Min($m, $queue.Count)\n[MASK]\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/32-1-multi", "prompt": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n<#\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n#>", "canonical_solution": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}", "test": "function Test-WaterCollectionTime {\nif ((Calculate-WaterCollectionTime 4 2 @(3, 3, 4, 4)) -ne 7) { throw \"Test case 1 failed\" }\nif ((Calculate-WaterCollectionTime 3 1 @(2, 3, 4)) -ne 9) { throw \"Test case 2 failed\" }\nif ((Calculate-WaterCollectionTime 6 3 @(1, 2, 2, 3, 1, 4)) -ne 6) { throw \"Test case 3 failed\" }\nif ((Calculate-WaterCollectionTime 2 2 @(5, 6)) -ne 6) { throw \"Test case 4 failed\" }\nif ((Calculate-WaterCollectionTime 5 3 @(1, 1, 1, 1, 1)) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nTest-WaterCollectionTime", "entry_point": "Calculate-WaterCollectionTime", "signature": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n", "docstring": "\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n\n\n* Incomplete Code:\nfunction Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n\n$queue = New-Object System.Collections.Queue\n$totalTime = 0\n[MASK]\n\nforeach ($amount in $waterAmounts) {\n[MASK]\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\n[MASK]\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n[MASK]\n\nforeach ($amount in $waterAmounts) {\n[MASK]\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\n[MASK]\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}"}
{"task_id": "PowerShell/33-0-multi", "prompt": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n<#\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n#>", "canonical_solution": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}", "test": "# Test cases\nfunction Test-WaysToClimb {\nif ((Calculate-WaysToClimb 4 2) -ne 5) { throw \"Test case 1 failed\" }\nif ((Calculate-WaysToClimb 3 3) -ne 4) { throw \"Test case 2 failed\" }\nif ((Calculate-WaysToClimb 6 3) -ne 24) { throw \"Test case 3 failed\" }\nif ((Calculate-WaysToClimb 7 4) -ne 56) { throw \"Test case 4 failed\" }\nif ((Calculate-WaysToClimb 10 5) -ne 464) { throw \"Test case 5 failed\" }\n}\n\nTest-WaysToClimb", "entry_point": "Calculate-WaysToClimb", "signature": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n", "docstring": "\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n\n\n* Incomplete Code:\nfunction Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n\n$mod = 100003\n$ways = New-Object int[] ($N + 1)\n[MASK]\n\n[MASK]\n[MASK]\nfor ($j = 1; $j -le $K; $j++) {\n[MASK]\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n[MASK]\n\n[MASK]\n[MASK]\nfor ($j = 1; $j -le $K; $j++) {\n[MASK]\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/33-1-multi", "prompt": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n<#\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n#>", "canonical_solution": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}", "test": "# Test cases\nfunction Test-WaysToClimb {\nif ((Calculate-WaysToClimb 4 2) -ne 5) { throw \"Test case 1 failed\" }\nif ((Calculate-WaysToClimb 3 3) -ne 4) { throw \"Test case 2 failed\" }\nif ((Calculate-WaysToClimb 6 3) -ne 24) { throw \"Test case 3 failed\" }\nif ((Calculate-WaysToClimb 7 4) -ne 56) { throw \"Test case 4 failed\" }\nif ((Calculate-WaysToClimb 10 5) -ne 464) { throw \"Test case 5 failed\" }\n}\n\nTest-WaysToClimb", "entry_point": "Calculate-WaysToClimb", "signature": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n", "docstring": "\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n\n\n* Incomplete Code:\nfunction Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n\n$mod = 100003\n$ways = New-Object int[] ($N + 1)\n[MASK]\n\n[MASK]\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n[MASK]\n}\n}\n}\n\nreturn $ways[$N]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n[MASK]\n\n[MASK]\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n[MASK]\n}\n}\n}\n\nreturn $ways[$N]\n}"}
{"task_id": "PowerShell/34-0-multi", "prompt": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n<#\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n#>", "canonical_solution": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}", "test": "function Test-MinimumMilkCost() {\n$farmers1 = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n$result1 = Get-MinimumMilkCost 100 $farmers1\nGet-MinimumMilkCost 100 $farmers1\nif ($result1 -ne 570) { throw \"Test case 1 failed: Expected 580, got $result1\" }\n\n$farmers2 = @([PSCustomObject]@{price=10; quantity=30}, [PSCustomObject]@{price=7; quantity=60}, [PSCustomObject]@{price=2; quantity=40})\n$result2 = Get-MinimumMilkCost 50 $farmers2\nif ($result2 -ne 150) { throw \"Test case 2 failed: Expected 140, got $result2\" }\n\n$farmers3 = @([PSCustomObject]@{price=8; quantity=25}, [PSCustomObject]@{price=5; quantity=55}, [PSCustomObject]@{price=6; quantity=20})\n$result3 = Get-MinimumMilkCost 75 $farmers3\nif ($result3 -ne 395) { throw \"Test case 3 failed: Expected 430, got $result3\" }\n}\n\nTest-MinimumMilkCost", "entry_point": "Get-MinimumMilkCost", "signature": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n", "docstring": "\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n\n\n* Incomplete Code:\nfunction Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n\n[MASK]\n\n$totalCost = 0\n[MASK]\n[MASK]\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n[MASK]\n}\n\nreturn $totalCost\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n\n$totalCost = 0\n[MASK]\n[MASK]\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n[MASK]\n}\n\nreturn $totalCost\n}"}
{"task_id": "PowerShell/34-1-multi", "prompt": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n<#\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n#>", "canonical_solution": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}", "test": "function Test-MinimumMilkCost() {\n$farmers1 = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n$result1 = Get-MinimumMilkCost 100 $farmers1\nGet-MinimumMilkCost 100 $farmers1\nif ($result1 -ne 570) { throw \"Test case 1 failed: Expected 580, got $result1\" }\n\n$farmers2 = @([PSCustomObject]@{price=10; quantity=30}, [PSCustomObject]@{price=7; quantity=60}, [PSCustomObject]@{price=2; quantity=40})\n$result2 = Get-MinimumMilkCost 50 $farmers2\nif ($result2 -ne 150) { throw \"Test case 2 failed: Expected 140, got $result2\" }\n\n$farmers3 = @([PSCustomObject]@{price=8; quantity=25}, [PSCustomObject]@{price=5; quantity=55}, [PSCustomObject]@{price=6; quantity=20})\n$result3 = Get-MinimumMilkCost 75 $farmers3\nif ($result3 -ne 395) { throw \"Test case 3 failed: Expected 430, got $result3\" }\n}\n\nTest-MinimumMilkCost", "entry_point": "Get-MinimumMilkCost", "signature": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n", "docstring": "\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n\n\n* Incomplete Code:\nfunction Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n\n[MASK]\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n[MASK]\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n[MASK]\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/35-0-multi", "prompt": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n<#\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n#>", "canonical_solution": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}", "test": "function Test-MaxPathSum() {\n$pyramid1 = @( @(3), @(7, 4), @(2, 4, 6), @(8, 5, 9, 3) )\n$result1 = Get-MaxPathSum $pyramid1\nif ($result1 -ne 23) { throw \"Test case 1 failed: Expected 23, got $result1\" }\n\n$pyramid2 = @( @(1), @(2, 1), @(1, 2, 1) )\n$result2 = Get-MaxPathSum $pyramid2\nif ($result2 -ne 5) { throw \"Test case 2 failed: Expected 4, got $result2\" }\n\n$pyramid3 = @( @(1) )\n$result3 = Get-MaxPathSum $pyramid3\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 1, got $result3\" }\n}\n\nTest-MaxPathSum", "entry_point": "Get-MaxPathSum", "signature": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n", "docstring": "\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n\n\n* Incomplete Code:\nfunction Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n\n\n[MASK]\n[MASK]\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\n[MASK]\n[MASK]\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}"}
{"task_id": "PowerShell/35-1-multi", "prompt": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n<#\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n#>", "canonical_solution": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}", "test": "function Test-MaxPathSum() {\n$pyramid1 = @( @(3), @(7, 4), @(2, 4, 6), @(8, 5, 9, 3) )\n$result1 = Get-MaxPathSum $pyramid1\nif ($result1 -ne 23) { throw \"Test case 1 failed: Expected 23, got $result1\" }\n\n$pyramid2 = @( @(1), @(2, 1), @(1, 2, 1) )\n$result2 = Get-MaxPathSum $pyramid2\nif ($result2 -ne 5) { throw \"Test case 2 failed: Expected 4, got $result2\" }\n\n$pyramid3 = @( @(1) )\n$result3 = Get-MaxPathSum $pyramid3\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 1, got $result3\" }\n}\n\nTest-MaxPathSum", "entry_point": "Get-MaxPathSum", "signature": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n", "docstring": "\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n\n\n* Incomplete Code:\nfunction Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n\n\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n[MASK]\n}\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n[MASK]\n}\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/36-0-multi", "prompt": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n<#\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n#>", "canonical_solution": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}", "test": "function Test-OptimalQueueOrder() {\n$result1 = Get-OptimalQueueOrder @(20, 10, 30)\nif ((Compare-Object $result1 @(1, 0, 2))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-OptimalQueueOrder @(5, 3, 8)\nif ((Compare-Object $result2 @(1, 0, 2))) { throw \"Test case 2 failed\" }\n\n$result3 = Get-OptimalQueueOrder @(15, 5, 3, 7)\nif ((Compare-Object $result3 @(2, 1, 3, 0))) { throw \"Test case 3 failed\" }\n}\n\nTest-OptimalQueueOrder", "entry_point": "Get-OptimalQueueOrder", "signature": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n", "docstring": "\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n\n\n* Incomplete Code:\nfunction Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n\n[MASK]\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n[MASK]\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n[MASK]\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\n[MASK]\n}"}
{"task_id": "PowerShell/36-1-multi", "prompt": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n<#\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n#>", "canonical_solution": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}", "test": "function Test-OptimalQueueOrder() {\n$result1 = Get-OptimalQueueOrder @(20, 10, 30)\nif ((Compare-Object $result1 @(1, 0, 2))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-OptimalQueueOrder @(5, 3, 8)\nif ((Compare-Object $result2 @(1, 0, 2))) { throw \"Test case 2 failed\" }\n\n$result3 = Get-OptimalQueueOrder @(15, 5, 3, 7)\nif ((Compare-Object $result3 @(2, 1, 3, 0))) { throw \"Test case 3 failed\" }\n}\n\nTest-OptimalQueueOrder", "entry_point": "Get-OptimalQueueOrder", "signature": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n", "docstring": "\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n\n\n* Incomplete Code:\nfunction Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n\n$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n[MASK]\n\n$totalTime = 0\n$cumulativeTime = 0\n[MASK]\n[MASK]\n[MASK]\n}\n\nreturn $sortedIndices\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n[MASK]\n\n$totalTime = 0\n$cumulativeTime = 0\n[MASK]\n[MASK]\n[MASK]\n}\n\nreturn $sortedIndices\n}"}
{"task_id": "PowerShell/37-0-multi", "prompt": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n<#\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n#>", "canonical_solution": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}", "test": "function Test-SpecialPrimes() {\n$result1 = Get-SpecialPrimes 2\nif (-not (Compare-Object $result1 @(23, 29, 31, 37, 53, 59, 71, 73, 79, 97))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-SpecialPrimes 3\nif ($result2.Count -eq 0) { throw \"Test case 2 failed: No special primes found\" }\n}\n\nTest-SpecialPrimes", "entry_point": "Get-SpecialPrimes", "signature": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n", "docstring": "\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n\n\n* Incomplete Code:\nfunction Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n\nfunction Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\n[MASK]\n[MASK]\nreturn $false\n}\n}\nreturn $true\n}\n\n[MASK]\n[MASK]\n[MASK]\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\n[MASK]\n[MASK]\nreturn $false\n}\n}\nreturn $true\n}\n\n[MASK]\n[MASK]\n[MASK]\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}"}
{"task_id": "PowerShell/37-1-multi", "prompt": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n<#\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n#>", "canonical_solution": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}", "test": "function Test-SpecialPrimes() {\n$result1 = Get-SpecialPrimes 2\nif (-not (Compare-Object $result1 @(23, 29, 31, 37, 53, 59, 71, 73, 79, 97))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-SpecialPrimes 3\nif ($result2.Count -eq 0) { throw \"Test case 2 failed: No special primes found\" }\n}\n\nTest-SpecialPrimes", "entry_point": "Get-SpecialPrimes", "signature": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n", "docstring": "\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n\n\n* Incomplete Code:\nfunction Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n\nfunction Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\n[MASK]\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\n[MASK]\nreturn $false\n}\n}\nreturn $true\n}\n\n[MASK]\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\n[MASK]\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\n[MASK]\nreturn $false\n}\n}\nreturn $true\n}\n\n[MASK]\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}"}
{"task_id": "PowerShell/38-0-multi", "prompt": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n<#\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n#>", "canonical_solution": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}", "test": "function Test-ModPower() {\n$result1 = Calculate-ModPower 2 10 9\nif ($result1 -ne 7) { throw \"Test case 1 failed: Expected 2^10 mod 9=7, got $result1\" }\n\n$result2 = Calculate-ModPower 3 7 5\nif ($result2 -ne 2) { throw \"Test case 2 failed: Expected 3^7 mod 5=2, got $result2\" }\n\n$result3 = Calculate-ModPower 5 3 4\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 5^3 mod 4=1, got $result3\" }\n}\n\nTest-ModPower", "entry_point": "Calculate-ModPower", "signature": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n", "docstring": "\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n\n\n* Incomplete Code:\nfunction Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n\n[MASK]\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n[MASK]\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n[MASK]\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/38-1-multi", "prompt": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n<#\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n#>", "canonical_solution": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}", "test": "function Test-ModPower() {\n$result1 = Calculate-ModPower 2 10 9\nif ($result1 -ne 7) { throw \"Test case 1 failed: Expected 2^10 mod 9=7, got $result1\" }\n\n$result2 = Calculate-ModPower 3 7 5\nif ($result2 -ne 2) { throw \"Test case 2 failed: Expected 3^7 mod 5=2, got $result2\" }\n\n$result3 = Calculate-ModPower 5 3 4\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 5^3 mod 4=1, got $result3\" }\n}\n\nTest-ModPower", "entry_point": "Calculate-ModPower", "signature": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n", "docstring": "\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n\n\n* Incomplete Code:\nfunction Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n\n[MASK]\n$a = $a % $p\n\n[MASK]\n[MASK]\n[MASK]\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n$a = $a % $p\n\n[MASK]\n[MASK]\n[MASK]\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/39-0-multi", "prompt": "function Find-MinimumSeriesSum {\n    <#\n    This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\n    The function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\n    Example:\n    >>> Find-MinimumSeriesSum -k 2\n    Returns the value of n for which the sum S_n exceeds 2.\n\n    >>> Find-MinimumSeriesSum -k 3\n    Returns the value of n for which the sum S_n exceeds 3.\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}", "test": "function Test-FindMinimumSeriesSum {\n    if ((Find-MinimumSeriesSum -k 2) -ne 4) { throw \"Test case 1 failed\" }\n    if ((Find-MinimumSeriesSum -k 3) -ne 11) { throw \"Test case 2 failed\" }\n    if ((Find-MinimumSeriesSum -k 4) -ne 31) { throw \"Test case 3 failed\" }\n    if ((Find-MinimumSeriesSum -k 5) -ne 83) { throw \"Test case 4 failed\" }\n    if ((Find-MinimumSeriesSum -k 6) -ne 227) { throw \"Test case 5 failed\" }\n}\n\nTest-FindMinimumSeriesSum", "entry_point": "Find-MinimumSeriesSum", "signature": "function Find-MinimumSeriesSum {", "docstring": "This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.\n\n* Incomplete Code:\nfunction Find-MinimumSeriesSum {\n    param (\n[MASK]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n[MASK]\n        $n++\n    }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n[MASK]\n        $n++\n    }\n\n[MASK]\n}"}
{"task_id": "PowerShell/39-1-multi", "prompt": "function Find-MinimumSeriesSum {\n    <#\n    This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\n    The function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\n    Example:\n    >>> Find-MinimumSeriesSum -k 2\n    Returns the value of n for which the sum S_n exceeds 2.\n\n    >>> Find-MinimumSeriesSum -k 3\n    Returns the value of n for which the sum S_n exceeds 3.\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}", "test": "function Test-FindMinimumSeriesSum {\n    if ((Find-MinimumSeriesSum -k 2) -ne 4) { throw \"Test case 1 failed\" }\n    if ((Find-MinimumSeriesSum -k 3) -ne 11) { throw \"Test case 2 failed\" }\n    if ((Find-MinimumSeriesSum -k 4) -ne 31) { throw \"Test case 3 failed\" }\n    if ((Find-MinimumSeriesSum -k 5) -ne 83) { throw \"Test case 4 failed\" }\n    if ((Find-MinimumSeriesSum -k 6) -ne 227) { throw \"Test case 5 failed\" }\n}\n\nTest-FindMinimumSeriesSum", "entry_point": "Find-MinimumSeriesSum", "signature": "function Find-MinimumSeriesSum {", "docstring": "This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.\n\n* Incomplete Code:\nfunction Find-MinimumSeriesSum {\n[MASK]\n[MASK]\n        [int]$k\n    )\n\n[MASK]\n    $sum = 0\n\n    while ($sum -le $k) {\n[MASK]\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n        [int]$k\n    )\n\n[MASK]\n    $sum = 0\n\n    while ($sum -le $k) {\n[MASK]\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}"}
{"task_id": "PowerShell/40-0-multi", "prompt": "function Get-MaxPens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}", "test": "function Test-GetMaxPens {\n    if ((Get-MaxPens -a 10 -b 3) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-MaxPens -a 20 -b 5) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-MaxPens -a 5 -b 9) -ne 3) { throw \"Test case 3 failed\" }\n    if ((Get-MaxPens -a 0 -b 19) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Get-MaxPens -a 7 -b 2) -ne 3) { throw \"Test case 5 failed\" }\n}\n\nTest-GetMaxPens", "entry_point": "Get-MaxPens", "signature": "function Get-MaxPens {", "docstring": "# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n\n* Incomplete Code:\nfunction Get-MaxPens {\n[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n[MASK]\n}"}
{"task_id": "PowerShell/40-1-multi", "prompt": "function Get-MaxPens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}", "test": "function Test-GetMaxPens {\n    if ((Get-MaxPens -a 10 -b 3) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-MaxPens -a 20 -b 5) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-MaxPens -a 5 -b 9) -ne 3) { throw \"Test case 3 failed\" }\n    if ((Get-MaxPens -a 0 -b 19) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Get-MaxPens -a 7 -b 2) -ne 3) { throw \"Test case 5 failed\" }\n}\n\nTest-GetMaxPens", "entry_point": "Get-MaxPens", "signature": "function Get-MaxPens {", "docstring": "# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n\n* Incomplete Code:\nfunction Get-MaxPens {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n[MASK]\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n[MASK]\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}"}
{"task_id": "PowerShell/41-0-multi", "prompt": "function Get-AbsoluteValue {\n    <#\n    This function takes an integer as input and returns its absolute value.\n\n    >>> Get-AbsoluteValue -n 5\n    5\n    >>> Get-AbsoluteValue -n -10\n    10\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}", "test": "function Test-GetAbsoluteValue {\n    if ((Get-AbsoluteValue -n 5) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-AbsoluteValue -n -10) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-AbsoluteValue -n 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Get-AbsoluteValue -n -20000) -ne 20000) { throw \"Test case 4 failed\" }\n    if ((Get-AbsoluteValue -n 10000) -ne 10000) { throw \"Test case 5 failed\" }\n}\n\nTest-GetAbsoluteValue", "entry_point": "Get-AbsoluteValue", "signature": "function Get-AbsoluteValue {", "docstring": "This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10\n\n* Incomplete Code:\nfunction Get-AbsoluteValue {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n        return -$n\n    } else {\n[MASK]\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n        return -$n\n    } else {\n[MASK]\n    }\n}"}
{"task_id": "PowerShell/41-1-multi", "prompt": "function Get-AbsoluteValue {\n    <#\n    This function takes an integer as input and returns its absolute value.\n\n    >>> Get-AbsoluteValue -n 5\n    5\n    >>> Get-AbsoluteValue -n -10\n    10\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}", "test": "function Test-GetAbsoluteValue {\n    if ((Get-AbsoluteValue -n 5) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-AbsoluteValue -n -10) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-AbsoluteValue -n 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Get-AbsoluteValue -n -20000) -ne 20000) { throw \"Test case 4 failed\" }\n    if ((Get-AbsoluteValue -n 10000) -ne 10000) { throw \"Test case 5 failed\" }\n}\n\nTest-GetAbsoluteValue", "entry_point": "Get-AbsoluteValue", "signature": "function Get-AbsoluteValue {", "docstring": "This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10\n\n* Incomplete Code:\nfunction Get-AbsoluteValue {\n[MASK]\n[MASK]\n        [int]$n\n    )\n\n[MASK]\n        return -$n\n    } else {\n        return $n\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n        [int]$n\n    )\n\n[MASK]\n        return -$n\n    } else {\n        return $n\n    }\n}"}
{"task_id": "PowerShell/42-0-multi", "prompt": "function Test-NumberSign {\n    <#\n    This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n    >>> Test-NumberSign -n 5\n    positive\n    >>> Test-NumberSign -n -10\n    negative\n    >>> Test-NumberSign -n 0\n    zero\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}", "test": "function Test-TestNumberSign {\n    if ((Test-NumberSign -n 5) -ne \"positive\") { throw \"Test case 1 failed\" }\n    if ((Test-NumberSign -n -10) -ne \"negative\") { throw \"Test case 2 failed\" }\n    if ((Test-NumberSign -n 0) -ne \"zero\") { throw \"Test case 3 failed\" }\n    if ((Test-NumberSign -n 1000000000) -ne \"positive\") { throw \"Test case 4 failed\" }\n    if ((Test-NumberSign -n -1000000000) -ne \"negative\") { throw \"Test case 5 failed\" }\n}\n\nTest-TestNumberSign", "entry_point": "Test-NumberSign", "signature": "function Test-NumberSign {", "docstring": "This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero\n\n* Incomplete Code:\nfunction Test-NumberSign {\n    param (\n[MASK]\n[MASK]\n    )\n\n    if ($n -gt 0) {\n[MASK]\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n[MASK]\n    )\n\n    if ($n -gt 0) {\n[MASK]\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}"}
{"task_id": "PowerShell/42-1-multi", "prompt": "function Test-NumberSign {\n    <#\n    This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n    >>> Test-NumberSign -n 5\n    positive\n    >>> Test-NumberSign -n -10\n    negative\n    >>> Test-NumberSign -n 0\n    zero\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}", "test": "function Test-TestNumberSign {\n    if ((Test-NumberSign -n 5) -ne \"positive\") { throw \"Test case 1 failed\" }\n    if ((Test-NumberSign -n -10) -ne \"negative\") { throw \"Test case 2 failed\" }\n    if ((Test-NumberSign -n 0) -ne \"zero\") { throw \"Test case 3 failed\" }\n    if ((Test-NumberSign -n 1000000000) -ne \"positive\") { throw \"Test case 4 failed\" }\n    if ((Test-NumberSign -n -1000000000) -ne \"negative\") { throw \"Test case 5 failed\" }\n}\n\nTest-TestNumberSign", "entry_point": "Test-NumberSign", "signature": "function Test-NumberSign {", "docstring": "This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero\n\n* Incomplete Code:\nfunction Test-NumberSign {\n    param (\n[MASK]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n[MASK]\n    } else {\n        return \"zero\"\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n[MASK]\n    } else {\n        return \"zero\"\n    }\n}"}
{"task_id": "PowerShell/43-0-multi", "prompt": "function Get-PowerOfTwo {\n    <#\n    This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n    >>> Get-PowerOfTwo -n 3\n    8\n    >>> Get-PowerOfTwo -n 0\n    1\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}", "test": "function Test-GetPowerOfTwo {\n    if ((Get-PowerOfTwo -n 3) -ne 8) { throw \"Test case 1 failed\" }\n    if ((Get-PowerOfTwo -n 0) -ne 1) { throw \"Test case 2 failed\" }\n    if ((Get-PowerOfTwo -n 10) -ne 1024) { throw \"Test case 3 failed\" }\n    if ((Get-PowerOfTwo -n 15) -ne 32768) { throw \"Test case 4 failed\" }\n    if ((Get-PowerOfTwo -n 20) -ne 1048576) { throw \"Test case 5 failed\" }\n}\n\nTest-GetPowerOfTwo", "entry_point": "Get-PowerOfTwo", "signature": "function Get-PowerOfTwo {", "docstring": "This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1\n\n* Incomplete Code:\nfunction Get-PowerOfTwo {\n    param (\n[MASK]\n        [int]$n\n    )\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$n\n    )\n\n[MASK]\n}"}
{"task_id": "PowerShell/43-1-multi", "prompt": "function Get-PowerOfTwo {\n    <#\n    This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n    >>> Get-PowerOfTwo -n 3\n    8\n    >>> Get-PowerOfTwo -n 0\n    1\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}", "test": "function Test-GetPowerOfTwo {\n    if ((Get-PowerOfTwo -n 3) -ne 8) { throw \"Test case 1 failed\" }\n    if ((Get-PowerOfTwo -n 0) -ne 1) { throw \"Test case 2 failed\" }\n    if ((Get-PowerOfTwo -n 10) -ne 1024) { throw \"Test case 3 failed\" }\n    if ((Get-PowerOfTwo -n 15) -ne 32768) { throw \"Test case 4 failed\" }\n    if ((Get-PowerOfTwo -n 20) -ne 1048576) { throw \"Test case 5 failed\" }\n}\n\nTest-GetPowerOfTwo", "entry_point": "Get-PowerOfTwo", "signature": "function Get-PowerOfTwo {", "docstring": "This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1\n\n* Incomplete Code:\nfunction Get-PowerOfTwo {\n    param (\n[MASK]\n[MASK]\n    )\n\n    return [Math]::Pow(2, $n)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n[MASK]\n    )\n\n    return [Math]::Pow(2, $n)\n}"}
{"task_id": "PowerShell/44-0-multi", "prompt": "function Multiply-TwoNumbers {\n    <#\n    This function takes two positive integers as input and returns their product.\n\n    >>> Multiply-TwoNumbers -A 3 -B 4\n    12\n    >>> Multiply-TwoNumbers -A 10 -B 20\n    200\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}", "test": "function Test-MultiplyTwoNumbers {\n    if ((Multiply-TwoNumbers -A 3 -B 4) -ne 12) { throw \"Test case 1 failed\" }\n    if ((Multiply-TwoNumbers -A 10 -B 20) -ne 200) { throw \"Test case 2 failed\" }\n    if ((Multiply-TwoNumbers -A 50000 -B 1) -ne 50000) { throw \"Test case 3 failed\" }\n    if ((Multiply-TwoNumbers -A 1 -B 50000) -ne 50000) { throw \"Test case 4 failed\" }\n    if ((Multiply-TwoNumbers -A 25000 -B 2) -ne 50000) { throw \"Test case 5 failed\" }\n}\n\nTest-MultiplyTwoNumbers", "entry_point": "Multiply-TwoNumbers", "signature": "function Multiply-TwoNumbers {", "docstring": "This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200\n\n* Incomplete Code:\nfunction Multiply-TwoNumbers {\n[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n[MASK]\n}"}
{"task_id": "PowerShell/44-1-multi", "prompt": "function Multiply-TwoNumbers {\n    <#\n    This function takes two positive integers as input and returns their product.\n\n    >>> Multiply-TwoNumbers -A 3 -B 4\n    12\n    >>> Multiply-TwoNumbers -A 10 -B 20\n    200\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}", "test": "function Test-MultiplyTwoNumbers {\n    if ((Multiply-TwoNumbers -A 3 -B 4) -ne 12) { throw \"Test case 1 failed\" }\n    if ((Multiply-TwoNumbers -A 10 -B 20) -ne 200) { throw \"Test case 2 failed\" }\n    if ((Multiply-TwoNumbers -A 50000 -B 1) -ne 50000) { throw \"Test case 3 failed\" }\n    if ((Multiply-TwoNumbers -A 1 -B 50000) -ne 50000) { throw \"Test case 4 failed\" }\n    if ((Multiply-TwoNumbers -A 25000 -B 2) -ne 50000) { throw \"Test case 5 failed\" }\n}\n\nTest-MultiplyTwoNumbers", "entry_point": "Multiply-TwoNumbers", "signature": "function Multiply-TwoNumbers {", "docstring": "This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200\n\n* Incomplete Code:\nfunction Multiply-TwoNumbers {\n    param (\n[MASK]\n[MASK]\n\n[MASK]\n[MASK]\n    )\n\n    return $A * $B\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n[MASK]\n\n[MASK]\n[MASK]\n    )\n\n    return $A * $B\n}"}
{"task_id": "PowerShell/45-0-multi", "prompt": "function Get-ArithmeticSeriesTerm {\n    <#\n    This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n    >>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n    298\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}", "test": "function Test-GetArithmeticSeriesTerm {\n    if ((Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100) -ne 298) { throw \"Test case 1 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 5 -a2 10 -n 50) -ne 250) { throw \"Test case 2 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 100 -a2 99 -n 50) -ne 51) { throw \"Test case 3 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 0 -a2 0 -n 1000) -ne 0) { throw \"Test case 4 failed\" }\n}\n\nTest-GetArithmeticSeriesTerm", "entry_point": "Get-ArithmeticSeriesTerm", "signature": "function Get-ArithmeticSeriesTerm {", "docstring": "This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298\n\n* Incomplete Code:\nfunction Get-ArithmeticSeriesTerm {\n    param (\n[MASK]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}"}
{"task_id": "PowerShell/45-1-multi", "prompt": "function Get-ArithmeticSeriesTerm {\n    <#\n    This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n    >>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n    298\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}", "test": "function Test-GetArithmeticSeriesTerm {\n    if ((Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100) -ne 298) { throw \"Test case 1 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 5 -a2 10 -n 50) -ne 250) { throw \"Test case 2 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 100 -a2 99 -n 50) -ne 51) { throw \"Test case 3 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 0 -a2 0 -n 1000) -ne 0) { throw \"Test case 4 failed\" }\n}\n\nTest-GetArithmeticSeriesTerm", "entry_point": "Get-ArithmeticSeriesTerm", "signature": "function Get-ArithmeticSeriesTerm {", "docstring": "This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298\n\n* Incomplete Code:\nfunction Get-ArithmeticSeriesTerm {\n    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n[MASK]\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}"}
{"task_id": "PowerShell/46-0-multi", "prompt": "function Reverse-ThreeDigitNumber {\n<#\nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n#>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}", "test": "function Test-ReverseThreeDigitNumber {\n    if ((Reverse-ThreeDigitNumber -n 100) -ne 001) { throw \"Test case 1 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 678) -ne 876) { throw \"Test case 2 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 987) -ne 789) { throw \"Test case 3 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 321) -ne 123) { throw \"Test case 4 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 123) -ne 321) { throw \"Test case 5 failed\" }\n}\n\nTest-ReverseThreeDigitNumber", "entry_point": "Reverse-ThreeDigitNumber", "signature": "function Reverse-ThreeDigitNumber {", "docstring": "This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n\n* Incomplete Code:\nfunction Reverse-ThreeDigitNumber {\n    param (\n[MASK]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n[MASK]\n}"}
{"task_id": "PowerShell/46-1-multi", "prompt": "function Reverse-ThreeDigitNumber {\n<#\nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n#>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}", "test": "function Test-ReverseThreeDigitNumber {\n    if ((Reverse-ThreeDigitNumber -n 100) -ne 001) { throw \"Test case 1 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 678) -ne 876) { throw \"Test case 2 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 987) -ne 789) { throw \"Test case 3 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 321) -ne 123) { throw \"Test case 4 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 123) -ne 321) { throw \"Test case 5 failed\" }\n}\n\nTest-ReverseThreeDigitNumber", "entry_point": "Reverse-ThreeDigitNumber", "signature": "function Reverse-ThreeDigitNumber {", "docstring": "This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n\n* Incomplete Code:\nfunction Reverse-ThreeDigitNumber {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n[MASK]\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n[MASK]\n}"}
{"task_id": "PowerShell/47-0-multi", "prompt": "function Convert-IntToBoolAndBack {\n    <#\n    This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n    >>> Convert-IntToBoolAndBack -intValue 3\n    1\n    >>> Convert-IntToBoolAndBack -intValue 0\n    0\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}", "test": "function Test-ConvertIntToBoolAndBack {\n    if ((Convert-IntToBoolAndBack -intValue 3) -ne 1) { throw \"Test case 1 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 0) -ne 0) { throw \"Test case 2 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 1) -ne 1) { throw \"Test case 3 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue -1) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 100) -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-ConvertIntToBoolAndBack", "entry_point": "Convert-IntToBoolAndBack", "signature": "function Convert-IntToBoolAndBack {", "docstring": "This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0\n\n* Incomplete Code:\nfunction Convert-IntToBoolAndBack {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n[MASK]\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n[MASK]\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n[MASK]\n}"}
{"task_id": "PowerShell/47-1-multi", "prompt": "function Convert-IntToBoolAndBack {\n    <#\n    This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n    >>> Convert-IntToBoolAndBack -intValue 3\n    1\n    >>> Convert-IntToBoolAndBack -intValue 0\n    0\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}", "test": "function Test-ConvertIntToBoolAndBack {\n    if ((Convert-IntToBoolAndBack -intValue 3) -ne 1) { throw \"Test case 1 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 0) -ne 0) { throw \"Test case 2 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 1) -ne 1) { throw \"Test case 3 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue -1) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 100) -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-ConvertIntToBoolAndBack", "entry_point": "Convert-IntToBoolAndBack", "signature": "function Convert-IntToBoolAndBack {", "docstring": "This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0\n\n* Incomplete Code:\nfunction Convert-IntToBoolAndBack {\n    param (\n[MASK]\n[MASK]\n    )\n\n    # Convert the integer to a boolean\n[MASK]\n\n    # Convert the boolean back to an integer\n[MASK]\n\n    return $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n[MASK]\n    )\n\n    # Convert the integer to a boolean\n[MASK]\n\n    # Convert the boolean back to an integer\n[MASK]\n\n    return $result\n}"}
{"task_id": "PowerShell/48-0-multi", "prompt": "function Get-ASCIIChar {\n    <#\n    This function takes an ASCII code as input and returns the corresponding character.\n\n    >>> Get-ASCIIChar -asciiCode 65\n    A\n    >>> Get-ASCIIChar -asciiCode 97\n    a\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}", "test": "function Test-GetASCIIChar {\n    if ((Get-ASCIIChar -asciiCode 65) -ne 'A') { throw \"Test case 1 failed\" }\n    if ((Get-ASCIIChar -asciiCode 97) -ne 'a') { throw \"Test case 2 failed\" }\n    if ((Get-ASCIIChar -asciiCode 48) -ne '0') { throw \"Test case 3 failed\" }\n    if ((Get-ASCIIChar -asciiCode 33) -ne '!') { throw \"Test case 4 failed\" }\n    if ((Get-ASCIIChar -asciiCode 126) -ne '~') { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIIChar", "entry_point": "Get-ASCIIChar", "signature": "function Get-ASCIIChar {", "docstring": "This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na\n\n* Incomplete Code:\nfunction Get-ASCIIChar {\n[MASK]\n[MASK]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[MASK]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}"}
{"task_id": "PowerShell/48-1-multi", "prompt": "function Get-ASCIIChar {\n    <#\n    This function takes an ASCII code as input and returns the corresponding character.\n\n    >>> Get-ASCIIChar -asciiCode 65\n    A\n    >>> Get-ASCIIChar -asciiCode 97\n    a\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}", "test": "function Test-GetASCIIChar {\n    if ((Get-ASCIIChar -asciiCode 65) -ne 'A') { throw \"Test case 1 failed\" }\n    if ((Get-ASCIIChar -asciiCode 97) -ne 'a') { throw \"Test case 2 failed\" }\n    if ((Get-ASCIIChar -asciiCode 48) -ne '0') { throw \"Test case 3 failed\" }\n    if ((Get-ASCIIChar -asciiCode 33) -ne '!') { throw \"Test case 4 failed\" }\n    if ((Get-ASCIIChar -asciiCode 126) -ne '~') { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIIChar", "entry_point": "Get-ASCIIChar", "signature": "function Get-ASCIIChar {", "docstring": "This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na\n\n* Incomplete Code:\nfunction Get-ASCIIChar {\n[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [char]$asciiCode\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [char]$asciiCode\n}"}
{"task_id": "PowerShell/49-0-multi", "prompt": "function Get-ASCIICode {\n    <#\n    This function takes a character as input and returns its ASCII code.\n\n    >>> Get-ASCIICode -char 'A'\n    65\n    >>> Get-ASCIICode -char 'a'\n    97\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}", "test": "function Test-GetASCIICode {\n    if ((Get-ASCIICode -char 'A') -ne 65) { throw \"Test case 1 failed\" }\n    if ((Get-ASCIICode -char 'a') -ne 97) { throw \"Test case 2 failed\" }\n    if ((Get-ASCIICode -char '0') -ne 48) { throw \"Test case 3 failed\" }\n    if ((Get-ASCIICode -char '!') -ne 33) { throw \"Test case 4 failed\" }\n    if ((Get-ASCIICode -char '~') -ne 126) { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIICode", "entry_point": "Get-ASCIICode", "signature": "function Get-ASCIICode {", "docstring": "This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97\n\n* Incomplete Code:\nfunction Get-ASCIICode {\n    param (\n[MASK]\n[MASK]\n    )\n\n    return [int][char]$char\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n[MASK]\n    )\n\n    return [int][char]$char\n}"}
{"task_id": "PowerShell/49-1-multi", "prompt": "function Get-ASCIICode {\n    <#\n    This function takes a character as input and returns its ASCII code.\n\n    >>> Get-ASCIICode -char 'A'\n    65\n    >>> Get-ASCIICode -char 'a'\n    97\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}", "test": "function Test-GetASCIICode {\n    if ((Get-ASCIICode -char 'A') -ne 65) { throw \"Test case 1 failed\" }\n    if ((Get-ASCIICode -char 'a') -ne 97) { throw \"Test case 2 failed\" }\n    if ((Get-ASCIICode -char '0') -ne 48) { throw \"Test case 3 failed\" }\n    if ((Get-ASCIICode -char '!') -ne 33) { throw \"Test case 4 failed\" }\n    if ((Get-ASCIICode -char '~') -ne 126) { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIICode", "entry_point": "Get-ASCIICode", "signature": "function Get-ASCIICode {", "docstring": "This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97\n\n* Incomplete Code:\nfunction Get-ASCIICode {\n[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [int][char]$char\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n[MASK]\n    )\n\n    return [int][char]$char\n}"}
{"task_id": "PowerShell/50-0-multi", "prompt": "function Calculate-Expression {\n    <#\n    This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n    >>> Calculate-Expression -a 2 -b 3 -c 5\n    25\n    >>> Calculate-Expression -a 1 -b 1 -c 1\n    2\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}", "test": "function Test-CalculateExpression {\n    if ((Calculate-Expression -a 2 -b 3 -c 5) -ne 25) { throw \"Test case 1 failed\" }\n    if ((Calculate-Expression -a 1 -b 1 -c 1) -ne 2) { throw \"Test case 2 failed\" }\n    if ((Calculate-Expression -a 0 -b 0 -c 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Calculate-Expression -a -1 -b -1 -c -1) -ne 2) { throw \"Test case 4 failed\" }\n    if ((Calculate-Expression -a 10000 -b 10000 -c 10000) -ne 200000000) { throw \"Test case 5 failed\" }\n    if ((Calculate-Expression -a -10000 -b -10000 -c -10000) -ne 200000000) { throw \"Test case 6 failed\" }\n}", "entry_point": "Calculate-Expression", "signature": "function Calculate-Expression {", "docstring": "This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2\n\n* Incomplete Code:\nfunction Calculate-Expression {\n    param (\n[MASK]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n[MASK]\n        [int]$c\n    )\n\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n[MASK]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n[MASK]\n        [int]$c\n    )\n\n[MASK]\n}"}
{"task_id": "PowerShell/50-1-multi", "prompt": "function Calculate-Expression {\n    <#\n    This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n    >>> Calculate-Expression -a 2 -b 3 -c 5\n    25\n    >>> Calculate-Expression -a 1 -b 1 -c 1\n    2\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}", "test": "function Test-CalculateExpression {\n    if ((Calculate-Expression -a 2 -b 3 -c 5) -ne 25) { throw \"Test case 1 failed\" }\n    if ((Calculate-Expression -a 1 -b 1 -c 1) -ne 2) { throw \"Test case 2 failed\" }\n    if ((Calculate-Expression -a 0 -b 0 -c 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Calculate-Expression -a -1 -b -1 -c -1) -ne 2) { throw \"Test case 4 failed\" }\n    if ((Calculate-Expression -a 10000 -b 10000 -c 10000) -ne 200000000) { throw \"Test case 5 failed\" }\n    if ((Calculate-Expression -a -10000 -b -10000 -c -10000) -ne 200000000) { throw \"Test case 6 failed\" }\n}", "entry_point": "Calculate-Expression", "signature": "function Calculate-Expression {", "docstring": "This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2\n\n* Incomplete Code:\nfunction Calculate-Expression {\n[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n[MASK]\n[MASK]\n\n[MASK]\n[MASK]\n    )\n\n    return ($a + $b) * $c\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n[MASK]\n[MASK]\n\n[MASK]\n[MASK]\n    )\n\n    return ($a + $b) * $c\n}"}
{"task_id": "PowerShell/1-0-span", "prompt": "function Has-CloseElements {\n<#\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n#> param (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "canonical_solution": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}", "test": "# Test cases\nfunction Check-CloseElements() {\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.3) -ne $true) { throw \"Test case 1 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.05) -ne $false) { throw \"Test case 2 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.95) -ne $true) { throw \"Test case 3 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.8) -ne $false) { throw \"Test case 4 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.0, 4.0, 5.0, 2.0)))) 0.1) -ne $true) { throw \"Test case 5 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 1.0) -ne $true) { throw \"Test case 6 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 0.5) -ne $false) { throw \"Test case 7 failed\" }\n}\n\nCheck-CloseElements", "entry_point": "Has-CloseElements", "signature": "function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunction Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)\n\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j)[MASK]rn $true\n}\n}\n}\n}\n\nreturn $false\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j)[MASK]rn $true\n}\n}\n}\n}\n\nreturn $false\n}"}
{"task_id": "PowerShell/1-1-span", "prompt": "function Has-CloseElements {\n<#\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n#> param (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "canonical_solution": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}", "test": "# Test cases\nfunction Check-CloseElements() {\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.3) -ne $true) { throw \"Test case 1 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.05) -ne $false) { throw \"Test case 2 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.95) -ne $true) { throw \"Test case 3 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.8) -ne $false) { throw \"Test case 4 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.0, 4.0, 5.0, 2.0)))) 0.1) -ne $true) { throw \"Test case 5 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 1.0) -ne $true) { throw \"Test case 6 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 0.5) -ne $false) { throw \"Test case 7 failed\" }\n}\n\nCheck-CloseElements", "entry_point": "Has-CloseElements", "signature": "function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunction Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)\n\n\nfor ($i = 0; $i -lt $numbers.Cou[MASK]n $true\n}\n}\n}\n}\n\nreturn $false\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\n\nfor ($i = 0; $i -lt $numbers.Cou[MASK]n $true\n}\n}\n}\n}\n\nreturn $false\n}"}
{"task_id": "PowerShell/2-0-span", "prompt": "function Remove-DuplicatesFromSortedArray {\n<#\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "canonical_solution": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}", "test": "function Check-RemoveDuplicatesFromSortedArray() {\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 2)) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(0,0,1,1,1,2,2,3,3,4)) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 2, 3)) -ne 3) { throw \"Test case 3 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(2, 2, 2)) -ne 1) { throw \"Test case 4 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1)) -ne 1) { throw \"Test case 5 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4)) -ne 4) { throw \"Test case 6 failed\" }\n}\n\nCheck-RemoveDuplicatesFromSortedArray", "entry_point": "Remove-DuplicatesFromSortedArray", "signature": "function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "docstring": "\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n\n\n* Incomplete Code:\nfunction Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)\nif ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor [MASK]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor [MASK]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}"}
{"task_id": "PowerShell/2-1-span", "prompt": "function Remove-DuplicatesFromSortedArray {\n<#\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "canonical_solution": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}", "test": "function Check-RemoveDuplicatesFromSortedArray() {\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 2)) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(0,0,1,1,1,2,2,3,3,4)) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 2, 3)) -ne 3) { throw \"Test case 3 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(2, 2, 2)) -ne 1) { throw \"Test case 4 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1)) -ne 1) { throw \"Test case 5 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4)) -ne 4) { throw \"Test case 6 failed\" }\n}\n\nCheck-RemoveDuplicatesFromSortedArray", "entry_point": "Remove-DuplicatesFromSortedArray", "signature": "function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "docstring": "\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n\n\n* Incomplete Code:\nfunction Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)\nif ($num[MASK]+\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($num[MASK]+\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}"}
{"task_id": "PowerShell/3-0-span", "prompt": "function Get-LongestUniqueSubstringLength {\n<#\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}", "test": "function Check-LongestUniqueSubstringLength() {\nif ((Get-LongestUniqueSubstringLength \"abcabcbb\") -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-LongestUniqueSubstringLength \"bbbbb\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-LongestUniqueSubstringLength \"pwwkew\") -ne 3) { throw \"Test case 3 failed\" }\nif ((Get-LongestUniqueSubstringLength \" \") -ne 1) { throw \"Test case 4 failed\" }\nif ((Get-LongestUniqueSubstringLength \"dvdf\") -ne 3) { throw \"Test case 5 failed\" }\nif ((Get-LongestUniqueSubstringLength \"anviaj\") -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-LongestUniqueSubstringLength \"abba\") -ne 2) { throw \"Test case 7 failed\" }\n}\n\nCheck-LongestUniqueSubstringLength", "entry_point": "Get-LongestUniqueSubstringLength", "signature": "function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n\n\n* Incomplete Code:\nfunction Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end[MASK]$charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end[MASK]$charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}"}
{"task_id": "PowerShell/3-1-span", "prompt": "function Get-LongestUniqueSubstringLength {\n<#\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}", "test": "function Check-LongestUniqueSubstringLength() {\nif ((Get-LongestUniqueSubstringLength \"abcabcbb\") -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-LongestUniqueSubstringLength \"bbbbb\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-LongestUniqueSubstringLength \"pwwkew\") -ne 3) { throw \"Test case 3 failed\" }\nif ((Get-LongestUniqueSubstringLength \" \") -ne 1) { throw \"Test case 4 failed\" }\nif ((Get-LongestUniqueSubstringLength \"dvdf\") -ne 3) { throw \"Test case 5 failed\" }\nif ((Get-LongestUniqueSubstringLength \"anviaj\") -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-LongestUniqueSubstringLength \"abba\") -ne 2) { throw \"Test case 7 failed\" }\n}\n\nCheck-LongestUniqueSubstringLength", "entry_point": "Get-LongestUniqueSubstringLength", "signature": "function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n\n\n* Incomplete Code:\nfunction Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$start = 0\n$maxLength = 0\n$charMa[MASK]xLength\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$start = 0\n$maxLength = 0\n$charMa[MASK]xLength\n}"}
{"task_id": "PowerShell/4-0-span", "prompt": "function Get-LongestPalindromicSubstring {\n<#\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}", "test": "function Check-LongestPalindromicSubstring() {\n$result1 = Get-LongestPalindromicSubstring \"babad\"\nif (-not ($result1 -eq \"bab\" -or $result1 -eq \"aba\")) { throw \"Test case 1 failed\" }\nif ((Get-LongestPalindromicSubstring \"cbbd\") -ne \"bb\") { throw \"Test case 2 failed\" }\nif ((Get-LongestPalindromicSubstring \"a\") -ne \"a\") { throw \"Test case 3 failed\" }\nif ((Get-LongestPalindromicSubstring \"racecar\") -ne \"racecar\") { throw \"Test case 4 failed\" }\nif ((Get-LongestPalindromicSubstring \"madam\") -ne \"madam\") { throw \"Test case 5 failed\" }\nif ((Get-LongestPalindromicSubstring \"abcdcba\") -ne \"abcdcba\") { throw \"Test case 6 failed\" }\n}\n\nCheck-LongestPalindromicSubstring", "entry_point": "Get-LongestPalindromicSubstring", "signature": "function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n\n\n* Incomplete Code:\nfunction Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\nif (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n[MASK]ft--\n$right++\n}\n\nreturn $right - $left - 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n[MASK]ft--\n$right++\n}\n\nreturn $right - $left - 1\n}"}
{"task_id": "PowerShell/4-1-span", "prompt": "function Get-LongestPalindromicSubstring {\n<#\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}", "test": "function Check-LongestPalindromicSubstring() {\n$result1 = Get-LongestPalindromicSubstring \"babad\"\nif (-not ($result1 -eq \"bab\" -or $result1 -eq \"aba\")) { throw \"Test case 1 failed\" }\nif ((Get-LongestPalindromicSubstring \"cbbd\") -ne \"bb\") { throw \"Test case 2 failed\" }\nif ((Get-LongestPalindromicSubstring \"a\") -ne \"a\") { throw \"Test case 3 failed\" }\nif ((Get-LongestPalindromicSubstring \"racecar\") -ne \"racecar\") { throw \"Test case 4 failed\" }\nif ((Get-LongestPalindromicSubstring \"madam\") -ne \"madam\") { throw \"Test case 5 failed\" }\nif ((Get-LongestPalindromicSubstring \"abcdcba\") -ne \"abcdcba\") { throw \"Test case 6 failed\" }\n}\n\nCheck-LongestPalindromicSubstring", "entry_point": "Get-LongestPalindromicSubstring", "signature": "function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n\n\n* Incomplete Code:\nfunction Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\nif (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} e[MASK]ft - 1\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} e[MASK]ft - 1\n}"}
{"task_id": "PowerShell/5-0-span", "prompt": "function MyAtoi {\n<#\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}", "test": "# Test cases\nfunction Check-MyAtoi() {\nif ((MyAtoi \"42\") -ne 42) { throw \"Test case 1 failed\" }\nif ((MyAtoi \" -42\") -ne -42) { throw \"Test case 2 failed\" }\nif ((MyAtoi \"4193 with words\") -ne 4193) { throw \"Test case 3 failed\" }\nif ((MyAtoi \"words and 987\") -ne 0) { throw \"Test case 4 failed\" }\n}\nCheck-MyAtoi", "entry_point": "MyAtoi", "signature": "function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n\n\n* Incomplete Code:\nfunction MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$s = $s.Trim()\nif (-n[MASK]gn\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$s = $s.Trim()\nif (-n[MASK]gn\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}"}
{"task_id": "PowerShell/5-1-span", "prompt": "function MyAtoi {\n<#\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}", "test": "# Test cases\nfunction Check-MyAtoi() {\nif ((MyAtoi \"42\") -ne 42) { throw \"Test case 1 failed\" }\nif ((MyAtoi \" -42\") -ne -42) { throw \"Test case 2 failed\" }\nif ((MyAtoi \"4193 with words\") -ne 4193) { throw \"Test case 3 failed\" }\nif ((MyAtoi \"words and 987\") -ne 0) { throw \"Test case 4 failed\" }\n}\nCheck-MyAtoi", "entry_point": "MyAtoi", "signature": "function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n\n\n* Incomplete Code:\nfunction MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)\n$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign =[MASK]i++\n}\n\nreturn $base * $sign\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign =[MASK]i++\n}\n\nreturn $base * $sign\n}"}
{"task_id": "PowerShell/6-0-span", "prompt": "function FindLongestCommonPrefix {\n<#\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "canonical_solution": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}", "test": "function Check-FindLongestCommonPrefix() {\nif ((FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")) -ne \"fl\") { throw \"Test case 1 failed\" }\nif ((FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")) -ne \"\") { throw \"Test case 2 failed\" }\nif ((FindLongestCommonPrefix @(\"interspecies\",\"interstellar\",\"interstate\")) -ne \"inters\") { throw \"Test case 3 failed\" }\nif ((FindLongestCommonPrefix @(\"throne\",\"throne\")) -ne \"throne\") { throw \"Test case 4 failed\" }\nif ((FindLongestCommonPrefix @(\"a\",\"ab\")) -ne \"a\") { throw \"Test case 5 failed\" }\nif ((FindLongestCommonPrefix @(\"abc\",\"abcd\",\"ab\")) -ne \"ab\") { throw \"Test case 6 failed\" }\nif ((FindLongestCommonPrefix @(\"complete\",\"compliment\",\"complex\")) -ne \"compl\") { throw \"Test case 7 failed\" }\nif ((FindLongestCommonPrefix @(\"nomatch\",\"nomadic\",\"noir\")) -ne \"no\") { throw \"Test case 8 failed\" }\n}\n\nCheck-FindLongestCommonPrefix", "entry_point": "FindLongestCommonPrefix", "signature": "function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "docstring": "\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n\n\n* Incomplete Code:\nfunction FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)\nif ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字[MASK]tr in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字[MASK]tr in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}"}
{"task_id": "PowerShell/6-1-span", "prompt": "function FindLongestCommonPrefix {\n<#\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "canonical_solution": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}", "test": "function Check-FindLongestCommonPrefix() {\nif ((FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")) -ne \"fl\") { throw \"Test case 1 failed\" }\nif ((FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")) -ne \"\") { throw \"Test case 2 failed\" }\nif ((FindLongestCommonPrefix @(\"interspecies\",\"interstellar\",\"interstate\")) -ne \"inters\") { throw \"Test case 3 failed\" }\nif ((FindLongestCommonPrefix @(\"throne\",\"throne\")) -ne \"throne\") { throw \"Test case 4 failed\" }\nif ((FindLongestCommonPrefix @(\"a\",\"ab\")) -ne \"a\") { throw \"Test case 5 failed\" }\nif ((FindLongestCommonPrefix @(\"abc\",\"abcd\",\"ab\")) -ne \"ab\") { throw \"Test case 6 failed\" }\nif ((FindLongestCommonPrefix @(\"complete\",\"compliment\",\"complex\")) -ne \"compl\") { throw \"Test case 7 failed\" }\nif ((FindLongestCommonPrefix @(\"nomatch\",\"nomadic\",\"noir\")) -ne \"no\") { throw \"Test case 8 failed\" }\n}\n\nCheck-FindLongestCommonPrefix", "entry_point": "FindLongestCommonPrefix", "signature": "function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "docstring": "\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n\n\n* Incomplete Code:\nfunction FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)\nif ($strs.Length -eq 0) { return \"\" }\nif ($strs.L[MASK] # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.L[MASK] # 检查并处理包含空字符串的情况\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}"}
{"task_id": "PowerShell/7-0-span", "prompt": "function Find-NeedleInHaystack {\n<#\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)", "canonical_solution": "return $haystack.IndexOf($needle)\n}", "test": "function Check-NeedleInHaystack() {\nif ((Find-NeedleInHaystack \"hello world\" \"world\") -ne 6) { throw \"Test case 1 failed\" }\nif ((Find-NeedleInHaystack \"hello world\" \"goodbye\") -ne -1) { throw \"Test case 2 failed\" }\nif ((Find-NeedleInHaystack \"openai\" \"ai\") -ne 4) { throw \"Test case 3 failed\" }\nif ((Find-NeedleInHaystack \"chatbot\" \"bot\") -ne 4) { throw \"Test case 4 failed\" }\nif ((Find-NeedleInHaystack \"chatbot\" \"hello\") -ne -1) { throw \"Test case 5 failed\" }\nif ((Find-NeedleInHaystack \"abcdefg\" \"cd\") -ne 2) { throw \"Test case 6 failed\" }\nif ((Find-NeedleInHaystack \"abcdefg\" \"xyz\") -ne -1) { throw \"Test case 7 failed\" }\n}\n\nCheck-NeedleInHaystack", "entry_point": "Find-NeedleInHaystack", "signature": "function Find-NeedleInHaystack {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)", "docstring": "\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n\n\n* Incomplete Code:\nfunction Find-NeedleInHaystack {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)\nreturn $[MASK]xOf($needle)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "return $[MASK]xOf($needle)\n}"}
{"task_id": "PowerShell/7-1-span", "prompt": "function Find-NeedleInHaystack {\n<#\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)", "canonical_solution": "return $haystack.IndexOf($needle)\n}", "test": "function Check-NeedleInHaystack() {\nif ((Find-NeedleInHaystack \"hello world\" \"world\") -ne 6) { throw \"Test case 1 failed\" }\nif ((Find-NeedleInHaystack \"hello world\" \"goodbye\") -ne -1) { throw \"Test case 2 failed\" }\nif ((Find-NeedleInHaystack \"openai\" \"ai\") -ne 4) { throw \"Test case 3 failed\" }\nif ((Find-NeedleInHaystack \"chatbot\" \"bot\") -ne 4) { throw \"Test case 4 failed\" }\nif ((Find-NeedleInHaystack \"chatbot\" \"hello\") -ne -1) { throw \"Test case 5 failed\" }\nif ((Find-NeedleInHaystack \"abcdefg\" \"cd\") -ne 2) { throw \"Test case 6 failed\" }\nif ((Find-NeedleInHaystack \"abcdefg\" \"xyz\") -ne -1) { throw \"Test case 7 failed\" }\n}\n\nCheck-NeedleInHaystack", "entry_point": "Find-NeedleInHaystack", "signature": "function Find-NeedleInHaystack {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)", "docstring": "\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n\n\n* Incomplete Code:\nfunction Find-NeedleInHaystack {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)\nreturn $h[MASK]Of($needle)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "return $h[MASK]Of($needle)\n}"}
{"task_id": "PowerShell/8-0-span", "prompt": "function Find-ConcatenatedSubstrings {\n<#\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "canonical_solution": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}", "test": "function Check-ConcatenatedSubstrings() {\n$result = Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\nif (($result -join ',') -ne '0,9') { throw \"Test case 1 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\nif (($result -join ',') -ne '') { throw \"Test case 2 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcabcabc\" @(\"abc\",\"abc\")\nif (($result -join ',') -ne '0,3') { throw \"Test case 3 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"ab\",\"cd\")\nif (($result -join ',') -ne '0') { throw \"Test case 4 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"cd\",\"ab\")\nif (($result -join ',') -ne '0') { throw \"Test case 5 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abababab\" @(\"ab\",\"ba\")\nif (($result -join ',') -ne '') { throw \"Test case 6 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcdef\" @(\"gh\",\"ij\")\nif (($result -join ',') -ne '') { throw \"Test case 7 failed\" }\n}\n\nCheck-ConcatenatedSubstrings", "entry_point": "Find-ConcatenatedSubstrings", "signature": "function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "docstring": "\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n\n\n* Incomplete Code:\nfunction Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)\n$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n[MASK]dLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n[MASK]dLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/8-1-span", "prompt": "function Find-ConcatenatedSubstrings {\n<#\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "canonical_solution": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}", "test": "function Check-ConcatenatedSubstrings() {\n$result = Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\nif (($result -join ',') -ne '0,9') { throw \"Test case 1 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\nif (($result -join ',') -ne '') { throw \"Test case 2 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcabcabc\" @(\"abc\",\"abc\")\nif (($result -join ',') -ne '0,3') { throw \"Test case 3 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"ab\",\"cd\")\nif (($result -join ',') -ne '0') { throw \"Test case 4 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"cd\",\"ab\")\nif (($result -join ',') -ne '0') { throw \"Test case 5 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abababab\" @(\"ab\",\"ba\")\nif (($result -join ',') -ne '') { throw \"Test case 6 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcdef\" @(\"gh\",\"ij\")\nif (($result -join ',') -ne '') { throw \"Test case 7 failed\" }\n}\n\nCheck-ConcatenatedSubstrings", "entry_point": "Find-ConcatenatedSubstrings", "signature": "function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "docstring": "\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n\n\n* Incomplete Code:\nfunction Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)\n$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++[MASK]while ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++[MASK]while ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/9-0-span", "prompt": "function Find-MedianOfTwoSortedArrays {\n<#\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "canonical_solution": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}", "test": "function Check-MedianOfTwoSortedArrays() {\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))) -ne 2.0) { throw \"Test case 1 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))) -ne 2.5) { throw \"Test case 2 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5, 7)) @([int[]](2, 4, 6, 8))) -ne 4.5) { throw \"Test case 3 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1)) @([int[]](1))) -ne 1.0) { throw \"Test case 4 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5)) @([int[]](2))) -ne 2.5) { throw \"Test case 5 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](10, 20, 30, 40, 50)) @([int[]](5, 15, 25, 35, 45))) -ne 27.5) { throw \"Test case 6 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 12, 15, 26, 38)) @([int[]](2, 13, 17, 30, 45, 50))) -ne 17.0) { throw \"Test case 7 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 4, 5)) @([int[]](2, 3, 6, 7, 8))) -ne 4.5) { throw \"Test case 8 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 1, 1)) @([int[]](1, 1, 1, 1))) -ne 1.0) { throw \"Test case 10 failed\" }\n}\n\nCheck-MedianOfTwoSortedArrays", "entry_point": "Find-MedianOfTwoSortedArrays", "signature": "function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "docstring": "\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n\n\n* Incomplete Code:\nfunction Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)\n$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($n[MASK]{\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($n[MASK]{\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}"}
{"task_id": "PowerShell/9-1-span", "prompt": "function Find-MedianOfTwoSortedArrays {\n<#\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "canonical_solution": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}", "test": "function Check-MedianOfTwoSortedArrays() {\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))) -ne 2.0) { throw \"Test case 1 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))) -ne 2.5) { throw \"Test case 2 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5, 7)) @([int[]](2, 4, 6, 8))) -ne 4.5) { throw \"Test case 3 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1)) @([int[]](1))) -ne 1.0) { throw \"Test case 4 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5)) @([int[]](2))) -ne 2.5) { throw \"Test case 5 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](10, 20, 30, 40, 50)) @([int[]](5, 15, 25, 35, 45))) -ne 27.5) { throw \"Test case 6 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 12, 15, 26, 38)) @([int[]](2, 13, 17, 30, 45, 50))) -ne 17.0) { throw \"Test case 7 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 4, 5)) @([int[]](2, 3, 6, 7, 8))) -ne 4.5) { throw \"Test case 8 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 1, 1)) @([int[]](1, 1, 1, 1))) -ne 1.0) { throw \"Test case 10 failed\" }\n}\n\nCheck-MedianOfTwoSortedArrays", "entry_point": "Find-MedianOfTwoSortedArrays", "signature": "function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "docstring": "\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n\n\n* Incomplete Code:\nfunction Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)\n$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $m[MASK] 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $m[MASK] 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}"}
{"task_id": "PowerShell/10-0-span", "prompt": "function Reverse-Integer {\n<#\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}", "test": "function Check-ReverseInteger() {\nif ((Reverse-Integer 123) -ne 321) { throw \"Test case 1 failed\" }\nif ((Reverse-Integer -123) -ne -321) { throw \"Test case 2 failed\" }\nif ((Reverse-Integer 120) -ne 21) { throw \"Test case 3 failed\" }\nif ((Reverse-Integer 0) -ne 0) { throw \"Test case 4 failed\" }\nif ((Reverse-Integer 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Reverse-Integer -10) -ne -1) { throw \"Test case 6 failed\" }\n\n}\n\nCheck-ReverseInteger", "entry_point": "Reverse-Integer", "signature": "function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n\n\n* Incomplete Code:\nfunction Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\n\n$isNegative = $x -lt 0\nif ([MASK]Negative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "\n$isNegative = $x -lt 0\nif ([MASK]Negative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}"}
{"task_id": "PowerShell/10-1-span", "prompt": "function Reverse-Integer {\n<#\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}", "test": "function Check-ReverseInteger() {\nif ((Reverse-Integer 123) -ne 321) { throw \"Test case 1 failed\" }\nif ((Reverse-Integer -123) -ne -321) { throw \"Test case 2 failed\" }\nif ((Reverse-Integer 120) -ne 21) { throw \"Test case 3 failed\" }\nif ((Reverse-Integer 0) -ne 0) { throw \"Test case 4 failed\" }\nif ((Reverse-Integer 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Reverse-Integer -10) -ne -1) { throw \"Test case 6 failed\" }\n\n}\n\nCheck-ReverseInteger", "entry_point": "Reverse-Integer", "signature": "function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n\n\n* Incomplete Code:\nfunction Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\n\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$re[MASK]Value -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$re[MASK]Value -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}"}
{"task_id": "PowerShell/11-0-span", "prompt": "function Is-PalindromeNumber {\n<#\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}", "test": "function Check-PalindromeNumber() {\nif ((Is-PalindromeNumber 121) -ne $true) { throw \"Test case 1 failed\" }\nif ((Is-PalindromeNumber -121) -ne $false) { throw \"Test case 2 failed\" }\nif ((Is-PalindromeNumber 10) -ne $false) { throw \"Test case 3 failed\" }\nif ((Is-PalindromeNumber 1221) -ne $true) { throw \"Test case 4 failed\" }\nif ((Is-PalindromeNumber 12321) -ne $true) { throw \"Test case 5 failed\" }\nif ((Is-PalindromeNumber 123321) -ne $true) { throw \"Test case 6 failed\" }\nif ((Is-PalindromeNumber 0) -ne $true) { throw \"Test case 7 failed\" }\nif ((Is-PalindromeNumber 123) -ne $false) { throw \"Test case 8 failed\" }\nif ((Is-PalindromeNumber 1) -ne $true) { throw \"Test case 9 failed\" }\nif ((Is-PalindromeNumber 1000021) -ne $false) { throw \"Test case 10 failed\" }\n}\n\nCheck-PalindromeNumber", "entry_point": "Is-PalindromeNumber", "signature": "function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n\n\n* Incomplete Code:\nfunction Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\nif ($x -lt [MASK]sed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($x -lt [MASK]sed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}"}
{"task_id": "PowerShell/11-1-span", "prompt": "function Is-PalindromeNumber {\n<#\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}", "test": "function Check-PalindromeNumber() {\nif ((Is-PalindromeNumber 121) -ne $true) { throw \"Test case 1 failed\" }\nif ((Is-PalindromeNumber -121) -ne $false) { throw \"Test case 2 failed\" }\nif ((Is-PalindromeNumber 10) -ne $false) { throw \"Test case 3 failed\" }\nif ((Is-PalindromeNumber 1221) -ne $true) { throw \"Test case 4 failed\" }\nif ((Is-PalindromeNumber 12321) -ne $true) { throw \"Test case 5 failed\" }\nif ((Is-PalindromeNumber 123321) -ne $true) { throw \"Test case 6 failed\" }\nif ((Is-PalindromeNumber 0) -ne $true) { throw \"Test case 7 failed\" }\nif ((Is-PalindromeNumber 123) -ne $false) { throw \"Test case 8 failed\" }\nif ((Is-PalindromeNumber 1) -ne $true) { throw \"Test case 9 failed\" }\nif ((Is-PalindromeNumber 1000021) -ne $false) { throw \"Test case 10 failed\" }\n}\n\nCheck-PalindromeNumber", "entry_point": "Is-PalindromeNumber", "signature": "function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n\n\n* Incomplete Code:\nfunction Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)\nif ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reverse[MASK][int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reverse[MASK][int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}"}
{"task_id": "PowerShell/12-0-span", "prompt": "function Max-WaterContainer {\n<#\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "canonical_solution": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}", "test": "function Check-MaxWaterContainer() {\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))) -ne 49) { throw \"Test case 1 failed\" }\nif ((Max-WaterContainer @([int[]](1, 1))) -ne 1) { throw \"Test case 2 failed\" }\nif ((Max-WaterContainer @([int[]](4, 3, 2, 1, 4))) -ne 16) { throw \"Test case 3 failed\" }\nif ((Max-WaterContainer @([int[]](1, 2, 4, 3))) -ne 4) { throw \"Test case 4 failed\" }\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 25, 7))) -ne 49) { throw \"Test case 5 failed\" }\nif ((Max-WaterContainer @([int[]](1, 3, 2, 5, 25, 24, 5))) -ne 24) { throw \"Test case 6 failed\" }\n}\n\nCheck-MaxWaterContainer", "entry_point": "Max-WaterContainer", "signature": "function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "docstring": "\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n\n\n* Incomplete Code:\nfunction Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)\n$left = 0\n$right = $h[MASK]r, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$left = 0\n$right = $h[MASK]r, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}"}
{"task_id": "PowerShell/12-1-span", "prompt": "function Max-WaterContainer {\n<#\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "canonical_solution": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}", "test": "function Check-MaxWaterContainer() {\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))) -ne 49) { throw \"Test case 1 failed\" }\nif ((Max-WaterContainer @([int[]](1, 1))) -ne 1) { throw \"Test case 2 failed\" }\nif ((Max-WaterContainer @([int[]](4, 3, 2, 1, 4))) -ne 16) { throw \"Test case 3 failed\" }\nif ((Max-WaterContainer @([int[]](1, 2, 4, 3))) -ne 4) { throw \"Test case 4 failed\" }\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 25, 7))) -ne 49) { throw \"Test case 5 failed\" }\nif ((Max-WaterContainer @([int[]](1, 3, 2, 5, 25, 24, 5))) -ne 24) { throw \"Test case 6 failed\" }\n}\n\nCheck-MaxWaterContainer", "entry_point": "Max-WaterContainer", "signature": "function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "docstring": "\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n\n\n* Incomplete Code:\nfunction Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)\n$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWate[MASK]-\n}\n}\n\nreturn $maxWater\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWate[MASK]-\n}\n}\n\nreturn $maxWater\n}"}
{"task_id": "PowerShell/13-0-span", "prompt": "function Remove-Element {\n<#\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "canonical_solution": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}", "test": "function Check-RemoveElement() {\n#if ((Remove-Element @(3, 2, 2, 3) 3) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-Element @(1, 2, 3, 4, 5) 6) -ne 5) { throw \"Test case 3 failed\" }\nif ((Remove-Element @(1, 1, 1) 1) -ne 0) { throw \"Test case 4 failed\" }\nif ((Remove-Element @(2, 2, 3, 3) 2) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nCheck-RemoveElement", "entry_point": "Remove-Element", "signature": "function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "docstring": "\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n\n\n* Incomplete Code:\nfunction Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)\n$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val)[MASK] $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val)[MASK] $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}"}
{"task_id": "PowerShell/13-1-span", "prompt": "function Remove-Element {\n<#\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "canonical_solution": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # 移除多余的元素\n\nreturn $i\n}", "test": "function Check-RemoveElement() {\n#if ((Remove-Element @(3, 2, 2, 3) 3) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-Element @(1, 2, 3, 4, 5) 6) -ne 5) { throw \"Test case 3 failed\" }\nif ((Remove-Element @(1, 1, 1) 1) -ne 0) { throw \"Test case 4 failed\" }\nif ((Remove-Element @(2, 2, 3, 3) 2) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nCheck-RemoveElement", "entry_point": "Remove-Element", "signature": "function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "docstring": "\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n\n\n* Incomplete Code:\nfunction Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)\n$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$[MASK]$i\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$[MASK]$i\n}"}
{"task_id": "PowerShell/14-0-span", "prompt": "function Count-GoodIntegers {\n<#\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "canonical_solution": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}", "test": "function Check-GoodIntegers() {\nif ((Count-GoodIntegers \"25\" \"30\" 7 5) -ne 1) { throw \"Test case 1 failed\" }\nif ((Count-GoodIntegers \"1\" \"12\" 8 1) -ne 11) { throw \"Test case 2 failed\" }\nif ((Count-GoodIntegers \"1\" \"5\" 5 1) -ne 5) { throw \"Test case 3 failed\" }\n}\n\nCheck-GoodIntegers", "entry_point": "Count-GoodIntegers", "signature": "function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "docstring": "\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n\n\n* Incomplete Code:\nfunction Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)\n$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$n[MASK]d $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$n[MASK]d $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}"}
{"task_id": "PowerShell/14-1-span", "prompt": "function Count-GoodIntegers {\n<#\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "canonical_solution": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}", "test": "function Check-GoodIntegers() {\nif ((Count-GoodIntegers \"25\" \"30\" 7 5) -ne 1) { throw \"Test case 1 failed\" }\nif ((Count-GoodIntegers \"1\" \"12\" 8 1) -ne 11) { throw \"Test case 2 failed\" }\nif ((Count-GoodIntegers \"1\" \"5\" 5 1) -ne 5) { throw \"Test case 3 failed\" }\n}\n\nCheck-GoodIntegers", "entry_point": "Count-GoodIntegers", "signature": "function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "docstring": "\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n\n\n* Incomplete Code:\nfunction Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)\n$mod = 1000000007\n$[MASK]turn $count % $mod\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$mod = 1000000007\n$[MASK]turn $count % $mod\n}"}
{"task_id": "PowerShell/15-0-span", "prompt": "function Count-WordFrequency {\n<# Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"#>", "canonical_solution": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}", "test": "function Test-CountWordFrequency {\n# Test function for Count-WordFrequency\n# Create a sample frequency.txt file\n\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n\n# Expected output\n$expected_output = \"apple 3\\nbanana 3\" -split \"\\n\"\n\n# Actual output from the function\n$actual_output = Count-WordFrequency\n\n# Compare actual output to expected output\nif ($actual_output -join \"`n\" -eq $expected_output -join \"`n\") {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item frequency.txt\n}\n\n# Call the test function\nTest-CountWordFrequency", "entry_point": "Count-WordFrequency", "signature": "function Count-WordFrequency {\n", "docstring": " Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"\n\n* Incomplete Code:\nfunction Count-WordFrequency {\n\n$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = [MASK]dCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = [MASK]dCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}"}
{"task_id": "PowerShell/15-1-span", "prompt": "function Count-WordFrequency {\n<# Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"#>", "canonical_solution": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}", "test": "function Test-CountWordFrequency {\n# Test function for Count-WordFrequency\n# Create a sample frequency.txt file\n\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n\n# Expected output\n$expected_output = \"apple 3\\nbanana 3\" -split \"\\n\"\n\n# Actual output from the function\n$actual_output = Count-WordFrequency\n\n# Compare actual output to expected output\nif ($actual_output -join \"`n\" -eq $expected_output -join \"`n\") {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item frequency.txt\n}\n\n# Call the test function\nTest-CountWordFrequency", "entry_point": "Count-WordFrequency", "signature": "function Count-WordFrequency {\n", "docstring": " Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"\n\n* Incomplete Code:\nfunction Count-WordFrequency {\n\n$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$[MASK]() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$[MASK]() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}"}
{"task_id": "PowerShell/16-0-span", "prompt": "function Find-ValidNumbers {\n<# Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"#>", "canonical_solution": "Get-Content file.txt | Where-Object { $_ -match '^\\(\\d{3}\\) \\d{3}-\\d{4}$|^\\d{3}-\\d{3}-\\d{4}$' }\n}", "test": "function Test-FindValidNumbers {\n# Test function for Find-ValidNumbers\n# Create a sample file.txt file\n\"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"123-456-7890\", \"(123) 456-7890\"\n\n# Actual output from the function\n$actual_output = Find-ValidNumbers\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-FindValidNumbers", "entry_point": "Find-ValidNumbers", "signature": "function Find-ValidNumbers {\n", "docstring": " Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"\n\n* Incomplete Code:\nfunction Find-ValidNumbers {\n\nGet-Content file.txt | Where-Obj[MASK]}$|^\\d{3}-\\d{3}-\\d{4}$' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Get-Content file.txt | Where-Obj[MASK]}$|^\\d{3}-\\d{3}-\\d{4}$' }\n}"}
{"task_id": "PowerShell/16-1-span", "prompt": "function Find-ValidNumbers {\n<# Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"#>", "canonical_solution": "Get-Content file.txt | Where-Object { $_ -match '^\\(\\d{3}\\) \\d{3}-\\d{4}$|^\\d{3}-\\d{3}-\\d{4}$' }\n}", "test": "function Test-FindValidNumbers {\n# Test function for Find-ValidNumbers\n# Create a sample file.txt file\n\"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"123-456-7890\", \"(123) 456-7890\"\n\n# Actual output from the function\n$actual_output = Find-ValidNumbers\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-FindValidNumbers", "entry_point": "Find-ValidNumbers", "signature": "function Find-ValidNumbers {\n", "docstring": " Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"\n\n* Incomplete Code:\nfunction Find-ValidNumbers {\n\nGet-Content fil[MASK]d{3}\\) \\d{3}-\\d{4}$|^\\d{3}-\\d{3}-\\d{4}$' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Get-Content fil[MASK]d{3}\\) \\d{3}-\\d{4}$|^\\d{3}-\\d{3}-\\d{4}$' }\n}"}
{"task_id": "PowerShell/17-0-span", "prompt": "function Transpose-File {\n<# Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"#>", "canonical_solution": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}", "test": "function Test-TransposeFile {\n# Test function for Transpose-File\n# Create a sample file.txt file\n\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n# Actual output from the function\n$actual_output = Transpose-File\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-TransposeFile", "entry_point": "Transpose-File", "signature": "function Transpose-File {\n", "docstring": " Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n* Incomplete Code:\nfunction Transpose-File {\n\n$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$[MASK]e | ForEach-Object { $_ -join ' ' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$[MASK]e | ForEach-Object { $_ -join ' ' }\n}"}
{"task_id": "PowerShell/17-1-span", "prompt": "function Transpose-File {\n<# Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"#>", "canonical_solution": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}", "test": "function Test-TransposeFile {\n# Test function for Transpose-File\n# Create a sample file.txt file\n\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n# Actual output from the function\n$actual_output = Transpose-File\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-TransposeFile", "entry_point": "Transpose-File", "signature": "function Transpose-File {\n", "docstring": " Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n* Incomplete Code:\nfunction Transpose-File {\n\n$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.L[MASK]e += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.L[MASK]e += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}"}
{"task_id": "PowerShell/18-0-span", "prompt": "function Extract-TenthLine {\n<# Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"#>", "canonical_solution": "Get-Content file.txt | Select-Object -Index 9\n}", "test": "function Test-ExtractTenthLine {\n# Test function for Extract-TenthLine\n# Create a sample file.txt file\n1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n\n# Expected output\n$expected_output = \"Line 10\"\n\n# Actual output from the function\n$actual_output = Extract-TenthLine\n\n# Compare actual output to expected output\nif ($actual_output -eq $expected_output) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-ExtractTenthLine", "entry_point": "Extract-TenthLine", "signature": "function Extract-TenthLine {\n", "docstring": " Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"\n\n* Incomplete Code:\nfunction Extract-TenthLine {\n\nGet-Conte[MASK]ct-Object -Index 9\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Get-Conte[MASK]ct-Object -Index 9\n}"}
{"task_id": "PowerShell/18-1-span", "prompt": "function Extract-TenthLine {\n<# Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"#>", "canonical_solution": "Get-Content file.txt | Select-Object -Index 9\n}", "test": "function Test-ExtractTenthLine {\n# Test function for Extract-TenthLine\n# Create a sample file.txt file\n1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n\n# Expected output\n$expected_output = \"Line 10\"\n\n# Actual output from the function\n$actual_output = Extract-TenthLine\n\n# Compare actual output to expected output\nif ($actual_output -eq $expected_output) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-ExtractTenthLine", "entry_point": "Extract-TenthLine", "signature": "function Extract-TenthLine {\n", "docstring": " Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"\n\n* Incomplete Code:\nfunction Extract-TenthLine {\n\nGet-Content file[MASK]ct -Index 9\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Get-Content file[MASK]ct -Index 9\n}"}
{"task_id": "PowerShell/19-0-span", "prompt": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n<#\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n#>", "canonical_solution": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}", "test": "function Test-TotalCoins() {\nif ((Get-TotalCoins -days 7) -ne 18) { throw \"Test case 1 failed\" }\nif ((Get-TotalCoins -days 10) -ne 30) { throw \"Test case 2 failed\" }\nif ((Get-TotalCoins -days 15) -ne 55) { throw \"Test case 3 failed\" }\nif ((Get-TotalCoins -days 20) -ne 85) { throw \"Test case 4 failed\" }\nif ((Get-TotalCoins -days 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Get-TotalCoins -days 3) -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-TotalCoins -days 5) -ne 11) { throw \"Test case 7 failed\" }\n}\n\nTest-TotalCoins", "entry_point": "Get-TotalCoins", "signature": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n", "docstring": "\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n\n\n* Incomplete Code:\nfunction Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n\n$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le [MASK]rentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le [MASK]rentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}"}
{"task_id": "PowerShell/19-1-span", "prompt": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n<#\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n#>", "canonical_solution": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}", "test": "function Test-TotalCoins() {\nif ((Get-TotalCoins -days 7) -ne 18) { throw \"Test case 1 failed\" }\nif ((Get-TotalCoins -days 10) -ne 30) { throw \"Test case 2 failed\" }\nif ((Get-TotalCoins -days 15) -ne 55) { throw \"Test case 3 failed\" }\nif ((Get-TotalCoins -days 20) -ne 85) { throw \"Test case 4 failed\" }\nif ((Get-TotalCoins -days 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Get-TotalCoins -days 3) -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-TotalCoins -days 5) -ne 11) { throw \"Test case 7 failed\" }\n}\n\nTest-TotalCoins", "entry_point": "Get-TotalCoins", "signature": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n", "docstring": "\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n\n\n* Incomplete Code:\nfunction Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n\n$totalCoins =[MASK]turn $totalCoins\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$totalCoins =[MASK]turn $totalCoins\n}"}
{"task_id": "PowerShell/20-0-span", "prompt": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n<#\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n#>", "canonical_solution": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}", "test": "# Test cases\nfunction Test-MinesweeperGrid() {\n$test1 = Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n$expected1 = @(\"*10\", \"221\", \"1*1\")\n\n$test2 = Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n$expected2 = @(\"2*1\", \"*21\")\n\nif (Compare-Object $test1 $expected1) { throw \"Test case 1 failed\" }\nif (Compare-Object $test2 $expected2) { throw \"Test case 2 failed\" }\n}\n\nTest-MinesweeperGrid", "entry_point": "Get-MinesweeperGrid", "signature": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n", "docstring": "\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n\n\n* Incomplete Code:\nfunction Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n\n$o[MASK]neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$o[MASK]neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}"}
{"task_id": "PowerShell/20-1-span", "prompt": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n<#\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n#>", "canonical_solution": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}", "test": "# Test cases\nfunction Test-MinesweeperGrid() {\n$test1 = Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n$expected1 = @(\"*10\", \"221\", \"1*1\")\n\n$test2 = Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n$expected2 = @(\"2*1\", \"*21\")\n\nif (Compare-Object $test1 $expected1) { throw \"Test case 1 failed\" }\nif (Compare-Object $test2 $expected2) { throw \"Test case 2 failed\" }\n}\n\nTest-MinesweeperGrid", "entry_point": "Get-MinesweeperGrid", "signature": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n", "docstring": "\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n\n\n* Incomplete Code:\nfunction Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n\n$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforea[MASK]inue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforea[MASK]inue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}"}
{"task_id": "PowerShell/21-0-span", "prompt": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n<#\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n#>", "canonical_solution": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}", "test": "function Test-MinimumCowsForHeight() {\nif ((Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5))))) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18))))) -ne 3) { throw \"Test case 2 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 45 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](9, 15, 8, 17, 6))))) -ne 4) { throw \"Test case 3 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 70 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](22, 27, 15, 10, 18))))) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MinimumCowsForHeight", "entry_point": "Get-MinimumCowsForHeight", "signature": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n", "docstring": "\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n\n\n* Incomplete Code:\nfunction Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n\n$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeigh[MASK]eturn $cowCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeigh[MASK]eturn $cowCount\n}"}
{"task_id": "PowerShell/21-1-span", "prompt": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n<#\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n#>", "canonical_solution": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}", "test": "function Test-MinimumCowsForHeight() {\nif ((Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5))))) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18))))) -ne 3) { throw \"Test case 2 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 45 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](9, 15, 8, 17, 6))))) -ne 4) { throw \"Test case 3 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 70 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](22, 27, 15, 10, 18))))) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MinimumCowsForHeight", "entry_point": "Get-MinimumCowsForHeight", "signature": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n", "docstring": "\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n\n\n* Incomplete Code:\nfunction Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n\n$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights[MASK]reak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights[MASK]reak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}"}
{"task_id": "PowerShell/22-0-span", "prompt": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n<#\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n#>", "canonical_solution": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}", "test": "# Test cases\nfunction Test-MaximumScore() {\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 200) -ne 1400) { throw \"Test case 1 failed\" }\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 300) -ne 1600) { throw \"Test case 2 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 150 -scoreBlueInBlue 200 -scoreCrossColor 100) -ne 850) { throw \"Test case 3 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 3 -scoreRedInRed 150 -scoreBlueInBlue 300 -scoreCrossColor 200) -ne 1350) { throw \"Test case 4 failed\" }\n}\n\nTest-MaximumScore", "entry_point": "Get-MaximumScore", "signature": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n", "docstring": "\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n\n\n* Incomplete Code:\nfunction Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n\n$maxScor[MASK]ColorScore)\n\nreturn $maxScore\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$maxScor[MASK]ColorScore)\n\nreturn $maxScore\n}"}
{"task_id": "PowerShell/22-1-span", "prompt": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n<#\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n#>", "canonical_solution": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}", "test": "# Test cases\nfunction Test-MaximumScore() {\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 200) -ne 1400) { throw \"Test case 1 failed\" }\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 300) -ne 1600) { throw \"Test case 2 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 150 -scoreBlueInBlue 200 -scoreCrossColor 100) -ne 850) { throw \"Test case 3 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 3 -scoreRedInRed 150 -scoreBlueInBlue 300 -scoreCrossColor 200) -ne 1350) { throw \"Test case 4 failed\" }\n}\n\nTest-MaximumScore", "entry_point": "Get-MaximumScore", "signature": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n", "docstring": "\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n\n\n* Incomplete Code:\nfunction Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n\n$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore[MASK]$maxScore\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "$maxScore = 0\n\n# 计算同色放置得分\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# 计算交叉放置得分\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# 取两种情况中的最大值\n$maxScore = [Math]::Max($sameColorScore[MASK]$maxScore\n}"}
{"task_id": "PowerShell/23-0-span", "prompt": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n<#\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n#>", "canonical_solution": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}", "test": "function Test-MostFrequentDiceSum() {\nif ((Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3) -ne 5) { throw \"Test case 1 failed\" }\nif ((Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6) -ne 8) { throw \"Test case 2 failed\" }\nif ((Get-MostFrequentDiceSum -s1 6 -s2 6 -s3 6) -ne 10) { throw \"Test case 3 failed\" }\nif ((Get-MostFrequentDiceSum -s1 2 -s2 2 -s3 2) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MostFrequentDiceSum", "entry_point": "Get-MostFrequentDiceSum", "signature": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n", "docstring": "\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n\n\n* Incomplete Code:\nfunction Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n\n$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) [MASK][$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) [MASK][$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}"}
{"task_id": "PowerShell/23-1-span", "prompt": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n<#\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n#>", "canonical_solution": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}", "test": "function Test-MostFrequentDiceSum() {\nif ((Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3) -ne 5) { throw \"Test case 1 failed\" }\nif ((Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6) -ne 8) { throw \"Test case 2 failed\" }\nif ((Get-MostFrequentDiceSum -s1 6 -s2 6 -s3 6) -ne 10) { throw \"Test case 3 failed\" }\nif ((Get-MostFrequentDiceSum -s1 2 -s2 2 -s3 2) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MostFrequentDiceSum", "entry_point": "Get-MostFrequentDiceSum", "signature": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n", "docstring": "\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n\n\n* Incomplete Code:\nfunction Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n\n$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $[MASK]s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $[MASK]s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}"}
{"task_id": "PowerShell/24-0-span", "prompt": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n<#\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n#>", "canonical_solution": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}", "test": "function Test-DetermineParity() {\n$result1 = Determine-Parity @(\"1024\", \"5931\")\n\nif (Compare-Object $result1 @(\"even\", \"odd\")) { throw \"Test case 1 failed\" }\n\n$result2 = Determine-Parity @(\"123456789012345678901234567890\", \"123456789012345678901234567891\")\nif (Compare-Object $result2 @(\"even\", \"odd\")) { throw \"Test case 2 failed\" }\n}\n\nTest-DetermineParity", "entry_point": "Determine-Parity", "signature": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n", "docstring": "\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n\n\n* Incomplete Code:\nfunction Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n\n$result = @[MASK]en\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = @[MASK]en\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/24-1-span", "prompt": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n<#\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n#>", "canonical_solution": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}", "test": "function Test-DetermineParity() {\n$result1 = Determine-Parity @(\"1024\", \"5931\")\n\nif (Compare-Object $result1 @(\"even\", \"odd\")) { throw \"Test case 1 failed\" }\n\n$result2 = Determine-Parity @(\"123456789012345678901234567890\", \"123456789012345678901234567891\")\nif (Compare-Object $result2 @(\"even\", \"odd\")) { throw \"Test case 2 failed\" }\n}\n\nTest-DetermineParity", "entry_point": "Determine-Parity", "signature": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n", "docstring": "\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n\n\n* Incomplete Code:\nfunction Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n\n$result = @()\n\nforeach ($n[MASK]+= \"odd\"\n}\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = @()\n\nforeach ($n[MASK]+= \"odd\"\n}\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/25-0-span", "prompt": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n<#\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n#>", "canonical_solution": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\nreturn $results\n}", "test": "function Test-StudentIDsByOrder() {\n$result1 = Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\nif (Compare-Object $result1 @(1, 8, 5)) { throw \"Test case 1 failed\" }\n\n$result2 = Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\nif (Compare-Object $result2 @(15, 22)) { throw \"Test case 2 failed\" }\n}\n\nTest-StudentIDsByOrder", "entry_point": "Get-StudentIDsByOrder", "signature": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n", "docstring": "\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n\n\n* Incomplete Code:\nfunction Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n\n$res[MASK]y - 1]\n}\n\nreturn $results\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$res[MASK]y - 1]\n}\n\nreturn $results\n}"}
{"task_id": "PowerShell/25-1-span", "prompt": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n<#\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n#>", "canonical_solution": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\nreturn $results\n}", "test": "function Test-StudentIDsByOrder() {\n$result1 = Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\nif (Compare-Object $result1 @(1, 8, 5)) { throw \"Test case 1 failed\" }\n\n$result2 = Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\nif (Compare-Object $result2 @(15, 22)) { throw \"Test case 2 failed\" }\n}\n\nTest-StudentIDsByOrder", "entry_point": "Get-StudentIDsByOrder", "signature": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n", "docstring": "\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n\n\n* Incomplete Code:\nfunction Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n\n$results = @()\n\nforeach ($query in $q[MASK]eturn $results\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$results = @()\n\nforeach ($query in $q[MASK]eturn $results\n}"}
{"task_id": "PowerShell/26-0-span", "prompt": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n<#\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n#>", "canonical_solution": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\nreturn $vkCount\n}", "test": "function Test-MaximizeVKOccurrences() {\nif ((Maximize-VKOccurrences -inputString \"VK\") -ne 1) { throw \"Test case 1 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VV\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Maximize-VKOccurrences -inputString \"V\") -ne 0) { throw \"Test case 3 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\") -ne 3) { throw \"Test case 4 failed\" }\nif ((Maximize-VKOccurrences -inputString \"KVKV\") -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-MaximizeVKOccurrences", "entry_point": "Maximize-VKOccurrences", "signature": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n", "docstring": "\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n\n\n* Incomplete Code:\nfunction Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n\n$vkCount = ([regex]::Matches($inputString, \"VK\")).Cou[MASK]vkCount++\n}\n\nreturn $vkCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Cou[MASK]vkCount++\n}\n\nreturn $vkCount\n}"}
{"task_id": "PowerShell/26-1-span", "prompt": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n<#\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n#>", "canonical_solution": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\nreturn $vkCount\n}", "test": "function Test-MaximizeVKOccurrences() {\nif ((Maximize-VKOccurrences -inputString \"VK\") -ne 1) { throw \"Test case 1 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VV\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Maximize-VKOccurrences -inputString \"V\") -ne 0) { throw \"Test case 3 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\") -ne 3) { throw \"Test case 4 failed\" }\nif ((Maximize-VKOccurrences -inputString \"KVKV\") -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-MaximizeVKOccurrences", "entry_point": "Maximize-VKOccurrences", "signature": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n", "docstring": "\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n\n\n* Incomplete Code:\nfunction Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n\n$vkCount = ([regex]::Matches($inputString, [MASK]rn $vkCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$vkCount = ([regex]::Matches($inputString, [MASK]rn $vkCount\n}"}
{"task_id": "PowerShell/27-0-span", "prompt": "function Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n<#\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n#>", "canonical_solution": "$finalGrade = [math]::Round(($homeworkScore * 0.2) + ($quizScore * 0.3) + ($finalExamScore * 0.5))\nreturn $finalGrade\n}", "test": "function Test-CalculateFinalGrade() {\nif ((Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80) -ne 90) { throw \"Test case 1 failed\" }\nif ((Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80) -ne 79) { throw \"Test case 2 failed\" }\n}\n\nTest-CalculateFinalGrade", "entry_point": "Calculate-FinalGrade", "signature": "function Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n", "docstring": "\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n\n\n* Incomplete Code:\nfunction Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n\n$finalGrade = [math]::Ro[MASK]e * 0.3) + ($finalExamScore * 0.5))\nreturn $finalGrade\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$finalGrade = [math]::Ro[MASK]e * 0.3) + ($finalExamScore * 0.5))\nreturn $finalGrade\n}"}
{"task_id": "PowerShell/27-1-span", "prompt": "function Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n<#\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n#>", "canonical_solution": "$finalGrade = [math]::Round(($homeworkScore * 0.2) + ($quizScore * 0.3) + ($finalExamScore * 0.5))\nreturn $finalGrade\n}", "test": "function Test-CalculateFinalGrade() {\nif ((Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80) -ne 90) { throw \"Test case 1 failed\" }\nif ((Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80) -ne 79) { throw \"Test case 2 failed\" }\n}\n\nTest-CalculateFinalGrade", "entry_point": "Calculate-FinalGrade", "signature": "function Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n", "docstring": "\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n\n\n* Incomplete Code:\nfunction Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n\n$finalGrade = [math]::Round(($homeworkScore * 0.2) + ($quizScore * 0.3) + ($finalExamScore * 0.5))\nretur[MASK]lGrade\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$finalGrade = [math]::Round(($homeworkScore * 0.2) + ($quizScore * 0.3) + ($finalExamScore * 0.5))\nretur[MASK]lGrade\n}"}
{"task_id": "PowerShell/28-0-span", "prompt": "function Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n<#\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n#>", "canonical_solution": "$remainders = $numbers | ForEach-Object { $_ % 42 } | Sort-Object -Unique\nreturn $remainders.Count\n}", "test": "function Test-GetDistinctRemainders() {\nif ((Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) -ne 10) { throw \"Test case 1 failed\" }\nif ((Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)) -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)) -ne 6) { throw \"Test case 3 failed\" }\n}\n\nTest-GetDistinctRemainders", "entry_point": "Get-DistinctRemainders", "signature": "function Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n", "docstring": "\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n\n\n* Incomplete Code:\nfunction Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n\n$remainders = $numbers | ForEac[MASK]bject -Unique\nreturn $remainders.Count\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$remainders = $numbers | ForEac[MASK]bject -Unique\nreturn $remainders.Count\n}"}
{"task_id": "PowerShell/28-1-span", "prompt": "function Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n<#\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n#>", "canonical_solution": "$remainders = $numbers | ForEach-Object { $_ % 42 } | Sort-Object -Unique\nreturn $remainders.Count\n}", "test": "function Test-GetDistinctRemainders() {\nif ((Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) -ne 10) { throw \"Test case 1 failed\" }\nif ((Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)) -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)) -ne 6) { throw \"Test case 3 failed\" }\n}\n\nTest-GetDistinctRemainders", "entry_point": "Get-DistinctRemainders", "signature": "function Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n", "docstring": "\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n\n\n* Incomplete Code:\nfunction Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n\n$remainders = $numbers [MASK]| Sort-Object -Unique\nreturn $remainders.Count\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$remainders = $numbers [MASK]| Sort-Object -Unique\nreturn $remainders.Count\n}"}
{"task_id": "PowerShell/29-0-span", "prompt": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n<#\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n#>", "canonical_solution": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}", "test": "function Test-MinimumSegments() {\nif ((Get-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumSegments -numbers @(1, 2, 3, 4, 5) -maxSum 10) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MinimumSegments -numbers @(10, 10, 10) -maxSum 10) -ne 3) { throw \"Test case 3 failed\" }\n}\n\nTest-MinimumSegments", "entry_point": "Get-MinimumSegments", "signature": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n", "docstring": "\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n\n\n* Incomplete Code:\nfunction Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n\n$segmentCount = 0\n$currentSum = 0\n\nforeach[MASK] $segmentCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$segmentCount = 0\n$currentSum = 0\n\nforeach[MASK] $segmentCount\n}"}
{"task_id": "PowerShell/29-1-span", "prompt": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n<#\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n#>", "canonical_solution": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}", "test": "function Test-MinimumSegments() {\nif ((Get-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumSegments -numbers @(1, 2, 3, 4, 5) -maxSum 10) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MinimumSegments -numbers @(10, 10, 10) -maxSum 10) -ne 3) { throw \"Test case 3 failed\" }\n}\n\nTest-MinimumSegments", "entry_point": "Get-MinimumSegments", "signature": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n", "docstring": "\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n\n\n* Incomplete Code:\nfunction Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n\n$segmentCount[MASK]egmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$segmentCount[MASK]egmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}"}
{"task_id": "PowerShell/30-0-span", "prompt": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n<#\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n#>", "canonical_solution": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}", "test": "function Test-MaxDaysTogether() {\nif ((Get-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")) -ne 1) { throw \"Test case 1 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Park\", \"Mall\") -herLocations @(\"Park\", \"School\", \"Mall\", \"Home\")) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Library\", \"Cafe\") -herLocations @(\"Home\", \"School\", \"Gym\")) -ne 0) { throw \"Test case 3 failed\" }\n}\n\nTest-MaxDaysTogether", "entry_point": "Get-MaxDaysTogether", "signature": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n", "docstring": "\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n\n\n* Incomplete Code:\nfunction Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n\n$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$[MASK]{\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$[MASK]{\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}"}
{"task_id": "PowerShell/30-1-span", "prompt": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n<#\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n#>", "canonical_solution": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}", "test": "function Test-MaxDaysTogether() {\nif ((Get-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")) -ne 1) { throw \"Test case 1 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Park\", \"Mall\") -herLocations @(\"Park\", \"School\", \"Mall\", \"Home\")) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Library\", \"Cafe\") -herLocations @(\"Home\", \"School\", \"Gym\")) -ne 0) { throw \"Test case 3 failed\" }\n}\n\nTest-MaxDaysTogether", "entry_point": "Get-MaxDaysTogether", "signature": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n", "docstring": "\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n\n\n* Incomplete Code:\nfunction Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n\n$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocati[MASK]foreach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocati[MASK]foreach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}"}
{"task_id": "PowerShell/31-0-span", "prompt": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n<#\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n#>", "canonical_solution": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}", "test": "function Test-ModelSurfaceArea {\nif ((Calculate-ModelSurfaceArea 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))) -ne 38) { throw \"Test case 1 failed\" }\nif ((Calculate-ModelSurfaceArea 2 2 @(@(1,0), @(0,1))) -ne 12) { throw \"Test case 2 failed\" }\nif ((Calculate-ModelSurfaceArea 2 3 @(@(2,3,2), @(1,0,1))) -ne 34) { throw \"Test case 3 failed\" }\nif ((Calculate-ModelSurfaceArea 4 4 @(@(0,0,0,0), @(0,2,2,0), @(0,2,2,0), @(0,0,0,0))) -ne 24) { throw \"Test case 4 failed\" }\n}\n\nTest-ModelSurfaceArea", "entry_point": "Calculate-ModelSurfaceArea", "signature": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n", "docstring": "\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n\n\n* Incomplete Code:\nfunction Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n\n$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea +[MASK]totalArea\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea +[MASK]totalArea\n}"}
{"task_id": "PowerShell/31-1-span", "prompt": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n<#\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n#>", "canonical_solution": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}", "test": "function Test-ModelSurfaceArea {\nif ((Calculate-ModelSurfaceArea 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))) -ne 38) { throw \"Test case 1 failed\" }\nif ((Calculate-ModelSurfaceArea 2 2 @(@(1,0), @(0,1))) -ne 12) { throw \"Test case 2 failed\" }\nif ((Calculate-ModelSurfaceArea 2 3 @(@(2,3,2), @(1,0,1))) -ne 34) { throw \"Test case 3 failed\" }\nif ((Calculate-ModelSurfaceArea 4 4 @(@(0,0,0,0), @(0,2,2,0), @(0,2,2,0), @(0,0,0,0))) -ne 24) { throw \"Test case 4 failed\" }\n}\n\nTest-ModelSurfaceArea", "entry_point": "Calculate-ModelSurfaceArea", "signature": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n", "docstring": "\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n\n\n* Incomplete Code:\nfunction Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n\n$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i+[MASK]a += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i+[MASK]a += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}"}
{"task_id": "PowerShell/32-0-span", "prompt": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n<#\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n#>", "canonical_solution": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}", "test": "function Test-WaterCollectionTime {\nif ((Calculate-WaterCollectionTime 4 2 @(3, 3, 4, 4)) -ne 7) { throw \"Test case 1 failed\" }\nif ((Calculate-WaterCollectionTime 3 1 @(2, 3, 4)) -ne 9) { throw \"Test case 2 failed\" }\nif ((Calculate-WaterCollectionTime 6 3 @(1, 2, 2, 3, 1, 4)) -ne 6) { throw \"Test case 3 failed\" }\nif ((Calculate-WaterCollectionTime 2 2 @(5, 6)) -ne 6) { throw \"Test case 4 failed\" }\nif ((Calculate-WaterCollectionTime 5 3 @(1, 1, 1, 1, 1)) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nTest-WaterCollectionTime", "entry_point": "Calculate-WaterCollectionTime", "signature": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n", "docstring": "\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n\n\n* Incomplete Code:\nfunction Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n\n$queue = New-Object System.Collections[MASK]rentAmount)\n}\n}\n}\n\nreturn $totalTime\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$queue = New-Object System.Collections[MASK]rentAmount)\n}\n}\n}\n\nreturn $totalTime\n}"}
{"task_id": "PowerShell/32-1-span", "prompt": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n<#\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n#>", "canonical_solution": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}", "test": "function Test-WaterCollectionTime {\nif ((Calculate-WaterCollectionTime 4 2 @(3, 3, 4, 4)) -ne 7) { throw \"Test case 1 failed\" }\nif ((Calculate-WaterCollectionTime 3 1 @(2, 3, 4)) -ne 9) { throw \"Test case 2 failed\" }\nif ((Calculate-WaterCollectionTime 6 3 @(1, 2, 2, 3, 1, 4)) -ne 6) { throw \"Test case 3 failed\" }\nif ((Calculate-WaterCollectionTime 2 2 @(5, 6)) -ne 6) { throw \"Test case 4 failed\" }\nif ((Calculate-WaterCollectionTime 5 3 @(1, 1, 1, 1, 1)) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nTest-WaterCollectionTime", "entry_point": "Calculate-WaterCollectionTime", "signature": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n", "docstring": "\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n\n\n* Incomplete Code:\nfunction Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n\n$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt [MASK]lTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt [MASK]lTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}"}
{"task_id": "PowerShell/33-0-span", "prompt": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n<#\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n#>", "canonical_solution": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}", "test": "# Test cases\nfunction Test-WaysToClimb {\nif ((Calculate-WaysToClimb 4 2) -ne 5) { throw \"Test case 1 failed\" }\nif ((Calculate-WaysToClimb 3 3) -ne 4) { throw \"Test case 2 failed\" }\nif ((Calculate-WaysToClimb 6 3) -ne 24) { throw \"Test case 3 failed\" }\nif ((Calculate-WaysToClimb 7 4) -ne 56) { throw \"Test case 4 failed\" }\nif ((Calculate-WaysToClimb 10 5) -ne 464) { throw \"Test case 5 failed\" }\n}\n\nTest-WaysToClimb", "entry_point": "Calculate-WaysToClimb", "signature": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n", "docstring": "\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n\n\n* Incomplete Code:\nfunction Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n\n$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; [MASK]r ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; [MASK]r ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}"}
{"task_id": "PowerShell/33-1-span", "prompt": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n<#\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n#>", "canonical_solution": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}", "test": "# Test cases\nfunction Test-WaysToClimb {\nif ((Calculate-WaysToClimb 4 2) -ne 5) { throw \"Test case 1 failed\" }\nif ((Calculate-WaysToClimb 3 3) -ne 4) { throw \"Test case 2 failed\" }\nif ((Calculate-WaysToClimb 6 3) -ne 24) { throw \"Test case 3 failed\" }\nif ((Calculate-WaysToClimb 7 4) -ne 56) { throw \"Test case 4 failed\" }\nif ((Calculate-WaysToClimb 10 5) -ne 464) { throw \"Test case 5 failed\" }\n}\n\nTest-WaysToClimb", "entry_point": "Calculate-WaysToClimb", "signature": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n", "docstring": "\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n\n\n* Incomplete Code:\nfunction Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n\n$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] =[MASK]le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] =[MASK]le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}"}
{"task_id": "PowerShell/34-0-span", "prompt": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n<#\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n#>", "canonical_solution": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}", "test": "function Test-MinimumMilkCost() {\n$farmers1 = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n$result1 = Get-MinimumMilkCost 100 $farmers1\nGet-MinimumMilkCost 100 $farmers1\nif ($result1 -ne 570) { throw \"Test case 1 failed: Expected 580, got $result1\" }\n\n$farmers2 = @([PSCustomObject]@{price=10; quantity=30}, [PSCustomObject]@{price=7; quantity=60}, [PSCustomObject]@{price=2; quantity=40})\n$result2 = Get-MinimumMilkCost 50 $farmers2\nif ($result2 -ne 150) { throw \"Test case 2 failed: Expected 140, got $result2\" }\n\n$farmers3 = @([PSCustomObject]@{price=8; quantity=25}, [PSCustomObject]@{price=5; quantity=55}, [PSCustomObject]@{price=6; quantity=20})\n$result3 = Get-MinimumMilkCost 75 $farmers3\nif ($result3 -ne 395) { throw \"Test case 3 failed: Expected 430, got $result3\" }\n}\n\nTest-MinimumMilkCost", "entry_point": "Get-MinimumMilkCost", "signature": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n", "docstring": "\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n\n\n* Incomplete Code:\nfunction Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n\n$farmers = $f[MASK], $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$farmers = $f[MASK], $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}"}
{"task_id": "PowerShell/34-1-span", "prompt": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n<#\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n#>", "canonical_solution": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}", "test": "function Test-MinimumMilkCost() {\n$farmers1 = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n$result1 = Get-MinimumMilkCost 100 $farmers1\nGet-MinimumMilkCost 100 $farmers1\nif ($result1 -ne 570) { throw \"Test case 1 failed: Expected 580, got $result1\" }\n\n$farmers2 = @([PSCustomObject]@{price=10; quantity=30}, [PSCustomObject]@{price=7; quantity=60}, [PSCustomObject]@{price=2; quantity=40})\n$result2 = Get-MinimumMilkCost 50 $farmers2\nif ($result2 -ne 150) { throw \"Test case 2 failed: Expected 140, got $result2\" }\n\n$farmers3 = @([PSCustomObject]@{price=8; quantity=25}, [PSCustomObject]@{price=5; quantity=55}, [PSCustomObject]@{price=6; quantity=20})\n$result3 = Get-MinimumMilkCost 75 $farmers3\nif ($result3 -ne 395) { throw \"Test case 3 failed: Expected 430, got $result3\" }\n}\n\nTest-MinimumMilkCost", "entry_point": "Get-MinimumMilkCost", "signature": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n", "docstring": "\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n\n\n* Incomplete Code:\nfunction Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n\n$farmers = $farmers | Sort-Object price\n\n$tot[MASK]equiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$farmers = $farmers | Sort-Object price\n\n$tot[MASK]equiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}"}
{"task_id": "PowerShell/35-0-span", "prompt": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n<#\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n#>", "canonical_solution": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}", "test": "function Test-MaxPathSum() {\n$pyramid1 = @( @(3), @(7, 4), @(2, 4, 6), @(8, 5, 9, 3) )\n$result1 = Get-MaxPathSum $pyramid1\nif ($result1 -ne 23) { throw \"Test case 1 failed: Expected 23, got $result1\" }\n\n$pyramid2 = @( @(1), @(2, 1), @(1, 2, 1) )\n$result2 = Get-MaxPathSum $pyramid2\nif ($result2 -ne 5) { throw \"Test case 2 failed: Expected 4, got $result2\" }\n\n$pyramid3 = @( @(1) )\n$result3 = Get-MaxPathSum $pyramid3\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 1, got $result3\" }\n}\n\nTest-MaxPathSum", "entry_point": "Get-MaxPathSum", "signature": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n", "docstring": "\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n\n\n* Incomplete Code:\nfunction Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n\n\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][[MASK]]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][[MASK]]\n}"}
{"task_id": "PowerShell/35-1-span", "prompt": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n<#\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n#>", "canonical_solution": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}", "test": "function Test-MaxPathSum() {\n$pyramid1 = @( @(3), @(7, 4), @(2, 4, 6), @(8, 5, 9, 3) )\n$result1 = Get-MaxPathSum $pyramid1\nif ($result1 -ne 23) { throw \"Test case 1 failed: Expected 23, got $result1\" }\n\n$pyramid2 = @( @(1), @(2, 1), @(1, 2, 1) )\n$result2 = Get-MaxPathSum $pyramid2\nif ($result2 -ne 5) { throw \"Test case 2 failed: Expected 4, got $result2\" }\n\n$pyramid3 = @( @(1) )\n$result3 = Get-MaxPathSum $pyramid3\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 1, got $result3\" }\n}\n\nTest-MaxPathSum", "entry_point": "Get-MaxPathSum", "signature": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n", "docstring": "\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n\n\n* Incomplete Code:\nfunction Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n\n\nfor ($i = $pyram[MASK][0]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "\nfor ($i = $pyram[MASK][0]\n}"}
{"task_id": "PowerShell/36-0-span", "prompt": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n<#\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n#>", "canonical_solution": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}", "test": "function Test-OptimalQueueOrder() {\n$result1 = Get-OptimalQueueOrder @(20, 10, 30)\nif ((Compare-Object $result1 @(1, 0, 2))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-OptimalQueueOrder @(5, 3, 8)\nif ((Compare-Object $result2 @(1, 0, 2))) { throw \"Test case 2 failed\" }\n\n$result3 = Get-OptimalQueueOrder @(15, 5, 3, 7)\nif ((Compare-Object $result3 @(2, 1, 3, 0))) { throw \"Test case 3 failed\" }\n}\n\nTest-OptimalQueueOrder", "entry_point": "Get-OptimalQueueOrder", "signature": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n", "docstring": "\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n\n\n* Incomplete Code:\nfunction Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n\n$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingT[MASK]ices\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingT[MASK]ices\n}"}
{"task_id": "PowerShell/36-1-span", "prompt": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n<#\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n#>", "canonical_solution": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}", "test": "function Test-OptimalQueueOrder() {\n$result1 = Get-OptimalQueueOrder @(20, 10, 30)\nif ((Compare-Object $result1 @(1, 0, 2))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-OptimalQueueOrder @(5, 3, 8)\nif ((Compare-Object $result2 @(1, 0, 2))) { throw \"Test case 2 failed\" }\n\n$result3 = Get-OptimalQueueOrder @(15, 5, 3, 7)\nif ((Compare-Object $result3 @(2, 1, 3, 0))) { throw \"Test case 3 failed\" }\n}\n\nTest-OptimalQueueOrder", "entry_point": "Get-OptimalQueueOrder", "signature": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n", "docstring": "\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n\n\n* Incomplete Code:\nfunction Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n\n$indexed[MASK]edIndices\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "$indexed[MASK]edIndices\n}"}
{"task_id": "PowerShell/37-0-span", "prompt": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n<#\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n#>", "canonical_solution": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}", "test": "function Test-SpecialPrimes() {\n$result1 = Get-SpecialPrimes 2\nif (-not (Compare-Object $result1 @(23, 29, 31, 37, 53, 59, 71, 73, 79, 97))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-SpecialPrimes 3\nif ($result2.Count -eq 0) { throw \"Test case 2 failed: No special primes found\" }\n}\n\nTest-SpecialPrimes", "entry_point": "Get-SpecialPrimes", "signature": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n", "docstring": "\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n\n\n* Incomplete Code:\nfunction Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n\nfunction Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nretu[MASK]rn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nretu[MASK]rn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}"}
{"task_id": "PowerShell/37-1-span", "prompt": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n<#\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n#>", "canonical_solution": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}", "test": "function Test-SpecialPrimes() {\n$result1 = Get-SpecialPrimes 2\nif (-not (Compare-Object $result1 @(23, 29, 31, 37, 53, 59, 71, 73, 79, 97))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-SpecialPrimes 3\nif ($result2.Count -eq 0) { throw \"Test case 2 failed: No special primes found\" }\n}\n\nTest-SpecialPrimes", "entry_point": "Get-SpecialPrimes", "signature": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n", "docstring": "\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n\n\n* Incomplete Code:\nfunction Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n\nfunction Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true[MASK]math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true[MASK]math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}"}
{"task_id": "PowerShell/38-0-span", "prompt": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n<#\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n#>", "canonical_solution": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}", "test": "function Test-ModPower() {\n$result1 = Calculate-ModPower 2 10 9\nif ($result1 -ne 7) { throw \"Test case 1 failed: Expected 2^10 mod 9=7, got $result1\" }\n\n$result2 = Calculate-ModPower 3 7 5\nif ($result2 -ne 2) { throw \"Test case 2 failed: Expected 3^7 mod 5=2, got $result2\" }\n\n$result3 = Calculate-ModPower 5 3 4\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 5^3 mod 4=1, got $result3\" }\n}\n\nTest-ModPower", "entry_point": "Calculate-ModPower", "signature": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n", "docstring": "\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n\n\n* Incomplete Code:\nfunction Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n\n$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [mat[MASK]lt\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [mat[MASK]lt\n}"}
{"task_id": "PowerShell/38-1-span", "prompt": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n<#\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n#>", "canonical_solution": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}", "test": "function Test-ModPower() {\n$result1 = Calculate-ModPower 2 10 9\nif ($result1 -ne 7) { throw \"Test case 1 failed: Expected 2^10 mod 9=7, got $result1\" }\n\n$result2 = Calculate-ModPower 3 7 5\nif ($result2 -ne 2) { throw \"Test case 2 failed: Expected 3^7 mod 5=2, got $result2\" }\n\n$result3 = Calculate-ModPower 5 3 4\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 5^3 mod 4=1, got $result3\" }\n}\n\nTest-ModPower", "entry_point": "Calculate-ModPower", "signature": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n", "docstring": "\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n\n\n* Incomplete Code:\nfunction Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n\n$re[MASK] 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "$re[MASK] 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}"}
{"task_id": "PowerShell/39-0-span", "prompt": "function Find-MinimumSeriesSum {\n    <#\n    This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\n    The function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\n    Example:\n    >>> Find-MinimumSeriesSum -k 2\n    Returns the value of n for which the sum S_n exceeds 2.\n\n    >>> Find-MinimumSeriesSum -k 3\n    Returns the value of n for which the sum S_n exceeds 3.\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}", "test": "function Test-FindMinimumSeriesSum {\n    if ((Find-MinimumSeriesSum -k 2) -ne 4) { throw \"Test case 1 failed\" }\n    if ((Find-MinimumSeriesSum -k 3) -ne 11) { throw \"Test case 2 failed\" }\n    if ((Find-MinimumSeriesSum -k 4) -ne 31) { throw \"Test case 3 failed\" }\n    if ((Find-MinimumSeriesSum -k 5) -ne 83) { throw \"Test case 4 failed\" }\n    if ((Find-MinimumSeriesSum -k 6) -ne 227) { throw \"Test case 5 failed\" }\n}\n\nTest-FindMinimumSeriesSum", "entry_point": "Find-MinimumSeriesSum", "signature": "function Find-MinimumSeriesSum {", "docstring": "This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.\n\n* Incomplete Code:\nfunction Find-MinimumSeriesSum {\n    param (\n        [Parameter(Mandatory=$true)]\n[MASK]d one time too many in the loop\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n[MASK]d one time too many in the loop\n}"}
{"task_id": "PowerShell/39-1-span", "prompt": "function Find-MinimumSeriesSum {\n    <#\n    This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\n    The function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\n    Example:\n    >>> Find-MinimumSeriesSum -k 2\n    Returns the value of n for which the sum S_n exceeds 2.\n\n    >>> Find-MinimumSeriesSum -k 3\n    Returns the value of n for which the sum S_n exceeds 3.\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}", "test": "function Test-FindMinimumSeriesSum {\n    if ((Find-MinimumSeriesSum -k 2) -ne 4) { throw \"Test case 1 failed\" }\n    if ((Find-MinimumSeriesSum -k 3) -ne 11) { throw \"Test case 2 failed\" }\n    if ((Find-MinimumSeriesSum -k 4) -ne 31) { throw \"Test case 3 failed\" }\n    if ((Find-MinimumSeriesSum -k 5) -ne 83) { throw \"Test case 4 failed\" }\n    if ((Find-MinimumSeriesSum -k 6) -ne 227) { throw \"Test case 5 failed\" }\n}\n\nTest-FindMinimumSeriesSum", "entry_point": "Find-MinimumSeriesSum", "signature": "function Find-MinimumSeriesSum {", "docstring": "This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.\n\n* Incomplete Code:\nfunction Find-MinimumSeriesSum {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $[MASK]       $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $[MASK]       $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}"}
{"task_id": "PowerShell/40-0-span", "prompt": "function Get-MaxPens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}", "test": "function Test-GetMaxPens {\n    if ((Get-MaxPens -a 10 -b 3) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-MaxPens -a 20 -b 5) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-MaxPens -a 5 -b 9) -ne 3) { throw \"Test case 3 failed\" }\n    if ((Get-MaxPens -a 0 -b 19) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Get-MaxPens -a 7 -b 2) -ne 3) { throw \"Test case 5 failed\" }\n}\n\nTest-GetMaxPens", "entry_point": "Get-MaxPens", "signature": "function Get-MaxPens {", "docstring": "# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n\n* Incomplete Code:\nfunction Get-MaxPens {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [[MASK]rPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [[MASK]rPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}"}
{"task_id": "PowerShell/40-1-span", "prompt": "function Get-MaxPens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}", "test": "function Test-GetMaxPens {\n    if ((Get-MaxPens -a 10 -b 3) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-MaxPens -a 20 -b 5) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-MaxPens -a 5 -b 9) -ne 3) { throw \"Test case 3 failed\" }\n    if ((Get-MaxPens -a 0 -b 19) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Get-MaxPens -a 7 -b 2) -ne 3) { throw \"Test case 5 failed\" }\n}\n\nTest-GetMaxPens", "entry_point": "Get-MaxPens", "signature": "function Get-MaxPens {", "docstring": "# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \n# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n\n* Incomplete Code:\nfunction Get-MaxPens {\n  [MASK]    [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "  [MASK]    [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}"}
{"task_id": "PowerShell/41-0-span", "prompt": "function Get-AbsoluteValue {\n    <#\n    This function takes an integer as input and returns its absolute value.\n\n    >>> Get-AbsoluteValue -n 5\n    5\n    >>> Get-AbsoluteValue -n -10\n    10\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}", "test": "function Test-GetAbsoluteValue {\n    if ((Get-AbsoluteValue -n 5) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-AbsoluteValue -n -10) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-AbsoluteValue -n 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Get-AbsoluteValue -n -20000) -ne 20000) { throw \"Test case 4 failed\" }\n    if ((Get-AbsoluteValue -n 10000) -ne 10000) { throw \"Test case 5 failed\" }\n}\n\nTest-GetAbsoluteValue", "entry_point": "Get-AbsoluteValue", "signature": "function Get-AbsoluteValue {", "docstring": "This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10\n\n* Incomplete Code:\nfunction Get-AbsoluteValue {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -[MASK]turn $n\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -[MASK]turn $n\n    }\n}"}
{"task_id": "PowerShell/41-1-span", "prompt": "function Get-AbsoluteValue {\n    <#\n    This function takes an integer as input and returns its absolute value.\n\n    >>> Get-AbsoluteValue -n 5\n    5\n    >>> Get-AbsoluteValue -n -10\n    10\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}", "test": "function Test-GetAbsoluteValue {\n    if ((Get-AbsoluteValue -n 5) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-AbsoluteValue -n -10) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-AbsoluteValue -n 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Get-AbsoluteValue -n -20000) -ne 20000) { throw \"Test case 4 failed\" }\n    if ((Get-AbsoluteValue -n 10000) -ne 10000) { throw \"Test case 5 failed\" }\n}\n\nTest-GetAbsoluteValue", "entry_point": "Get-AbsoluteValue", "signature": "function Get-AbsoluteValue {", "docstring": "This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10\n\n* Incomplete Code:\nfunction Get-AbsoluteValue {\n    param (\n        [Parameter(Mand[MASK][int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mand[MASK][int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}"}
{"task_id": "PowerShell/42-0-span", "prompt": "function Test-NumberSign {\n    <#\n    This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n    >>> Test-NumberSign -n 5\n    positive\n    >>> Test-NumberSign -n -10\n    negative\n    >>> Test-NumberSign -n 0\n    zero\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}", "test": "function Test-TestNumberSign {\n    if ((Test-NumberSign -n 5) -ne \"positive\") { throw \"Test case 1 failed\" }\n    if ((Test-NumberSign -n -10) -ne \"negative\") { throw \"Test case 2 failed\" }\n    if ((Test-NumberSign -n 0) -ne \"zero\") { throw \"Test case 3 failed\" }\n    if ((Test-NumberSign -n 1000000000) -ne \"positive\") { throw \"Test case 4 failed\" }\n    if ((Test-NumberSign -n -1000000000) -ne \"negative\") { throw \"Test case 5 failed\" }\n}\n\nTest-TestNumberSign", "entry_point": "Test-NumberSign", "signature": "function Test-NumberSign {", "docstring": "This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero\n\n* Incomplete Code:\nfunction Test-NumberSign {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int[MASK]       return \"zero\"\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int[MASK]       return \"zero\"\n    }\n}"}
{"task_id": "PowerShell/42-1-span", "prompt": "function Test-NumberSign {\n    <#\n    This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n    >>> Test-NumberSign -n 5\n    positive\n    >>> Test-NumberSign -n -10\n    negative\n    >>> Test-NumberSign -n 0\n    zero\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}", "test": "function Test-TestNumberSign {\n    if ((Test-NumberSign -n 5) -ne \"positive\") { throw \"Test case 1 failed\" }\n    if ((Test-NumberSign -n -10) -ne \"negative\") { throw \"Test case 2 failed\" }\n    if ((Test-NumberSign -n 0) -ne \"zero\") { throw \"Test case 3 failed\" }\n    if ((Test-NumberSign -n 1000000000) -ne \"positive\") { throw \"Test case 4 failed\" }\n    if ((Test-NumberSign -n -1000000000) -ne \"negative\") { throw \"Test case 5 failed\" }\n}\n\nTest-TestNumberSign", "entry_point": "Test-NumberSign", "signature": "function Test-NumberSign {", "docstring": "This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero\n\n* Incomplete Code:\nfunction Test-NumberSign {\n    param [MASK]]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param [MASK]]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}"}
{"task_id": "PowerShell/43-0-span", "prompt": "function Get-PowerOfTwo {\n    <#\n    This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n    >>> Get-PowerOfTwo -n 3\n    8\n    >>> Get-PowerOfTwo -n 0\n    1\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}", "test": "function Test-GetPowerOfTwo {\n    if ((Get-PowerOfTwo -n 3) -ne 8) { throw \"Test case 1 failed\" }\n    if ((Get-PowerOfTwo -n 0) -ne 1) { throw \"Test case 2 failed\" }\n    if ((Get-PowerOfTwo -n 10) -ne 1024) { throw \"Test case 3 failed\" }\n    if ((Get-PowerOfTwo -n 15) -ne 32768) { throw \"Test case 4 failed\" }\n    if ((Get-PowerOfTwo -n 20) -ne 1048576) { throw \"Test case 5 failed\" }\n}\n\nTest-GetPowerOfTwo", "entry_point": "Get-PowerOfTwo", "signature": "function Get-PowerOfTwo {", "docstring": "This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1\n\n* Incomplete Code:\nfunction Get-PowerOfTwo {\n [MASK]true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK]true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}"}
{"task_id": "PowerShell/43-1-span", "prompt": "function Get-PowerOfTwo {\n    <#\n    This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n    >>> Get-PowerOfTwo -n 3\n    8\n    >>> Get-PowerOfTwo -n 0\n    1\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}", "test": "function Test-GetPowerOfTwo {\n    if ((Get-PowerOfTwo -n 3) -ne 8) { throw \"Test case 1 failed\" }\n    if ((Get-PowerOfTwo -n 0) -ne 1) { throw \"Test case 2 failed\" }\n    if ((Get-PowerOfTwo -n 10) -ne 1024) { throw \"Test case 3 failed\" }\n    if ((Get-PowerOfTwo -n 15) -ne 32768) { throw \"Test case 4 failed\" }\n    if ((Get-PowerOfTwo -n 20) -ne 1048576) { throw \"Test case 5 failed\" }\n}\n\nTest-GetPowerOfTwo", "entry_point": "Get-PowerOfTwo", "signature": "function Get-PowerOfTwo {", "docstring": "This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1\n\n* Incomplete Code:\nfunction Get-PowerOfTwo {\n    par[MASK]        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    par[MASK]        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}"}
{"task_id": "PowerShell/44-0-span", "prompt": "function Multiply-TwoNumbers {\n    <#\n    This function takes two positive integers as input and returns their product.\n\n    >>> Multiply-TwoNumbers -A 3 -B 4\n    12\n    >>> Multiply-TwoNumbers -A 10 -B 20\n    200\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}", "test": "function Test-MultiplyTwoNumbers {\n    if ((Multiply-TwoNumbers -A 3 -B 4) -ne 12) { throw \"Test case 1 failed\" }\n    if ((Multiply-TwoNumbers -A 10 -B 20) -ne 200) { throw \"Test case 2 failed\" }\n    if ((Multiply-TwoNumbers -A 50000 -B 1) -ne 50000) { throw \"Test case 3 failed\" }\n    if ((Multiply-TwoNumbers -A 1 -B 50000) -ne 50000) { throw \"Test case 4 failed\" }\n    if ((Multiply-TwoNumbers -A 25000 -B 2) -ne 50000) { throw \"Test case 5 failed\" }\n}\n\nTest-MultiplyTwoNumbers", "entry_point": "Multiply-TwoNumbers", "signature": "function Multiply-TwoNumbers {", "docstring": "This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200\n\n* Incomplete Code:\nfunction Multiply-TwoNumbers {\n    param (\n        [Parameter(Mandatory=$true)]\n        [[MASK]n $A * $B\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [[MASK]n $A * $B\n}"}
{"task_id": "PowerShell/44-1-span", "prompt": "function Multiply-TwoNumbers {\n    <#\n    This function takes two positive integers as input and returns their product.\n\n    >>> Multiply-TwoNumbers -A 3 -B 4\n    12\n    >>> Multiply-TwoNumbers -A 10 -B 20\n    200\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}", "test": "function Test-MultiplyTwoNumbers {\n    if ((Multiply-TwoNumbers -A 3 -B 4) -ne 12) { throw \"Test case 1 failed\" }\n    if ((Multiply-TwoNumbers -A 10 -B 20) -ne 200) { throw \"Test case 2 failed\" }\n    if ((Multiply-TwoNumbers -A 50000 -B 1) -ne 50000) { throw \"Test case 3 failed\" }\n    if ((Multiply-TwoNumbers -A 1 -B 50000) -ne 50000) { throw \"Test case 4 failed\" }\n    if ((Multiply-TwoNumbers -A 25000 -B 2) -ne 50000) { throw \"Test case 5 failed\" }\n}\n\nTest-MultiplyTwoNumbers", "entry_point": "Multiply-TwoNumbers", "signature": "function Multiply-TwoNumbers {", "docstring": "This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200\n\n* Incomplete Code:\nfunction Multiply-TwoNumbers {\n    param (\n        [Paramete[MASK]    [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Paramete[MASK]    [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}"}
{"task_id": "PowerShell/45-0-span", "prompt": "function Get-ArithmeticSeriesTerm {\n    <#\n    This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n    >>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n    298\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}", "test": "function Test-GetArithmeticSeriesTerm {\n    if ((Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100) -ne 298) { throw \"Test case 1 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 5 -a2 10 -n 50) -ne 250) { throw \"Test case 2 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 100 -a2 99 -n 50) -ne 51) { throw \"Test case 3 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 0 -a2 0 -n 1000) -ne 0) { throw \"Test case 4 failed\" }\n}\n\nTest-GetArithmeticSeriesTerm", "entry_point": "Get-ArithmeticSeriesTerm", "signature": "function Get-ArithmeticSeriesTerm {", "docstring": "This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298\n\n* Incomplete Code:\nfunction Get-ArithmeticSeriesTerm {\n    par[MASK]t]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    par[MASK]t]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}"}
{"task_id": "PowerShell/45-1-span", "prompt": "function Get-ArithmeticSeriesTerm {\n    <#\n    This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n    >>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n    298\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}", "test": "function Test-GetArithmeticSeriesTerm {\n    if ((Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100) -ne 298) { throw \"Test case 1 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 5 -a2 10 -n 50) -ne 250) { throw \"Test case 2 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 100 -a2 99 -n 50) -ne 51) { throw \"Test case 3 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 0 -a2 0 -n 1000) -ne 0) { throw \"Test case 4 failed\" }\n}\n\nTest-GetArithmeticSeriesTerm", "entry_point": "Get-ArithmeticSeriesTerm", "signature": "function Get-ArithmeticSeriesTerm {", "docstring": "This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298\n\n* Incomplete Code:\nfunction Get-ArithmeticSeriesTerm {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n [MASK]t]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n [MASK]t]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}"}
{"task_id": "PowerShell/46-0-span", "prompt": "function Reverse-ThreeDigitNumber {\n<#\nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n#>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}", "test": "function Test-ReverseThreeDigitNumber {\n    if ((Reverse-ThreeDigitNumber -n 100) -ne 001) { throw \"Test case 1 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 678) -ne 876) { throw \"Test case 2 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 987) -ne 789) { throw \"Test case 3 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 321) -ne 123) { throw \"Test case 4 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 123) -ne 321) { throw \"Test case 5 failed\" }\n}\n\nTest-ReverseThreeDigitNumber", "entry_point": "Reverse-ThreeDigitNumber", "signature": "function Reverse-ThreeDigitNumber {", "docstring": "This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n\n* Incomplete Code:\nfunction Reverse-ThreeDigitNumber {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$[MASK]eversed\n    }\n\n    return [int]$reversed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$[MASK]eversed\n    }\n\n    return [int]$reversed\n}"}
{"task_id": "PowerShell/46-1-span", "prompt": "function Reverse-ThreeDigitNumber {\n<#\nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n#>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}", "test": "function Test-ReverseThreeDigitNumber {\n    if ((Reverse-ThreeDigitNumber -n 100) -ne 001) { throw \"Test case 1 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 678) -ne 876) { throw \"Test case 2 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 987) -ne 789) { throw \"Test case 3 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 321) -ne 123) { throw \"Test case 4 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 123) -ne 321) { throw \"Test case 5 failed\" }\n}\n\nTest-ReverseThreeDigitNumber", "entry_point": "Reverse-ThreeDigitNumber", "signature": "function Reverse-ThreeDigitNumber {", "docstring": "This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n\n* Incomplete Code:\nfunction Reverse-ThreeDigitNumber {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    forea[MASK]ed\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    forea[MASK]ed\n}"}
{"task_id": "PowerShell/47-0-span", "prompt": "function Convert-IntToBoolAndBack {\n    <#\n    This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n    >>> Convert-IntToBoolAndBack -intValue 3\n    1\n    >>> Convert-IntToBoolAndBack -intValue 0\n    0\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}", "test": "function Test-ConvertIntToBoolAndBack {\n    if ((Convert-IntToBoolAndBack -intValue 3) -ne 1) { throw \"Test case 1 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 0) -ne 0) { throw \"Test case 2 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 1) -ne 1) { throw \"Test case 3 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue -1) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 100) -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-ConvertIntToBoolAndBack", "entry_point": "Convert-IntToBoolAndBack", "signature": "function Convert-IntToBoolAndBack {", "docstring": "This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0\n\n* Incomplete Code:\nfunction Convert-IntToBoolAndBack {\n    param (\n        [Parameter(Mandator[MASK]e\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandator[MASK]e\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}"}
{"task_id": "PowerShell/47-1-span", "prompt": "function Convert-IntToBoolAndBack {\n    <#\n    This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n    >>> Convert-IntToBoolAndBack -intValue 3\n    1\n    >>> Convert-IntToBoolAndBack -intValue 0\n    0\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}", "test": "function Test-ConvertIntToBoolAndBack {\n    if ((Convert-IntToBoolAndBack -intValue 3) -ne 1) { throw \"Test case 1 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 0) -ne 0) { throw \"Test case 2 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 1) -ne 1) { throw \"Test case 3 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue -1) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 100) -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-ConvertIntToBoolAndBack", "entry_point": "Convert-IntToBoolAndBack", "signature": "function Convert-IntToBoolAndBack {", "docstring": "This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0\n\n* Incomplete Code:\nfunction Convert-IntToBoolAndBack {\n    param (\n        [Parameter(Mandatory=$tr[MASK]boolValue\n\n    return $result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$tr[MASK]boolValue\n\n    return $result\n}"}
{"task_id": "PowerShell/48-0-span", "prompt": "function Get-ASCIIChar {\n    <#\n    This function takes an ASCII code as input and returns the corresponding character.\n\n    >>> Get-ASCIIChar -asciiCode 65\n    A\n    >>> Get-ASCIIChar -asciiCode 97\n    a\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}", "test": "function Test-GetASCIIChar {\n    if ((Get-ASCIIChar -asciiCode 65) -ne 'A') { throw \"Test case 1 failed\" }\n    if ((Get-ASCIIChar -asciiCode 97) -ne 'a') { throw \"Test case 2 failed\" }\n    if ((Get-ASCIIChar -asciiCode 48) -ne '0') { throw \"Test case 3 failed\" }\n    if ((Get-ASCIIChar -asciiCode 33) -ne '!') { throw \"Test case 4 failed\" }\n    if ((Get-ASCIIChar -asciiCode 126) -ne '~') { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIIChar", "entry_point": "Get-ASCIIChar", "signature": "function Get-ASCIIChar {", "docstring": "This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na\n\n* Incomplete Code:\nfunction Get-ASCIIChar {\n    p[MASK]eter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    p[MASK]eter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}"}
{"task_id": "PowerShell/48-1-span", "prompt": "function Get-ASCIIChar {\n    <#\n    This function takes an ASCII code as input and returns the corresponding character.\n\n    >>> Get-ASCIIChar -asciiCode 65\n    A\n    >>> Get-ASCIIChar -asciiCode 97\n    a\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}", "test": "function Test-GetASCIIChar {\n    if ((Get-ASCIIChar -asciiCode 65) -ne 'A') { throw \"Test case 1 failed\" }\n    if ((Get-ASCIIChar -asciiCode 97) -ne 'a') { throw \"Test case 2 failed\" }\n    if ((Get-ASCIIChar -asciiCode 48) -ne '0') { throw \"Test case 3 failed\" }\n    if ((Get-ASCIIChar -asciiCode 33) -ne '!') { throw \"Test case 4 failed\" }\n    if ((Get-ASCIIChar -asciiCode 126) -ne '~') { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIIChar", "entry_point": "Get-ASCIIChar", "signature": "function Get-ASCIIChar {", "docstring": "This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na\n\n* Incomplete Code:\nfunction Get-ASCIIChar {\n    param (\n        [Parameter([MASK]iiCode\n    )\n\n    return [char]$asciiCode\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter([MASK]iiCode\n    )\n\n    return [char]$asciiCode\n}"}
{"task_id": "PowerShell/49-0-span", "prompt": "function Get-ASCIICode {\n    <#\n    This function takes a character as input and returns its ASCII code.\n\n    >>> Get-ASCIICode -char 'A'\n    65\n    >>> Get-ASCIICode -char 'a'\n    97\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}", "test": "function Test-GetASCIICode {\n    if ((Get-ASCIICode -char 'A') -ne 65) { throw \"Test case 1 failed\" }\n    if ((Get-ASCIICode -char 'a') -ne 97) { throw \"Test case 2 failed\" }\n    if ((Get-ASCIICode -char '0') -ne 48) { throw \"Test case 3 failed\" }\n    if ((Get-ASCIICode -char '!') -ne 33) { throw \"Test case 4 failed\" }\n    if ((Get-ASCIICode -char '~') -ne 126) { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIICode", "entry_point": "Get-ASCIICode", "signature": "function Get-ASCIICode {", "docstring": "This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97\n\n* Incomplete Code:\nfunction Get-ASCIICode {\n    param (\n        [Parameter(Mandatory=$true)]\n    [MASK]  return [int][char]$char\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n    [MASK]  return [int][char]$char\n}"}
{"task_id": "PowerShell/49-1-span", "prompt": "function Get-ASCIICode {\n    <#\n    This function takes a character as input and returns its ASCII code.\n\n    >>> Get-ASCIICode -char 'A'\n    65\n    >>> Get-ASCIICode -char 'a'\n    97\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}", "test": "function Test-GetASCIICode {\n    if ((Get-ASCIICode -char 'A') -ne 65) { throw \"Test case 1 failed\" }\n    if ((Get-ASCIICode -char 'a') -ne 97) { throw \"Test case 2 failed\" }\n    if ((Get-ASCIICode -char '0') -ne 48) { throw \"Test case 3 failed\" }\n    if ((Get-ASCIICode -char '!') -ne 33) { throw \"Test case 4 failed\" }\n    if ((Get-ASCIICode -char '~') -ne 126) { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIICode", "entry_point": "Get-ASCIICode", "signature": "function Get-ASCIICode {", "docstring": "This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97\n\n* Incomplete Code:\nfunction Get-ASCIICode {\n    param (\n        [Parameter(Mandatory=$true)]\n        [c[MASK]r]$char\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [c[MASK]r]$char\n}"}
{"task_id": "PowerShell/50-0-span", "prompt": "function Calculate-Expression {\n    <#\n    This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n    >>> Calculate-Expression -a 2 -b 3 -c 5\n    25\n    >>> Calculate-Expression -a 1 -b 1 -c 1\n    2\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}", "test": "function Test-CalculateExpression {\n    if ((Calculate-Expression -a 2 -b 3 -c 5) -ne 25) { throw \"Test case 1 failed\" }\n    if ((Calculate-Expression -a 1 -b 1 -c 1) -ne 2) { throw \"Test case 2 failed\" }\n    if ((Calculate-Expression -a 0 -b 0 -c 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Calculate-Expression -a -1 -b -1 -c -1) -ne 2) { throw \"Test case 4 failed\" }\n    if ((Calculate-Expression -a 10000 -b 10000 -c 10000) -ne 200000000) { throw \"Test case 5 failed\" }\n    if ((Calculate-Expression -a -10000 -b -10000 -c -10000) -ne 200000000) { throw \"Test case 6 failed\" }\n}", "entry_point": "Calculate-Expression", "signature": "function Calculate-Expression {", "docstring": "This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2\n\n* Incomplete Code:\nfunction Calculate-Expression {\n    param (\n        [Parameter(Mandatory=$true)]\n        [int][MASK]  [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n        [int][MASK]  [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}"}
{"task_id": "PowerShell/50-1-span", "prompt": "function Calculate-Expression {\n    <#\n    This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n    >>> Calculate-Expression -a 2 -b 3 -c 5\n    25\n    >>> Calculate-Expression -a 1 -b 1 -c 1\n    2\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}", "test": "function Test-CalculateExpression {\n    if ((Calculate-Expression -a 2 -b 3 -c 5) -ne 25) { throw \"Test case 1 failed\" }\n    if ((Calculate-Expression -a 1 -b 1 -c 1) -ne 2) { throw \"Test case 2 failed\" }\n    if ((Calculate-Expression -a 0 -b 0 -c 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Calculate-Expression -a -1 -b -1 -c -1) -ne 2) { throw \"Test case 4 failed\" }\n    if ((Calculate-Expression -a 10000 -b 10000 -c 10000) -ne 200000000) { throw \"Test case 5 failed\" }\n    if ((Calculate-Expression -a -10000 -b -10000 -c -10000) -ne 200000000) { throw \"Test case 6 failed\" }\n}", "entry_point": "Calculate-Expression", "signature": "function Calculate-Expression {", "docstring": "This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "instruction": "Below is a explanation of PowerShell code and incomplete code implementation.\n\n* Docstring: \nThis function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2\n\n* Incomplete Code:\nfunction Calculate-Expression {\n    param (\n        [Parameter(Mandatory=$true)]\n    [MASK]$a + $b) * $c\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    param (\n        [Parameter(Mandatory=$true)]\n    [MASK]$a + $b) * $c\n}"}
