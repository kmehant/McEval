{"task_id": "F#/1-0-span", "prompt": "open System\n\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    (*\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    *)", "canonical_solution": "    let rec checkCloseElements = function\n        | [], _ -> false\n        | x::xs, y ->\n            if List.exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)", "test": "// Test cases\nlet check () =\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.3 <> true then\n        failwith \"Test Case 1 failed\"\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.05 <> false then\n        failwith \"Test Case 2 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.95 <> true then\n        failwith \"Test Case 3 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.8 <> false then\n        failwith \"Test Case 4 failed\"\n    if hasCloseElements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0] 0.1 <> true then\n        failwith \"Test Case 5 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 1.0 <> true then\n        failwith \"Test Case 6 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 0.5 <> false then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "hasCloseElements", "signature": "let hasCloseElements (numbers: float list) (threshold: float) =", "docstring": "\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n\n* Incomplete Code:\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    let rec checkCloseElements = function\n        | [], [MASK] (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkCloseElements = function\n        | [], [MASK] (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)"}
{"task_id": "F#/1-1-span", "prompt": "open System\n\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    (*\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    *)", "canonical_solution": "    let rec checkCloseElements = function\n        | [], _ -> false\n        | x::xs, y ->\n            if List.exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)", "test": "// Test cases\nlet check () =\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.3 <> true then\n        failwith \"Test Case 1 failed\"\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.05 <> false then\n        failwith \"Test Case 2 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.95 <> true then\n        failwith \"Test Case 3 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.8 <> false then\n        failwith \"Test Case 4 failed\"\n    if hasCloseElements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0] 0.1 <> true then\n        failwith \"Test Case 5 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 1.0 <> true then\n        failwith \"Test Case 6 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 0.5 <> false then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "hasCloseElements", "signature": "let hasCloseElements (numbers: float list) (threshold: float) =", "docstring": "\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n\n* Incomplete Code:\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    let rec checkCloseElements = function\n        | [], _ -> false\n        | [MASK].exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkCloseElements = function\n        | [], _ -> false\n        | [MASK].exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)"}
{"task_id": "F#/2-0-span", "prompt": "open System\n\nlet existsDouble (arr: int list) =\n    (*\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    *)", "canonical_solution": "    let checkForDouble = function\n        | [] -> false\n        | xs ->\n            List.exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr", "test": "let test () =\n    if existsDouble [1; 2; 3; 4] <> true then\n        failwith \"Test Case 1 failed\"\n    if existsDouble [1; 3; 5; 7] <> false then\n        failwith \"Test Case 2 failed\"\n    if existsDouble [10; 5; 3; 2] <> true then\n        failwith \"Test Case 3 failed\"\n    if existsDouble [6; 7; 9; 12] <> true then\n        failwith \"Test Case 4 failed\"\n    if existsDouble [20; 5; 10; 15] <> true then\n        failwith \"Test Case 5 failed\"\n    if existsDouble [4; 2; 1; 8] <> true then\n        failwith \"Test Case 6 failed\"\n    if existsDouble [11; 22; 33; 44] <> true then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "existsDouble", "signature": "let existsDouble (arr: int list) =", "docstring": "\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    \n\n* Incomplete Code:\nlet existsDouble (arr: int list) =\n    let checkForDouble = function\n        | [] -> false\n        | x[MASK].exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let checkForDouble = function\n        | [] -> false\n        | x[MASK].exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr"}
{"task_id": "F#/2-1-span", "prompt": "open System\n\nlet existsDouble (arr: int list) =\n    (*\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    *)", "canonical_solution": "    let checkForDouble = function\n        | [] -> false\n        | xs ->\n            List.exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr", "test": "let test () =\n    if existsDouble [1; 2; 3; 4] <> true then\n        failwith \"Test Case 1 failed\"\n    if existsDouble [1; 3; 5; 7] <> false then\n        failwith \"Test Case 2 failed\"\n    if existsDouble [10; 5; 3; 2] <> true then\n        failwith \"Test Case 3 failed\"\n    if existsDouble [6; 7; 9; 12] <> true then\n        failwith \"Test Case 4 failed\"\n    if existsDouble [20; 5; 10; 15] <> true then\n        failwith \"Test Case 5 failed\"\n    if existsDouble [4; 2; 1; 8] <> true then\n        failwith \"Test Case 6 failed\"\n    if existsDouble [11; 22; 33; 44] <> true then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "existsDouble", "signature": "let existsDouble (arr: int list) =", "docstring": "\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    \n\n* Incomplete Code:\nlet existsDouble (arr: int list) =\n    l[MASK]= 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    l[MASK]= 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr"}
{"task_id": "F#/3-0-span", "prompt": "open System\n\nlet countNegatives (grid: int list list) =\n    (*\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    *)", "canonical_solution": "    let countRowNegatives row =\n        row |> List.filter (fun x -> x < 0) |> List.length\n\n    grid |> List.map countRowNegatives |> List.sum", "test": "let test () =\n    if countNegatives [[4; 3; 2; -1]; [3; 2; 1; -1]; [1; 1; -1; -2]; [-1; -1; -2; -3]] <> 8 then\n        failwith \"Test Case 1 failed\"\n    if countNegatives [[3; 2]; [1; 0]] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countNegatives [[-1]] <> 1 then\n        failwith \"Test Case 3 failed\"\n    if countNegatives [[5; 4; -1]; [3; 2; -2]; [1; 0; -3]] <> 3 then\n        failwith \"Test Case 4 failed\"\n    if countNegatives [[-5; -4; -3]; [-2; -2; -1]; [-1; -1; -1]] <> 9 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "countNegatives", "signature": "let countNegatives (grid: int list list) =", "docstring": "\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    \n\n* Incomplete Code:\nlet countNegatives (grid: int list list) =\n    let countRowNegatives row =\n        row |> List.filt[MASK]List.length\n\n    grid |> List.map countRowNegatives |> List.sum\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let countRowNegatives row =\n        row |> List.filt[MASK]List.length\n\n    grid |> List.map countRowNegatives |> List.sum"}
{"task_id": "F#/3-1-span", "prompt": "open System\n\nlet countNegatives (grid: int list list) =\n    (*\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    *)", "canonical_solution": "    let countRowNegatives row =\n        row |> List.filter (fun x -> x < 0) |> List.length\n\n    grid |> List.map countRowNegatives |> List.sum", "test": "let test () =\n    if countNegatives [[4; 3; 2; -1]; [3; 2; 1; -1]; [1; 1; -1; -2]; [-1; -1; -2; -3]] <> 8 then\n        failwith \"Test Case 1 failed\"\n    if countNegatives [[3; 2]; [1; 0]] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countNegatives [[-1]] <> 1 then\n        failwith \"Test Case 3 failed\"\n    if countNegatives [[5; 4; -1]; [3; 2; -2]; [1; 0; -3]] <> 3 then\n        failwith \"Test Case 4 failed\"\n    if countNegatives [[-5; -4; -3]; [-2; -2; -1]; [-1; -1; -1]] <> 9 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "countNegatives", "signature": "let countNegatives (grid: int list list) =", "docstring": "\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    \n\n* Incomplete Code:\nlet countNegatives (grid: int list list) =\n    let countRowNegatives row =\n [MASK]er (fun x -> x < 0) |> List.length\n\n    grid |> List.map countRowNegatives |> List.sum\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let countRowNegatives row =\n [MASK]er (fun x -> x < 0) |> List.length\n\n    grid |> List.map countRowNegatives |> List.sum"}
{"task_id": "F#/4-0-span", "prompt": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    (*\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    *)", "canonical_solution": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "test": "let test () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "sortByBinaryOnes", "signature": "let sortByBinaryOnes (arr: int list) =", "docstring": "\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    \n\n* Incomplete Code:\nlet sortByBinaryOnes (arr: int list) =\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> Li[MASK]pare onesX onesY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> Li[MASK]pare onesX onesY)"}
{"task_id": "F#/4-1-span", "prompt": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    (*\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    *)", "canonical_solution": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "test": "let test () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "sortByBinaryOnes", "signature": "let sortByBinaryOnes (arr: int list) =", "docstring": "\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    \n\n* Incomplete Code:\nlet sortByBinaryOnes (arr: int list) =\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.len[MASK]X onesY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.len[MASK]X onesY)"}
{"task_id": "F#/5-0-span", "prompt": "open System\n\nlet smallerNumbersThanCurrent (nums: int list) =\n    (*\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    *)", "canonical_solution": "    let countSmaller n =\n        nums |> List.filter (fun x -> x < n) |> List.length\n\n    nums |> List.map countSmaller", "test": "let test () =\n    if smallerNumbersThanCurrent [8; 1; 2; 2; 3] <> [4; 0; 1; 1; 3] then\n        failwith \"Test Case 1 failed\"\n    if smallerNumbersThanCurrent [6; 5; 4; 8] <> [2; 1; 0; 3] then\n        failwith \"Test Case 2 failed\"\n    if smallerNumbersThanCurrent [7; 7; 7; 7] <> [0; 0; 0; 0] then\n        failwith \"Test Case 3 failed\"\n    if smallerNumbersThanCurrent [1; 2; 3; 4; 5] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 4 failed\"\n    if smallerNumbersThanCurrent [5; 4; 3; 2; 1] <> [4; 3; 2; 1; 0] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "smallerNumbersThanCurrent", "signature": "let smallerNumbersThanCurrent (nums: int list) =", "docstring": "\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    \n\n* Incomplete Code:\nlet smallerNumbersThanCurrent (nums: int list) =\n  [MASK]ntSmaller n =\n        nums |> List.filter (fun x -> x < n) |> List.length\n\n    nums |> List.map countSmaller\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "  [MASK]ntSmaller n =\n        nums |> List.filter (fun x -> x < n) |> List.length\n\n    nums |> List.map countSmaller"}
{"task_id": "F#/5-1-span", "prompt": "open System\n\nlet smallerNumbersThanCurrent (nums: int list) =\n    (*\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    *)", "canonical_solution": "    let countSmaller n =\n        nums |> List.filter (fun x -> x < n) |> List.length\n\n    nums |> List.map countSmaller", "test": "let test () =\n    if smallerNumbersThanCurrent [8; 1; 2; 2; 3] <> [4; 0; 1; 1; 3] then\n        failwith \"Test Case 1 failed\"\n    if smallerNumbersThanCurrent [6; 5; 4; 8] <> [2; 1; 0; 3] then\n        failwith \"Test Case 2 failed\"\n    if smallerNumbersThanCurrent [7; 7; 7; 7] <> [0; 0; 0; 0] then\n        failwith \"Test Case 3 failed\"\n    if smallerNumbersThanCurrent [1; 2; 3; 4; 5] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 4 failed\"\n    if smallerNumbersThanCurrent [5; 4; 3; 2; 1] <> [4; 3; 2; 1; 0] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "smallerNumbersThanCurrent", "signature": "let smallerNumbersThanCurrent (nums: int list) =", "docstring": "\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    \n\n* Incomplete Code:\nlet smallerNumbersThanCurrent (nums: int list) =\n [MASK]untSmaller n =\n        nums |> List.filter (fun x -> x < n) |> List.length\n\n    nums |> List.map countSmaller\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK]untSmaller n =\n        nums |> List.filter (fun x -> x < n) |> List.length\n\n    nums |> List.map countSmaller"}
{"task_id": "F#/6-0-span", "prompt": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    (*\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    *)", "canonical_solution": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "test": "let test () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findLuckyNumbers", "signature": "let findLuckyNumbers (matrix: int list list) =", "docstring": "\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    \n\n* Incomplete Code:\nlet findLuckyNumbers (matrix: int list list) =\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n      [MASK] 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n      [MASK] 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]"}
{"task_id": "F#/6-1-span", "prompt": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    (*\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    *)", "canonical_solution": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "test": "let test () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findLuckyNumbers", "signature": "let findLuckyNumbers (matrix: int list list) =", "docstring": "\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    \n\n* Incomplete Code:\nlet findLuckyNumbers (matrix: int list list) =\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let val[MASK]x] && value = colMaxs.[colIdx] then\n                yield value]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let val[MASK]x] && value = colMaxs.[colIdx] then\n                yield value]"}
{"task_id": "F#/7-0-span", "prompt": "open System\n\nlet findDistanceValue (arr1: int list) (arr2: int list) (d: int) =\n    (*\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    *)", "canonical_solution": "    let isDistanceValid a1 a2 =\n        not (List.exists (fun x -> abs (a1 - x) <= d) a2)\n\n    arr1 |> List.filter (fun x -> isDistanceValid x arr2) |> List.length", "test": "let test () =\n    if findDistanceValue [4; 5; 8] [10; 9; 1; 8] 2 <> 2 then\n        failwith \"Test Case 1 failed\"\n    if findDistanceValue [1; 4; 2; 3] [-4; -3; 6; 10; 20; 30] 3 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if findDistanceValue [2; 1; 100; 3] [10; 9; 8; 7] 6 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if findDistanceValue [-2; -1; -3; 0] [1; 2; 3; 4] 1 <> 3 then\n        failwith \"Test Case 4 failed\"\n    if findDistanceValue [0; 0; 0; 0] [5; 6; 7; 8] 4 <> 4 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findDistanceValue", "signature": "let findDistanceValue (arr1: int list) (arr2: int list) (d: int) =", "docstring": "\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    \n\n* Incomplete Code:\nlet findDistanceValue (arr1: int list) (arr2: int list) (d: int) =\n    let[MASK]alid a1 a2 =\n        not (List.exists (fun x -> abs (a1 - x) <= d) a2)\n\n    arr1 |> List.filter (fun x -> isDistanceValid x arr2) |> List.length\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let[MASK]alid a1 a2 =\n        not (List.exists (fun x -> abs (a1 - x) <= d) a2)\n\n    arr1 |> List.filter (fun x -> isDistanceValid x arr2) |> List.length"}
{"task_id": "F#/7-1-span", "prompt": "open System\n\nlet findDistanceValue (arr1: int list) (arr2: int list) (d: int) =\n    (*\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    *)", "canonical_solution": "    let isDistanceValid a1 a2 =\n        not (List.exists (fun x -> abs (a1 - x) <= d) a2)\n\n    arr1 |> List.filter (fun x -> isDistanceValid x arr2) |> List.length", "test": "let test () =\n    if findDistanceValue [4; 5; 8] [10; 9; 1; 8] 2 <> 2 then\n        failwith \"Test Case 1 failed\"\n    if findDistanceValue [1; 4; 2; 3] [-4; -3; 6; 10; 20; 30] 3 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if findDistanceValue [2; 1; 100; 3] [10; 9; 8; 7] 6 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if findDistanceValue [-2; -1; -3; 0] [1; 2; 3; 4] 1 <> 3 then\n        failwith \"Test Case 4 failed\"\n    if findDistanceValue [0; 0; 0; 0] [5; 6; 7; 8] 4 <> 4 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findDistanceValue", "signature": "let findDistanceValue (arr1: int list) (arr2: int list) (d: int) =", "docstring": "\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    \n\n* Incomplete Code:\nlet findDistanceValue (arr1: int list) (arr2: int list) (d: int) =\n    let isDis[MASK]1 a2 =\n        not (List.exists (fun x -> abs (a1 - x) <= d) a2)\n\n    arr1 |> List.filter (fun x -> isDistanceValid x arr2) |> List.length\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let isDis[MASK]1 a2 =\n        not (List.exists (fun x -> abs (a1 - x) <= d) a2)\n\n    arr1 |> List.filter (fun x -> isDistanceValid x arr2) |> List.length"}
{"task_id": "F#/8-0-span", "prompt": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    (*\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    *)", "canonical_solution": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "test": "let test () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "createTargetArray", "signature": "let createTargetArray (nums: int list) (index: int list) =", "docstring": "\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    \n\n* Incomplete Code:\nlet createTargetArray (nums: int list) (index: int list) =\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [MASK]ms index\n    target\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [MASK]ms index\n    target"}
{"task_id": "F#/8-1-span", "prompt": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    (*\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    *)", "canonical_solution": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "test": "let test () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "createTargetArray", "signature": "let createTargetArray (nums: int list) (index: int list) =", "docstring": "\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    \n\n* Incomplete Code:\nlet createTargetArray (nums: int list) (index: int list) =\n[MASK]的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target"}
{"task_id": "F#/9-0-span", "prompt": "open System\n\nlet kidsWithCandies (candies: int list) (extraCandies: int) =\n    (*\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    *)", "canonical_solution": "    let maxCandies = List.max candies\n    candies |> List.map (fun x -> x + extraCandies >= maxCandies)", "test": "let test () =\n    if kidsWithCandies [2; 3; 5; 1; 3] 3 <> [true; true; true; false; true] then\n        failwith \"Test Case 1 failed\"\n    if kidsWithCandies [4; 2; 1; 1; 2] 1 <> [true; false; false; false; false] then\n        failwith \"Test Case 2 failed\"\n    if kidsWithCandies [1; 1; 1; 1; 1] 5 <> [true; true; true; true; true] then\n        failwith \"Test Case 3 failed\"\n    if kidsWithCandies [5; 10; 5; 10; 10] 5 <> [true; true; true; true; true] then\n        failwith \"Test Case 4 failed\"\n    if kidsWithCandies [10; 5; 3; 2; 1] 2 <> [true; false; false; false; false] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "kidsWithCandies", "signature": "let kidsWithCandies (candies: int list) (extraCandies: int) =", "docstring": "\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    \n\n* Incomplete Code:\nlet kidsWithCandies (candies: int list) (extraCandies: int) =\n    let maxCandies = List.max candies\n    candies |> List.map (fun x[MASK]xCandies)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let maxCandies = List.max candies\n    candies |> List.map (fun x[MASK]xCandies)"}
{"task_id": "F#/9-1-span", "prompt": "open System\n\nlet kidsWithCandies (candies: int list) (extraCandies: int) =\n    (*\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    *)", "canonical_solution": "    let maxCandies = List.max candies\n    candies |> List.map (fun x -> x + extraCandies >= maxCandies)", "test": "let test () =\n    if kidsWithCandies [2; 3; 5; 1; 3] 3 <> [true; true; true; false; true] then\n        failwith \"Test Case 1 failed\"\n    if kidsWithCandies [4; 2; 1; 1; 2] 1 <> [true; false; false; false; false] then\n        failwith \"Test Case 2 failed\"\n    if kidsWithCandies [1; 1; 1; 1; 1] 5 <> [true; true; true; true; true] then\n        failwith \"Test Case 3 failed\"\n    if kidsWithCandies [5; 10; 5; 10; 10] 5 <> [true; true; true; true; true] then\n        failwith \"Test Case 4 failed\"\n    if kidsWithCandies [10; 5; 3; 2; 1] 2 <> [true; false; false; false; false] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "kidsWithCandies", "signature": "let kidsWithCandies (candies: int list) (extraCandies: int) =", "docstring": "\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    \n\n* Incomplete Code:\nlet kidsWithCandies (candies: int list) (extraCandies: int) =\n    let maxCandies = List.max candies\n    candies |> L[MASK]aCandies >= maxCandies)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let maxCandies = List.max candies\n    candies |> L[MASK]aCandies >= maxCandies)"}
{"task_id": "F#/10-0-span", "prompt": "open System\nopen System.Collections.Generic\n\nlet findDestination (paths: (string * string) list) =\n    (*\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    *)", "canonical_solution": "    let startCities = paths |> List.map fst |> HashSet\n    paths |> List.tryFind (fun (_, cityB) -> not (startCities.Contains(cityB))) |> Option.map snd", "test": "let test () =\n    if findDestination [(\"London\", \"New York\"); (\"New York\", \"Tokyo\"); (\"Tokyo\", \"Berlin\")] <> Some \"Berlin\" then\n        failwith \"Test Case 1 failed\"\n    if findDestination [(\"Chicago\", \"Winnipeg\"); (\"Halifax\", \"Montreal\"); (\"Montreal\", \"Toronto\"); (\"Toronto\", \"Chicago\")] <> Some \"Winnipeg\" then\n        failwith \"Test Case 2 failed\"\n    if findDestination [(\"A\", \"B\"); (\"B\", \"C\"); (\"C\", \"D\")] <> Some \"D\" then\n        failwith \"Test Case 3 failed\"\n    if findDestination [(\"Paris\", \"Lyon\"); (\"Lyon\", \"Marseille\")] <> Some \"Marseille\" then\n        failwith \"Test Case 4 failed\"\n\ntest ()", "entry_point": "findDestination", "signature": "let findDestination (paths: (string * string) list) =", "docstring": "\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    \n\n* Incomplete Code:\nlet findDestination (paths: (string * string) list) =\n    let startCities = paths |> List.map fst |> HashSet\n    paths |> List.tryFind (fun (_, city[MASK])) |> Option.map snd\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let startCities = paths |> List.map fst |> HashSet\n    paths |> List.tryFind (fun (_, city[MASK])) |> Option.map snd"}
{"task_id": "F#/10-1-span", "prompt": "open System\nopen System.Collections.Generic\n\nlet findDestination (paths: (string * string) list) =\n    (*\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    *)", "canonical_solution": "    let startCities = paths |> List.map fst |> HashSet\n    paths |> List.tryFind (fun (_, cityB) -> not (startCities.Contains(cityB))) |> Option.map snd", "test": "let test () =\n    if findDestination [(\"London\", \"New York\"); (\"New York\", \"Tokyo\"); (\"Tokyo\", \"Berlin\")] <> Some \"Berlin\" then\n        failwith \"Test Case 1 failed\"\n    if findDestination [(\"Chicago\", \"Winnipeg\"); (\"Halifax\", \"Montreal\"); (\"Montreal\", \"Toronto\"); (\"Toronto\", \"Chicago\")] <> Some \"Winnipeg\" then\n        failwith \"Test Case 2 failed\"\n    if findDestination [(\"A\", \"B\"); (\"B\", \"C\"); (\"C\", \"D\")] <> Some \"D\" then\n        failwith \"Test Case 3 failed\"\n    if findDestination [(\"Paris\", \"Lyon\"); (\"Lyon\", \"Marseille\")] <> Some \"Marseille\" then\n        failwith \"Test Case 4 failed\"\n\ntest ()", "entry_point": "findDestination", "signature": "let findDestination (paths: (string * string) list) =", "docstring": "\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    \n\n* Incomplete Code:\nlet findDestination (paths: (string * string) list) =\n    let st[MASK]List.map fst |> HashSet\n    paths |> List.tryFind (fun (_, cityB) -> not (startCities.Contains(cityB))) |> Option.map snd\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let st[MASK]List.map fst |> HashSet\n    paths |> List.tryFind (fun (_, cityB) -> not (startCities.Contains(cityB))) |> Option.map snd"}
{"task_id": "F#/11-0-span", "prompt": "open System\n\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    (*\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    *)", "canonical_solution": "    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0", "test": "// Test cases\nlet test () =\n    if homeworkAtQueryTime [1; 2; 3] [3; 2; 7] 4 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if homeworkAtQueryTime [4; 2; 2; 1] [4; 3; 7; 8] 3 <> 3 then\n        failwith \"Test Case 2 failed\"\n    if homeworkAtQueryTime [5; 1; 1; 1] [10; 3; 2; 2] 5 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if homeworkAtQueryTime [1; 1; 1; 1] [4; 4; 4; 4] 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if homeworkAtQueryTime [2; 2; 2] [3; 3; 3] 1 <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "homeworkAtQueryTime", "signature": "let homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =", "docstring": "\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    \n\n* Incomplete Code:\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    [MASK]rk, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    [MASK]rk, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0"}
{"task_id": "F#/11-1-span", "prompt": "open System\n\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    (*\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    *)", "canonical_solution": "    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0", "test": "// Test cases\nlet test () =\n    if homeworkAtQueryTime [1; 2; 3] [3; 2; 7] 4 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if homeworkAtQueryTime [4; 2; 2; 1] [4; 3; 7; 8] 3 <> 3 then\n        failwith \"Test Case 2 failed\"\n    if homeworkAtQueryTime [5; 1; 1; 1] [10; 3; 2; 2] 5 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if homeworkAtQueryTime [1; 1; 1; 1] [4; 4; 4; 4] 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if homeworkAtQueryTime [2; 2; 2] [3; 3; 3] 1 <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "homeworkAtQueryTime", "signature": "let homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =", "docstring": "\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    \n\n* Incomplete Code:\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n[MASK] None -> 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n[MASK] None -> 0"}
{"task_id": "F#/12-0-span", "prompt": "open System\n\nlet canMakeSameAsTarget (target: int list) (arr: int list) =\n    (*\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    *)", "canonical_solution": "    let sortedTarget = List.sort target\n    let sortedArr = List.sort arr\n    sortedTarget = sortedArr", "test": "let test () =\n    if canMakeSameAsTarget [1; 2; 3; 4] [2; 4; 1; 3] <> true then\n        failwith \"Test Case 1 failed\"\n    if canMakeSameAsTarget [7; 7; 7] [7; 7; 7] <> true then\n        failwith \"Test Case 2 failed\"\n    if canMakeSameAsTarget [5; 1; 3] [1; 3; 5] <> true then\n        failwith \"Test Case 3 failed\"\n    if canMakeSameAsTarget [1; 4; 3; 2] [2; 3; 4; 1] <> true then\n        failwith \"Test Case 4 failed\"\n    if canMakeSameAsTarget [1; 2; 1; 2] [2; 1; 2; 1] <> true then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "canMakeSameAsTarget", "signature": "let canMakeSameAsTarget (target: int list) (arr: int list) =", "docstring": "\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    \n\n* Incomplete Code:\nlet canMakeSameAsTarget (target: int list) (arr: int list) =\n    let sortedTarget = List.sort target\n    let [MASK]ist.sort arr\n    sortedTarget = sortedArr\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sortedTarget = List.sort target\n    let [MASK]ist.sort arr\n    sortedTarget = sortedArr"}
{"task_id": "F#/12-1-span", "prompt": "open System\n\nlet canMakeSameAsTarget (target: int list) (arr: int list) =\n    (*\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    *)", "canonical_solution": "    let sortedTarget = List.sort target\n    let sortedArr = List.sort arr\n    sortedTarget = sortedArr", "test": "let test () =\n    if canMakeSameAsTarget [1; 2; 3; 4] [2; 4; 1; 3] <> true then\n        failwith \"Test Case 1 failed\"\n    if canMakeSameAsTarget [7; 7; 7] [7; 7; 7] <> true then\n        failwith \"Test Case 2 failed\"\n    if canMakeSameAsTarget [5; 1; 3] [1; 3; 5] <> true then\n        failwith \"Test Case 3 failed\"\n    if canMakeSameAsTarget [1; 4; 3; 2] [2; 3; 4; 1] <> true then\n        failwith \"Test Case 4 failed\"\n    if canMakeSameAsTarget [1; 2; 1; 2] [2; 1; 2; 1] <> true then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "canMakeSameAsTarget", "signature": "let canMakeSameAsTarget (target: int list) (arr: int list) =", "docstring": "\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    \n\n* Incomplete Code:\nlet canMakeSameAsTarget (target: int list) (arr: int list) =\n    let sortedTa[MASK]t target\n    let sortedArr = List.sort arr\n    sortedTarget = sortedArr\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sortedTa[MASK]t target\n    let sortedArr = List.sort arr\n    sortedTarget = sortedArr"}
{"task_id": "F#/13-0-span", "prompt": "open System\n\nlet maxProduct (nums: int list) =\n    (*\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    *)", "canonical_solution": "    let sorted = List.sortDescending nums\n    match sorted with\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0", "test": "let test () =\n    if maxProduct [3; 4; 5; 2] <> 12 then\n        failwith \"Test Case 1 failed\"\n    if maxProduct [1; 5; 4; 5] <> 16 then\n        failwith \"Test Case 2 failed\"\n    if maxProduct [1; 2; 3] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxProduct [10; 2; 5; 2] <> 36 then\n        failwith \"Test Case 4 failed\"\n    if maxProduct [1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "maxProduct", "signature": "let maxProduct (nums: int list) =", "docstring": "\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    \n\n* Incomplete Code:\nlet maxProduct (nums: int list) =\n    let sorted = List.sortDescending nums\n    match [MASK] | _ -> 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sorted = List.sortDescending nums\n    match [MASK] | _ -> 0"}
{"task_id": "F#/13-1-span", "prompt": "open System\n\nlet maxProduct (nums: int list) =\n    (*\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    *)", "canonical_solution": "    let sorted = List.sortDescending nums\n    match sorted with\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0", "test": "let test () =\n    if maxProduct [3; 4; 5; 2] <> 12 then\n        failwith \"Test Case 1 failed\"\n    if maxProduct [1; 5; 4; 5] <> 16 then\n        failwith \"Test Case 2 failed\"\n    if maxProduct [1; 2; 3] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxProduct [10; 2; 5; 2] <> 36 then\n        failwith \"Test Case 4 failed\"\n    if maxProduct [1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "maxProduct", "signature": "let maxProduct (nums: int list) =", "docstring": "\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    \n\n* Incomplete Code:\nlet maxProduct (nums: int list) =\n    let sorted = List.sortDescen[MASK]ith\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sorted = List.sortDescen[MASK]ith\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0"}
{"task_id": "F#/14-0-span", "prompt": "open System\n\nlet shuffleArray (nums: int list) =\n    (*\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    *)", "canonical_solution": "    let n = List.length nums / 2\n    List.init n (fun i -> [nums.[i]; nums.[i + n]]) |> List.concat", "test": "let test () =\n    if shuffleArray [2; 5; 1; 3; 4; 7] <> [2; 3; 5; 4; 1; 7] then\n        failwith \"Test Case 1 failed\"\n    if shuffleArray [1; 2; 3; 4; 4; 3; 2; 1] <> [1; 4; 2; 3; 3; 2; 4; 1] then\n        failwith \"Test Case 2 failed\"\n    if shuffleArray [1; 3; 5; 7; 2; 4; 6; 8] <> [1; 2; 3; 4; 5; 6; 7; 8] then\n        failwith \"Test Case 3 failed\"\n    if shuffleArray [10; 20; 30; 40; 11; 21; 31; 41] <> [10; 11; 20; 21; 30; 31; 40; 41] then\n        failwith \"Test Case 4 failed\"\n    if shuffleArray [9; 7; 5; 3; 8; 6; 4; 2] <> [9; 8; 7; 6; 5; 4; 3; 2] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "shuffleArray", "signature": "let shuffleArray (nums: int list) =", "docstring": "\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    \n\n* Incomplete Code:\nlet shuffleArray (nums: int list) =\n    let n = List.length nums / 2\n [MASK]nums.[i]; nums.[i + n]]) |> List.concat\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let n = List.length nums / 2\n [MASK]nums.[i]; nums.[i + n]]) |> List.concat"}
{"task_id": "F#/14-1-span", "prompt": "open System\n\nlet shuffleArray (nums: int list) =\n    (*\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    *)", "canonical_solution": "    let n = List.length nums / 2\n    List.init n (fun i -> [nums.[i]; nums.[i + n]]) |> List.concat", "test": "let test () =\n    if shuffleArray [2; 5; 1; 3; 4; 7] <> [2; 3; 5; 4; 1; 7] then\n        failwith \"Test Case 1 failed\"\n    if shuffleArray [1; 2; 3; 4; 4; 3; 2; 1] <> [1; 4; 2; 3; 3; 2; 4; 1] then\n        failwith \"Test Case 2 failed\"\n    if shuffleArray [1; 3; 5; 7; 2; 4; 6; 8] <> [1; 2; 3; 4; 5; 6; 7; 8] then\n        failwith \"Test Case 3 failed\"\n    if shuffleArray [10; 20; 30; 40; 11; 21; 31; 41] <> [10; 11; 20; 21; 30; 31; 40; 41] then\n        failwith \"Test Case 4 failed\"\n    if shuffleArray [9; 7; 5; 3; 8; 6; 4; 2] <> [9; 8; 7; 6; 5; 4; 3; 2] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "shuffleArray", "signature": "let shuffleArray (nums: int list) =", "docstring": "\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    \n\n* Incomplete Code:\nlet shuffleArray (nums: int list) =\n    let[MASK]ngth nums / 2\n    List.init n (fun i -> [nums.[i]; nums.[i + n]]) |> List.concat\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let[MASK]ngth nums / 2\n    List.init n (fun i -> [nums.[i]; nums.[i + n]]) |> List.concat"}
{"task_id": "F#/15-0-span", "prompt": "open System\n\nlet finalPrices (prices: int list) =\n    (*\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let findDiscount i price =\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices", "test": "let test () =\n    if finalPrices [8; 4; 6; 2; 3] <> [4; 2; 4; 2; 3] then\n        failwith \"Test Case 1 failed\"\n    if finalPrices [1; 2; 3; 4; 5] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if finalPrices [10; 1; 1; 6] <> [9; 0; 1; 6] then\n        failwith \"Test Case 3 failed\"\n    if finalPrices [4; 2; 4; 2; 3] <> [2; 0; 2; 2; 3] then\n        failwith \"Test Case 4 failed\"\n    if finalPrices [7; 7; 7; 7; 7] <> [0; 0; 0; 0; 7] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "finalPrices", "signature": "let finalPrices (prices: int list) =", "docstring": "\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet finalPrices (prices: int list) =\n    let findDiscount i price =\n    [MASK]t.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let findDiscount i price =\n    [MASK]t.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices"}
{"task_id": "F#/15-1-span", "prompt": "open System\n\nlet finalPrices (prices: int list) =\n    (*\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let findDiscount i price =\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices", "test": "let test () =\n    if finalPrices [8; 4; 6; 2; 3] <> [4; 2; 4; 2; 3] then\n        failwith \"Test Case 1 failed\"\n    if finalPrices [1; 2; 3; 4; 5] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if finalPrices [10; 1; 1; 6] <> [9; 0; 1; 6] then\n        failwith \"Test Case 3 failed\"\n    if finalPrices [4; 2; 4; 2; 3] <> [2; 0; 2; 2; 3] then\n        failwith \"Test Case 4 failed\"\n    if finalPrices [7; 7; 7; 7; 7] <> [0; 0; 0; 0; 7] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "finalPrices", "signature": "let finalPrices (prices: int list) =", "docstring": "\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet finalPrices (prices: int list) =\n    let findDiscount i price =\n        prices.[i+1..]\n  [MASK]| None -> price\n\n    List.mapi findDiscount prices\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let findDiscount i price =\n        prices.[i+1..]\n  [MASK]| None -> price\n\n    List.mapi findDiscount prices"}
{"task_id": "F#/16-0-span", "prompt": "open System\n\nlet runningSum (nums: int list) =\n    (*\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let rec calcRunningSum acc sumSoFar =\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0", "test": "let test () =\n    if runningSum [1; 2; 3; 4] <> [1; 3; 6; 10] then\n        failwith \"Test Case 1 failed\"\n    if runningSum [1; 1; 1; 1; 1] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if runningSum [3; 1; 2; 10; 1] <> [3; 4; 6; 16; 17] then\n        failwith \"Test Case 3 failed\"\n    if runningSum [0; 0; 0; 0] <> [0; 0; 0; 0] then\n        failwith \"Test Case 4 failed\"\n    if runningSum [5; -1; -2; 3] <> [5; 4; 2; 5] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "runningSum", "signature": "let runningSum (nums: int list) =", "docstring": "\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet runningSum (nums: int list) =\n    let rec calcRunningSum acc sumSoFar =\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum[MASK]nums 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec calcRunningSum acc sumSoFar =\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum[MASK]nums 0"}
{"task_id": "F#/16-1-span", "prompt": "open System\n\nlet runningSum (nums: int list) =\n    (*\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let rec calcRunningSum acc sumSoFar =\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0", "test": "let test () =\n    if runningSum [1; 2; 3; 4] <> [1; 3; 6; 10] then\n        failwith \"Test Case 1 failed\"\n    if runningSum [1; 1; 1; 1; 1] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if runningSum [3; 1; 2; 10; 1] <> [3; 4; 6; 16; 17] then\n        failwith \"Test Case 3 failed\"\n    if runningSum [0; 0; 0; 0] <> [0; 0; 0; 0] then\n        failwith \"Test Case 4 failed\"\n    if runningSum [5; -1; -2; 3] <> [5; 4; 2; 5] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "runningSum", "signature": "let runningSum (nums: int list) =", "docstring": "\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet runningSum (nums: int list) =\n    l[MASK]      match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    l[MASK]      match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0"}
{"task_id": "F#/17-0-span", "prompt": "open System\n\nlet averageSalaryExcludingMinMax (salary: int list) =\n    (*\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    *)", "canonical_solution": "    let sorted = List.sort salary\n    let filtered = sorted.Tail |> List.take (List.length sorted - 2)\n    List.averageBy float filtered", "test": "let test () =\n    if averageSalaryExcludingMinMax [4000; 3000; 1000; 2000] <> 2500.0 then\n        failwith \"Test Case 1 failed\"\n    if averageSalaryExcludingMinMax [6000; 5000; 4000; 3000; 2000; 1000] <> 3500.0 then\n        failwith \"Test Case 2 failed\"\n    if averageSalaryExcludingMinMax [8000; 7000; 6000; 5000; 4000] <> 6000.0 then\n        failwith \"Test Case 3 failed\"\n    if averageSalaryExcludingMinMax [3000; 2000; 1000] <> 2000.0 then\n        failwith \"Test Case 4 failed\"\n    if averageSalaryExcludingMinMax [5000; 3000; 2000; 1000; 4000] <> 3000.0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "averageSalaryExcludingMinMax", "signature": "let averageSalaryExcludingMinMax (salary: int list) =", "docstring": "\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    \n\n* Incomplete Code:\nlet averageSalaryExcludingMinMax (salary: int list) =\n    let sorted = List.sort salary\n    let filtered = sorted.Tail |> List.take (List.length sorted - 2)\n    L[MASK] float filtered\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sorted = List.sort salary\n    let filtered = sorted.Tail |> List.take (List.length sorted - 2)\n    L[MASK] float filtered"}
{"task_id": "F#/17-1-span", "prompt": "open System\n\nlet averageSalaryExcludingMinMax (salary: int list) =\n    (*\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    *)", "canonical_solution": "    let sorted = List.sort salary\n    let filtered = sorted.Tail |> List.take (List.length sorted - 2)\n    List.averageBy float filtered", "test": "let test () =\n    if averageSalaryExcludingMinMax [4000; 3000; 1000; 2000] <> 2500.0 then\n        failwith \"Test Case 1 failed\"\n    if averageSalaryExcludingMinMax [6000; 5000; 4000; 3000; 2000; 1000] <> 3500.0 then\n        failwith \"Test Case 2 failed\"\n    if averageSalaryExcludingMinMax [8000; 7000; 6000; 5000; 4000] <> 6000.0 then\n        failwith \"Test Case 3 failed\"\n    if averageSalaryExcludingMinMax [3000; 2000; 1000] <> 2000.0 then\n        failwith \"Test Case 4 failed\"\n    if averageSalaryExcludingMinMax [5000; 3000; 2000; 1000; 4000] <> 3000.0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "averageSalaryExcludingMinMax", "signature": "let averageSalaryExcludingMinMax (salary: int list) =", "docstring": "\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    \n\n* Incomplete Code:\nlet averageSalaryExcludingMinMax (salary: int list) =\n    let sorted = List.sort salary\n   [MASK] |> List.take (List.length sorted - 2)\n    List.averageBy float filtered\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sorted = List.sort salary\n   [MASK] |> List.take (List.length sorted - 2)\n    List.averageBy float filtered"}
{"task_id": "F#/18-0-span", "prompt": "open System\n\nlet rearrangeString (s: string) (indices: int list) =\n    (*\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    *)", "canonical_solution": "    let combined = List.zip indices (s.ToCharArray() |> Array.toList)\n    let sorted = List.sortBy fst combined\n    sorted |> List.map snd |> String.Concat", "test": "let test () =\n    if rearrangeString \"codeleet\" [4; 5; 6; 7; 0; 2; 1; 3] <> \"leetcode\" then\n        failwith \"Test Case 1 failed\"\n    if rearrangeString \"abc\" [0; 1; 2] <> \"abc\" then\n        failwith \"Test Case 2 failed\"\n    if rearrangeString \"aiohn\" [3; 1; 4; 2; 0] <> \"nihao\" then\n        failwith \"Test Case 3 failed\"\n    if rearrangeString \"aaiougrt\" [4; 0; 2; 6; 7; 3; 1; 5] <> \"arigatou\" then\n        failwith \"Test Case 4 failed\"\n    if rearrangeString \"art\" [1; 0; 2] <> \"rat\" then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "rearrangeString", "signature": "let rearrangeString (s: string) (indices: int list) =", "docstring": "\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    \n\n* Incomplete Code:\nlet rearrangeString (s: string) (indices: int list) =\n    let combined = List.zip indices (s.ToCharArray() |> Array.toList)\n    let sorted = [MASK]combined\n    sorted |> List.map snd |> String.Concat\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let combined = List.zip indices (s.ToCharArray() |> Array.toList)\n    let sorted = [MASK]combined\n    sorted |> List.map snd |> String.Concat"}
{"task_id": "F#/18-1-span", "prompt": "open System\n\nlet rearrangeString (s: string) (indices: int list) =\n    (*\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    *)", "canonical_solution": "    let combined = List.zip indices (s.ToCharArray() |> Array.toList)\n    let sorted = List.sortBy fst combined\n    sorted |> List.map snd |> String.Concat", "test": "let test () =\n    if rearrangeString \"codeleet\" [4; 5; 6; 7; 0; 2; 1; 3] <> \"leetcode\" then\n        failwith \"Test Case 1 failed\"\n    if rearrangeString \"abc\" [0; 1; 2] <> \"abc\" then\n        failwith \"Test Case 2 failed\"\n    if rearrangeString \"aiohn\" [3; 1; 4; 2; 0] <> \"nihao\" then\n        failwith \"Test Case 3 failed\"\n    if rearrangeString \"aaiougrt\" [4; 0; 2; 6; 7; 3; 1; 5] <> \"arigatou\" then\n        failwith \"Test Case 4 failed\"\n    if rearrangeString \"art\" [1; 0; 2] <> \"rat\" then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "rearrangeString", "signature": "let rearrangeString (s: string) (indices: int list) =", "docstring": "\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    \n\n* Incomplete Code:\nlet rearrangeString (s: string) (indices: int list) =\n   [MASK]dices (s.ToCharArray() |> Array.toList)\n    let sorted = List.sortBy fst combined\n    sorted |> List.map snd |> String.Concat\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK]dices (s.ToCharArray() |> Array.toList)\n    let sorted = List.sortBy fst combined\n    sorted |> List.map snd |> String.Concat"}
{"task_id": "F#/19-0-span", "prompt": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    (*\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    *)", "canonical_solution": "    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "test": "let test () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "countGoodTriplets", "signature": "let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =", "docstring": "\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    \n\n* Incomplete Code:\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    let isGoodTriplet i j k =\n  [MASK]> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let isGoodTriplet i j k =\n  [MASK]> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0"}
{"task_id": "F#/19-1-span", "prompt": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    (*\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    *)", "canonical_solution": "    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "test": "let test () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "countGoodTriplets", "signature": "let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =", "docstring": "\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    \n\n* Incomplete Code:\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= Li[MASK]      countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= Li[MASK]      countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0"}
{"task_id": "F#/20-0-span", "prompt": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    (*\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    *)", "canonical_solution": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "test": "let test () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "hasThreeConsecutiveOdds", "signature": "let hasThreeConsecutiveOdds (arr: int list) =", "docstring": "\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    \n\n* Incomplete Code:\nlet hasThreeConsecutiveOdds (arr: int list) =\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n [MASK]2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n [MASK]2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0"}
{"task_id": "F#/20-1-span", "prompt": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    (*\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    *)", "canonical_solution": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "test": "let test () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "hasThreeConsecutiveOdds", "signature": "let hasThreeConsecutiveOdds (arr: int list) =", "docstring": "\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    \n\n* Incomplete Code:\nlet hasThreeConsecutiveOdds (arr: int list) =\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n         [MASK]<> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n         [MASK]<> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0"}
{"task_id": "F#/21-0-span", "prompt": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n(*\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n*)", "canonical_solution": "    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateSwimmingTime", "signature": "let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =", "docstring": "\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n\n\n* Incomplete Code:\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endM[MASK]s)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endM[MASK]s)"}
{"task_id": "F#/21-1-span", "prompt": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n(*\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n*)", "canonical_solution": "    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateSwimmingTime", "signature": "let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =", "docstring": "\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n\n\n* Incomplete Code:\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n    let start = new TimeSpan[MASK] = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let start = new TimeSpan[MASK] = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)"}
{"task_id": "F#/22-0-span", "prompt": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n(*\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n*)", "canonical_solution": "    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "test": "let check () =\n    if reorderNumbers [1; 3; 5] \"ABC\" <> \"1 3 5\" then\n        failwith \"Test Case 1 failed\"\n    if reorderNumbers [6; 2; 4] \"BCA\" <> \"4 6 2\" then\n        failwith \"Test Case 2 failed\"\n    if reorderNumbers [8; 10; 9] \"CAB\" <> \"10 8 9\" then\n        failwith \"Test Case 3 failed\"\n    if reorderNumbers [15; 20; 17] \"ACB\" <> \"15 20 17\" then\n        failwith \"Test Case 4 failed\"\n    if reorderNumbers [21; 19; 23] \"BAC\" <> \"21 19 23\" then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "reorderNumbers", "signature": "let reorderNumbers (nums: int list) (order: string) =", "docstring": "\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n\n\n* Incomplete Code:\nlet reorderNumbers (nums: int list) (order: string) =\n    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    St[MASK]map (fun c -> mapping.[c].ToString()))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    St[MASK]map (fun c -> mapping.[c].ToString()))"}
{"task_id": "F#/22-1-span", "prompt": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n(*\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n*)", "canonical_solution": "    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "test": "let check () =\n    if reorderNumbers [1; 3; 5] \"ABC\" <> \"1 3 5\" then\n        failwith \"Test Case 1 failed\"\n    if reorderNumbers [6; 2; 4] \"BCA\" <> \"4 6 2\" then\n        failwith \"Test Case 2 failed\"\n    if reorderNumbers [8; 10; 9] \"CAB\" <> \"10 8 9\" then\n        failwith \"Test Case 3 failed\"\n    if reorderNumbers [15; 20; 17] \"ACB\" <> \"15 20 17\" then\n        failwith \"Test Case 4 failed\"\n    if reorderNumbers [21; 19; 23] \"BAC\" <> \"21 19 23\" then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "reorderNumbers", "signature": "let reorderNumbers (nums: int list) (order: string) =", "docstring": "\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n\n\n* Incomplete Code:\nlet reorderNumbers (nums: int list) (order: string) =\n    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A',[MASK]; ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A',[MASK]; ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))"}
{"task_id": "F#/23-0-span", "prompt": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n(*\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n*)", "canonical_solution": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "mostUnhappyDay", "signature": "let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =", "docstring": "\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n\n\n* Incomplete Code:\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUn[MASK]ex + 1\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUn[MASK]ex + 1"}
{"task_id": "F#/23-1-span", "prompt": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n(*\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n*)", "canonical_solution": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "mostUnhappyDay", "signature": "let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =", "docstring": "\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n\n\n* Incomplete Code:\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = ma[MASK]x + 1\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = ma[MASK]x + 1"}
{"task_id": "F#/24-0-span", "prompt": "open System\n\nlet findLargerPrimeFactor (n: int) =\n(*\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n*)", "canonical_solution": "    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "test": "let testFindLargerPrimeFactor () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ntestFindLargerPrimeFactor ()", "entry_point": "findLargerPrimeFactor", "signature": "let findLargerPrimeFactor (n: int) =", "docstring": "\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n\n\n* Incomplete Code:\nlet findLargerPrimeFactor (n: int) =\n    let rec findFactor i =\n        i[MASK]f n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec findFactor i =\n        i[MASK]f n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2"}
{"task_id": "F#/24-1-span", "prompt": "open System\n\nlet findLargerPrimeFactor (n: int) =\n(*\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n*)", "canonical_solution": "    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "test": "let testFindLargerPrimeFactor () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ntestFindLargerPrimeFactor ()", "entry_point": "findLargerPrimeFactor", "signature": "let findLargerPrimeFactor (n: int) =", "docstring": "\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n\n\n* Incomplete Code:\nlet findLargerPrimeFactor (n: int) =\n    let rec findFactor i[MASK]if n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec findFactor i[MASK]if n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2"}
{"task_id": "F#/25-0-span", "prompt": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  (*\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  *)", "canonical_solution": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "longestConsecutiveSequence", "signature": "let longestConsecutiveSequence (numbers: int list) =", "docstring": "\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  \n\n* Incomplete Code:\nlet longestConsecutiveSequence (numbers: int list) =\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                w[MASK]len <- len + 1\n                max maxLen len) 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                w[MASK]len <- len + 1\n                max maxLen len) 0"}
{"task_id": "F#/25-1-span", "prompt": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  (*\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  *)", "canonical_solution": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "longestConsecutiveSequence", "signature": "let longestConsecutiveSequence (numbers: int list) =", "docstring": "\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  \n\n* Incomplete Code:\nlet longestConsecutiveSequence (numbers: int list) =\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fo[MASK]numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fo[MASK]numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0"}
{"task_id": "F#/26-0-span", "prompt": "open System\nlet reverseDigits (n: int) =\n(*\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n*)", "canonical_solution": "    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "test": "let testReverseDigits () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ntestReverseDigits ()", "entry_point": "reverseDigits", "signature": "let reverseDigits (n: int) =", "docstring": "\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n\n\n* Incomplete Code:\nlet reverseDigits (n: int) =\n    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toA[MASK]if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toA[MASK]if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt"}
{"task_id": "F#/26-1-span", "prompt": "open System\nlet reverseDigits (n: int) =\n(*\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n*)", "canonical_solution": "    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "test": "let testReverseDigits () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ntestReverseDigits ()", "entry_point": "reverseDigits", "signature": "let reverseDigits (n: int) =", "docstring": "\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n\n\n* Incomplete Code:\nlet reverseDigits (n: int) =\n    let reversedStr =\n        string n\n        |> Seq.r[MASK]reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let reversedStr =\n        string n\n        |> Seq.r[MASK]reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt"}
{"task_id": "F#/27-0-span", "prompt": "open System\nlet rec calculateBessieScore (n: int) : int =\n(*\n    This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n*)", "canonical_solution": "    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n    | _ -> 1 + calculateBessieScore (3 * n + 1)", "test": "let test () =\n    if calculateBessieScore 6 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if calculateBessieScore 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if calculateBessieScore 7 <> 16 then\n        failwith \"Test Case 3 failed\"\n    if calculateBessieScore 15 <> 17 then\n        failwith \"Test Case 4 failed\"\n    if calculateBessieScore 22 <> 15 then\n        failwith \"Test Case 5 failed\"\n    if calculateBessieScore 2 <> 1 then\n        failwith \"Test Case 6 failed\"\n    if calculateBessieScore 10 <> 6 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "signature": "let rec calculateBessieScore (n: int) : int =", "docstring": "This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)", "entry_point": "calculateBessieScore", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n\n* Incomplete Code:\nlet rec calculateBessieScore (n: int) : int =\n    match n with\n[MASK] + calculateBessieScore (3 * n + 1)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    match n with\n[MASK] + calculateBessieScore (3 * n + 1)"}
{"task_id": "F#/27-1-span", "prompt": "open System\nlet rec calculateBessieScore (n: int) : int =\n(*\n    This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n*)", "canonical_solution": "    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n    | _ -> 1 + calculateBessieScore (3 * n + 1)", "test": "let test () =\n    if calculateBessieScore 6 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if calculateBessieScore 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if calculateBessieScore 7 <> 16 then\n        failwith \"Test Case 3 failed\"\n    if calculateBessieScore 15 <> 17 then\n        failwith \"Test Case 4 failed\"\n    if calculateBessieScore 22 <> 15 then\n        failwith \"Test Case 5 failed\"\n    if calculateBessieScore 2 <> 1 then\n        failwith \"Test Case 6 failed\"\n    if calculateBessieScore 10 <> 6 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "signature": "let rec calculateBessieScore (n: int) : int =", "docstring": "This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)", "entry_point": "calculateBessieScore", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n\n* Incomplete Code:\nlet rec calculateBessieScore (n: int) : int =\n    match n with\n    | [MASK]alculateBessieScore (3 * n + 1)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    match n with\n    | [MASK]alculateBessieScore (3 * n + 1)"}
{"task_id": "F#/28-0-span", "prompt": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n(*\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n*)", "canonical_solution": "    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed", "test": "let test () =\n    if calculateAvailableData 10 3 [4; 6; 2] <> 28 then\n        failwith \"Test Case 1 failed\"\n    if calculateAvailableData 15 2 [10; 12] <> 23 then\n        failwith \"Test Case 2 failed\"\n    if calculateAvailableData 12 4 [3; 6; 9; 4] <> 38 then\n        failwith \"Test Case 3 failed\"\n    if calculateAvailableData 10 2 [5; 5; 5] <> 15 then\n        failwith \"Test Case 4 failed\"\n    if calculateAvailableData 20 1 [15] <> 25 then\n        failwith \"Test Case 5 failed\"\n    if calculateAvailableData 8 3 [2; 4; 3] <> 23 then\n        failwith \"Test Case 6 failed\"\n    if calculateAvailableData 5 0 [] <> 5 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "calculateAvailableData", "signature": "let calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =", "docstring": "\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n\n\n* Incomplete Code:\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n    let total[MASK] * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let total[MASK] * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed"}
{"task_id": "F#/28-1-span", "prompt": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n(*\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n*)", "canonical_solution": "    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed", "test": "let test () =\n    if calculateAvailableData 10 3 [4; 6; 2] <> 28 then\n        failwith \"Test Case 1 failed\"\n    if calculateAvailableData 15 2 [10; 12] <> 23 then\n        failwith \"Test Case 2 failed\"\n    if calculateAvailableData 12 4 [3; 6; 9; 4] <> 38 then\n        failwith \"Test Case 3 failed\"\n    if calculateAvailableData 10 2 [5; 5; 5] <> 15 then\n        failwith \"Test Case 4 failed\"\n    if calculateAvailableData 20 1 [15] <> 25 then\n        failwith \"Test Case 5 failed\"\n    if calculateAvailableData 8 3 [2; 4; 3] <> 23 then\n        failwith \"Test Case 6 failed\"\n    if calculateAvailableData 5 0 [] <> 5 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "calculateAvailableData", "signature": "let calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =", "docstring": "\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n\n\n* Incomplete Code:\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQu[MASK]lUsed\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQu[MASK]lUsed"}
{"task_id": "F#/29-0-span", "prompt": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n(*\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n*)", "canonical_solution": "    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )", "test": "let check () =\n    let test1 = canMatchFit 3 3 4 [2; 5; 6]\n    let expected1 = [\"DA\"; \"DA\"; \"NE\"]\n    if test1 <> expected1 then\n        failwith \"Test Case 1 failed\"\n\n    let test2 = canMatchFit 2 5 5 [7; 3]\n    let expected2 = [\"DA\"; \"DA\"]\n    if test2 <> expected2 then\n        failwith \"Test Case 2 failed\"\n\n    let test3 = canMatchFit 4 10 10 [5; 12; 8; 15]\n    let expected3 = [\"DA\"; \"DA\"; \"DA\"; \"NE\"]\n    if test3 <> expected3 then\n        failwith \"Test Case 3 failed\"\n\n    let test4 = canMatchFit 3 6 8 [10; 6; 7]\n    let expected4 = [\"DA\"; \"DA\"; \"DA\"]\n    if test4 <> expected4 then\n        failwith \"Test Case 4 failed\"\n\n    printfn \"All tests passed!\"\n\ncheck ()", "entry_point": "canMatchFit", "signature": "let canMatchFit (n: int) (w: int) (h: int) (matches: int list) =", "docstring": "\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n\n\n* Incomplete Code:\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLen[MASK]A\" else \"NE\"\n    )\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLen[MASK]A\" else \"NE\"\n    )"}
{"task_id": "F#/29-1-span", "prompt": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n(*\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n*)", "canonical_solution": "    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )", "test": "let check () =\n    let test1 = canMatchFit 3 3 4 [2; 5; 6]\n    let expected1 = [\"DA\"; \"DA\"; \"NE\"]\n    if test1 <> expected1 then\n        failwith \"Test Case 1 failed\"\n\n    let test2 = canMatchFit 2 5 5 [7; 3]\n    let expected2 = [\"DA\"; \"DA\"]\n    if test2 <> expected2 then\n        failwith \"Test Case 2 failed\"\n\n    let test3 = canMatchFit 4 10 10 [5; 12; 8; 15]\n    let expected3 = [\"DA\"; \"DA\"; \"DA\"; \"NE\"]\n    if test3 <> expected3 then\n        failwith \"Test Case 3 failed\"\n\n    let test4 = canMatchFit 3 6 8 [10; 6; 7]\n    let expected4 = [\"DA\"; \"DA\"; \"DA\"]\n    if test4 <> expected4 then\n        failwith \"Test Case 4 failed\"\n\n    printfn \"All tests passed!\"\n\ncheck ()", "entry_point": "canMatchFit", "signature": "let canMatchFit (n: int) (w: int) (h: int) (matches: int list) =", "docstring": "\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n\n\n* Incomplete Code:\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n    let diagonal = Math.Sqrt(float(w * w + h * h))\n   [MASK]map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let diagonal = Math.Sqrt(float(w * w + h * h))\n   [MASK]map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )"}
{"task_id": "F#/30-0-span", "prompt": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n(*\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n*)", "canonical_solution": "    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "findFourthVertex", "signature": "let findFourthVertex (coordinates: (int * int) list) : int * int =", "docstring": "\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n\n\n* Incomplete Code:\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Inval[MASK] = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Inval[MASK] = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)"}
{"task_id": "F#/30-1-span", "prompt": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n(*\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n*)", "canonical_solution": "    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "findFourthVertex", "signature": "let findFourthVertex (coordinates: (int * int) list) : int * int =", "docstring": "\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n\n\n* Incomplete Code:\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n    let (xList, yList) = List.unzip coordinates\n    let fi[MASK]  let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let (xList, yList) = List.unzip coordinates\n    let fi[MASK]  let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)"}
{"task_id": "F#/31-0-span", "prompt": "open System\n\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n(*\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n*)", "canonical_solution": "    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n    let totalMinutes = timeToSchool + 10 // Additional 10 minutes for garbage sorting\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")", "test": "let check () =\n    if calculateDepartureTime 500 50 <> \"07:40\" then\n        failwith \"Test Case 1 failed\"\n    if calculateDepartureTime 300 30 <> \"07:40\" then\n        failwith \"Test Case 2 failed\"\n    if calculateDepartureTime 600 60 <> \"07:40\" then\n        failwith \"Test Case 3 failed\"\n    if calculateDepartureTime 720 80 <> \"07:41\" then\n        failwith \"Test Case 4 failed\"\n    if calculateDepartureTime 100 10 <> \"07:40\" then\n        failwith \"Test Case 5 failed\"\n    if calculateDepartureTime 1000 100 <> \"07:40\" then\n        failwith \"Test Case 6 failed\"\n    if calculateDepartureTime 150 25 <> \"07:44\" then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateDepartureTime", "signature": "let calculateDepartureTime (distance: int) (speed: int) : string =", "docstring": "\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n\n\n* Incomplete Code:\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n    let timeToSchool = (distan[MASK] 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let timeToSchool = (distan[MASK] 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")"}
{"task_id": "F#/31-1-span", "prompt": "open System\n\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n(*\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n*)", "canonical_solution": "    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n    let totalMinutes = timeToSchool + 10 // Additional 10 minutes for garbage sorting\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")", "test": "let check () =\n    if calculateDepartureTime 500 50 <> \"07:40\" then\n        failwith \"Test Case 1 failed\"\n    if calculateDepartureTime 300 30 <> \"07:40\" then\n        failwith \"Test Case 2 failed\"\n    if calculateDepartureTime 600 60 <> \"07:40\" then\n        failwith \"Test Case 3 failed\"\n    if calculateDepartureTime 720 80 <> \"07:41\" then\n        failwith \"Test Case 4 failed\"\n    if calculateDepartureTime 100 10 <> \"07:40\" then\n        failwith \"Test Case 5 failed\"\n    if calculateDepartureTime 1000 100 <> \"07:40\" then\n        failwith \"Test Case 6 failed\"\n    if calculateDepartureTime 150 25 <> \"07:44\" then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateDepartureTime", "signature": "let calculateDepartureTime (distance: int) (speed: int) : string =", "docstring": "\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n\n\n* Incomplete Code:\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n    let totalMinutes = timeToSchool + 10 // A[MASK]ddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n    let totalMinutes = timeToSchool + 10 // A[MASK]ddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")"}
{"task_id": "F#/32-0-span", "prompt": "open System\nlet validateISBN (isbnInput: string) : string =\n(*\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n*)", "canonical_solution": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actualCheckDigitChar = isbnInput.[isbnInput.Length - 1]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()", "test": "let checkISBNValidation () =\n    assert (validateISBN(\"0-670-82162-4\") = \"Right\")\n    assert (validateISBN(\"0-123-45678-9\") = \"Right\")\n    assert (validateISBN(\"0-670-82162-0\") = \"0-670-82162-4\")\n    assert (validateISBN(\"1-234-56789-5\") = \"1-234-56789-X\")\n    assert (validateISBN(\"9-876-54321-1\") = \"9-876-54321-0\")\n    assert (validateISBN(\"5-555-55555-5\") = \"Right\")\n\ncheckISBNValidation()", "entry_point": "validateISBN", "signature": "let validateISBN (isbnInput: string) : string =", "docstring": "\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n\n\n* Incomplete Code:\nlet validateISBN (isbnInput: string) : string =\n    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar [MASK]  if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar [MASK]  if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()"}
{"task_id": "F#/32-1-span", "prompt": "open System\nlet validateISBN (isbnInput: string) : string =\n(*\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n*)", "canonical_solution": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actualCheckDigitChar = isbnInput.[isbnInput.Length - 1]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()", "test": "let checkISBNValidation () =\n    assert (validateISBN(\"0-670-82162-4\") = \"Right\")\n    assert (validateISBN(\"0-123-45678-9\") = \"Right\")\n    assert (validateISBN(\"0-670-82162-0\") = \"0-670-82162-4\")\n    assert (validateISBN(\"1-234-56789-5\") = \"1-234-56789-X\")\n    assert (validateISBN(\"9-876-54321-1\") = \"9-876-54321-0\")\n    assert (validateISBN(\"5-555-55555-5\") = \"Right\")\n\ncheckISBNValidation()", "entry_point": "validateISBN", "signature": "let validateISBN (isbnInput: string) : string =", "docstring": "\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n\n\n* Incomplete Code:\nlet validateISBN (isbnInput: string) : string =\n    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actu[MASK]put.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actu[MASK]put.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()"}
{"task_id": "F#/33-0-span", "prompt": "open System\nlet calculateFinalScore (scores: int list) =\n(*\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n*)", "canonical_solution": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "test": "let testCalculateFinalScore () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ntestCalculateFinalScore ()", "entry_point": "calculateFinalScore", "signature": "let calculateFinalScore (scores: int list) =", "docstring": "\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n\n\n* Incomplete Code:\nlet calculateFinalScore (scores: int list) =\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trim[MASK]nd(average, 2)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trim[MASK]nd(average, 2)"}
{"task_id": "F#/33-1-span", "prompt": "open System\nlet calculateFinalScore (scores: int list) =\n(*\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n*)", "canonical_solution": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "test": "let testCalculateFinalScore () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ntestCalculateFinalScore ()", "entry_point": "calculateFinalScore", "signature": "let calculateFinalScore (scores: int list) =", "docstring": "\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n\n\n* Incomplete Code:\nlet calculateFinalScore (scores: int list) =\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float s[MASK]d(average, 2)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float s[MASK]d(average, 2)"}
{"task_id": "F#/34-0-span", "prompt": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    (*\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    *)", "canonical_solution": "    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "finalPosition", "signature": "let finalPosition (commands: string) (time: int) : (int * int) =", "docstring": "\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    \n\n* Incomplete Code:\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    let move (x, y) (command: char) =\n        match[MASK]ime: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let move (x, y) (command: char) =\n        match[MASK]ime: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time"}
{"task_id": "F#/34-1-span", "prompt": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    (*\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    *)", "canonical_solution": "    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "finalPosition", "signature": "let finalPosition (commands: string) (time: int) : (int * int) =", "docstring": "\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    \n\n* Incomplete Code:\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    let move (x, y) (command: char) =\n        match command with\n        | 'E'[MASK](x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let move (x, y) (command: char) =\n        match command with\n        | 'E'[MASK](x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time"}
{"task_id": "F#/35-0-span", "prompt": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n(*\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n*)", "canonical_solution": "    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "test": "let test () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ntest ()", "entry_point": "maxGroupedKnapsackValue", "signature": "let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =", "docstring": "\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n\n\n* Incomplete Code:\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n [MASK]for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n [MASK]for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])"}
{"task_id": "F#/35-1-span", "prompt": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n(*\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n*)", "canonical_solution": "    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "test": "let test () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ntest ()", "entry_point": "maxGroupedKnapsackValue", "signature": "let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =", "docstring": "\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n\n\n* Incomplete Code:\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n    let groups = items |> List.map (fun (_, _, g) [MASK]otalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let groups = items |> List.map (fun (_, _, g) [MASK]otalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])"}
{"task_id": "F#/36-0-span", "prompt": "open System\nlet hanoiTowerSteps (n: int) =\n(*\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n*)", "canonical_solution": "    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"", "test": "let checkHanoi () =\n    if hanoiTowerSteps 1 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if hanoiTowerSteps 3 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if hanoiTowerSteps 4 <> 15 then\n        failwith \"Test Case 3 failed\"\n    if hanoiTowerSteps 5 <> 31 then\n        failwith \"Test Case 4 failed\"\n    if hanoiTowerSteps 6 <> 63 then\n        failwith \"Test Case 5 failed\"\n    if hanoiTowerSteps 10 <> 1023 then\n        failwith \"Test Case 6 failed\"\n    if hanoiTowerSteps 0 <> 0 then\n        failwith \"Test Case 7 failed\"\n\ncheckHanoi ()", "entry_point": "hanoiTowerSteps", "signature": "let hanoiTowerSteps (n: int) =", "docstring": "\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n\n\n* Incomplete Code:\nlet hanoiTowerSteps (n: int) =\n    l[MASK] 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    l[MASK] 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\""}
{"task_id": "F#/36-1-span", "prompt": "open System\nlet hanoiTowerSteps (n: int) =\n(*\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n*)", "canonical_solution": "    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"", "test": "let checkHanoi () =\n    if hanoiTowerSteps 1 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if hanoiTowerSteps 3 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if hanoiTowerSteps 4 <> 15 then\n        failwith \"Test Case 3 failed\"\n    if hanoiTowerSteps 5 <> 31 then\n        failwith \"Test Case 4 failed\"\n    if hanoiTowerSteps 6 <> 63 then\n        failwith \"Test Case 5 failed\"\n    if hanoiTowerSteps 10 <> 1023 then\n        failwith \"Test Case 6 failed\"\n    if hanoiTowerSteps 0 <> 0 then\n        failwith \"Test Case 7 failed\"\n\ncheckHanoi ()", "entry_point": "hanoiTowerSteps", "signature": "let hanoiTowerSteps (n: int) =", "docstring": "\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n\n\n* Incomplete Code:\nlet hanoiTowerSteps (n: int) =\n    let rec solveHanoi n a b c [MASK]lveHanoi n \"A\" \"B\" \"C\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec solveHanoi n a b c [MASK]lveHanoi n \"A\" \"B\" \"C\""}
{"task_id": "F#/37-0-span", "prompt": "open System\n\nlet maxContests (contests: (int * int) list) =\n(*\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n*)", "canonical_solution": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maxContests", "signature": "let maxContests (contests: (int * int) list) =", "docstring": "\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n\n\n* Incomplete Code:\nlet maxContests (contests: (int * int) list) =\n    let sortedContests = List.sortBy snd contes[MASK] [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedContests = List.sortBy snd contes[MASK] [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0"}
{"task_id": "F#/37-1-span", "prompt": "open System\n\nlet maxContests (contests: (int * int) list) =\n(*\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n*)", "canonical_solution": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maxContests", "signature": "let maxContests (contests: (int * int) list) =", "docstring": "\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n\n\n* Incomplete Code:\nlet maxContests (contests: (int * int) list) =\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tai[MASK]s Int32.MinValue sortedContests 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tai[MASK]s Int32.MinValue sortedContests 0"}
{"task_id": "F#/38-0-span", "prompt": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n(*\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n*)", "canonical_solution": "    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "test": "let testCountWordClasses () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ntestCountWordClasses ()", "entry_point": "countWordClasses", "signature": "let countWordClasses (words: string list) =", "docstring": "\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n\n\n* Incomplete Code:\nlet countWordClasses (words: string list) =\n    let getLetterFrequency word =\n        w[MASK]   |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let getLetterFrequency word =\n        w[MASK]   |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count"}
{"task_id": "F#/38-1-span", "prompt": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n(*\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n*)", "canonical_solution": "    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "test": "let testCountWordClasses () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ntestCountWordClasses ()", "entry_point": "countWordClasses", "signature": "let countWordClasses (words: string list) =", "docstring": "\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n\n\n* Incomplete Code:\nlet countWordClasses (words: string list) =\n    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n [MASK]> Set.count\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n [MASK]> Set.count"}
{"task_id": "F#/39-0-span", "prompt": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n(*\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n*)", "canonical_solution": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maximumMinimumDistance", "signature": "let maximumMinimumDistance (stalls: int list) (cows: int) : int =", "docstring": "\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n\n\n* Incomplete Code:\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            [MASK]arySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            [MASK]arySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)"}
{"task_id": "F#/39-1-span", "prompt": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n(*\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n*)", "canonical_solution": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maximumMinimumDistance", "signature": "let maximumMinimumDistance (stalls: int list) (cows: int) : int =", "docstring": "\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n\n\n* Incomplete Code:\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n        [MASK]) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n        [MASK]) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)"}
{"task_id": "F#/40-0-span", "prompt": "let maxPens (a: int) (b: int): int =\n(*\n    This function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \n    Each pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\n    It is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\n    Example:\n    >>> maxPens 20 5\n    10\n\n    >>> maxPens 0 9\n    0\n\n    Note: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n*)", "canonical_solution": "    let totalJiao = a * 10 + b\n    let pricePerPenJiao = 19\n    totalJiao / pricePerPenJiao", "test": "let check () =\n    if maxPens 20 5 <> 10 then\n        failwith \"Test Case 1 failed\"\n    if maxPens 0 9 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if maxPens 3 1 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if maxPens 57 0 <> 30 then\n        failwith \"Test Case 4 failed\"\n\ncheck ()", "entry_point": "maxPens", "signature": "let maxPens (a: int) (b: int): int =", "docstring": "\nThis function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \nEach pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\nIt is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\nExample:\n>>> maxPens 20 5\n10\n\n>>> maxPens 0 9\n0\n\nNote: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \nEach pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\nIt is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\nExample:\n>>> maxPens 20 5\n10\n\n>>> maxPens 0 9\n0\n\nNote: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n\n\n* Incomplete Code:\nlet maxPens (a: int) (b: int): int =\n    let totalJiao = a * 10 + b\n    let p[MASK]iao = 19\n    totalJiao / pricePerPenJiao\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let totalJiao = a * 10 + b\n    let p[MASK]iao = 19\n    totalJiao / pricePerPenJiao"}
{"task_id": "F#/40-1-span", "prompt": "let maxPens (a: int) (b: int): int =\n(*\n    This function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \n    Each pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\n    It is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\n    Example:\n    >>> maxPens 20 5\n    10\n\n    >>> maxPens 0 9\n    0\n\n    Note: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n*)", "canonical_solution": "    let totalJiao = a * 10 + b\n    let pricePerPenJiao = 19\n    totalJiao / pricePerPenJiao", "test": "let check () =\n    if maxPens 20 5 <> 10 then\n        failwith \"Test Case 1 failed\"\n    if maxPens 0 9 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if maxPens 3 1 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if maxPens 57 0 <> 30 then\n        failwith \"Test Case 4 failed\"\n\ncheck ()", "entry_point": "maxPens", "signature": "let maxPens (a: int) (b: int): int =", "docstring": "\nThis function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \nEach pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\nIt is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\nExample:\n>>> maxPens 20 5\n10\n\n>>> maxPens 0 9\n0\n\nNote: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \nEach pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\nIt is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\nExample:\n>>> maxPens 20 5\n10\n\n>>> maxPens 0 9\n0\n\nNote: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n\n\n* Incomplete Code:\nlet maxPens (a: int) (b: int): int =\n    let totalJiao = a * 10 + b\n   [MASK]erPenJiao = 19\n    totalJiao / pricePerPenJiao\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let totalJiao = a * 10 + b\n   [MASK]erPenJiao = 19\n    totalJiao / pricePerPenJiao"}
{"task_id": "F#/41-0-span", "prompt": "let calculateExpression (a: int) (b: int) (c: int): int =\n(*\n    This function calculates the value of the expression (a + b) * c given three integers a, b, and c.\n    It is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\n    Example:\n    >>> calculateExpression 1 2 3\n    9\n\n    >>> calculateExpression -1 2 -3\n    -3\n\n    Note: The function performs simple arithmetic operations and handles negative numbers correctly.\n*)", "canonical_solution": "    (a + b) * c", "test": "\nlet check () =\n    if calculateExpression 1 2 3 <> 9 then\n        failwith \"Test Case 1 failed\"\n    if calculateExpression -1 2 -3 <> -3 then\n        failwith \"Test Case 2 failed\"\n    if calculateExpression 0 0 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if calculateExpression 100 -50 2 <> 100 then\n        failwith \"Test Case 4 failed\"\n    if calculateExpression -100 50 -2 <> 100 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "calculateExpression", "signature": "let calculateExpression (a: int) (b: int) (c: int): int =", "docstring": "\nThis function calculates the value of the expression (a + b) * c given three integers a, b, and c.\nIt is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\nExample:\n>>> calculateExpression 1 2 3\n9\n\n>>> calculateExpression -1 2 -3\n-3\n\nNote: The function performs simple arithmetic operations and handles negative numbers correctly.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the value of the expression (a + b) * c given three integers a, b, and c.\nIt is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\nExample:\n>>> calculateExpression 1 2 3\n9\n\n>>> calculateExpression -1 2 -3\n-3\n\nNote: The function performs simple arithmetic operations and handles negative numbers correctly.\n\n\n* Incomplete Code:\nlet calculateExpression (a: int) (b: int) (c: int): int =\n  [MASK] b) * c\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "  [MASK] b) * c"}
{"task_id": "F#/41-1-span", "prompt": "let calculateExpression (a: int) (b: int) (c: int): int =\n(*\n    This function calculates the value of the expression (a + b) * c given three integers a, b, and c.\n    It is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\n    Example:\n    >>> calculateExpression 1 2 3\n    9\n\n    >>> calculateExpression -1 2 -3\n    -3\n\n    Note: The function performs simple arithmetic operations and handles negative numbers correctly.\n*)", "canonical_solution": "    (a + b) * c", "test": "\nlet check () =\n    if calculateExpression 1 2 3 <> 9 then\n        failwith \"Test Case 1 failed\"\n    if calculateExpression -1 2 -3 <> -3 then\n        failwith \"Test Case 2 failed\"\n    if calculateExpression 0 0 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if calculateExpression 100 -50 2 <> 100 then\n        failwith \"Test Case 4 failed\"\n    if calculateExpression -100 50 -2 <> 100 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "calculateExpression", "signature": "let calculateExpression (a: int) (b: int) (c: int): int =", "docstring": "\nThis function calculates the value of the expression (a + b) * c given three integers a, b, and c.\nIt is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\nExample:\n>>> calculateExpression 1 2 3\n9\n\n>>> calculateExpression -1 2 -3\n-3\n\nNote: The function performs simple arithmetic operations and handles negative numbers correctly.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the value of the expression (a + b) * c given three integers a, b, and c.\nIt is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\nExample:\n>>> calculateExpression 1 2 3\n9\n\n>>> calculateExpression -1 2 -3\n-3\n\nNote: The function performs simple arithmetic operations and handles negative numbers correctly.\n\n\n* Incomplete Code:\nlet calculateExpression (a: int) (b: int) (c: int): int =\n   [MASK]b) * c\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK]b) * c"}
{"task_id": "F#/42-0-span", "prompt": "let getAsciiCode (character: char): int =\n(*\n    This function receives a character (excluding spaces) and returns its ASCII code as an integer.\n    The character must be a visible character according to the ASCII standard, excluding control characters and space.\n\n    Example:\n    >>> getAsciiCode 'B'\n    66\n\n    >>> getAsciiCode '#'\n    35\n\n    Note: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n*)", "canonical_solution": "    int character", "test": "let check () =\n    if getAsciiCode 'B' <> 66 then\n        failwith \"Test Case 1 failed\"\n    if getAsciiCode '#' <> 35 then\n        failwith \"Test Case 2 failed\"\n    if getAsciiCode '0' <> 48 then\n        failwith \"Test Case 3 failed\"\n    if getAsciiCode '9' <> 57 then\n        failwith \"Test Case 4 failed\"\n    if getAsciiCode 'a' <> 97 then\n        failwith \"Test Case 5 failed\"\n    if getAsciiCode 'z' <> 122 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "getAsciiCode", "signature": "let getAsciiCode (character: char): int =", "docstring": "\nThis function receives a character (excluding spaces) and returns its ASCII code as an integer.\nThe character must be a visible character according to the ASCII standard, excluding control characters and space.\n\nExample:\n>>> getAsciiCode 'B'\n66\n\n>>> getAsciiCode '#'\n35\n\nNote: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function receives a character (excluding spaces) and returns its ASCII code as an integer.\nThe character must be a visible character according to the ASCII standard, excluding control characters and space.\n\nExample:\n>>> getAsciiCode 'B'\n66\n\n>>> getAsciiCode '#'\n35\n\nNote: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n\n\n* Incomplete Code:\nlet getAsciiCode (character: char): int =\n    i[MASK]racter\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    i[MASK]racter"}
{"task_id": "F#/42-1-span", "prompt": "let getAsciiCode (character: char): int =\n(*\n    This function receives a character (excluding spaces) and returns its ASCII code as an integer.\n    The character must be a visible character according to the ASCII standard, excluding control characters and space.\n\n    Example:\n    >>> getAsciiCode 'B'\n    66\n\n    >>> getAsciiCode '#'\n    35\n\n    Note: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n*)", "canonical_solution": "    int character", "test": "let check () =\n    if getAsciiCode 'B' <> 66 then\n        failwith \"Test Case 1 failed\"\n    if getAsciiCode '#' <> 35 then\n        failwith \"Test Case 2 failed\"\n    if getAsciiCode '0' <> 48 then\n        failwith \"Test Case 3 failed\"\n    if getAsciiCode '9' <> 57 then\n        failwith \"Test Case 4 failed\"\n    if getAsciiCode 'a' <> 97 then\n        failwith \"Test Case 5 failed\"\n    if getAsciiCode 'z' <> 122 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "getAsciiCode", "signature": "let getAsciiCode (character: char): int =", "docstring": "\nThis function receives a character (excluding spaces) and returns its ASCII code as an integer.\nThe character must be a visible character according to the ASCII standard, excluding control characters and space.\n\nExample:\n>>> getAsciiCode 'B'\n66\n\n>>> getAsciiCode '#'\n35\n\nNote: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function receives a character (excluding spaces) and returns its ASCII code as an integer.\nThe character must be a visible character according to the ASCII standard, excluding control characters and space.\n\nExample:\n>>> getAsciiCode 'B'\n66\n\n>>> getAsciiCode '#'\n35\n\nNote: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n\n\n* Incomplete Code:\nlet getAsciiCode (character: char): int =\n   [MASK]haracter\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK]haracter"}
{"task_id": "F#/43-0-span", "prompt": "let asciiToChar (asciiCode: int): char =\n(*\n    This function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\n    Example:\n    >>> asciiToChar 66\n    'B'\n\n    >>> asciiToChar 35\n    '#'\n\n    Note: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n*)", "canonical_solution": "    char asciiCode", "test": "let check () =\n    if asciiToChar 66 <> 'B' then\n        failwith \"Test Case 1 failed\"\n    if asciiToChar 35 <> '#' then\n        failwith \"Test Case 2 failed\"\n    if asciiToChar 48 <> '0' then\n        failwith \"Test Case 3 failed\"\n    if asciiToChar 57 <> '9' then\n        failwith \"Test Case 4 failed\"\n    if asciiToChar 97 <> 'a' then\n        failwith \"Test Case 5 failed\"\n    if asciiToChar 122 <> 'z' then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "asciiToChar", "signature": "let asciiToChar (asciiCode: int): char =", "docstring": "\nThis function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\nExample:\n>>> asciiToChar 66\n'B'\n\n>>> asciiToChar 35\n'#'\n\nNote: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\nExample:\n>>> asciiToChar 66\n'B'\n\n>>> asciiToChar 35\n'#'\n\nNote: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n\n\n* Incomplete Code:\nlet asciiToChar (asciiCode: int): char =\n    char[MASK]ode\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    char[MASK]ode"}
{"task_id": "F#/43-1-span", "prompt": "let asciiToChar (asciiCode: int): char =\n(*\n    This function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\n    Example:\n    >>> asciiToChar 66\n    'B'\n\n    >>> asciiToChar 35\n    '#'\n\n    Note: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n*)", "canonical_solution": "    char asciiCode", "test": "let check () =\n    if asciiToChar 66 <> 'B' then\n        failwith \"Test Case 1 failed\"\n    if asciiToChar 35 <> '#' then\n        failwith \"Test Case 2 failed\"\n    if asciiToChar 48 <> '0' then\n        failwith \"Test Case 3 failed\"\n    if asciiToChar 57 <> '9' then\n        failwith \"Test Case 4 failed\"\n    if asciiToChar 97 <> 'a' then\n        failwith \"Test Case 5 failed\"\n    if asciiToChar 122 <> 'z' then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "asciiToChar", "signature": "let asciiToChar (asciiCode: int): char =", "docstring": "\nThis function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\nExample:\n>>> asciiToChar 66\n'B'\n\n>>> asciiToChar 35\n'#'\n\nNote: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\nExample:\n>>> asciiToChar 66\n'B'\n\n>>> asciiToChar 35\n'#'\n\nNote: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n\n\n* Incomplete Code:\nlet asciiToChar (asciiCode: int): char =\n    cha[MASK]Code\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    cha[MASK]Code"}
{"task_id": "F#/44-0-span", "prompt": "let intBoolIntConversion (intValue: int): int =\n(*\n    This function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\n    Example:\n    >>> intBoolIntConversion 5\n    1\n\n    >>> intBoolIntConversion 0\n    0\n\n    Note: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n*)", "canonical_solution": "    if intValue = 0 then 0 else 1", "test": "let check () =\n    if intBoolIntConversion 5 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if intBoolIntConversion 0 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if intBoolIntConversion -1 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if intBoolIntConversion 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if intBoolIntConversion 127 <> 1 then\n        failwith \"Test Case 5 failed\"\n    if intBoolIntConversion -127 <> 1 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "intBoolIntConversion", "signature": "let intBoolIntConversion (intValue: int): int =", "docstring": "\nThis function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\nExample:\n>>> intBoolIntConversion 5\n1\n\n>>> intBoolIntConversion 0\n0\n\nNote: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\nExample:\n>>> intBoolIntConversion 5\n1\n\n>>> intBoolIntConversion 0\n0\n\nNote: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n\n\n* Incomplete Code:\nlet intBoolIntConversion (intValue: int): int =\n    [MASK] 0 then 0 else 1\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    [MASK] 0 then 0 else 1"}
{"task_id": "F#/44-1-span", "prompt": "let intBoolIntConversion (intValue: int): int =\n(*\n    This function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\n    Example:\n    >>> intBoolIntConversion 5\n    1\n\n    >>> intBoolIntConversion 0\n    0\n\n    Note: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n*)", "canonical_solution": "    if intValue = 0 then 0 else 1", "test": "let check () =\n    if intBoolIntConversion 5 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if intBoolIntConversion 0 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if intBoolIntConversion -1 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if intBoolIntConversion 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if intBoolIntConversion 127 <> 1 then\n        failwith \"Test Case 5 failed\"\n    if intBoolIntConversion -127 <> 1 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "intBoolIntConversion", "signature": "let intBoolIntConversion (intValue: int): int =", "docstring": "\nThis function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\nExample:\n>>> intBoolIntConversion 5\n1\n\n>>> intBoolIntConversion 0\n0\n\nNote: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\nExample:\n>>> intBoolIntConversion 5\n1\n\n>>> intBoolIntConversion 0\n0\n\nNote: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n\n\n* Incomplete Code:\nlet intBoolIntConversion (intValue: int): int =\n    if intValue [MASK]se 1\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if intValue [MASK]se 1"}
{"task_id": "F#/45-0-span", "prompt": "let reverseThreeDigitNumber (n: int): int =\n(*\n    This function reverses a three-digit number. For example, if the input is 358, the output will be 853. \n    The function is designed to work with numbers ranging from 100 to 999, inclusive. \n    It handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\n    Example:\n    >>> reverseThreeDigitNumber 100\n    1\n\n    >>> reverseThreeDigitNumber 250\n    52\n\n    Note: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n*)", "canonical_solution": "    let reversedString = n.ToString() |> Array.ofSeq |> Array.rev |> Array.map string |> String.concat \"\"\n    int reversedString", "test": "let check () =\n    if reverseThreeDigitNumber 100 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if reverseThreeDigitNumber 250 <> 52 then\n        failwith \"Test Case 2 failed\"\n    if reverseThreeDigitNumber 678 <> 876 then\n        failwith \"Test Case 3 failed\"\n    if reverseThreeDigitNumber 321 <> 123 then\n        failwith \"Test Case 4 failed\"\n    if reverseThreeDigitNumber 909 <> 909 then\n        failwith \"Test Case 5 failed\"\n    if reverseThreeDigitNumber 111 <> 111 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "reverseThreeDigitNumber", "signature": "let reverseThreeDigitNumber (n: int): int =", "docstring": "\nThis function reverses a three-digit number. For example, if the input is 358, the output will be 853. \nThe function is designed to work with numbers ranging from 100 to 999, inclusive. \nIt handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\nExample:\n>>> reverseThreeDigitNumber 100\n1\n\n>>> reverseThreeDigitNumber 250\n52\n\nNote: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function reverses a three-digit number. For example, if the input is 358, the output will be 853. \nThe function is designed to work with numbers ranging from 100 to 999, inclusive. \nIt handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\nExample:\n>>> reverseThreeDigitNumber 100\n1\n\n>>> reverseThreeDigitNumber 250\n52\n\nNote: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n\n\n* Incomplete Code:\nlet reverseThreeDigitNumber (n: int): int =\n    let reversed[MASK]ray.rev |> Array.map string |> String.concat \"\"\n    int reversedString\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let reversed[MASK]ray.rev |> Array.map string |> String.concat \"\"\n    int reversedString"}
{"task_id": "F#/45-1-span", "prompt": "let reverseThreeDigitNumber (n: int): int =\n(*\n    This function reverses a three-digit number. For example, if the input is 358, the output will be 853. \n    The function is designed to work with numbers ranging from 100 to 999, inclusive. \n    It handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\n    Example:\n    >>> reverseThreeDigitNumber 100\n    1\n\n    >>> reverseThreeDigitNumber 250\n    52\n\n    Note: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n*)", "canonical_solution": "    let reversedString = n.ToString() |> Array.ofSeq |> Array.rev |> Array.map string |> String.concat \"\"\n    int reversedString", "test": "let check () =\n    if reverseThreeDigitNumber 100 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if reverseThreeDigitNumber 250 <> 52 then\n        failwith \"Test Case 2 failed\"\n    if reverseThreeDigitNumber 678 <> 876 then\n        failwith \"Test Case 3 failed\"\n    if reverseThreeDigitNumber 321 <> 123 then\n        failwith \"Test Case 4 failed\"\n    if reverseThreeDigitNumber 909 <> 909 then\n        failwith \"Test Case 5 failed\"\n    if reverseThreeDigitNumber 111 <> 111 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "reverseThreeDigitNumber", "signature": "let reverseThreeDigitNumber (n: int): int =", "docstring": "\nThis function reverses a three-digit number. For example, if the input is 358, the output will be 853. \nThe function is designed to work with numbers ranging from 100 to 999, inclusive. \nIt handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\nExample:\n>>> reverseThreeDigitNumber 100\n1\n\n>>> reverseThreeDigitNumber 250\n52\n\nNote: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nThis function reverses a three-digit number. For example, if the input is 358, the output will be 853. \nThe function is designed to work with numbers ranging from 100 to 999, inclusive. \nIt handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\nExample:\n>>> reverseThreeDigitNumber 100\n1\n\n>>> reverseThreeDigitNumber 250\n52\n\nNote: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n\n\n* Incomplete Code:\nlet reverseThreeDigitNumber (n: int): int =\n    let reversedString [MASK] |> Array.map string |> String.concat \"\"\n    int reversedString\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let reversedString [MASK] |> Array.map string |> String.concat \"\"\n    int reversedString"}
{"task_id": "F#/46-0-span", "prompt": "let nthTerm (a1: int) (a2: int) (n: int): int =\n(*\n    Calculates the nth term of an arithmetic sequence given its first two terms and the term's position.\n    An arithmetic sequence is characterized by a constant difference between consecutive terms.\n\n    Example:\n    >>> nthTerm 2 5 3\n    8\n\n    >>> nthTerm 10 13 5\n    22\n\n    Note: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\n    and n is the position of the term in the sequence to be found.\n*)", "canonical_solution": "    let difference = a2 - a1\n    a1 + (n - 1) * difference", "test": "let check () =\n    if nthTerm 2 5 3 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if nthTerm 10 13 5 <> 22 then\n        failwith \"Test Case 2 failed\"\n    if nthTerm 3 6 10 <> 30 then\n        failwith \"Test Case 3 failed\"\n    if nthTerm -5 -2 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if nthTerm 7 10 20 <> 64 then\n        failwith \"Test Case 5 failed\"\n    if nthTerm 0 4 50 <> 196 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "nthTerm", "signature": "let nthTerm (a1: int) (a2: int) (n: int): int =", "docstring": "\nCalculates the nth term of an arithmetic sequence given its first two terms and the term's position.\nAn arithmetic sequence is characterized by a constant difference between consecutive terms.\n\nExample:\n>>> nthTerm 2 5 3\n8\n\n>>> nthTerm 10 13 5\n22\n\nNote: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\nand n is the position of the term in the sequence to be found.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the nth term of an arithmetic sequence given its first two terms and the term's position.\nAn arithmetic sequence is characterized by a constant difference between consecutive terms.\n\nExample:\n>>> nthTerm 2 5 3\n8\n\n>>> nthTerm 10 13 5\n22\n\nNote: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\nand n is the position of the term in the sequence to be found.\n\n\n* Incomplete Code:\nlet nthTerm (a1: int) (a2: int) (n: int): int =\n    let difference = a2 - a1\n    a1 + (n - [MASK]ence\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let difference = a2 - a1\n    a1 + (n - [MASK]ence"}
{"task_id": "F#/46-1-span", "prompt": "let nthTerm (a1: int) (a2: int) (n: int): int =\n(*\n    Calculates the nth term of an arithmetic sequence given its first two terms and the term's position.\n    An arithmetic sequence is characterized by a constant difference between consecutive terms.\n\n    Example:\n    >>> nthTerm 2 5 3\n    8\n\n    >>> nthTerm 10 13 5\n    22\n\n    Note: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\n    and n is the position of the term in the sequence to be found.\n*)", "canonical_solution": "    let difference = a2 - a1\n    a1 + (n - 1) * difference", "test": "let check () =\n    if nthTerm 2 5 3 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if nthTerm 10 13 5 <> 22 then\n        failwith \"Test Case 2 failed\"\n    if nthTerm 3 6 10 <> 30 then\n        failwith \"Test Case 3 failed\"\n    if nthTerm -5 -2 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if nthTerm 7 10 20 <> 64 then\n        failwith \"Test Case 5 failed\"\n    if nthTerm 0 4 50 <> 196 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "nthTerm", "signature": "let nthTerm (a1: int) (a2: int) (n: int): int =", "docstring": "\nCalculates the nth term of an arithmetic sequence given its first two terms and the term's position.\nAn arithmetic sequence is characterized by a constant difference between consecutive terms.\n\nExample:\n>>> nthTerm 2 5 3\n8\n\n>>> nthTerm 10 13 5\n22\n\nNote: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\nand n is the position of the term in the sequence to be found.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the nth term of an arithmetic sequence given its first two terms and the term's position.\nAn arithmetic sequence is characterized by a constant difference between consecutive terms.\n\nExample:\n>>> nthTerm 2 5 3\n8\n\n>>> nthTerm 10 13 5\n22\n\nNote: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\nand n is the position of the term in the sequence to be found.\n\n\n* Incomplete Code:\nlet nthTerm (a1: int) (a2: int) (n: int): int =\n    let difference = a2 - a1\n    a1 +[MASK]difference\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let difference = a2 - a1\n    a1 +[MASK]difference"}
{"task_id": "F#/47-0-span", "prompt": "let multiply (a: int) (b: int): int =\n(*\n    Calculates the product of two positive integers, A and B. This function is designed \n    to handle inputs within the range of 1 to 50,000. Careful consideration is given \n    to the data type to accommodate the maximum possible product without overflow.\n\n    Example:\n    >>> multiply 2 3\n    6\n\n    >>> multiply 100 200\n    20000\n\n    Note: The function takes two arguments, a and b, which represent the integers A and B, \n    respectively, and returns their product.\n*)", "canonical_solution": "    a * b", "test": "let check () =\n    if multiply 2 3 <> 6 then\n        failwith \"Test Case 1 failed\"\n    if multiply 100 200 <> 20000 then\n        failwith \"Test Case 2 failed\"\n    if multiply 1 50000 <> 50000 then\n        failwith \"Test Case 3 failed\"\n    if multiply 250 200 <> 50000 then\n        failwith \"Test Case 4 failed\"\n    if multiply 123 456 <> 56088 then\n        failwith \"Test Case 5 failed\"\n    if multiply 500 100 <> 50000 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "multiply", "signature": "let multiply (a: int) (b: int): int =", "docstring": "\nCalculates the product of two positive integers, A and B. This function is designed \nto handle inputs within the range of 1 to 50,000. Careful consideration is given \nto the data type to accommodate the maximum possible product without overflow.\n\nExample:\n>>> multiply 2 3\n6\n\n>>> multiply 100 200\n20000\n\nNote: The function takes two arguments, a and b, which represent the integers A and B, \nrespectively, and returns their product.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the product of two positive integers, A and B. This function is designed \nto handle inputs within the range of 1 to 50,000. Careful consideration is given \nto the data type to accommodate the maximum possible product without overflow.\n\nExample:\n>>> multiply 2 3\n6\n\n>>> multiply 100 200\n20000\n\nNote: The function takes two arguments, a and b, which represent the integers A and B, \nrespectively, and returns their product.\n\n\n* Incomplete Code:\nlet multiply (a: int) (b: int): int =\n   [MASK]* b\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK]* b"}
{"task_id": "F#/47-1-span", "prompt": "let multiply (a: int) (b: int): int =\n(*\n    Calculates the product of two positive integers, A and B. This function is designed \n    to handle inputs within the range of 1 to 50,000. Careful consideration is given \n    to the data type to accommodate the maximum possible product without overflow.\n\n    Example:\n    >>> multiply 2 3\n    6\n\n    >>> multiply 100 200\n    20000\n\n    Note: The function takes two arguments, a and b, which represent the integers A and B, \n    respectively, and returns their product.\n*)", "canonical_solution": "    a * b", "test": "let check () =\n    if multiply 2 3 <> 6 then\n        failwith \"Test Case 1 failed\"\n    if multiply 100 200 <> 20000 then\n        failwith \"Test Case 2 failed\"\n    if multiply 1 50000 <> 50000 then\n        failwith \"Test Case 3 failed\"\n    if multiply 250 200 <> 50000 then\n        failwith \"Test Case 4 failed\"\n    if multiply 123 456 <> 56088 then\n        failwith \"Test Case 5 failed\"\n    if multiply 500 100 <> 50000 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "multiply", "signature": "let multiply (a: int) (b: int): int =", "docstring": "\nCalculates the product of two positive integers, A and B. This function is designed \nto handle inputs within the range of 1 to 50,000. Careful consideration is given \nto the data type to accommodate the maximum possible product without overflow.\n\nExample:\n>>> multiply 2 3\n6\n\n>>> multiply 100 200\n20000\n\nNote: The function takes two arguments, a and b, which represent the integers A and B, \nrespectively, and returns their product.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the product of two positive integers, A and B. This function is designed \nto handle inputs within the range of 1 to 50,000. Careful consideration is given \nto the data type to accommodate the maximum possible product without overflow.\n\nExample:\n>>> multiply 2 3\n6\n\n>>> multiply 100 200\n20000\n\nNote: The function takes two arguments, a and b, which represent the integers A and B, \nrespectively, and returns their product.\n\n\n* Incomplete Code:\nlet multiply (a: int) (b: int): int =\n [MASK]a * b\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK]a * b"}
{"task_id": "F#/48-0-span", "prompt": "let powerOfTwo (n: int): int =\n(*\n    Calculates 2 raised to the power of a given non-negative integer n. This function is designed \n    to work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \n    represented as an integer without overflow.\n\n    Example:\n    >>> powerOfTwo 4\n    16\n\n    >>> powerOfTwo 5\n    32\n\n    Note: The function takes a single argument, n, which represents the exponent, and returns \n    the result of 2^n.\n*)", "canonical_solution": "    1 <<< n", "test": "let check () =\n    if powerOfTwo 4 <> 16 then\n        failwith \"Test Case 1 failed\"\n    if powerOfTwo 5 <> 32 then\n        failwith \"Test Case 2 failed\"\n    if powerOfTwo 0 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if powerOfTwo 10 <> 1024 then\n        failwith \"Test Case 4 failed\"\n    if powerOfTwo 15 <> 32768 then\n        failwith \"Test Case 5 failed\"\n    if powerOfTwo 20 <> 1048576 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "powerOfTwo", "signature": "let powerOfTwo (n: int): int =", "docstring": "\nCalculates 2 raised to the power of a given non-negative integer n. This function is designed \nto work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \nrepresented as an integer without overflow.\n\nExample:\n>>> powerOfTwo 4\n16\n\n>>> powerOfTwo 5\n32\n\nNote: The function takes a single argument, n, which represents the exponent, and returns \nthe result of 2^n.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nCalculates 2 raised to the power of a given non-negative integer n. This function is designed \nto work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \nrepresented as an integer without overflow.\n\nExample:\n>>> powerOfTwo 4\n16\n\n>>> powerOfTwo 5\n32\n\nNote: The function takes a single argument, n, which represents the exponent, and returns \nthe result of 2^n.\n\n\n* Incomplete Code:\nlet powerOfTwo (n: int): int =\n    1[MASK] n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    1[MASK] n"}
{"task_id": "F#/48-1-span", "prompt": "let powerOfTwo (n: int): int =\n(*\n    Calculates 2 raised to the power of a given non-negative integer n. This function is designed \n    to work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \n    represented as an integer without overflow.\n\n    Example:\n    >>> powerOfTwo 4\n    16\n\n    >>> powerOfTwo 5\n    32\n\n    Note: The function takes a single argument, n, which represents the exponent, and returns \n    the result of 2^n.\n*)", "canonical_solution": "    1 <<< n", "test": "let check () =\n    if powerOfTwo 4 <> 16 then\n        failwith \"Test Case 1 failed\"\n    if powerOfTwo 5 <> 32 then\n        failwith \"Test Case 2 failed\"\n    if powerOfTwo 0 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if powerOfTwo 10 <> 1024 then\n        failwith \"Test Case 4 failed\"\n    if powerOfTwo 15 <> 32768 then\n        failwith \"Test Case 5 failed\"\n    if powerOfTwo 20 <> 1048576 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "powerOfTwo", "signature": "let powerOfTwo (n: int): int =", "docstring": "\nCalculates 2 raised to the power of a given non-negative integer n. This function is designed \nto work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \nrepresented as an integer without overflow.\n\nExample:\n>>> powerOfTwo 4\n16\n\n>>> powerOfTwo 5\n32\n\nNote: The function takes a single argument, n, which represents the exponent, and returns \nthe result of 2^n.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nCalculates 2 raised to the power of a given non-negative integer n. This function is designed \nto work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \nrepresented as an integer without overflow.\n\nExample:\n>>> powerOfTwo 4\n16\n\n>>> powerOfTwo 5\n32\n\nNote: The function takes a single argument, n, which represents the exponent, and returns \nthe result of 2^n.\n\n\n* Incomplete Code:\nlet powerOfTwo (n: int): int =\n [MASK] <<< n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK] <<< n"}
{"task_id": "F#/49-0-span", "prompt": "let determineSign (n: int): string =\n(*\n    Determines the sign of a given integer N. The function returns \"positive\" if N is greater \n    than zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \n    provides a straightforward way to categorize an integer according to its sign.\n\n    Example:\n    >>> determineSign 10\n    \"positive\"\n\n    >>> determineSign 0\n    \"zero\"\n\n    >>> determineSign -5\n    \"negative\"\n\n    Note: The function takes a single argument, n, which represents the integer whose sign \n    is to be determined, and returns a string indicating the sign of the integer.\n*)", "canonical_solution": "    match n with\n    | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n    | _ -> \"negative\"", "test": "let check () =\n    if determineSign 10 <> \"positive\" then\n        failwith \"Test Case 1 failed\"\n    if determineSign 0 <> \"zero\" then\n        failwith \"Test Case 2 failed\"\n    if determineSign -5 <> \"negative\" then\n        failwith \"Test Case 3 failed\"\n    if determineSign 100 <> \"positive\" then\n        failwith \"Test Case 4 failed\"\n    if determineSign -100 <> \"negative\" then\n        failwith \"Test Case 5 failed\"\n    if determineSign 1 <> \"positive\" then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "determineSign", "signature": "let determineSign (n: int): string =", "docstring": "\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n\n\n* Incomplete Code:\nlet determineSign (n: int): string =\n   [MASK]   | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n    | _ -> \"negative\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK]   | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n    | _ -> \"negative\""}
{"task_id": "F#/49-1-span", "prompt": "let determineSign (n: int): string =\n(*\n    Determines the sign of a given integer N. The function returns \"positive\" if N is greater \n    than zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \n    provides a straightforward way to categorize an integer according to its sign.\n\n    Example:\n    >>> determineSign 10\n    \"positive\"\n\n    >>> determineSign 0\n    \"zero\"\n\n    >>> determineSign -5\n    \"negative\"\n\n    Note: The function takes a single argument, n, which represents the integer whose sign \n    is to be determined, and returns a string indicating the sign of the integer.\n*)", "canonical_solution": "    match n with\n    | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n    | _ -> \"negative\"", "test": "let check () =\n    if determineSign 10 <> \"positive\" then\n        failwith \"Test Case 1 failed\"\n    if determineSign 0 <> \"zero\" then\n        failwith \"Test Case 2 failed\"\n    if determineSign -5 <> \"negative\" then\n        failwith \"Test Case 3 failed\"\n    if determineSign 100 <> \"positive\" then\n        failwith \"Test Case 4 failed\"\n    if determineSign -100 <> \"negative\" then\n        failwith \"Test Case 5 failed\"\n    if determineSign 1 <> \"positive\" then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "determineSign", "signature": "let determineSign (n: int): string =", "docstring": "\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n\n\n* Incomplete Code:\nlet determineSign (n: int): string =\n    match n wi[MASK]    | 0 -> \"zero\"\n    | _ -> \"negative\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    match n wi[MASK]    | 0 -> \"zero\"\n    | _ -> \"negative\""}
{"task_id": "F#/50-0-span", "prompt": "let absoluteValue (n: int): int =\n(*\n    Computes the absolute value of an integer n. This function returns the non-negative value of n, \n    effectively removing any negative sign from n. It is designed to handle integers whose absolute \n    values do not exceed 10,000.\n\n    Example:\n    >>> absoluteValue -10\n    10\n\n    >>> absoluteValue 5\n    5\n\n    Note: The function takes a single argument, n, which represents the integer whose absolute value \n    is to be computed, and returns the absolute value of n.\n*)", "canonical_solution": "    if n < 0 then -n else n", "test": "let check () =\n    if absoluteValue -10 <> 10 then\n        failwith \"Test Case 1 failed\"\n    if absoluteValue 5 <> 5 then\n        failwith \"Test Case 2 failed\"\n    if absoluteValue 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if absoluteValue -10000 <> 10000 then\n        failwith \"Test Case 4 failed\"\n    if absoluteValue 9999 <> 9999 then\n        failwith \"Test Case 5 failed\"\n    if absoluteValue -1 <> 1 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "absoluteValue", "signature": "let absoluteValue (n: int): int =", "docstring": "\nComputes the absolute value of an integer n. This function returns the non-negative value of n, \neffectively removing any negative sign from n. It is designed to handle integers whose absolute \nvalues do not exceed 10,000.\n\nExample:\n>>> absoluteValue -10\n10\n\n>>> absoluteValue 5\n5\n\nNote: The function takes a single argument, n, which represents the integer whose absolute value \nis to be computed, and returns the absolute value of n.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nComputes the absolute value of an integer n. This function returns the non-negative value of n, \neffectively removing any negative sign from n. It is designed to handle integers whose absolute \nvalues do not exceed 10,000.\n\nExample:\n>>> absoluteValue -10\n10\n\n>>> absoluteValue 5\n5\n\nNote: The function takes a single argument, n, which represents the integer whose absolute value \nis to be computed, and returns the absolute value of n.\n\n\n* Incomplete Code:\nlet absoluteValue (n: int): int =\n    if n [MASK]n else n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if n [MASK]n else n"}
{"task_id": "F#/50-1-span", "prompt": "let absoluteValue (n: int): int =\n(*\n    Computes the absolute value of an integer n. This function returns the non-negative value of n, \n    effectively removing any negative sign from n. It is designed to handle integers whose absolute \n    values do not exceed 10,000.\n\n    Example:\n    >>> absoluteValue -10\n    10\n\n    >>> absoluteValue 5\n    5\n\n    Note: The function takes a single argument, n, which represents the integer whose absolute value \n    is to be computed, and returns the absolute value of n.\n*)", "canonical_solution": "    if n < 0 then -n else n", "test": "let check () =\n    if absoluteValue -10 <> 10 then\n        failwith \"Test Case 1 failed\"\n    if absoluteValue 5 <> 5 then\n        failwith \"Test Case 2 failed\"\n    if absoluteValue 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if absoluteValue -10000 <> 10000 then\n        failwith \"Test Case 4 failed\"\n    if absoluteValue 9999 <> 9999 then\n        failwith \"Test Case 5 failed\"\n    if absoluteValue -1 <> 1 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "absoluteValue", "signature": "let absoluteValue (n: int): int =", "docstring": "\nComputes the absolute value of an integer n. This function returns the non-negative value of n, \neffectively removing any negative sign from n. It is designed to handle integers whose absolute \nvalues do not exceed 10,000.\n\nExample:\n>>> absoluteValue -10\n10\n\n>>> absoluteValue 5\n5\n\nNote: The function takes a single argument, n, which represents the integer whose absolute value \nis to be computed, and returns the absolute value of n.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nComputes the absolute value of an integer n. This function returns the non-negative value of n, \neffectively removing any negative sign from n. It is designed to handle integers whose absolute \nvalues do not exceed 10,000.\n\nExample:\n>>> absoluteValue -10\n10\n\n>>> absoluteValue 5\n5\n\nNote: The function takes a single argument, n, which represents the integer whose absolute value \nis to be computed, and returns the absolute value of n.\n\n\n* Incomplete Code:\nlet absoluteValue (n: int): int =\n   [MASK]then -n else n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK]then -n else n"}
