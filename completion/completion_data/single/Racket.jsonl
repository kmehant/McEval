{"task_id": "Racket/1-0-single", "prompt": "#lang racket\n(require rackunit)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;False\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;True\n(define (has-close-elements numbers threshold)", "canonical_solution": "(define (check-distance lst elem)\n(cond\n[(null? lst) #f]\n[(< (abs (- elem (car lst))) threshold) #t]\n[else (check-distance (cdr lst) elem)]))\n\n(define (iter elems)\n(cond\n[(null? elems) #f]\n[else (or (check-distance (cdr elems) (car elems))\n(iter (cdr elems)))]))\n\n(iter numbers))", "test": ";; Test cases\n(define (check has-close-elements)\n(define tests\n(list (check-equal? (has-close-elements (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)\n(check-equal? (has-close-elements (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)\n(check-equal? (has-close-elements (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)\n(check-equal? (has-close-elements (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)\n(check-equal? (has-close-elements (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)\n(check-equal? (has-close-elements (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)\n(check-equal? (has-close-elements (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)))\n(andmap identity tests))\n\n(check has-close-elements)", "entry_point": "has-close-elements", "signature": "(define (has-close-elements", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\n(define (has-close-elements\n(define (check-distance lst elem)\n(cond\n[(null? lst) #f]\n[(< (abs (- elem (car lst))) threshold) #t]\n[else (check-distance (cdr lst) elem)]))\n\n(define (iter elems)\n(cond\n[(null? elems) #f]\n[MASK]\n(iter (cdr elems)))]))\n\n(iter numbers))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (check-distance lst elem)\n(cond\n[(null? lst) #f]\n[(< (abs (- elem (car lst))) threshold) #t]\n[else (check-distance (cdr lst) elem)]))\n\n(define (iter elems)\n(cond\n[(null? elems) #f]\n[MASK]\n(iter (cdr elems)))]))\n\n(iter numbers))"}
{"task_id": "Racket/1-1-single", "prompt": "#lang racket\n(require rackunit)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;False\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;True\n(define (has-close-elements numbers threshold)", "canonical_solution": "(define (check-distance lst elem)\n(cond\n[(null? lst) #f]\n[(< (abs (- elem (car lst))) threshold) #t]\n[else (check-distance (cdr lst) elem)]))\n\n(define (iter elems)\n(cond\n[(null? elems) #f]\n[else (or (check-distance (cdr elems) (car elems))\n(iter (cdr elems)))]))\n\n(iter numbers))", "test": ";; Test cases\n(define (check has-close-elements)\n(define tests\n(list (check-equal? (has-close-elements (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)\n(check-equal? (has-close-elements (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)\n(check-equal? (has-close-elements (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)\n(check-equal? (has-close-elements (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)\n(check-equal? (has-close-elements (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)\n(check-equal? (has-close-elements (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)\n(check-equal? (has-close-elements (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)))\n(andmap identity tests))\n\n(check has-close-elements)", "entry_point": "has-close-elements", "signature": "(define (has-close-elements", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\n(define (has-close-elements\n(define (check-distance lst elem)\n(cond\n[(null? lst) #f]\n[(< (abs (- elem (car lst))) threshold) #t]\n[MASK]\n\n(define (iter elems)\n(cond\n[(null? elems) #f]\n[else (or (check-distance (cdr elems) (car elems))\n(iter (cdr elems)))]))\n\n(iter numbers))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (check-distance lst elem)\n(cond\n[(null? lst) #f]\n[(< (abs (- elem (car lst))) threshold) #t]\n[MASK]\n\n(define (iter elems)\n(cond\n[(null? elems) #f]\n[else (or (check-distance (cdr elems) (car elems))\n(iter (cdr elems)))]))\n\n(iter numbers))"}
{"task_id": "Racket/2-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array `arr`, this function returns `true` if the array can be\n;; partitioned into three non-empty parts with equal sums, and `false` otherwise.\n;; Formally, it checks if there exist indices i + 1 < j with\n;; (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n;;\n;; Examples:\n;; >>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n;; #t\n;; >>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n;; #f\n\n(define (can-partition-into-three-equals arr)", "canonical_solution": "(define total-sum (apply + arr))\n(if (not (= (remainder total-sum 3) 0))\n#f\n(let* ([target (/ total-sum 3)]\n[count 0]\n[sum 0])\n(for ([a arr])\n(set! sum (+ sum a))\n(when (= sum target)\n(set! count (add1 count))\n(set! sum 0)))\n(>= count 3))))", "test": "(define (check can-partition-into-three-equals)\n(define tests\n(list (check-equal? (can-partition-into-three-equals (list 0 2 1 -6 6 -7 9 1 2 0 1)) #t)\n(check-equal? (can-partition-into-three-equals (list 0 2 1 -6 6 7 9 -1 2 0 1)) #f)\n(check-equal? (can-partition-into-three-equals (list 3 3 3 3 3 3)) #t)\n(check-equal? (can-partition-into-three-equals (list 1 1 1 1)) #f)\n(check-equal? (can-partition-into-three-equals (list 1 -1 1 -1)) #f)))\n(andmap identity tests))\n\n(check can-partition-into-three-equals)", "entry_point": "can-partition-into-three-equals", "signature": "(define (can-partition-into-three-equals", "docstring": "Function Description:\nGiven an integer array `arr`, this function returns `true` if the array can be\npartitioned into three non-empty parts with equal sums, and `false` otherwise.\nFormally, it checks if there exist indices i + 1 < j with\n(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n\nExamples:\n>>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n#t\n>>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n#f\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an integer array `arr`, this function returns `true` if the array can be\npartitioned into three non-empty parts with equal sums, and `false` otherwise.\nFormally, it checks if there exist indices i + 1 < j with\n(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n\nExamples:\n>>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n#t\n>>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n#f\n\n\n\n* Incomplete Code:\n(define (can-partition-into-three-equals\n(define total-sum (apply + arr))\n(if (not (= (remainder total-sum 3) 0))\n#f\n(let* ([target (/ total-sum 3)]\n[count 0]\n[sum 0])\n(for ([a arr])\n(set! sum (+ sum a))\n(when (= sum target)\n(set! count (add1 count))\n[MASK]\n(>= count 3))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define total-sum (apply + arr))\n(if (not (= (remainder total-sum 3) 0))\n#f\n(let* ([target (/ total-sum 3)]\n[count 0]\n[sum 0])\n(for ([a arr])\n(set! sum (+ sum a))\n(when (= sum target)\n(set! count (add1 count))\n[MASK]\n(>= count 3))))"}
{"task_id": "Racket/2-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array `arr`, this function returns `true` if the array can be\n;; partitioned into three non-empty parts with equal sums, and `false` otherwise.\n;; Formally, it checks if there exist indices i + 1 < j with\n;; (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n;;\n;; Examples:\n;; >>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n;; #t\n;; >>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n;; #f\n\n(define (can-partition-into-three-equals arr)", "canonical_solution": "(define total-sum (apply + arr))\n(if (not (= (remainder total-sum 3) 0))\n#f\n(let* ([target (/ total-sum 3)]\n[count 0]\n[sum 0])\n(for ([a arr])\n(set! sum (+ sum a))\n(when (= sum target)\n(set! count (add1 count))\n(set! sum 0)))\n(>= count 3))))", "test": "(define (check can-partition-into-three-equals)\n(define tests\n(list (check-equal? (can-partition-into-three-equals (list 0 2 1 -6 6 -7 9 1 2 0 1)) #t)\n(check-equal? (can-partition-into-three-equals (list 0 2 1 -6 6 7 9 -1 2 0 1)) #f)\n(check-equal? (can-partition-into-three-equals (list 3 3 3 3 3 3)) #t)\n(check-equal? (can-partition-into-three-equals (list 1 1 1 1)) #f)\n(check-equal? (can-partition-into-three-equals (list 1 -1 1 -1)) #f)))\n(andmap identity tests))\n\n(check can-partition-into-three-equals)", "entry_point": "can-partition-into-three-equals", "signature": "(define (can-partition-into-three-equals", "docstring": "Function Description:\nGiven an integer array `arr`, this function returns `true` if the array can be\npartitioned into three non-empty parts with equal sums, and `false` otherwise.\nFormally, it checks if there exist indices i + 1 < j with\n(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n\nExamples:\n>>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n#t\n>>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n#f\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an integer array `arr`, this function returns `true` if the array can be\npartitioned into three non-empty parts with equal sums, and `false` otherwise.\nFormally, it checks if there exist indices i + 1 < j with\n(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n\nExamples:\n>>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n#t\n>>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n#f\n\n\n\n* Incomplete Code:\n(define (can-partition-into-three-equals\n(define total-sum (apply + arr))\n(if (not (= (remainder total-sum 3) 0))\n#f\n[MASK]\n[count 0]\n[sum 0])\n(for ([a arr])\n(set! sum (+ sum a))\n(when (= sum target)\n(set! count (add1 count))\n(set! sum 0)))\n(>= count 3))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define total-sum (apply + arr))\n(if (not (= (remainder total-sum 3) 0))\n#f\n[MASK]\n[count 0]\n[sum 0])\n(for ([a arr])\n(set! sum (+ sum a))\n(when (= sum target)\n(set! count (add1 count))\n(set! sum 0)))\n(>= count 3))))"}
{"task_id": "Racket/3-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\n;; this function returns 'true' if these points form a boomerang.\n;; A 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n;;\n;; Examples:\n;; >>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n;; #t\n;; >>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n;; #f\n\n(define (is-boomerang points)", "canonical_solution": "(define (slope p1 p2)\n(/ (- (cadr p2) (cadr p1))\n(- (car p2) (car p1))))\n\n(define (distinct-points? pts)\n(and (not (equal? (car pts) (cadr pts)))\n(not (equal? (car pts) (caddr pts)))\n(not (equal? (cadr pts) (caddr pts)))))\n\n(and (distinct-points? points)\n(not (= (slope (car points) (cadr points))\n(slope (car points) (caddr points))))))", "test": "(define (check is-boomerang)\n(define tests\n(list (check-equal? (is-boomerang (list (list 1 1) (list 2 3) (list 3 2))) #t)\n(check-equal? (is-boomerang (list (list 1 1) (list 2 2) (list 3 3))) #f)\n(check-equal? (is-boomerang (list (list 0 0) (list 1 1) (list 1 0))) #t)\n(check-equal? (is-boomerang (list (list 1 1) (list 1 1) (list 2 2))) #f)\n(check-equal? (is-boomerang (list (list 1 2) (list 3 4) (list 5 6))) #f)))\n(andmap identity tests))\n\n(check is-boomerang)", "entry_point": "is-boomerang", "signature": "(define (is-boomerang", "docstring": "Function Description:\nGiven an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\nthis function returns 'true' if these points form a boomerang.\nA 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n\nExamples:\n>>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n#t\n>>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n#f\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\nthis function returns 'true' if these points form a boomerang.\nA 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n\nExamples:\n>>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n#t\n>>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n#f\n\n\n\n* Incomplete Code:\n(define (is-boomerang\n(define (slope p1 p2)\n(/ (- (cadr p2) (cadr p1))\n(- (car p2) (car p1))))\n\n(define (distinct-points? pts)\n(and (not (equal? (car pts) (cadr pts)))\n(not (equal? (car pts) (caddr pts)))\n(not (equal? (cadr pts) (caddr pts)))))\n\n[MASK]\n(not (= (slope (car points) (cadr points))\n(slope (car points) (caddr points))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (slope p1 p2)\n(/ (- (cadr p2) (cadr p1))\n(- (car p2) (car p1))))\n\n(define (distinct-points? pts)\n(and (not (equal? (car pts) (cadr pts)))\n(not (equal? (car pts) (caddr pts)))\n(not (equal? (cadr pts) (caddr pts)))))\n\n[MASK]\n(not (= (slope (car points) (cadr points))\n(slope (car points) (caddr points))))))"}
{"task_id": "Racket/3-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\n;; this function returns 'true' if these points form a boomerang.\n;; A 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n;;\n;; Examples:\n;; >>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n;; #t\n;; >>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n;; #f\n\n(define (is-boomerang points)", "canonical_solution": "(define (slope p1 p2)\n(/ (- (cadr p2) (cadr p1))\n(- (car p2) (car p1))))\n\n(define (distinct-points? pts)\n(and (not (equal? (car pts) (cadr pts)))\n(not (equal? (car pts) (caddr pts)))\n(not (equal? (cadr pts) (caddr pts)))))\n\n(and (distinct-points? points)\n(not (= (slope (car points) (cadr points))\n(slope (car points) (caddr points))))))", "test": "(define (check is-boomerang)\n(define tests\n(list (check-equal? (is-boomerang (list (list 1 1) (list 2 3) (list 3 2))) #t)\n(check-equal? (is-boomerang (list (list 1 1) (list 2 2) (list 3 3))) #f)\n(check-equal? (is-boomerang (list (list 0 0) (list 1 1) (list 1 0))) #t)\n(check-equal? (is-boomerang (list (list 1 1) (list 1 1) (list 2 2))) #f)\n(check-equal? (is-boomerang (list (list 1 2) (list 3 4) (list 5 6))) #f)))\n(andmap identity tests))\n\n(check is-boomerang)", "entry_point": "is-boomerang", "signature": "(define (is-boomerang", "docstring": "Function Description:\nGiven an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\nthis function returns 'true' if these points form a boomerang.\nA 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n\nExamples:\n>>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n#t\n>>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n#f\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\nthis function returns 'true' if these points form a boomerang.\nA 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n\nExamples:\n>>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n#t\n>>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n#f\n\n\n\n* Incomplete Code:\n(define (is-boomerang\n(define (slope p1 p2)\n(/ (- (cadr p2) (cadr p1))\n(- (car p2) (car p1))))\n\n(define (distinct-points? pts)\n[MASK]\n(not (equal? (car pts) (caddr pts)))\n(not (equal? (cadr pts) (caddr pts)))))\n\n(and (distinct-points? points)\n(not (= (slope (car points) (cadr points))\n(slope (car points) (caddr points))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (slope p1 p2)\n(/ (- (cadr p2) (cadr p1))\n(- (car p2) (car p1))))\n\n(define (distinct-points? pts)\n[MASK]\n(not (equal? (car pts) (caddr pts)))\n(not (equal? (cadr pts) (caddr pts)))))\n\n(and (distinct-points? points)\n(not (= (slope (car points) (cadr points))\n(slope (car points) (caddr points))))))"}
{"task_id": "Racket/4-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of stone weights (each weight is a positive integer), this function simulates a process\n;; where in each round, the two heaviest stones are smashed together. The possible outcomes are:\n;; - If x == y (both stones have the same weight), both stones are completely smashed;\n;; - If x != y (stones have different weights), the stone with weight x is completely smashed, and\n;; the stone with weight y has a new weight of y-x.\n;; The process is repeated until at most one stone remains. The function returns the weight of this remaining\n;; stone, or 0 if no stones are left.\n;;\n;; Examples:\n;; >>> last-stone-weight([2 7 4 1 8 1])\n;; 1\n;; >>> last-stone-weight([10])\n;; 10\n\n(define (last-stone-weight stones)", "canonical_solution": "(define (smash largest second-largest rest)\n(if (= largest second-largest)\nrest\n(cons (- largest second-largest) rest)))\n\n(define (iterate stones)\n(cond\n[(null? stones) 0]\n[(null? (cdr stones)) (car stones)]\n[else\n(let* ([sorted-stones (sort stones >)]\n[largest (car sorted-stones)]\n[second-largest (cadr sorted-stones)]\n[rest (cddr sorted-stones)])\n(iterate (smash largest second-largest rest)))]))\n\n(iterate stones))", "test": ";; Test Cases\n(define (check last-stone-weight)\n(define tests\n(list (check-equal? (last-stone-weight (list 2 7 4 1 8 1)) 1)\n(check-equal? (last-stone-weight (list 10)) 10)\n(check-equal? (last-stone-weight (list 8 10 4)) 2)\n(check-equal? (last-stone-weight (list 20 15 10 5)) 0)\n(check-equal? (last-stone-weight (list)) 0)))\n(andmap identity tests))\n\n(check last-stone-weight)", "entry_point": "last-stone-weight", "signature": "(define (last-stone-weight", "docstring": "Function Description:\nGiven a list of stone weights (each weight is a positive integer), this function simulates a process\nwhere in each round, the two heaviest stones are smashed together. The possible outcomes are:\n- If x == y (both stones have the same weight), both stones are completely smashed;\n- If x != y (stones have different weights), the stone with weight x is completely smashed, and\nthe stone with weight y has a new weight of y-x.\nThe process is repeated until at most one stone remains. The function returns the weight of this remaining\nstone, or 0 if no stones are left.\n\nExamples:\n>>> last-stone-weight([2 7 4 1 8 1])\n1\n>>> last-stone-weight([10])\n10\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a list of stone weights (each weight is a positive integer), this function simulates a process\nwhere in each round, the two heaviest stones are smashed together. The possible outcomes are:\n- If x == y (both stones have the same weight), both stones are completely smashed;\n- If x != y (stones have different weights), the stone with weight x is completely smashed, and\nthe stone with weight y has a new weight of y-x.\nThe process is repeated until at most one stone remains. The function returns the weight of this remaining\nstone, or 0 if no stones are left.\n\nExamples:\n>>> last-stone-weight([2 7 4 1 8 1])\n1\n>>> last-stone-weight([10])\n10\n\n\n\n* Incomplete Code:\n(define (last-stone-weight\n(define (smash largest second-largest rest)\n(if (= largest second-largest)\nrest\n(cons (- largest second-largest) rest)))\n\n(define (iterate stones)\n(cond\n[(null? stones) 0]\n[(null? (cdr stones)) (car stones)]\n[else\n(let* ([sorted-stones (sort stones >)]\n[largest (car sorted-stones)]\n[second-largest (cadr sorted-stones)]\n[rest (cddr sorted-stones)])\n(iterate (smash largest second-largest rest)))]))\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (smash largest second-largest rest)\n(if (= largest second-largest)\nrest\n(cons (- largest second-largest) rest)))\n\n(define (iterate stones)\n(cond\n[(null? stones) 0]\n[(null? (cdr stones)) (car stones)]\n[else\n(let* ([sorted-stones (sort stones >)]\n[largest (car sorted-stones)]\n[second-largest (cadr sorted-stones)]\n[rest (cddr sorted-stones)])\n(iterate (smash largest second-largest rest)))]))\n\n[MASK]"}
{"task_id": "Racket/4-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of stone weights (each weight is a positive integer), this function simulates a process\n;; where in each round, the two heaviest stones are smashed together. The possible outcomes are:\n;; - If x == y (both stones have the same weight), both stones are completely smashed;\n;; - If x != y (stones have different weights), the stone with weight x is completely smashed, and\n;; the stone with weight y has a new weight of y-x.\n;; The process is repeated until at most one stone remains. The function returns the weight of this remaining\n;; stone, or 0 if no stones are left.\n;;\n;; Examples:\n;; >>> last-stone-weight([2 7 4 1 8 1])\n;; 1\n;; >>> last-stone-weight([10])\n;; 10\n\n(define (last-stone-weight stones)", "canonical_solution": "(define (smash largest second-largest rest)\n(if (= largest second-largest)\nrest\n(cons (- largest second-largest) rest)))\n\n(define (iterate stones)\n(cond\n[(null? stones) 0]\n[(null? (cdr stones)) (car stones)]\n[else\n(let* ([sorted-stones (sort stones >)]\n[largest (car sorted-stones)]\n[second-largest (cadr sorted-stones)]\n[rest (cddr sorted-stones)])\n(iterate (smash largest second-largest rest)))]))\n\n(iterate stones))", "test": ";; Test Cases\n(define (check last-stone-weight)\n(define tests\n(list (check-equal? (last-stone-weight (list 2 7 4 1 8 1)) 1)\n(check-equal? (last-stone-weight (list 10)) 10)\n(check-equal? (last-stone-weight (list 8 10 4)) 2)\n(check-equal? (last-stone-weight (list 20 15 10 5)) 0)\n(check-equal? (last-stone-weight (list)) 0)))\n(andmap identity tests))\n\n(check last-stone-weight)", "entry_point": "last-stone-weight", "signature": "(define (last-stone-weight", "docstring": "Function Description:\nGiven a list of stone weights (each weight is a positive integer), this function simulates a process\nwhere in each round, the two heaviest stones are smashed together. The possible outcomes are:\n- If x == y (both stones have the same weight), both stones are completely smashed;\n- If x != y (stones have different weights), the stone with weight x is completely smashed, and\nthe stone with weight y has a new weight of y-x.\nThe process is repeated until at most one stone remains. The function returns the weight of this remaining\nstone, or 0 if no stones are left.\n\nExamples:\n>>> last-stone-weight([2 7 4 1 8 1])\n1\n>>> last-stone-weight([10])\n10\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a list of stone weights (each weight is a positive integer), this function simulates a process\nwhere in each round, the two heaviest stones are smashed together. The possible outcomes are:\n- If x == y (both stones have the same weight), both stones are completely smashed;\n- If x != y (stones have different weights), the stone with weight x is completely smashed, and\nthe stone with weight y has a new weight of y-x.\nThe process is repeated until at most one stone remains. The function returns the weight of this remaining\nstone, or 0 if no stones are left.\n\nExamples:\n>>> last-stone-weight([2 7 4 1 8 1])\n1\n>>> last-stone-weight([10])\n10\n\n\n\n* Incomplete Code:\n(define (last-stone-weight\n(define (smash largest second-largest rest)\n(if (= largest second-largest)\nrest\n(cons (- largest second-largest) rest)))\n\n(define (iterate stones)\n(cond\n[(null? stones) 0]\n[(null? (cdr stones)) (car stones)]\n[else\n(let* ([sorted-stones (sort stones >)]\n[MASK]\n[second-largest (cadr sorted-stones)]\n[rest (cddr sorted-stones)])\n(iterate (smash largest second-largest rest)))]))\n\n(iterate stones))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (smash largest second-largest rest)\n(if (= largest second-largest)\nrest\n(cons (- largest second-largest) rest)))\n\n(define (iterate stones)\n(cond\n[(null? stones) 0]\n[(null? (cdr stones)) (car stones)]\n[else\n(let* ([sorted-stones (sort stones >)]\n[MASK]\n[second-largest (cadr sorted-stones)]\n[rest (cddr sorted-stones)])\n(iterate (smash largest second-largest rest)))]))\n\n(iterate stones))"}
{"task_id": "Racket/5-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given two integer arrays 'heights' and 'expected', where 'expected' represents the heights\n;; of students in non-decreasing order, and 'heights' represents the current order of student heights,\n;; this function returns the count of indices where heights[i] != expected[i].\n;;\n;; Examples:\n;; >>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n;; 3\n;; >>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n;; 5\n\n(define (height-mismatch-count heights expected)", "canonical_solution": "(define (count-mismatches lst1 lst2)\n(cond\n[(null? lst1) 0]\n[else\n(if (= (car lst1) (car lst2))\n(count-mismatches (cdr lst1) (cdr lst2))\n(+ 1 (count-mismatches (cdr lst1) (cdr lst2))))]))\n(count-mismatches heights expected))", "test": "(define (check height-mismatch-count)\n(define tests\n(list (check-equal? (height-mismatch-count (list 1 1 4 2 1 3) (list 1 1 1 2 3 4)) 3)\n(check-equal? (height-mismatch-count (list 5 1 2 3 4) (list 1 2 3 4 5)) 5)\n(check-equal? (height-mismatch-count (list 1 2 3 4 5) (list 1 2 3 4 5)) 0)\n(check-equal? (height-mismatch-count (list 3 3 3 3 3) (list 3 3 3 3 3)) 0)\n(check-equal? (height-mismatch-count (list 2 1 2 1 2) (list 1 1 2 2 2)) 2)))\n(andmap identity tests))\n\n(check height-mismatch-count)", "entry_point": "height-mismatch-count", "signature": "(define (height-mismatch-count", "docstring": "Function Description:\nGiven two integer arrays 'heights' and 'expected', where 'expected' represents the heights\nof students in non-decreasing order, and 'heights' represents the current order of student heights,\nthis function returns the count of indices where heights[i] != expected[i].\n\nExamples:\n>>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n3\n>>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n5\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven two integer arrays 'heights' and 'expected', where 'expected' represents the heights\nof students in non-decreasing order, and 'heights' represents the current order of student heights,\nthis function returns the count of indices where heights[i] != expected[i].\n\nExamples:\n>>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n3\n>>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n5\n\n\n\n* Incomplete Code:\n(define (height-mismatch-count\n[MASK]\n(cond\n[(null? lst1) 0]\n[else\n(if (= (car lst1) (car lst2))\n(count-mismatches (cdr lst1) (cdr lst2))\n(+ 1 (count-mismatches (cdr lst1) (cdr lst2))))]))\n(count-mismatches heights expected))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(cond\n[(null? lst1) 0]\n[else\n(if (= (car lst1) (car lst2))\n(count-mismatches (cdr lst1) (cdr lst2))\n(+ 1 (count-mismatches (cdr lst1) (cdr lst2))))]))\n(count-mismatches heights expected))"}
{"task_id": "Racket/5-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given two integer arrays 'heights' and 'expected', where 'expected' represents the heights\n;; of students in non-decreasing order, and 'heights' represents the current order of student heights,\n;; this function returns the count of indices where heights[i] != expected[i].\n;;\n;; Examples:\n;; >>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n;; 3\n;; >>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n;; 5\n\n(define (height-mismatch-count heights expected)", "canonical_solution": "(define (count-mismatches lst1 lst2)\n(cond\n[(null? lst1) 0]\n[else\n(if (= (car lst1) (car lst2))\n(count-mismatches (cdr lst1) (cdr lst2))\n(+ 1 (count-mismatches (cdr lst1) (cdr lst2))))]))\n(count-mismatches heights expected))", "test": "(define (check height-mismatch-count)\n(define tests\n(list (check-equal? (height-mismatch-count (list 1 1 4 2 1 3) (list 1 1 1 2 3 4)) 3)\n(check-equal? (height-mismatch-count (list 5 1 2 3 4) (list 1 2 3 4 5)) 5)\n(check-equal? (height-mismatch-count (list 1 2 3 4 5) (list 1 2 3 4 5)) 0)\n(check-equal? (height-mismatch-count (list 3 3 3 3 3) (list 3 3 3 3 3)) 0)\n(check-equal? (height-mismatch-count (list 2 1 2 1 2) (list 1 1 2 2 2)) 2)))\n(andmap identity tests))\n\n(check height-mismatch-count)", "entry_point": "height-mismatch-count", "signature": "(define (height-mismatch-count", "docstring": "Function Description:\nGiven two integer arrays 'heights' and 'expected', where 'expected' represents the heights\nof students in non-decreasing order, and 'heights' represents the current order of student heights,\nthis function returns the count of indices where heights[i] != expected[i].\n\nExamples:\n>>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n3\n>>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n5\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven two integer arrays 'heights' and 'expected', where 'expected' represents the heights\nof students in non-decreasing order, and 'heights' represents the current order of student heights,\nthis function returns the count of indices where heights[i] != expected[i].\n\nExamples:\n>>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n3\n>>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n5\n\n\n\n* Incomplete Code:\n(define (height-mismatch-count\n(define (count-mismatches lst1 lst2)\n(cond\n[(null? lst1) 0]\n[else\n[MASK]\n(count-mismatches (cdr lst1) (cdr lst2))\n(+ 1 (count-mismatches (cdr lst1) (cdr lst2))))]))\n(count-mismatches heights expected))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define (count-mismatches lst1 lst2)\n(cond\n[(null? lst1) 0]\n[else\n[MASK]\n(count-mismatches (cdr lst1) (cdr lst2))\n(+ 1 (count-mismatches (cdr lst1) (cdr lst2))))]))\n(count-mismatches heights expected))"}
{"task_id": "Racket/6-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\n;; shifting the remaining elements to the right. The array is modified in place.\n;;\n;; Examples:\n;; >>> duplicate-zeros([1 0 2 3 0 4 5 0])\n;; '(1 0 0 2 3 0 0 4)\n;; >>> duplicate-zeros([1 2 3])\n;; '(1 2 3)\n\n(define (duplicate-zeros arr)", "canonical_solution": "(define (process-list lst processed)\n(cond\n[(null? lst) (reverse processed)]\n[else\n(if (= 0 (car lst))\n(if (null? (cdr lst))\n(process-list '() (cons 0 processed))\n(process-list (cdr lst) (cons 0 (cons 0 processed))))\n(process-list (cdr lst) (cons (car lst) processed)))]))\n(take (process-list arr '()) (length arr)))", "test": ";; Test Cases\n(define (check duplicate-zeros)\n(define tests\n(list (check-equal? (duplicate-zeros (list 1 0 2 3 0 4 5 0)) (list 1 0 0 2 3 0 0 4))\n(check-equal? (duplicate-zeros (list 1 2 3)) (list 1 2 3))\n(check-equal? (duplicate-zeros (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0))\n(check-equal? (duplicate-zeros (list 0 1 7 6 0)) (list 0 0 1 7 6))\n(check-equal? (duplicate-zeros (list 8 4 5 0 0 0 0 7)) (list 8 4 5 0 0 0 0 0))))\n(andmap identity tests))\n\n(check duplicate-zeros)", "entry_point": "duplicate-zeros", "signature": "(define (duplicate-zeros", "docstring": "Function Description:\nGiven a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\nshifting the remaining elements to the right. The array is modified in place.\n\nExamples:\n>>> duplicate-zeros([1 0 2 3 0 4 5 0])\n'(1 0 0 2 3 0 0 4)\n>>> duplicate-zeros([1 2 3])\n'(1 2 3)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\nshifting the remaining elements to the right. The array is modified in place.\n\nExamples:\n>>> duplicate-zeros([1 0 2 3 0 4 5 0])\n'(1 0 0 2 3 0 0 4)\n>>> duplicate-zeros([1 2 3])\n'(1 2 3)\n\n\n\n* Incomplete Code:\n(define (duplicate-zeros\n(define (process-list lst processed)\n(cond\n[(null? lst) (reverse processed)]\n[MASK]\n(if (= 0 (car lst))\n(if (null? (cdr lst))\n(process-list '() (cons 0 processed))\n(process-list (cdr lst) (cons 0 (cons 0 processed))))\n(process-list (cdr lst) (cons (car lst) processed)))]))\n(take (process-list arr '()) (length arr)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (process-list lst processed)\n(cond\n[(null? lst) (reverse processed)]\n[MASK]\n(if (= 0 (car lst))\n(if (null? (cdr lst))\n(process-list '() (cons 0 processed))\n(process-list (cdr lst) (cons 0 (cons 0 processed))))\n(process-list (cdr lst) (cons (car lst) processed)))]))\n(take (process-list arr '()) (length arr)))"}
{"task_id": "Racket/6-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\n;; shifting the remaining elements to the right. The array is modified in place.\n;;\n;; Examples:\n;; >>> duplicate-zeros([1 0 2 3 0 4 5 0])\n;; '(1 0 0 2 3 0 0 4)\n;; >>> duplicate-zeros([1 2 3])\n;; '(1 2 3)\n\n(define (duplicate-zeros arr)", "canonical_solution": "(define (process-list lst processed)\n(cond\n[(null? lst) (reverse processed)]\n[else\n(if (= 0 (car lst))\n(if (null? (cdr lst))\n(process-list '() (cons 0 processed))\n(process-list (cdr lst) (cons 0 (cons 0 processed))))\n(process-list (cdr lst) (cons (car lst) processed)))]))\n(take (process-list arr '()) (length arr)))", "test": ";; Test Cases\n(define (check duplicate-zeros)\n(define tests\n(list (check-equal? (duplicate-zeros (list 1 0 2 3 0 4 5 0)) (list 1 0 0 2 3 0 0 4))\n(check-equal? (duplicate-zeros (list 1 2 3)) (list 1 2 3))\n(check-equal? (duplicate-zeros (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0))\n(check-equal? (duplicate-zeros (list 0 1 7 6 0)) (list 0 0 1 7 6))\n(check-equal? (duplicate-zeros (list 8 4 5 0 0 0 0 7)) (list 8 4 5 0 0 0 0 0))))\n(andmap identity tests))\n\n(check duplicate-zeros)", "entry_point": "duplicate-zeros", "signature": "(define (duplicate-zeros", "docstring": "Function Description:\nGiven a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\nshifting the remaining elements to the right. The array is modified in place.\n\nExamples:\n>>> duplicate-zeros([1 0 2 3 0 4 5 0])\n'(1 0 0 2 3 0 0 4)\n>>> duplicate-zeros([1 2 3])\n'(1 2 3)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\nshifting the remaining elements to the right. The array is modified in place.\n\nExamples:\n>>> duplicate-zeros([1 0 2 3 0 4 5 0])\n'(1 0 0 2 3 0 0 4)\n>>> duplicate-zeros([1 2 3])\n'(1 2 3)\n\n\n\n* Incomplete Code:\n(define (duplicate-zeros\n(define (process-list lst processed)\n[MASK]\n[(null? lst) (reverse processed)]\n[else\n(if (= 0 (car lst))\n(if (null? (cdr lst))\n(process-list '() (cons 0 processed))\n(process-list (cdr lst) (cons 0 (cons 0 processed))))\n(process-list (cdr lst) (cons (car lst) processed)))]))\n(take (process-list arr '()) (length arr)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (process-list lst processed)\n[MASK]\n[(null? lst) (reverse processed)]\n[else\n(if (= 0 (car lst))\n(if (null? (cdr lst))\n(process-list '() (cons 0 processed))\n(process-list (cdr lst) (cons 0 (cons 0 processed))))\n(process-list (cdr lst) (cons (car lst) processed)))]))\n(take (process-list arr '()) (length arr)))"}
{"task_id": "Racket/7-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of words 'words' and a string 'chars', representing a character set,\n;; this function calculates the sum of the lengths of the words in 'words' that can be\n;; formed using the letters in 'chars'. Each letter in 'chars' can only be used once\n;; per word.\n;;\n;; Examples:\n;; >>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n;; 6 (cat and hat can be formed)\n;; >>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n;; 10 (world and hello can be formed)\n\n(define (sum-of-words-you-know words chars)", "canonical_solution": "(define (char-count str)\n(foldl (lambda (char dict)\n(dict-set dict char (add1 (dict-ref dict char 0))))\n(make-immutable-hash)\n(string->list str)))\n\n(define chars-count (char-count chars))\n\n(define (can-form-word word)\n(let ([word-count (char-count word)])\n(andmap (lambda (char) (<= (dict-ref word-count char 0) (dict-ref chars-count char 0)))\n(string->list word))))\n\n(apply + (map string-length (filter can-form-word words))))", "test": "(define (check sum-of-words-you-know)\n(define tests\n(list (check-equal? (sum-of-words-you-know '(\"cat\" \"bt\" \"hat\" \"tree\") \"atach\") 6)\n(check-equal? (sum-of-words-you-know '(\"hello\" \"world\" \"leetcode\") \"welldonehoneyr\") 10)\n(check-equal? (sum-of-words-you-know '(\"apple\" \"orange\" \"banana\") \"aabbcc\") 0)\n(check-equal? (sum-of-words-you-know '(\"abc\" \"de\" \"fgh\") \"abcdefgh\") 8)\n(check-equal? (sum-of-words-you-know '(\"a\" \"b\" \"c\") \"abc\") 3)))\n(andmap identity tests))\n\n(check sum-of-words-you-know)", "entry_point": "sum-of-words-you-know", "signature": "(define (sum-of-words-you-know", "docstring": "Function Description:\nGiven a list of words 'words' and a string 'chars', representing a character set,\nthis function calculates the sum of the lengths of the words in 'words' that can be\nformed using the letters in 'chars'. Each letter in 'chars' can only be used once\nper word.\n\nExamples:\n>>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n6 (cat and hat can be formed)\n>>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n10 (world and hello can be formed)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a list of words 'words' and a string 'chars', representing a character set,\nthis function calculates the sum of the lengths of the words in 'words' that can be\nformed using the letters in 'chars'. Each letter in 'chars' can only be used once\nper word.\n\nExamples:\n>>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n6 (cat and hat can be formed)\n>>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n10 (world and hello can be formed)\n\n\n\n* Incomplete Code:\n(define (sum-of-words-you-know\n(define (char-count str)\n(foldl (lambda (char dict)\n(dict-set dict char (add1 (dict-ref dict char 0))))\n(make-immutable-hash)\n(string->list str)))\n\n(define chars-count (char-count chars))\n\n(define (can-form-word word)\n(let ([word-count (char-count word)])\n[MASK]\n(string->list word))))\n\n(apply + (map string-length (filter can-form-word words))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (char-count str)\n(foldl (lambda (char dict)\n(dict-set dict char (add1 (dict-ref dict char 0))))\n(make-immutable-hash)\n(string->list str)))\n\n(define chars-count (char-count chars))\n\n(define (can-form-word word)\n(let ([word-count (char-count word)])\n[MASK]\n(string->list word))))\n\n(apply + (map string-length (filter can-form-word words))))"}
{"task_id": "Racket/7-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of words 'words' and a string 'chars', representing a character set,\n;; this function calculates the sum of the lengths of the words in 'words' that can be\n;; formed using the letters in 'chars'. Each letter in 'chars' can only be used once\n;; per word.\n;;\n;; Examples:\n;; >>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n;; 6 (cat and hat can be formed)\n;; >>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n;; 10 (world and hello can be formed)\n\n(define (sum-of-words-you-know words chars)", "canonical_solution": "(define (char-count str)\n(foldl (lambda (char dict)\n(dict-set dict char (add1 (dict-ref dict char 0))))\n(make-immutable-hash)\n(string->list str)))\n\n(define chars-count (char-count chars))\n\n(define (can-form-word word)\n(let ([word-count (char-count word)])\n(andmap (lambda (char) (<= (dict-ref word-count char 0) (dict-ref chars-count char 0)))\n(string->list word))))\n\n(apply + (map string-length (filter can-form-word words))))", "test": "(define (check sum-of-words-you-know)\n(define tests\n(list (check-equal? (sum-of-words-you-know '(\"cat\" \"bt\" \"hat\" \"tree\") \"atach\") 6)\n(check-equal? (sum-of-words-you-know '(\"hello\" \"world\" \"leetcode\") \"welldonehoneyr\") 10)\n(check-equal? (sum-of-words-you-know '(\"apple\" \"orange\" \"banana\") \"aabbcc\") 0)\n(check-equal? (sum-of-words-you-know '(\"abc\" \"de\" \"fgh\") \"abcdefgh\") 8)\n(check-equal? (sum-of-words-you-know '(\"a\" \"b\" \"c\") \"abc\") 3)))\n(andmap identity tests))\n\n(check sum-of-words-you-know)", "entry_point": "sum-of-words-you-know", "signature": "(define (sum-of-words-you-know", "docstring": "Function Description:\nGiven a list of words 'words' and a string 'chars', representing a character set,\nthis function calculates the sum of the lengths of the words in 'words' that can be\nformed using the letters in 'chars'. Each letter in 'chars' can only be used once\nper word.\n\nExamples:\n>>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n6 (cat and hat can be formed)\n>>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n10 (world and hello can be formed)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a list of words 'words' and a string 'chars', representing a character set,\nthis function calculates the sum of the lengths of the words in 'words' that can be\nformed using the letters in 'chars'. Each letter in 'chars' can only be used once\nper word.\n\nExamples:\n>>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n6 (cat and hat can be formed)\n>>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n10 (world and hello can be formed)\n\n\n\n* Incomplete Code:\n(define (sum-of-words-you-know\n(define (char-count str)\n(foldl (lambda (char dict)\n[MASK]\n(make-immutable-hash)\n(string->list str)))\n\n(define chars-count (char-count chars))\n\n(define (can-form-word word)\n(let ([word-count (char-count word)])\n(andmap (lambda (char) (<= (dict-ref word-count char 0) (dict-ref chars-count char 0)))\n(string->list word))))\n\n(apply + (map string-length (filter can-form-word words))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (char-count str)\n(foldl (lambda (char dict)\n[MASK]\n(make-immutable-hash)\n(string->list str)))\n\n(define chars-count (char-count chars))\n\n(define (can-form-word word)\n(let ([word-count (char-count word)])\n(andmap (lambda (char) (<= (dict-ref word-count char 0) (dict-ref chars-count char 0)))\n(string->list word))))\n\n(apply + (map string-length (filter can-form-word words))))"}
{"task_id": "Racket/8-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\n;; distance[i] represents the distance between station i and station (i + 1) % n, this function\n;; returns the shortest distance between a start station and a destination station on the route.\n;; The bus can travel in both clockwise and counterclockwise directions.\n;;\n;; Examples:\n;; >>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n;; 4 (The shortest way from station 0 to 3 is directly 4)\n;; >>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n;; 3 (The shortest way from station 0 to 2 is 1 + 2)\n\n(define (shortest-distance-in-bus-route distance start destination)", "canonical_solution": "(define total-distance (apply + distance))\n(define (slice lst start end)\n(take (drop lst start) (- end start)))\n(define clockwise-distance\n(if (< start destination)\n(apply + (slice distance start destination))\n(apply + (append (slice distance start (length distance))\n(slice distance 0 destination)))))\n(min clockwise-distance (- total-distance clockwise-distance)))", "test": ";; Test Cases\n(define (check shortest-distance-in-bus-route)\n(define tests\n(list (check-equal? (shortest-distance-in-bus-route (list 1 2 3 4) 0 3) 4)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4) 0 2) 3)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4 5) 3 1) 5)\n(check-equal? (shortest-distance-in-bus-route (list 7 10 1 12 11 14 5 0) 7 2) 17)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4 5) 2 2) 0)))\n(andmap identity tests))\n\n(check shortest-distance-in-bus-route)", "entry_point": "shortest-distance-in-bus-route", "signature": "(define (shortest-distance-in-bus-route", "docstring": "Function Description:\nGiven a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\ndistance[i] represents the distance between station i and station (i + 1) % n, this function\nreturns the shortest distance between a start station and a destination station on the route.\nThe bus can travel in both clockwise and counterclockwise directions.\n\nExamples:\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n4 (The shortest way from station 0 to 3 is directly 4)\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n3 (The shortest way from station 0 to 2 is 1 + 2)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\ndistance[i] represents the distance between station i and station (i + 1) % n, this function\nreturns the shortest distance between a start station and a destination station on the route.\nThe bus can travel in both clockwise and counterclockwise directions.\n\nExamples:\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n4 (The shortest way from station 0 to 3 is directly 4)\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n3 (The shortest way from station 0 to 2 is 1 + 2)\n\n\n\n* Incomplete Code:\n(define (shortest-distance-in-bus-route\n(define total-distance (apply + distance))\n(define (slice lst start end)\n(take (drop lst start) (- end start)))\n(define clockwise-distance\n(if (< start destination)\n(apply + (slice distance start destination))\n(apply + (append (slice distance start (length distance))\n[MASK]\n(min clockwise-distance (- total-distance clockwise-distance)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define total-distance (apply + distance))\n(define (slice lst start end)\n(take (drop lst start) (- end start)))\n(define clockwise-distance\n(if (< start destination)\n(apply + (slice distance start destination))\n(apply + (append (slice distance start (length distance))\n[MASK]\n(min clockwise-distance (- total-distance clockwise-distance)))"}
{"task_id": "Racket/8-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\n;; distance[i] represents the distance between station i and station (i + 1) % n, this function\n;; returns the shortest distance between a start station and a destination station on the route.\n;; The bus can travel in both clockwise and counterclockwise directions.\n;;\n;; Examples:\n;; >>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n;; 4 (The shortest way from station 0 to 3 is directly 4)\n;; >>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n;; 3 (The shortest way from station 0 to 2 is 1 + 2)\n\n(define (shortest-distance-in-bus-route distance start destination)", "canonical_solution": "(define total-distance (apply + distance))\n(define (slice lst start end)\n(take (drop lst start) (- end start)))\n(define clockwise-distance\n(if (< start destination)\n(apply + (slice distance start destination))\n(apply + (append (slice distance start (length distance))\n(slice distance 0 destination)))))\n(min clockwise-distance (- total-distance clockwise-distance)))", "test": ";; Test Cases\n(define (check shortest-distance-in-bus-route)\n(define tests\n(list (check-equal? (shortest-distance-in-bus-route (list 1 2 3 4) 0 3) 4)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4) 0 2) 3)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4 5) 3 1) 5)\n(check-equal? (shortest-distance-in-bus-route (list 7 10 1 12 11 14 5 0) 7 2) 17)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4 5) 2 2) 0)))\n(andmap identity tests))\n\n(check shortest-distance-in-bus-route)", "entry_point": "shortest-distance-in-bus-route", "signature": "(define (shortest-distance-in-bus-route", "docstring": "Function Description:\nGiven a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\ndistance[i] represents the distance between station i and station (i + 1) % n, this function\nreturns the shortest distance between a start station and a destination station on the route.\nThe bus can travel in both clockwise and counterclockwise directions.\n\nExamples:\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n4 (The shortest way from station 0 to 3 is directly 4)\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n3 (The shortest way from station 0 to 2 is 1 + 2)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\ndistance[i] represents the distance between station i and station (i + 1) % n, this function\nreturns the shortest distance between a start station and a destination station on the route.\nThe bus can travel in both clockwise and counterclockwise directions.\n\nExamples:\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n4 (The shortest way from station 0 to 3 is directly 4)\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n3 (The shortest way from station 0 to 2 is 1 + 2)\n\n\n\n* Incomplete Code:\n(define (shortest-distance-in-bus-route\n(define total-distance (apply + distance))\n[MASK]\n(take (drop lst start) (- end start)))\n(define clockwise-distance\n(if (< start destination)\n(apply + (slice distance start destination))\n(apply + (append (slice distance start (length distance))\n(slice distance 0 destination)))))\n(min clockwise-distance (- total-distance clockwise-distance)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define total-distance (apply + distance))\n[MASK]\n(take (drop lst start) (- end start)))\n(define clockwise-distance\n(if (< start destination)\n(apply + (slice distance start destination))\n(apply + (append (slice distance start (length distance))\n(slice distance 0 destination)))))\n(min clockwise-distance (- total-distance clockwise-distance)))"}
{"task_id": "Racket/9-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array 'arr', this function counts the occurrence of each number in the array.\n;; It returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n;;\n;; Examples:\n;; >>> unique-frequency-count([1 2 2 1 1 3])\n;; #t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n;; >>> unique-frequency-count([1 2 2 3 3 3])\n;; #f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n(define (unique-frequency-count arr)", "canonical_solution": "(define (count-elements lst)\n(foldl (lambda (elem counts)\n(dict-set counts elem (add1 (dict-ref counts elem 0))))\n(make-immutable-hash)\nlst))\n\n(define element-counts (count-elements arr))\n(define frequencies (dict-values element-counts))\n(equal? (length frequencies) (length (remove-duplicates frequencies))))", "test": ";; Test Cases\n(define (check unique-frequency-count)\n(define tests\n(list (check-equal? (unique-frequency-count (list 1 2 2 1 1 3)) #t)\n(check-equal? (unique-frequency-count (list 1 2 2 3 3 3)) #t)\n(check-equal? (unique-frequency-count (list 3 5 7 9 11)) #f)\n(check-equal? (unique-frequency-count (list 4 4 4 4 4)) #t)\n(check-equal? (unique-frequency-count (list 1 2 2 3 3 4 4 4)) #f)))\n(andmap identity tests))\n\n(check unique-frequency-count)", "entry_point": "unique-frequency-count", "signature": "(define (unique-frequency-count", "docstring": "Function Description:\nGiven an integer array 'arr', this function counts the occurrence of each number in the array.\nIt returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n\nExamples:\n>>> unique-frequency-count([1 2 2 1 1 3])\n#t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n>>> unique-frequency-count([1 2 2 3 3 3])\n#f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an integer array 'arr', this function counts the occurrence of each number in the array.\nIt returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n\nExamples:\n>>> unique-frequency-count([1 2 2 1 1 3])\n#t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n>>> unique-frequency-count([1 2 2 3 3 3])\n#f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n\n\n* Incomplete Code:\n(define (unique-frequency-count\n(define (count-elements lst)\n(foldl (lambda (elem counts)\n(dict-set counts elem (add1 (dict-ref counts elem 0))))\n(make-immutable-hash)\nlst))\n\n(define element-counts (count-elements arr))\n(define frequencies (dict-values element-counts))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (count-elements lst)\n(foldl (lambda (elem counts)\n(dict-set counts elem (add1 (dict-ref counts elem 0))))\n(make-immutable-hash)\nlst))\n\n(define element-counts (count-elements arr))\n(define frequencies (dict-values element-counts))\n[MASK]"}
{"task_id": "Racket/9-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array 'arr', this function counts the occurrence of each number in the array.\n;; It returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n;;\n;; Examples:\n;; >>> unique-frequency-count([1 2 2 1 1 3])\n;; #t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n;; >>> unique-frequency-count([1 2 2 3 3 3])\n;; #f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n(define (unique-frequency-count arr)", "canonical_solution": "(define (count-elements lst)\n(foldl (lambda (elem counts)\n(dict-set counts elem (add1 (dict-ref counts elem 0))))\n(make-immutable-hash)\nlst))\n\n(define element-counts (count-elements arr))\n(define frequencies (dict-values element-counts))\n(equal? (length frequencies) (length (remove-duplicates frequencies))))", "test": ";; Test Cases\n(define (check unique-frequency-count)\n(define tests\n(list (check-equal? (unique-frequency-count (list 1 2 2 1 1 3)) #t)\n(check-equal? (unique-frequency-count (list 1 2 2 3 3 3)) #t)\n(check-equal? (unique-frequency-count (list 3 5 7 9 11)) #f)\n(check-equal? (unique-frequency-count (list 4 4 4 4 4)) #t)\n(check-equal? (unique-frequency-count (list 1 2 2 3 3 4 4 4)) #f)))\n(andmap identity tests))\n\n(check unique-frequency-count)", "entry_point": "unique-frequency-count", "signature": "(define (unique-frequency-count", "docstring": "Function Description:\nGiven an integer array 'arr', this function counts the occurrence of each number in the array.\nIt returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n\nExamples:\n>>> unique-frequency-count([1 2 2 1 1 3])\n#t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n>>> unique-frequency-count([1 2 2 3 3 3])\n#f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an integer array 'arr', this function counts the occurrence of each number in the array.\nIt returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n\nExamples:\n>>> unique-frequency-count([1 2 2 1 1 3])\n#t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n>>> unique-frequency-count([1 2 2 3 3 3])\n#f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n\n\n* Incomplete Code:\n(define (unique-frequency-count\n(define (count-elements lst)\n(foldl (lambda (elem counts)\n[MASK]\n(make-immutable-hash)\nlst))\n\n(define element-counts (count-elements arr))\n(define frequencies (dict-values element-counts))\n(equal? (length frequencies) (length (remove-duplicates frequencies))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (count-elements lst)\n(foldl (lambda (elem counts)\n[MASK]\n(make-immutable-hash)\nlst))\n\n(define element-counts (count-elements arr))\n(define frequencies (dict-values element-counts))\n(equal? (length frequencies) (length (remove-duplicates frequencies))))"}
{"task_id": "Racket/10-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an array 'position' representing the positions of 'n' chips, this function calculates\n;; the minimum cost to move all chips to the same position. Moving a chip from position[i] to\n;; position[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\n;; costs 1.\n;;\n;; Examples:\n;; >>> min-cost-to-move-chips([1 2 3])\n;; 1 (Move the chip at position 3 to position 1 or 2)\n;; >>> min-cost-to-move-chips([2 2 2 3 3])\n;; 2 (Move two chips at position 3 to position 2)\n\n(define (min-cost-to-move-chips position)", "canonical_solution": "(define (even-odd-counts lst)\n(foldl (lambda (pos counts)\n(if (even? pos)\n(cons (add1 (car counts)) (cdr counts))\n(cons (car counts) (add1 (cdr counts)))))\n'(0 . 0) lst))\n\n(define counts (even-odd-counts position))\n(min (car counts) (cdr counts)))", "test": ";; Test Cases\n(define (check min-cost-to-move-chips)\n(define tests\n(list (check-equal? (min-cost-to-move-chips (list 1 2 3)) 1)\n(check-equal? (min-cost-to-move-chips (list 2 2 2 3 3)) 2)\n(check-equal? (min-cost-to-move-chips (list 1 3 5 7 9)) 0)\n(check-equal? (min-cost-to-move-chips (list 10 3 3 3)) 1)\n(check-equal? (min-cost-to-move-chips (list 6 4 7 8 2)) 1)))\n(andmap identity tests))\n\n(check min-cost-to-move-chips)", "entry_point": "min-cost-to-move-chips", "signature": "(define (min-cost-to-move-chips", "docstring": "Function Description:\nGiven an array 'position' representing the positions of 'n' chips, this function calculates\nthe minimum cost to move all chips to the same position. Moving a chip from position[i] to\nposition[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\ncosts 1.\n\nExamples:\n>>> min-cost-to-move-chips([1 2 3])\n1 (Move the chip at position 3 to position 1 or 2)\n>>> min-cost-to-move-chips([2 2 2 3 3])\n2 (Move two chips at position 3 to position 2)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an array 'position' representing the positions of 'n' chips, this function calculates\nthe minimum cost to move all chips to the same position. Moving a chip from position[i] to\nposition[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\ncosts 1.\n\nExamples:\n>>> min-cost-to-move-chips([1 2 3])\n1 (Move the chip at position 3 to position 1 or 2)\n>>> min-cost-to-move-chips([2 2 2 3 3])\n2 (Move two chips at position 3 to position 2)\n\n\n\n* Incomplete Code:\n(define (min-cost-to-move-chips\n(define (even-odd-counts lst)\n[MASK]\n(if (even? pos)\n(cons (add1 (car counts)) (cdr counts))\n(cons (car counts) (add1 (cdr counts)))))\n'(0 . 0) lst))\n\n(define counts (even-odd-counts position))\n(min (car counts) (cdr counts)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define (even-odd-counts lst)\n[MASK]\n(if (even? pos)\n(cons (add1 (car counts)) (cdr counts))\n(cons (car counts) (add1 (cdr counts)))))\n'(0 . 0) lst))\n\n(define counts (even-odd-counts position))\n(min (car counts) (cdr counts)))"}
{"task_id": "Racket/10-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an array 'position' representing the positions of 'n' chips, this function calculates\n;; the minimum cost to move all chips to the same position. Moving a chip from position[i] to\n;; position[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\n;; costs 1.\n;;\n;; Examples:\n;; >>> min-cost-to-move-chips([1 2 3])\n;; 1 (Move the chip at position 3 to position 1 or 2)\n;; >>> min-cost-to-move-chips([2 2 2 3 3])\n;; 2 (Move two chips at position 3 to position 2)\n\n(define (min-cost-to-move-chips position)", "canonical_solution": "(define (even-odd-counts lst)\n(foldl (lambda (pos counts)\n(if (even? pos)\n(cons (add1 (car counts)) (cdr counts))\n(cons (car counts) (add1 (cdr counts)))))\n'(0 . 0) lst))\n\n(define counts (even-odd-counts position))\n(min (car counts) (cdr counts)))", "test": ";; Test Cases\n(define (check min-cost-to-move-chips)\n(define tests\n(list (check-equal? (min-cost-to-move-chips (list 1 2 3)) 1)\n(check-equal? (min-cost-to-move-chips (list 2 2 2 3 3)) 2)\n(check-equal? (min-cost-to-move-chips (list 1 3 5 7 9)) 0)\n(check-equal? (min-cost-to-move-chips (list 10 3 3 3)) 1)\n(check-equal? (min-cost-to-move-chips (list 6 4 7 8 2)) 1)))\n(andmap identity tests))\n\n(check min-cost-to-move-chips)", "entry_point": "min-cost-to-move-chips", "signature": "(define (min-cost-to-move-chips", "docstring": "Function Description:\nGiven an array 'position' representing the positions of 'n' chips, this function calculates\nthe minimum cost to move all chips to the same position. Moving a chip from position[i] to\nposition[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\ncosts 1.\n\nExamples:\n>>> min-cost-to-move-chips([1 2 3])\n1 (Move the chip at position 3 to position 1 or 2)\n>>> min-cost-to-move-chips([2 2 2 3 3])\n2 (Move two chips at position 3 to position 2)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an array 'position' representing the positions of 'n' chips, this function calculates\nthe minimum cost to move all chips to the same position. Moving a chip from position[i] to\nposition[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\ncosts 1.\n\nExamples:\n>>> min-cost-to-move-chips([1 2 3])\n1 (Move the chip at position 3 to position 1 or 2)\n>>> min-cost-to-move-chips([2 2 2 3 3])\n2 (Move two chips at position 3 to position 2)\n\n\n\n* Incomplete Code:\n(define (min-cost-to-move-chips\n(define (even-odd-counts lst)\n(foldl (lambda (pos counts)\n(if (even? pos)\n[MASK]\n(cons (car counts) (add1 (cdr counts)))))\n'(0 . 0) lst))\n\n(define counts (even-odd-counts position))\n(min (car counts) (cdr counts)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define (even-odd-counts lst)\n(foldl (lambda (pos counts)\n(if (even? pos)\n[MASK]\n(cons (car counts) (add1 (cdr counts)))))\n'(0 . 0) lst))\n\n(define counts (even-odd-counts position))\n(min (car counts) (cdr counts)))"}
{"task_id": "Racket/11-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a non-decreasing ordered array of integers, where exactly one integer appears more\n;; than 25% of the time, this function finds and returns that integer.\n;;\n;; Examples:\n;; >>> find-element-over-quarter([1 2 2 3 3 3 3])\n;; 3 (3 appears 4 times which is more than 25% of 7 elements)\n;; >>> find-element-over-quarter([1 1 2 2 3])\n;; 1 (1 appears 2 times which is more than 25% of 5 elements)\n\n(define (find-element-over-quarter arr)", "canonical_solution": "(define quarter-length (/ (length arr) 4))\n\n(define (iter lst count prev-elem)\n(cond\n[(null? lst) prev-elem]\n[else\n(let ([current-elem (car lst)])\n(if (equal? current-elem prev-elem)\n(if (> (add1 count) quarter-length)\ncurrent-elem\n(iter (cdr lst) (add1 count) current-elem))\n(iter (cdr lst) 1 current-elem)))]))\n\n(iter (cdr arr) 1 (car arr)))", "test": ";; Test Cases\n(define (check find-element-over-quarter)\n(define tests\n(list (check-equal? (find-element-over-quarter (list 1 2 2 3 4 5 6)) 2)\n(check-equal? (find-element-over-quarter (list 1 1 2 2 3)) 1)\n(check-equal? (find-element-over-quarter (list 4 4 4 5 6 7 9 10)) 4)\n(check-equal? (find-element-over-quarter (list 1 1 1 1 2 3 4)) 1)\n(check-equal? (find-element-over-quarter (list 7 7 8 9 10 11 12)) 7)))\n(andmap identity tests))\n\n(check find-element-over-quarter)", "entry_point": "find-element-over-quarter", "signature": "(define (find-element-over-quarter", "docstring": "Function Description:\nGiven a non-decreasing ordered array of integers, where exactly one integer appears more\nthan 25% of the time, this function finds and returns that integer.\n\nExamples:\n>>> find-element-over-quarter([1 2 2 3 3 3 3])\n3 (3 appears 4 times which is more than 25% of 7 elements)\n>>> find-element-over-quarter([1 1 2 2 3])\n1 (1 appears 2 times which is more than 25% of 5 elements)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a non-decreasing ordered array of integers, where exactly one integer appears more\nthan 25% of the time, this function finds and returns that integer.\n\nExamples:\n>>> find-element-over-quarter([1 2 2 3 3 3 3])\n3 (3 appears 4 times which is more than 25% of 7 elements)\n>>> find-element-over-quarter([1 1 2 2 3])\n1 (1 appears 2 times which is more than 25% of 5 elements)\n\n\n\n* Incomplete Code:\n(define (find-element-over-quarter\n(define quarter-length (/ (length arr) 4))\n\n(define (iter lst count prev-elem)\n(cond\n[(null? lst) prev-elem]\n[else\n(let ([current-elem (car lst)])\n(if (equal? current-elem prev-elem)\n(if (> (add1 count) quarter-length)\ncurrent-elem\n(iter (cdr lst) (add1 count) current-elem))\n[MASK]\n\n(iter (cdr arr) 1 (car arr)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define quarter-length (/ (length arr) 4))\n\n(define (iter lst count prev-elem)\n(cond\n[(null? lst) prev-elem]\n[else\n(let ([current-elem (car lst)])\n(if (equal? current-elem prev-elem)\n(if (> (add1 count) quarter-length)\ncurrent-elem\n(iter (cdr lst) (add1 count) current-elem))\n[MASK]\n\n(iter (cdr arr) 1 (car arr)))"}
{"task_id": "Racket/11-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a non-decreasing ordered array of integers, where exactly one integer appears more\n;; than 25% of the time, this function finds and returns that integer.\n;;\n;; Examples:\n;; >>> find-element-over-quarter([1 2 2 3 3 3 3])\n;; 3 (3 appears 4 times which is more than 25% of 7 elements)\n;; >>> find-element-over-quarter([1 1 2 2 3])\n;; 1 (1 appears 2 times which is more than 25% of 5 elements)\n\n(define (find-element-over-quarter arr)", "canonical_solution": "(define quarter-length (/ (length arr) 4))\n\n(define (iter lst count prev-elem)\n(cond\n[(null? lst) prev-elem]\n[else\n(let ([current-elem (car lst)])\n(if (equal? current-elem prev-elem)\n(if (> (add1 count) quarter-length)\ncurrent-elem\n(iter (cdr lst) (add1 count) current-elem))\n(iter (cdr lst) 1 current-elem)))]))\n\n(iter (cdr arr) 1 (car arr)))", "test": ";; Test Cases\n(define (check find-element-over-quarter)\n(define tests\n(list (check-equal? (find-element-over-quarter (list 1 2 2 3 4 5 6)) 2)\n(check-equal? (find-element-over-quarter (list 1 1 2 2 3)) 1)\n(check-equal? (find-element-over-quarter (list 4 4 4 5 6 7 9 10)) 4)\n(check-equal? (find-element-over-quarter (list 1 1 1 1 2 3 4)) 1)\n(check-equal? (find-element-over-quarter (list 7 7 8 9 10 11 12)) 7)))\n(andmap identity tests))\n\n(check find-element-over-quarter)", "entry_point": "find-element-over-quarter", "signature": "(define (find-element-over-quarter", "docstring": "Function Description:\nGiven a non-decreasing ordered array of integers, where exactly one integer appears more\nthan 25% of the time, this function finds and returns that integer.\n\nExamples:\n>>> find-element-over-quarter([1 2 2 3 3 3 3])\n3 (3 appears 4 times which is more than 25% of 7 elements)\n>>> find-element-over-quarter([1 1 2 2 3])\n1 (1 appears 2 times which is more than 25% of 5 elements)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a non-decreasing ordered array of integers, where exactly one integer appears more\nthan 25% of the time, this function finds and returns that integer.\n\nExamples:\n>>> find-element-over-quarter([1 2 2 3 3 3 3])\n3 (3 appears 4 times which is more than 25% of 7 elements)\n>>> find-element-over-quarter([1 1 2 2 3])\n1 (1 appears 2 times which is more than 25% of 5 elements)\n\n\n\n* Incomplete Code:\n(define (find-element-over-quarter\n(define quarter-length (/ (length arr) 4))\n\n(define (iter lst count prev-elem)\n(cond\n[(null? lst) prev-elem]\n[MASK]\n(let ([current-elem (car lst)])\n(if (equal? current-elem prev-elem)\n(if (> (add1 count) quarter-length)\ncurrent-elem\n(iter (cdr lst) (add1 count) current-elem))\n(iter (cdr lst) 1 current-elem)))]))\n\n(iter (cdr arr) 1 (car arr)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define quarter-length (/ (length arr) 4))\n\n(define (iter lst count prev-elem)\n(cond\n[(null? lst) prev-elem]\n[MASK]\n(let ([current-elem (car lst)])\n(if (equal? current-elem prev-elem)\n(if (> (add1 count) quarter-length)\ncurrent-elem\n(iter (cdr lst) (add1 count) current-elem))\n(iter (cdr lst) 1 current-elem)))]))\n\n(iter (cdr arr) 1 (car arr)))"}
{"task_id": "Racket/12-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a string, this function extracts all the numbers from the string and returns them as a list.\n;; It considers consecutive digits as a single number.\n;;\n;; Examples:\n;; >>> extract-numbers-from-string(\"abc123def456\")\n;; '(123 456)\n;; >>> extract-numbers-from-string(\"123abc45def\")\n;; '(123 45)\n\n(define (extract-numbers-from-string str)", "canonical_solution": "(define (collect-digits chars)\n(let loop ([chars chars] [current '()] [result '()])\n(cond\n[(null? chars) (if (null? current) result (reverse (cons (list->string (reverse current)) result)))]\n[(char-numeric? (car chars)) (loop (cdr chars) (cons (car chars) current) result)]\n[else (loop (cdr chars) '() (if (null? current) result (reverse (cons (list->string (reverse current)) result))))])))\n(map string->number (collect-digits (string->list str))))", "test": "(define (check extract-numbers-from-string)\n(define tests\n(list (check-equal? (extract-numbers-from-string \"abc123def456\") '(123 456))\n(check-equal? (extract-numbers-from-string \"123abc45def\") '(123 45))\n(check-equal? (extract-numbers-from-string \"no numbers\") '())\n(check-equal? (extract-numbers-from-string \"100 300\") '(100 300))\n(check-equal? (extract-numbers-from-string \"abc123xyz\") '(123))))\n(andmap identity tests))\n\n(check extract-numbers-from-string)", "entry_point": "extract-numbers-from-string", "signature": "(define (extract-numbers-from-string", "docstring": "Function Description:\nGiven a string, this function extracts all the numbers from the string and returns them as a list.\nIt considers consecutive digits as a single number.\n\nExamples:\n>>> extract-numbers-from-string(\"abc123def456\")\n'(123 456)\n>>> extract-numbers-from-string(\"123abc45def\")\n'(123 45)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a string, this function extracts all the numbers from the string and returns them as a list.\nIt considers consecutive digits as a single number.\n\nExamples:\n>>> extract-numbers-from-string(\"abc123def456\")\n'(123 456)\n>>> extract-numbers-from-string(\"123abc45def\")\n'(123 45)\n\n\n\n* Incomplete Code:\n(define (extract-numbers-from-string\n(define (collect-digits chars)\n(let loop ([chars chars] [current '()] [result '()])\n(cond\n[MASK]\n[(char-numeric? (car chars)) (loop (cdr chars) (cons (car chars) current) result)]\n[else (loop (cdr chars) '() (if (null? current) result (reverse (cons (list->string (reverse current)) result))))])))\n(map string->number (collect-digits (string->list str))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (collect-digits chars)\n(let loop ([chars chars] [current '()] [result '()])\n(cond\n[MASK]\n[(char-numeric? (car chars)) (loop (cdr chars) (cons (car chars) current) result)]\n[else (loop (cdr chars) '() (if (null? current) result (reverse (cons (list->string (reverse current)) result))))])))\n(map string->number (collect-digits (string->list str))))"}
{"task_id": "Racket/12-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a string, this function extracts all the numbers from the string and returns them as a list.\n;; It considers consecutive digits as a single number.\n;;\n;; Examples:\n;; >>> extract-numbers-from-string(\"abc123def456\")\n;; '(123 456)\n;; >>> extract-numbers-from-string(\"123abc45def\")\n;; '(123 45)\n\n(define (extract-numbers-from-string str)", "canonical_solution": "(define (collect-digits chars)\n(let loop ([chars chars] [current '()] [result '()])\n(cond\n[(null? chars) (if (null? current) result (reverse (cons (list->string (reverse current)) result)))]\n[(char-numeric? (car chars)) (loop (cdr chars) (cons (car chars) current) result)]\n[else (loop (cdr chars) '() (if (null? current) result (reverse (cons (list->string (reverse current)) result))))])))\n(map string->number (collect-digits (string->list str))))", "test": "(define (check extract-numbers-from-string)\n(define tests\n(list (check-equal? (extract-numbers-from-string \"abc123def456\") '(123 456))\n(check-equal? (extract-numbers-from-string \"123abc45def\") '(123 45))\n(check-equal? (extract-numbers-from-string \"no numbers\") '())\n(check-equal? (extract-numbers-from-string \"100 300\") '(100 300))\n(check-equal? (extract-numbers-from-string \"abc123xyz\") '(123))))\n(andmap identity tests))\n\n(check extract-numbers-from-string)", "entry_point": "extract-numbers-from-string", "signature": "(define (extract-numbers-from-string", "docstring": "Function Description:\nGiven a string, this function extracts all the numbers from the string and returns them as a list.\nIt considers consecutive digits as a single number.\n\nExamples:\n>>> extract-numbers-from-string(\"abc123def456\")\n'(123 456)\n>>> extract-numbers-from-string(\"123abc45def\")\n'(123 45)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a string, this function extracts all the numbers from the string and returns them as a list.\nIt considers consecutive digits as a single number.\n\nExamples:\n>>> extract-numbers-from-string(\"abc123def456\")\n'(123 456)\n>>> extract-numbers-from-string(\"123abc45def\")\n'(123 45)\n\n\n\n* Incomplete Code:\n(define (extract-numbers-from-string\n(define (collect-digits chars)\n(let loop ([chars chars] [current '()] [result '()])\n(cond\n[(null? chars) (if (null? current) result (reverse (cons (list->string (reverse current)) result)))]\n[MASK]\n[else (loop (cdr chars) '() (if (null? current) result (reverse (cons (list->string (reverse current)) result))))])))\n(map string->number (collect-digits (string->list str))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (collect-digits chars)\n(let loop ([chars chars] [current '()] [result '()])\n(cond\n[(null? chars) (if (null? current) result (reverse (cons (list->string (reverse current)) result)))]\n[MASK]\n[else (loop (cdr chars) '() (if (null? current) result (reverse (cons (list->string (reverse current)) result))))])))\n(map string->number (collect-digits (string->list str))))"}
{"task_id": "Racket/13-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of numbers, this function checks if the elements are strictly monotonic.\n;; Strictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n;;\n;; Examples:\n;; >>> is-strictly-monotonic([1 2 3 4 5])\n;; #t (Strictly increasing)\n;; >>> is-strictly-monotonic([5 4 3 2 1])\n;; #t (Strictly decreasing)\n;; >>> is-strictly-monotonic([1 2 2 3 4])\n;; #f (Not strictly monotonic)\n\n(define (is-strictly-monotonic lst)", "canonical_solution": "(define (check-direction lst increasing)\n(cond\n[(or (null? lst) (null? (cdr lst))) #t]\n[else\n(let ([current (car lst)]\n[next (cadr lst)])\n(and (if increasing (< current next) (> current next))\n(check-direction (cdr lst) increasing)))]))\n(or (check-direction lst #t) (check-direction lst #f)))", "test": "(define (check is-strictly-monotonic)\n(define tests\n(list (check-equal? (is-strictly-monotonic (list 1 2 3 4 5)) #t)\n(check-equal? (is-strictly-monotonic (list 5 4 3 2 1)) #t)\n(check-equal? (is-strictly-monotonic (list 1 2 2 3 4)) #f)\n(check-equal? (is-strictly-monotonic (list 1)) #t)\n(check-equal? (is-strictly-monotonic (list 3 2 1 2 3)) #f)))\n(andmap identity tests))\n\n(check is-strictly-monotonic)", "entry_point": "is-strictly-monotonic", "signature": "(define (is-strictly-monotonic", "docstring": "Function Description:\nGiven a list of numbers, this function checks if the elements are strictly monotonic.\nStrictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n\nExamples:\n>>> is-strictly-monotonic([1 2 3 4 5])\n#t (Strictly increasing)\n>>> is-strictly-monotonic([5 4 3 2 1])\n#t (Strictly decreasing)\n>>> is-strictly-monotonic([1 2 2 3 4])\n#f (Not strictly monotonic)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a list of numbers, this function checks if the elements are strictly monotonic.\nStrictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n\nExamples:\n>>> is-strictly-monotonic([1 2 3 4 5])\n#t (Strictly increasing)\n>>> is-strictly-monotonic([5 4 3 2 1])\n#t (Strictly decreasing)\n>>> is-strictly-monotonic([1 2 2 3 4])\n#f (Not strictly monotonic)\n\n\n\n* Incomplete Code:\n(define (is-strictly-monotonic\n[MASK]\n(cond\n[(or (null? lst) (null? (cdr lst))) #t]\n[else\n(let ([current (car lst)]\n[next (cadr lst)])\n(and (if increasing (< current next) (> current next))\n(check-direction (cdr lst) increasing)))]))\n(or (check-direction lst #t) (check-direction lst #f)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n(cond\n[(or (null? lst) (null? (cdr lst))) #t]\n[else\n(let ([current (car lst)]\n[next (cadr lst)])\n(and (if increasing (< current next) (> current next))\n(check-direction (cdr lst) increasing)))]))\n(or (check-direction lst #t) (check-direction lst #f)))"}
{"task_id": "Racket/13-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of numbers, this function checks if the elements are strictly monotonic.\n;; Strictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n;;\n;; Examples:\n;; >>> is-strictly-monotonic([1 2 3 4 5])\n;; #t (Strictly increasing)\n;; >>> is-strictly-monotonic([5 4 3 2 1])\n;; #t (Strictly decreasing)\n;; >>> is-strictly-monotonic([1 2 2 3 4])\n;; #f (Not strictly monotonic)\n\n(define (is-strictly-monotonic lst)", "canonical_solution": "(define (check-direction lst increasing)\n(cond\n[(or (null? lst) (null? (cdr lst))) #t]\n[else\n(let ([current (car lst)]\n[next (cadr lst)])\n(and (if increasing (< current next) (> current next))\n(check-direction (cdr lst) increasing)))]))\n(or (check-direction lst #t) (check-direction lst #f)))", "test": "(define (check is-strictly-monotonic)\n(define tests\n(list (check-equal? (is-strictly-monotonic (list 1 2 3 4 5)) #t)\n(check-equal? (is-strictly-monotonic (list 5 4 3 2 1)) #t)\n(check-equal? (is-strictly-monotonic (list 1 2 2 3 4)) #f)\n(check-equal? (is-strictly-monotonic (list 1)) #t)\n(check-equal? (is-strictly-monotonic (list 3 2 1 2 3)) #f)))\n(andmap identity tests))\n\n(check is-strictly-monotonic)", "entry_point": "is-strictly-monotonic", "signature": "(define (is-strictly-monotonic", "docstring": "Function Description:\nGiven a list of numbers, this function checks if the elements are strictly monotonic.\nStrictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n\nExamples:\n>>> is-strictly-monotonic([1 2 3 4 5])\n#t (Strictly increasing)\n>>> is-strictly-monotonic([5 4 3 2 1])\n#t (Strictly decreasing)\n>>> is-strictly-monotonic([1 2 2 3 4])\n#f (Not strictly monotonic)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a list of numbers, this function checks if the elements are strictly monotonic.\nStrictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n\nExamples:\n>>> is-strictly-monotonic([1 2 3 4 5])\n#t (Strictly increasing)\n>>> is-strictly-monotonic([5 4 3 2 1])\n#t (Strictly decreasing)\n>>> is-strictly-monotonic([1 2 2 3 4])\n#f (Not strictly monotonic)\n\n\n\n* Incomplete Code:\n(define (is-strictly-monotonic\n(define (check-direction lst increasing)\n(cond\n[(or (null? lst) (null? (cdr lst))) #t]\n[MASK]\n(let ([current (car lst)]\n[next (cadr lst)])\n(and (if increasing (< current next) (> current next))\n(check-direction (cdr lst) increasing)))]))\n(or (check-direction lst #t) (check-direction lst #f)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (check-direction lst increasing)\n(cond\n[(or (null? lst) (null? (cdr lst))) #t]\n[MASK]\n(let ([current (car lst)]\n[next (cadr lst)])\n(and (if increasing (< current next) (> current next))\n(check-direction (cdr lst) increasing)))]))\n(or (check-direction lst #t) (check-direction lst #f)))"}
{"task_id": "Racket/14-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array 'arr', this function replaces each element with its rank after sorting.\n;; The rank represents the magnitude of an element with the following rules:\n;; - Ranking starts from 1.\n;; - Larger elements have larger ranks. Equal elements have the same rank.\n;; - Each number's rank should be as small as possible.\n;;\n;; Examples:\n;; >>> replace-elements-with-ranks([40, 10, 20, 30])\n;; '(4 1 2 3)\n;; >>> replace-elements-with-ranks([100, 100, 100])\n;; '(1 1 1)\n\n(define (replace-elements-with-ranks arr)", "canonical_solution": "(define sorted-unique (remove-duplicates (sort arr <)))\n(define rank-dict (for/fold ([dict (make-immutable-hash)]) ([elem (in-list sorted-unique)] [i (in-naturals 1)])\n(dict-set dict elem i)))\n(map (lambda (elem) (dict-ref rank-dict elem)) arr))", "test": "(define (check replace-elements-with-ranks)\n(define tests\n(list (check-equal? (replace-elements-with-ranks (list 40 10 20 30)) '(4 1 2 3))\n(check-equal? (replace-elements-with-ranks (list 100 100 100)) '(1 1 1))\n(check-equal? (replace-elements-with-ranks (list 5 5 6 7)) '(1 1 2 3))\n(check-equal? (replace-elements-with-ranks (list 10 20 20 30)) '(1 2 2 3))\n(check-equal? (replace-elements-with-ranks (list 7 5 6 7)) '(3 1 2 3))))\n(andmap identity tests))\n\n(check replace-elements-with-ranks)", "entry_point": "replace-elements-with-ranks", "signature": "(define (replace-elements-with-ranks", "docstring": "Function Description:\nGiven an integer array 'arr', this function replaces each element with its rank after sorting.\nThe rank represents the magnitude of an element with the following rules:\n- Ranking starts from 1.\n- Larger elements have larger ranks. Equal elements have the same rank.\n- Each number's rank should be as small as possible.\n\nExamples:\n>>> replace-elements-with-ranks([40, 10, 20, 30])\n'(4 1 2 3)\n>>> replace-elements-with-ranks([100, 100, 100])\n'(1 1 1)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an integer array 'arr', this function replaces each element with its rank after sorting.\nThe rank represents the magnitude of an element with the following rules:\n- Ranking starts from 1.\n- Larger elements have larger ranks. Equal elements have the same rank.\n- Each number's rank should be as small as possible.\n\nExamples:\n>>> replace-elements-with-ranks([40, 10, 20, 30])\n'(4 1 2 3)\n>>> replace-elements-with-ranks([100, 100, 100])\n'(1 1 1)\n\n\n\n* Incomplete Code:\n(define (replace-elements-with-ranks\n[MASK]\n(define rank-dict (for/fold ([dict (make-immutable-hash)]) ([elem (in-list sorted-unique)] [i (in-naturals 1)])\n(dict-set dict elem i)))\n(map (lambda (elem) (dict-ref rank-dict elem)) arr))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(define rank-dict (for/fold ([dict (make-immutable-hash)]) ([elem (in-list sorted-unique)] [i (in-naturals 1)])\n(dict-set dict elem i)))\n(map (lambda (elem) (dict-ref rank-dict elem)) arr))"}
{"task_id": "Racket/14-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array 'arr', this function replaces each element with its rank after sorting.\n;; The rank represents the magnitude of an element with the following rules:\n;; - Ranking starts from 1.\n;; - Larger elements have larger ranks. Equal elements have the same rank.\n;; - Each number's rank should be as small as possible.\n;;\n;; Examples:\n;; >>> replace-elements-with-ranks([40, 10, 20, 30])\n;; '(4 1 2 3)\n;; >>> replace-elements-with-ranks([100, 100, 100])\n;; '(1 1 1)\n\n(define (replace-elements-with-ranks arr)", "canonical_solution": "(define sorted-unique (remove-duplicates (sort arr <)))\n(define rank-dict (for/fold ([dict (make-immutable-hash)]) ([elem (in-list sorted-unique)] [i (in-naturals 1)])\n(dict-set dict elem i)))\n(map (lambda (elem) (dict-ref rank-dict elem)) arr))", "test": "(define (check replace-elements-with-ranks)\n(define tests\n(list (check-equal? (replace-elements-with-ranks (list 40 10 20 30)) '(4 1 2 3))\n(check-equal? (replace-elements-with-ranks (list 100 100 100)) '(1 1 1))\n(check-equal? (replace-elements-with-ranks (list 5 5 6 7)) '(1 1 2 3))\n(check-equal? (replace-elements-with-ranks (list 10 20 20 30)) '(1 2 2 3))\n(check-equal? (replace-elements-with-ranks (list 7 5 6 7)) '(3 1 2 3))))\n(andmap identity tests))\n\n(check replace-elements-with-ranks)", "entry_point": "replace-elements-with-ranks", "signature": "(define (replace-elements-with-ranks", "docstring": "Function Description:\nGiven an integer array 'arr', this function replaces each element with its rank after sorting.\nThe rank represents the magnitude of an element with the following rules:\n- Ranking starts from 1.\n- Larger elements have larger ranks. Equal elements have the same rank.\n- Each number's rank should be as small as possible.\n\nExamples:\n>>> replace-elements-with-ranks([40, 10, 20, 30])\n'(4 1 2 3)\n>>> replace-elements-with-ranks([100, 100, 100])\n'(1 1 1)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven an integer array 'arr', this function replaces each element with its rank after sorting.\nThe rank represents the magnitude of an element with the following rules:\n- Ranking starts from 1.\n- Larger elements have larger ranks. Equal elements have the same rank.\n- Each number's rank should be as small as possible.\n\nExamples:\n>>> replace-elements-with-ranks([40, 10, 20, 30])\n'(4 1 2 3)\n>>> replace-elements-with-ranks([100, 100, 100])\n'(1 1 1)\n\n\n\n* Incomplete Code:\n(define (replace-elements-with-ranks\n(define sorted-unique (remove-duplicates (sort arr <)))\n[MASK]\n(dict-set dict elem i)))\n(map (lambda (elem) (dict-ref rank-dict elem)) arr))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define sorted-unique (remove-duplicates (sort arr <)))\n[MASK]\n(dict-set dict elem i)))\n(map (lambda (elem) (dict-ref rank-dict elem)) arr))"}
{"task_id": "Racket/17-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\n;; in 'nums', or returns the index where it would be if it were inserted in order.\n;;\n;; Examples:\n;; >>> find-or-insert-index([1 3 5 6] 5)\n;; 2 (Target 5 found at index 2)\n;; >>> find-or-insert-index([1 3 5 6] 2)\n;; 1 (Target 2 would be inserted at index 1)\n\n(define (find-or-insert-index nums target)", "canonical_solution": "(define (find-index lst elem index)\n(cond\n[(null? lst) index]\n[(<= elem (car lst)) index]\n[else (find-index (cdr lst) elem (add1 index))]))\n\n(find-index nums target 0))", "test": "(define (check find-or-insert-index)\n(define tests\n(list (check-equal? (find-or-insert-index (list 1 3 5 6) 5) 2)\n(check-equal? (find-or-insert-index (list 1 3 5 6) 2) 1)\n(check-equal? (find-or-insert-index (list 1 3 5 7) 6) 3)\n(check-equal? (find-or-insert-index (list 1 3 4 6 8 10) 5) 3)\n(check-equal? (find-or-insert-index '() 1) 0)))\n(andmap identity tests))\n\n(check find-or-insert-index)", "entry_point": "find-or-insert-index", "signature": "(define (find-or-insert-index", "docstring": "Function Description:\nGiven a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\nin 'nums', or returns the index where it would be if it were inserted in order.\n\nExamples:\n>>> find-or-insert-index([1 3 5 6] 5)\n2 (Target 5 found at index 2)\n>>> find-or-insert-index([1 3 5 6] 2)\n1 (Target 2 would be inserted at index 1)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\nin 'nums', or returns the index where it would be if it were inserted in order.\n\nExamples:\n>>> find-or-insert-index([1 3 5 6] 5)\n2 (Target 5 found at index 2)\n>>> find-or-insert-index([1 3 5 6] 2)\n1 (Target 2 would be inserted at index 1)\n\n\n\n* Incomplete Code:\n(define (find-or-insert-index\n(define (find-index lst elem index)\n(cond\n[MASK]\n[(<= elem (car lst)) index]\n[else (find-index (cdr lst) elem (add1 index))]))\n\n(find-index nums target 0))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define (find-index lst elem index)\n(cond\n[MASK]\n[(<= elem (car lst)) index]\n[else (find-index (cdr lst) elem (add1 index))]))\n\n(find-index nums target 0))"}
{"task_id": "Racket/17-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\n;; in 'nums', or returns the index where it would be if it were inserted in order.\n;;\n;; Examples:\n;; >>> find-or-insert-index([1 3 5 6] 5)\n;; 2 (Target 5 found at index 2)\n;; >>> find-or-insert-index([1 3 5 6] 2)\n;; 1 (Target 2 would be inserted at index 1)\n\n(define (find-or-insert-index nums target)", "canonical_solution": "(define (find-index lst elem index)\n(cond\n[(null? lst) index]\n[(<= elem (car lst)) index]\n[else (find-index (cdr lst) elem (add1 index))]))\n\n(find-index nums target 0))", "test": "(define (check find-or-insert-index)\n(define tests\n(list (check-equal? (find-or-insert-index (list 1 3 5 6) 5) 2)\n(check-equal? (find-or-insert-index (list 1 3 5 6) 2) 1)\n(check-equal? (find-or-insert-index (list 1 3 5 7) 6) 3)\n(check-equal? (find-or-insert-index (list 1 3 4 6 8 10) 5) 3)\n(check-equal? (find-or-insert-index '() 1) 0)))\n(andmap identity tests))\n\n(check find-or-insert-index)", "entry_point": "find-or-insert-index", "signature": "(define (find-or-insert-index", "docstring": "Function Description:\nGiven a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\nin 'nums', or returns the index where it would be if it were inserted in order.\n\nExamples:\n>>> find-or-insert-index([1 3 5 6] 5)\n2 (Target 5 found at index 2)\n>>> find-or-insert-index([1 3 5 6] 2)\n1 (Target 2 would be inserted at index 1)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\nin 'nums', or returns the index where it would be if it were inserted in order.\n\nExamples:\n>>> find-or-insert-index([1 3 5 6] 5)\n2 (Target 5 found at index 2)\n>>> find-or-insert-index([1 3 5 6] 2)\n1 (Target 2 would be inserted at index 1)\n\n\n\n* Incomplete Code:\n(define (find-or-insert-index\n(define (find-index lst elem index)\n[MASK]\n[(null? lst) index]\n[(<= elem (car lst)) index]\n[else (find-index (cdr lst) elem (add1 index))]))\n\n(find-index nums target 0))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define (find-index lst elem index)\n[MASK]\n[(null? lst) index]\n[(<= elem (car lst)) index]\n[else (find-index (cdr lst) elem (add1 index))]))\n\n(find-index nums target 0))"}
{"task_id": "Racket/19-0-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a non-empty array, this function returns the third largest number in the array.\n;; If the third largest number does not exist, it returns the largest number in the array.\n;;\n;; Examples:\n;; >>> third-largest-number([2 3 1])\n;; 1 (The third largest number is 1)\n;; >>> third-largest-number([1 2])\n;; 2 (The third largest number does not exist, return the largest number)\n\n(define (third-largest-number nums)", "canonical_solution": "(define sorted-unique (sort (remove-duplicates nums) >))\n(if (>= (length sorted-unique) 3)\n(list-ref sorted-unique 2)\n(car sorted-unique)))", "test": "(define (check third-largest-number)\n(define tests\n(list (check-equal? (third-largest-number (list 2 3 1)) 1)\n(check-equal? (third-largest-number (list 1 2)) 2)\n(check-equal? (third-largest-number (list 5 2 4)) 2)\n(check-equal? (third-largest-number (list 10 10 10)) 10)\n(check-equal? (third-largest-number (list 7 6 5 4)) 5)))\n(andmap identity tests))\n\n(check third-largest-number)", "entry_point": "third-largest-number", "signature": "(define (third-largest-number", "docstring": "Function Description:\nGiven a non-empty array, this function returns the third largest number in the array.\nIf the third largest number does not exist, it returns the largest number in the array.\n\nExamples:\n>>> third-largest-number([2 3 1])\n1 (The third largest number is 1)\n>>> third-largest-number([1 2])\n2 (The third largest number does not exist, return the largest number)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a non-empty array, this function returns the third largest number in the array.\nIf the third largest number does not exist, it returns the largest number in the array.\n\nExamples:\n>>> third-largest-number([2 3 1])\n1 (The third largest number is 1)\n>>> third-largest-number([1 2])\n2 (The third largest number does not exist, return the largest number)\n\n\n\n* Incomplete Code:\n(define (third-largest-number\n(define sorted-unique (sort (remove-duplicates nums) >))\n(if (>= (length sorted-unique) 3)\n[MASK]\n(car sorted-unique)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define sorted-unique (sort (remove-duplicates nums) >))\n(if (>= (length sorted-unique) 3)\n[MASK]\n(car sorted-unique)))"}
{"task_id": "Racket/19-1-single", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a non-empty array, this function returns the third largest number in the array.\n;; If the third largest number does not exist, it returns the largest number in the array.\n;;\n;; Examples:\n;; >>> third-largest-number([2 3 1])\n;; 1 (The third largest number is 1)\n;; >>> third-largest-number([1 2])\n;; 2 (The third largest number does not exist, return the largest number)\n\n(define (third-largest-number nums)", "canonical_solution": "(define sorted-unique (sort (remove-duplicates nums) >))\n(if (>= (length sorted-unique) 3)\n(list-ref sorted-unique 2)\n(car sorted-unique)))", "test": "(define (check third-largest-number)\n(define tests\n(list (check-equal? (third-largest-number (list 2 3 1)) 1)\n(check-equal? (third-largest-number (list 1 2)) 2)\n(check-equal? (third-largest-number (list 5 2 4)) 2)\n(check-equal? (third-largest-number (list 10 10 10)) 10)\n(check-equal? (third-largest-number (list 7 6 5 4)) 5)))\n(andmap identity tests))\n\n(check third-largest-number)", "entry_point": "third-largest-number", "signature": "(define (third-largest-number", "docstring": "Function Description:\nGiven a non-empty array, this function returns the third largest number in the array.\nIf the third largest number does not exist, it returns the largest number in the array.\n\nExamples:\n>>> third-largest-number([2 3 1])\n1 (The third largest number is 1)\n>>> third-largest-number([1 2])\n2 (The third largest number does not exist, return the largest number)\n\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFunction Description:\nGiven a non-empty array, this function returns the third largest number in the array.\nIf the third largest number does not exist, it returns the largest number in the array.\n\nExamples:\n>>> third-largest-number([2 3 1])\n1 (The third largest number is 1)\n>>> third-largest-number([1 2])\n2 (The third largest number does not exist, return the largest number)\n\n\n\n* Incomplete Code:\n(define (third-largest-number\n[MASK]\n(if (>= (length sorted-unique) 3)\n(list-ref sorted-unique 2)\n(car sorted-unique)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(if (>= (length sorted-unique) 3)\n(list-ref sorted-unique 2)\n(car sorted-unique)))"}
{"task_id": "Racket/21-0-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (sum-leap-years start-year end-year)\n;; Calculates the sum of all leap years between two given years (exclusive).\n;; Leap years are years divisible by 4, but not by 100 unless also divisible by 400.\n;;\n;; Args:\n;; start-year (integer): The starting year (exclusive).\n;; end-year (integer): The ending year (exclusive).\n;;\n;; Returns:\n;; integer: The sum of all leap years in the given range.\n;;\n;; Examples:\n;; >>> sum-leap-years 2000 2005\n;; 2004\n;; >>> sum-leap-years 1980 1990\n;; 1984 + 1988 = 3972", "canonical_solution": "(define (iter year acc)\n(if (> year end-year)\nacc\n(iter (add1 year)\n(if (is-leap-year year)\n(+ year acc)\nacc))))\n(iter (add1 start-year) 0))\n(define (divisible? n divisor)\n(= (modulo n divisor) 0))\n(define (is-leap-year year)\n(or (and (divisible? year 4)\n(not (divisible? year 100)))\n(divisible? year 400)))", "test": "(define (check sum-leap-years)\n(define tests\n(list (check-equal? (sum-leap-years 2000 2005) 2004)\n(check-equal? (sum-leap-years 1980 1990) 3972)\n(check-equal? (sum-leap-years 1990 2000) 5988)\n(check-equal? (sum-leap-years 1900 2001) 48800)\n(check-equal? (sum-leap-years 2001 2010) 4012)\n(check-equal? (sum-leap-years 1800 1900) 44400)))\n(andmap identity tests))\n\n(check sum-leap-years)", "entry_point": "sum-leap-years", "signature": "(define (sum-leap-years start-year end-year)", "docstring": "Calculates the sum of all leap years between two given years (exclusive).\nLeap years are years divisible by 4, but not by 100 unless also divisible by 400.\n\nArgs:\nstart-year (integer): The starting year (exclusive).\nend-year (integer): The ending year (exclusive).\n\nReturns:\ninteger: The sum of all leap years in the given range.\n\nExamples:\n>>> sum-leap-years 2000 2005\n2004\n>>> sum-leap-years 1980 1990\n1984 + 1988 = 3972", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCalculates the sum of all leap years between two given years (exclusive).\nLeap years are years divisible by 4, but not by 100 unless also divisible by 400.\n\nArgs:\nstart-year (integer): The starting year (exclusive).\nend-year (integer): The ending year (exclusive).\n\nReturns:\ninteger: The sum of all leap years in the given range.\n\nExamples:\n>>> sum-leap-years 2000 2005\n2004\n>>> sum-leap-years 1980 1990\n1984 + 1988 = 3972\n\n* Incomplete Code:\n(define (sum-leap-years start-year end-year)\n(define (iter year acc)\n(if (> year end-year)\nacc\n(iter (add1 year)\n(if (is-leap-year year)\n(+ year acc)\nacc))))\n(iter (add1 start-year) 0))\n(define (divisible? n divisor)\n(= (modulo n divisor) 0))\n(define (is-leap-year year)\n(or (and (divisible? year 4)\n[MASK]\n(divisible? year 400)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (iter year acc)\n(if (> year end-year)\nacc\n(iter (add1 year)\n(if (is-leap-year year)\n(+ year acc)\nacc))))\n(iter (add1 start-year) 0))\n(define (divisible? n divisor)\n(= (modulo n divisor) 0))\n(define (is-leap-year year)\n(or (and (divisible? year 4)\n[MASK]\n(divisible? year 400)))"}
{"task_id": "Racket/21-1-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (sum-leap-years start-year end-year)\n;; Calculates the sum of all leap years between two given years (exclusive).\n;; Leap years are years divisible by 4, but not by 100 unless also divisible by 400.\n;;\n;; Args:\n;; start-year (integer): The starting year (exclusive).\n;; end-year (integer): The ending year (exclusive).\n;;\n;; Returns:\n;; integer: The sum of all leap years in the given range.\n;;\n;; Examples:\n;; >>> sum-leap-years 2000 2005\n;; 2004\n;; >>> sum-leap-years 1980 1990\n;; 1984 + 1988 = 3972", "canonical_solution": "(define (iter year acc)\n(if (> year end-year)\nacc\n(iter (add1 year)\n(if (is-leap-year year)\n(+ year acc)\nacc))))\n(iter (add1 start-year) 0))\n(define (divisible? n divisor)\n(= (modulo n divisor) 0))\n(define (is-leap-year year)\n(or (and (divisible? year 4)\n(not (divisible? year 100)))\n(divisible? year 400)))", "test": "(define (check sum-leap-years)\n(define tests\n(list (check-equal? (sum-leap-years 2000 2005) 2004)\n(check-equal? (sum-leap-years 1980 1990) 3972)\n(check-equal? (sum-leap-years 1990 2000) 5988)\n(check-equal? (sum-leap-years 1900 2001) 48800)\n(check-equal? (sum-leap-years 2001 2010) 4012)\n(check-equal? (sum-leap-years 1800 1900) 44400)))\n(andmap identity tests))\n\n(check sum-leap-years)", "entry_point": "sum-leap-years", "signature": "(define (sum-leap-years start-year end-year)", "docstring": "Calculates the sum of all leap years between two given years (exclusive).\nLeap years are years divisible by 4, but not by 100 unless also divisible by 400.\n\nArgs:\nstart-year (integer): The starting year (exclusive).\nend-year (integer): The ending year (exclusive).\n\nReturns:\ninteger: The sum of all leap years in the given range.\n\nExamples:\n>>> sum-leap-years 2000 2005\n2004\n>>> sum-leap-years 1980 1990\n1984 + 1988 = 3972", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCalculates the sum of all leap years between two given years (exclusive).\nLeap years are years divisible by 4, but not by 100 unless also divisible by 400.\n\nArgs:\nstart-year (integer): The starting year (exclusive).\nend-year (integer): The ending year (exclusive).\n\nReturns:\ninteger: The sum of all leap years in the given range.\n\nExamples:\n>>> sum-leap-years 2000 2005\n2004\n>>> sum-leap-years 1980 1990\n1984 + 1988 = 3972\n\n* Incomplete Code:\n(define (sum-leap-years start-year end-year)\n(define (iter year acc)\n(if (> year end-year)\nacc\n(iter (add1 year)\n(if (is-leap-year year)\n(+ year acc)\nacc))))\n(iter (add1 start-year) 0))\n(define (divisible? n divisor)\n(= (modulo n divisor) 0))\n(define (is-leap-year year)\n[MASK]\n(not (divisible? year 100)))\n(divisible? year 400)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define (iter year acc)\n(if (> year end-year)\nacc\n(iter (add1 year)\n(if (is-leap-year year)\n(+ year acc)\nacc))))\n(iter (add1 start-year) 0))\n(define (divisible? n divisor)\n(= (modulo n divisor) 0))\n(define (is-leap-year year)\n[MASK]\n(not (divisible? year 100)))\n(divisible? year 400)))"}
{"task_id": "Racket/22-0-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-substring-index haystack needle)\n;; Finds the first index of a substring (needle) within a larger string (haystack).\n;; If the substring is not part of the haystack, returns -1.\n;;\n;; Args:\n;; haystack (string): The string to search within.\n;; needle (string): The substring to find.\n;;\n;; Returns:\n;; integer: The index of the first occurrence of the needle in the haystack or -1 if not found.\n;;\n;; Examples:\n;; >>> find-substring-index \"hello world\" \"world\"\n;; 6\n;; >>> find-substring-index \"racket\" \"et\"\n;; 4\n;; >>> find-substring-index \"programming\" \"fun\"\n;; -1", "canonical_solution": "(let loop ((start 0))\n(cond\n((> (+ start (string-length needle)) (string-length haystack)) -1)\n((string=? (substring haystack start (+ start (string-length needle))) needle) start)\n(else (loop (add1 start))))))", "test": "(define (check find-substring-index)\n(define tests\n(list (check-equal? (find-substring-index \"hello world\" \"world\") 6)\n(check-equal? (find-substring-index \"racket\" \"et\") 4)\n(check-equal? (find-substring-index \"programming\" \"fun\") -1)\n(check-equal? (find-substring-index \"hellohello\" \"lo\") 3)\n(check-equal? (find-substring-index \"racket language\" \"guage\") 10)\n(check-equal? (find-substring-index \"example\" \"exam\") 0)))\n(andmap identity tests))\n\n(check find-substring-index)", "entry_point": "find-substring-index", "signature": "(define (find-substring-index haystack needle)", "docstring": "Finds the first index of a substring (needle) within a larger string (haystack).\nIf the substring is not part of the haystack, returns -1.\n\nArgs:\nhaystack (string): The string to search within.\nneedle (string): The substring to find.\n\nReturns:\ninteger: The index of the first occurrence of the needle in the haystack or -1 if not found.\n\nExamples:\n>>> find-substring-index \"hello world\" \"world\"\n6\n>>> find-substring-index \"racket\" \"et\"\n4\n>>> find-substring-index \"programming\" \"fun\"\n-1", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFinds the first index of a substring (needle) within a larger string (haystack).\nIf the substring is not part of the haystack, returns -1.\n\nArgs:\nhaystack (string): The string to search within.\nneedle (string): The substring to find.\n\nReturns:\ninteger: The index of the first occurrence of the needle in the haystack or -1 if not found.\n\nExamples:\n>>> find-substring-index \"hello world\" \"world\"\n6\n>>> find-substring-index \"racket\" \"et\"\n4\n>>> find-substring-index \"programming\" \"fun\"\n-1\n\n* Incomplete Code:\n(define (find-substring-index haystack needle)\n(let loop ((start 0))\n(cond\n((> (+ start (string-length needle)) (string-length haystack)) -1)\n[MASK]\n(else (loop (add1 start))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let loop ((start 0))\n(cond\n((> (+ start (string-length needle)) (string-length haystack)) -1)\n[MASK]\n(else (loop (add1 start))))))"}
{"task_id": "Racket/22-1-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-substring-index haystack needle)\n;; Finds the first index of a substring (needle) within a larger string (haystack).\n;; If the substring is not part of the haystack, returns -1.\n;;\n;; Args:\n;; haystack (string): The string to search within.\n;; needle (string): The substring to find.\n;;\n;; Returns:\n;; integer: The index of the first occurrence of the needle in the haystack or -1 if not found.\n;;\n;; Examples:\n;; >>> find-substring-index \"hello world\" \"world\"\n;; 6\n;; >>> find-substring-index \"racket\" \"et\"\n;; 4\n;; >>> find-substring-index \"programming\" \"fun\"\n;; -1", "canonical_solution": "(let loop ((start 0))\n(cond\n((> (+ start (string-length needle)) (string-length haystack)) -1)\n((string=? (substring haystack start (+ start (string-length needle))) needle) start)\n(else (loop (add1 start))))))", "test": "(define (check find-substring-index)\n(define tests\n(list (check-equal? (find-substring-index \"hello world\" \"world\") 6)\n(check-equal? (find-substring-index \"racket\" \"et\") 4)\n(check-equal? (find-substring-index \"programming\" \"fun\") -1)\n(check-equal? (find-substring-index \"hellohello\" \"lo\") 3)\n(check-equal? (find-substring-index \"racket language\" \"guage\") 10)\n(check-equal? (find-substring-index \"example\" \"exam\") 0)))\n(andmap identity tests))\n\n(check find-substring-index)", "entry_point": "find-substring-index", "signature": "(define (find-substring-index haystack needle)", "docstring": "Finds the first index of a substring (needle) within a larger string (haystack).\nIf the substring is not part of the haystack, returns -1.\n\nArgs:\nhaystack (string): The string to search within.\nneedle (string): The substring to find.\n\nReturns:\ninteger: The index of the first occurrence of the needle in the haystack or -1 if not found.\n\nExamples:\n>>> find-substring-index \"hello world\" \"world\"\n6\n>>> find-substring-index \"racket\" \"et\"\n4\n>>> find-substring-index \"programming\" \"fun\"\n-1", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nFinds the first index of a substring (needle) within a larger string (haystack).\nIf the substring is not part of the haystack, returns -1.\n\nArgs:\nhaystack (string): The string to search within.\nneedle (string): The substring to find.\n\nReturns:\ninteger: The index of the first occurrence of the needle in the haystack or -1 if not found.\n\nExamples:\n>>> find-substring-index \"hello world\" \"world\"\n6\n>>> find-substring-index \"racket\" \"et\"\n4\n>>> find-substring-index \"programming\" \"fun\"\n-1\n\n* Incomplete Code:\n(define (find-substring-index haystack needle)\n(let loop ((start 0))\n(cond\n[MASK]\n((string=? (substring haystack start (+ start (string-length needle))) needle) start)\n(else (loop (add1 start))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let loop ((start 0))\n(cond\n[MASK]\n((string=? (substring haystack start (+ start (string-length needle))) needle) start)\n(else (loop (add1 start))))))"}
{"task_id": "Racket/24-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (rearrange-numbers numbers order)\n;; Rearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\n;; Each character represents the position of the smallest, middle, and largest number respectively.\n;;\n;; Args:\n;; numbers (list): A list of three integers.\n;; order (string): A string of three characters ('A', 'B', 'C') in any order.\n;;\n;; Returns:\n;; list: The numbers rearranged according to the specified order.\n;;\n;; Examples:\n;; >>> rearrange-numbers (list 8 3 5) \"BCA\"\n;; '(5 8 3)\n;; >>> rearrange-numbers (list 10 20 15) \"CAB\"\n;; '(20 10 15)", "canonical_solution": "(let* ((sorted (sort numbers <))\n(positions (map (lambda (ch) (case ch\n[(#\\A) 0]\n[(#\\B) 1]\n[(#\\C) 2]))\n(string->list order))))\n(map (lambda (pos) (list-ref sorted pos)) positions)))", "test": "(define (check rearrange-numbers)\n(define tests\n(list (check-equal? (rearrange-numbers (list 8 3 5) \"BCA\") '(5 8 3))\n(check-equal? (rearrange-numbers (list 10 20 15) \"CAB\") '(20 10 15))\n(check-equal? (rearrange-numbers (list 7 9 8) \"ACB\") '(7 9 8))\n(check-equal? (rearrange-numbers (list 12 18 14) \"BAC\") '(14 12 18))\n(check-equal? (rearrange-numbers (list 6 2 4) \"CBA\") '(6 4 2))))\n(andmap identity tests))\n\n(check rearrange-numbers)", "entry_point": "rearrange-numbers", "signature": "(define (rearrange-numbers numbers order)", "docstring": "Rearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\nEach character represents the position of the smallest, middle, and largest number respectively.\n\nArgs:\nnumbers (list): A list of three integers.\norder (string): A string of three characters ('A', 'B', 'C') in any order.\n\nReturns:\nlist: The numbers rearranged according to the specified order.\n\nExamples:\n>>> rearrange-numbers (list 8 3 5) \"BCA\"\n'(5 8 3)\n>>> rearrange-numbers (list 10 20 15) \"CAB\"\n'(20 10 15)", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nRearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\nEach character represents the position of the smallest, middle, and largest number respectively.\n\nArgs:\nnumbers (list): A list of three integers.\norder (string): A string of three characters ('A', 'B', 'C') in any order.\n\nReturns:\nlist: The numbers rearranged according to the specified order.\n\nExamples:\n>>> rearrange-numbers (list 8 3 5) \"BCA\"\n'(5 8 3)\n>>> rearrange-numbers (list 10 20 15) \"CAB\"\n'(20 10 15)\n\n* Incomplete Code:\n(define (rearrange-numbers numbers order)\n(let* ((sorted (sort numbers <))\n(positions (map (lambda (ch) (case ch\n[(#\\A) 0]\n[(#\\B) 1]\n[(#\\C) 2]))\n[MASK]\n(map (lambda (pos) (list-ref sorted pos)) positions)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let* ((sorted (sort numbers <))\n(positions (map (lambda (ch) (case ch\n[(#\\A) 0]\n[(#\\B) 1]\n[(#\\C) 2]))\n[MASK]\n(map (lambda (pos) (list-ref sorted pos)) positions)))"}
{"task_id": "Racket/24-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (rearrange-numbers numbers order)\n;; Rearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\n;; Each character represents the position of the smallest, middle, and largest number respectively.\n;;\n;; Args:\n;; numbers (list): A list of three integers.\n;; order (string): A string of three characters ('A', 'B', 'C') in any order.\n;;\n;; Returns:\n;; list: The numbers rearranged according to the specified order.\n;;\n;; Examples:\n;; >>> rearrange-numbers (list 8 3 5) \"BCA\"\n;; '(5 8 3)\n;; >>> rearrange-numbers (list 10 20 15) \"CAB\"\n;; '(20 10 15)", "canonical_solution": "(let* ((sorted (sort numbers <))\n(positions (map (lambda (ch) (case ch\n[(#\\A) 0]\n[(#\\B) 1]\n[(#\\C) 2]))\n(string->list order))))\n(map (lambda (pos) (list-ref sorted pos)) positions)))", "test": "(define (check rearrange-numbers)\n(define tests\n(list (check-equal? (rearrange-numbers (list 8 3 5) \"BCA\") '(5 8 3))\n(check-equal? (rearrange-numbers (list 10 20 15) \"CAB\") '(20 10 15))\n(check-equal? (rearrange-numbers (list 7 9 8) \"ACB\") '(7 9 8))\n(check-equal? (rearrange-numbers (list 12 18 14) \"BAC\") '(14 12 18))\n(check-equal? (rearrange-numbers (list 6 2 4) \"CBA\") '(6 4 2))))\n(andmap identity tests))\n\n(check rearrange-numbers)", "entry_point": "rearrange-numbers", "signature": "(define (rearrange-numbers numbers order)", "docstring": "Rearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\nEach character represents the position of the smallest, middle, and largest number respectively.\n\nArgs:\nnumbers (list): A list of three integers.\norder (string): A string of three characters ('A', 'B', 'C') in any order.\n\nReturns:\nlist: The numbers rearranged according to the specified order.\n\nExamples:\n>>> rearrange-numbers (list 8 3 5) \"BCA\"\n'(5 8 3)\n>>> rearrange-numbers (list 10 20 15) \"CAB\"\n'(20 10 15)", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nRearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\nEach character represents the position of the smallest, middle, and largest number respectively.\n\nArgs:\nnumbers (list): A list of three integers.\norder (string): A string of three characters ('A', 'B', 'C') in any order.\n\nReturns:\nlist: The numbers rearranged according to the specified order.\n\nExamples:\n>>> rearrange-numbers (list 8 3 5) \"BCA\"\n'(5 8 3)\n>>> rearrange-numbers (list 10 20 15) \"CAB\"\n'(20 10 15)\n\n* Incomplete Code:\n(define (rearrange-numbers numbers order)\n(let* ((sorted (sort numbers <))\n(positions (map (lambda (ch) (case ch\n[MASK]\n[(#\\B) 1]\n[(#\\C) 2]))\n(string->list order))))\n(map (lambda (pos) (list-ref sorted pos)) positions)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(let* ((sorted (sort numbers <))\n(positions (map (lambda (ch) (case ch\n[MASK]\n[(#\\B) 1]\n[(#\\C) 2]))\n(string->list order))))\n(map (lambda (pos) (list-ref sorted pos)) positions)))"}
{"task_id": "Racket/25-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (find-aron-position colors)\n;; Determines Aron's position in a queue based on the colors of the shirts worn by people in line.\n;; Groups of people wearing the same color shirt are considered as one entity in the queue.\n;;\n;; Args:\n;; colors (list): A list of strings, each representing the shirt color of a person in line.\n;;\n;; Returns:\n;; integer: The position of Aron in the queue.\n;;\n;; Examples:\n;; >>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n;; 5\n;; >>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n;; 5\n;; >>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n;; 2", "canonical_solution": "(let loop ((remaining colors) (count 0) (last-color #f))\n(cond\n[(null? remaining) (add1 count)]\n[(or (not last-color) (not (string=? (car remaining) last-color)))\n(loop (cdr remaining) (add1 count) (car remaining))]\n[else\n(loop (cdr remaining) count (car remaining))])))", "test": "(define (check find-aron-position)\n(define tests\n(list (check-equal? (find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")) 5)\n(check-equal? (find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")) 5)\n(check-equal? (find-aron-position '(\"Y\" \"Y\" \"Y\")) 2)\n(check-equal? (find-aron-position '(\"B\" \"G\" \"G\" \"R\" \"R\")) 4)\n(check-equal? (find-aron-position '(\"R\" \"R\" \"R\" \"B\" \"B\" \"B\" \"G\" \"G\")) 4)))\n(andmap identity tests))\n\n(check find-aron-position)", "entry_point": "find-aron-position", "signature": "(define (find-aron-position colors)", "docstring": "Determines Aron's position in a queue based on the colors of the shirts worn by people in line.\nGroups of people wearing the same color shirt are considered as one entity in the queue.\n\nArgs:\ncolors (list): A list of strings, each representing the shirt color of a person in line.\n\nReturns:\ninteger: The position of Aron in the queue.\n\nExamples:\n>>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n5\n>>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n5\n>>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n2", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nDetermines Aron's position in a queue based on the colors of the shirts worn by people in line.\nGroups of people wearing the same color shirt are considered as one entity in the queue.\n\nArgs:\ncolors (list): A list of strings, each representing the shirt color of a person in line.\n\nReturns:\ninteger: The position of Aron in the queue.\n\nExamples:\n>>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n5\n>>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n5\n>>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n2\n\n* Incomplete Code:\n(define (find-aron-position colors)\n(let loop ((remaining colors) (count 0) (last-color #f))\n(cond\n[(null? remaining) (add1 count)]\n[MASK]\n(loop (cdr remaining) (add1 count) (car remaining))]\n[else\n(loop (cdr remaining) count (car remaining))])))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let loop ((remaining colors) (count 0) (last-color #f))\n(cond\n[(null? remaining) (add1 count)]\n[MASK]\n(loop (cdr remaining) (add1 count) (car remaining))]\n[else\n(loop (cdr remaining) count (car remaining))])))"}
{"task_id": "Racket/25-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (find-aron-position colors)\n;; Determines Aron's position in a queue based on the colors of the shirts worn by people in line.\n;; Groups of people wearing the same color shirt are considered as one entity in the queue.\n;;\n;; Args:\n;; colors (list): A list of strings, each representing the shirt color of a person in line.\n;;\n;; Returns:\n;; integer: The position of Aron in the queue.\n;;\n;; Examples:\n;; >>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n;; 5\n;; >>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n;; 5\n;; >>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n;; 2", "canonical_solution": "(let loop ((remaining colors) (count 0) (last-color #f))\n(cond\n[(null? remaining) (add1 count)]\n[(or (not last-color) (not (string=? (car remaining) last-color)))\n(loop (cdr remaining) (add1 count) (car remaining))]\n[else\n(loop (cdr remaining) count (car remaining))])))", "test": "(define (check find-aron-position)\n(define tests\n(list (check-equal? (find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")) 5)\n(check-equal? (find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")) 5)\n(check-equal? (find-aron-position '(\"Y\" \"Y\" \"Y\")) 2)\n(check-equal? (find-aron-position '(\"B\" \"G\" \"G\" \"R\" \"R\")) 4)\n(check-equal? (find-aron-position '(\"R\" \"R\" \"R\" \"B\" \"B\" \"B\" \"G\" \"G\")) 4)))\n(andmap identity tests))\n\n(check find-aron-position)", "entry_point": "find-aron-position", "signature": "(define (find-aron-position colors)", "docstring": "Determines Aron's position in a queue based on the colors of the shirts worn by people in line.\nGroups of people wearing the same color shirt are considered as one entity in the queue.\n\nArgs:\ncolors (list): A list of strings, each representing the shirt color of a person in line.\n\nReturns:\ninteger: The position of Aron in the queue.\n\nExamples:\n>>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n5\n>>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n5\n>>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n2", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nDetermines Aron's position in a queue based on the colors of the shirts worn by people in line.\nGroups of people wearing the same color shirt are considered as one entity in the queue.\n\nArgs:\ncolors (list): A list of strings, each representing the shirt color of a person in line.\n\nReturns:\ninteger: The position of Aron in the queue.\n\nExamples:\n>>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n5\n>>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n5\n>>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n2\n\n* Incomplete Code:\n(define (find-aron-position colors)\n(let loop ((remaining colors) (count 0) (last-color #f))\n(cond\n[MASK]\n[(or (not last-color) (not (string=? (car remaining) last-color)))\n(loop (cdr remaining) (add1 count) (car remaining))]\n[else\n(loop (cdr remaining) count (car remaining))])))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(let loop ((remaining colors) (count 0) (last-color #f))\n(cond\n[MASK]\n[(or (not last-color) (not (string=? (car remaining) last-color)))\n(loop (cdr remaining) (add1 count) (car remaining))]\n[else\n(loop (cdr remaining) count (car remaining))])))"}
{"task_id": "Racket/27-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (can-fit-sticks-in-boxes sticks boxes)\n;; Determines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\n;; Each box can only contain one stick.\n;;\n;; Args:\n;; sticks (list): A list of integers representing the lengths of the sticks.\n;; boxes (list): A list of integers representing the heights of the boxes.\n;;\n;; Returns:\n;; string: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n;;\n;; Examples:\n;; >>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n;; \"DA\"\n;; >>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n;; \"NE\"\n;; >>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n;; \"NE\"", "canonical_solution": "(define sorted-sticks (sort sticks <))\n(define sorted-boxes (sort boxes <))\n(define (iter sticks boxes)\n(cond\n[(null? sticks) \"DA\"]\n[(null? boxes) \"NE\"]\n[(<= (car sticks) (car boxes))\n(iter (cdr sticks) (cdr boxes))]\n[else \"NE\"]))\n(iter sorted-sticks sorted-boxes))", "test": "(define (check can-fit-sticks-in-boxes)\n(define tests\n(list (check-equal? (can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)) \"DA\")\n(check-equal? (can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)) \"NE\")\n(check-equal? (can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)) \"NE\")\n(check-equal? (can-fit-sticks-in-boxes '(1 1 1) '(2 2 2)) \"DA\")\n(check-equal? (can-fit-sticks-in-boxes '(10 20 30) '(30 20 10)) \"DA\")))\n(andmap identity tests))\n\n(check can-fit-sticks-in-boxes)", "entry_point": "can-fit-sticks-in-boxes", "signature": "(define (can-fit-sticks-in-boxes sticks boxes)", "docstring": "Determines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\nEach box can only contain one stick.\n\nArgs:\nsticks (list): A list of integers representing the lengths of the sticks.\nboxes (list): A list of integers representing the heights of the boxes.\n\nReturns:\nstring: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n\nExamples:\n>>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n\"DA\"\n>>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n\"NE\"\n>>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n\"NE\"", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nDetermines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\nEach box can only contain one stick.\n\nArgs:\nsticks (list): A list of integers representing the lengths of the sticks.\nboxes (list): A list of integers representing the heights of the boxes.\n\nReturns:\nstring: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n\nExamples:\n>>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n\"DA\"\n>>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n\"NE\"\n>>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n\"NE\"\n\n* Incomplete Code:\n(define (can-fit-sticks-in-boxes sticks boxes)\n(define sorted-sticks (sort sticks <))\n(define sorted-boxes (sort boxes <))\n(define (iter sticks boxes)\n[MASK]\n[(null? sticks) \"DA\"]\n[(null? boxes) \"NE\"]\n[(<= (car sticks) (car boxes))\n(iter (cdr sticks) (cdr boxes))]\n[else \"NE\"]))\n(iter sorted-sticks sorted-boxes))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define sorted-sticks (sort sticks <))\n(define sorted-boxes (sort boxes <))\n(define (iter sticks boxes)\n[MASK]\n[(null? sticks) \"DA\"]\n[(null? boxes) \"NE\"]\n[(<= (car sticks) (car boxes))\n(iter (cdr sticks) (cdr boxes))]\n[else \"NE\"]))\n(iter sorted-sticks sorted-boxes))"}
{"task_id": "Racket/27-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (can-fit-sticks-in-boxes sticks boxes)\n;; Determines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\n;; Each box can only contain one stick.\n;;\n;; Args:\n;; sticks (list): A list of integers representing the lengths of the sticks.\n;; boxes (list): A list of integers representing the heights of the boxes.\n;;\n;; Returns:\n;; string: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n;;\n;; Examples:\n;; >>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n;; \"DA\"\n;; >>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n;; \"NE\"\n;; >>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n;; \"NE\"", "canonical_solution": "(define sorted-sticks (sort sticks <))\n(define sorted-boxes (sort boxes <))\n(define (iter sticks boxes)\n(cond\n[(null? sticks) \"DA\"]\n[(null? boxes) \"NE\"]\n[(<= (car sticks) (car boxes))\n(iter (cdr sticks) (cdr boxes))]\n[else \"NE\"]))\n(iter sorted-sticks sorted-boxes))", "test": "(define (check can-fit-sticks-in-boxes)\n(define tests\n(list (check-equal? (can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)) \"DA\")\n(check-equal? (can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)) \"NE\")\n(check-equal? (can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)) \"NE\")\n(check-equal? (can-fit-sticks-in-boxes '(1 1 1) '(2 2 2)) \"DA\")\n(check-equal? (can-fit-sticks-in-boxes '(10 20 30) '(30 20 10)) \"DA\")))\n(andmap identity tests))\n\n(check can-fit-sticks-in-boxes)", "entry_point": "can-fit-sticks-in-boxes", "signature": "(define (can-fit-sticks-in-boxes sticks boxes)", "docstring": "Determines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\nEach box can only contain one stick.\n\nArgs:\nsticks (list): A list of integers representing the lengths of the sticks.\nboxes (list): A list of integers representing the heights of the boxes.\n\nReturns:\nstring: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n\nExamples:\n>>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n\"DA\"\n>>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n\"NE\"\n>>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n\"NE\"", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nDetermines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\nEach box can only contain one stick.\n\nArgs:\nsticks (list): A list of integers representing the lengths of the sticks.\nboxes (list): A list of integers representing the heights of the boxes.\n\nReturns:\nstring: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n\nExamples:\n>>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n\"DA\"\n>>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n\"NE\"\n>>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n\"NE\"\n\n* Incomplete Code:\n(define (can-fit-sticks-in-boxes sticks boxes)\n(define sorted-sticks (sort sticks <))\n(define sorted-boxes (sort boxes <))\n(define (iter sticks boxes)\n(cond\n[(null? sticks) \"DA\"]\n[(null? boxes) \"NE\"]\n[(<= (car sticks) (car boxes))\n(iter (cdr sticks) (cdr boxes))]\n[MASK]\n(iter sorted-sticks sorted-boxes))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define sorted-sticks (sort sticks <))\n(define sorted-boxes (sort boxes <))\n(define (iter sticks boxes)\n(cond\n[(null? sticks) \"DA\"]\n[(null? boxes) \"NE\"]\n[(<= (car sticks) (car boxes))\n(iter (cdr sticks) (cdr boxes))]\n[MASK]\n(iter sorted-sticks sorted-boxes))"}
{"task_id": "Racket/31-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (count-hehe matrix)\n;; Counts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\n;; The string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n;;\n;; Args:\n;; matrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n;;\n;; Returns:\n;; integer: The number of times \"hehe\" appears in the matrix.\n;;\n;; Examples:\n;; >>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n;; 10\n;; >>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n;; 1", "canonical_solution": "(define (in-bounds? row col)\n(and (>= row 0) (< row (length matrix))\n(>= col 0) (< col (length (first matrix)))))\n(define (check-sequence row col dr dc)\n(and (in-bounds? (+ row (* 3 dr)) (+ col (* 3 dc)))\n(equal? (list-ref (list-ref matrix row) col) \"h\")\n(equal? (list-ref (list-ref matrix (+ row dr)) (+ col dc)) \"e\")\n(equal? (list-ref (list-ref matrix (+ row (* 2 dr))) (+ col (* 2 dc))) \"h\")\n(equal? (list-ref (list-ref matrix (+ row (* 3 dr))) (+ col (* 3 dc))) \"e\")))\n(define (iter row col count)\n(cond\n[(>= row (length matrix)) count]\n[(>= col (length (first matrix))) (iter (+ row 1) 0 count)]\n[else\n(iter row (+ col 1)\n(+ count\n(for/sum ([dr (in-list '(0 1 1 1))]\n[dc (in-list '(1 1 0 -1))])\n(if (and (in-bounds? row col) (check-sequence row col dr dc)) 1 0))))]))\n(iter 0 0 0))", "test": "(define (check count-hehe)\n(define tests\n(list (check-equal? (count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))) 10)\n(check-equal? (count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))) 1)))\n(andmap identity tests))\n\n(check count-hehe)", "entry_point": "count-hehe", "signature": "(define (count-hehe matrix)", "docstring": "Counts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\nThe string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n\nArgs:\nmatrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n\nReturns:\ninteger: The number of times \"hehe\" appears in the matrix.\n\nExamples:\n>>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n10\n>>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n1", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCounts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\nThe string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n\nArgs:\nmatrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n\nReturns:\ninteger: The number of times \"hehe\" appears in the matrix.\n\nExamples:\n>>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n10\n>>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n1\n\n* Incomplete Code:\n(define (count-hehe matrix)\n(define (in-bounds? row col)\n(and (>= row 0) (< row (length matrix))\n(>= col 0) (< col (length (first matrix)))))\n(define (check-sequence row col dr dc)\n(and (in-bounds? (+ row (* 3 dr)) (+ col (* 3 dc)))\n(equal? (list-ref (list-ref matrix row) col) \"h\")\n(equal? (list-ref (list-ref matrix (+ row dr)) (+ col dc)) \"e\")\n[MASK]\n(equal? (list-ref (list-ref matrix (+ row (* 3 dr))) (+ col (* 3 dc))) \"e\")))\n(define (iter row col count)\n(cond\n[(>= row (length matrix)) count]\n[(>= col (length (first matrix))) (iter (+ row 1) 0 count)]\n[else\n(iter row (+ col 1)\n(+ count\n(for/sum ([dr (in-list '(0 1 1 1))]\n[dc (in-list '(1 1 0 -1))])\n(if (and (in-bounds? row col) (check-sequence row col dr dc)) 1 0))))]))\n(iter 0 0 0))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (in-bounds? row col)\n(and (>= row 0) (< row (length matrix))\n(>= col 0) (< col (length (first matrix)))))\n(define (check-sequence row col dr dc)\n(and (in-bounds? (+ row (* 3 dr)) (+ col (* 3 dc)))\n(equal? (list-ref (list-ref matrix row) col) \"h\")\n(equal? (list-ref (list-ref matrix (+ row dr)) (+ col dc)) \"e\")\n[MASK]\n(equal? (list-ref (list-ref matrix (+ row (* 3 dr))) (+ col (* 3 dc))) \"e\")))\n(define (iter row col count)\n(cond\n[(>= row (length matrix)) count]\n[(>= col (length (first matrix))) (iter (+ row 1) 0 count)]\n[else\n(iter row (+ col 1)\n(+ count\n(for/sum ([dr (in-list '(0 1 1 1))]\n[dc (in-list '(1 1 0 -1))])\n(if (and (in-bounds? row col) (check-sequence row col dr dc)) 1 0))))]))\n(iter 0 0 0))"}
{"task_id": "Racket/31-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (count-hehe matrix)\n;; Counts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\n;; The string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n;;\n;; Args:\n;; matrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n;;\n;; Returns:\n;; integer: The number of times \"hehe\" appears in the matrix.\n;;\n;; Examples:\n;; >>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n;; 10\n;; >>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n;; 1", "canonical_solution": "(define (in-bounds? row col)\n(and (>= row 0) (< row (length matrix))\n(>= col 0) (< col (length (first matrix)))))\n(define (check-sequence row col dr dc)\n(and (in-bounds? (+ row (* 3 dr)) (+ col (* 3 dc)))\n(equal? (list-ref (list-ref matrix row) col) \"h\")\n(equal? (list-ref (list-ref matrix (+ row dr)) (+ col dc)) \"e\")\n(equal? (list-ref (list-ref matrix (+ row (* 2 dr))) (+ col (* 2 dc))) \"h\")\n(equal? (list-ref (list-ref matrix (+ row (* 3 dr))) (+ col (* 3 dc))) \"e\")))\n(define (iter row col count)\n(cond\n[(>= row (length matrix)) count]\n[(>= col (length (first matrix))) (iter (+ row 1) 0 count)]\n[else\n(iter row (+ col 1)\n(+ count\n(for/sum ([dr (in-list '(0 1 1 1))]\n[dc (in-list '(1 1 0 -1))])\n(if (and (in-bounds? row col) (check-sequence row col dr dc)) 1 0))))]))\n(iter 0 0 0))", "test": "(define (check count-hehe)\n(define tests\n(list (check-equal? (count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))) 10)\n(check-equal? (count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))) 1)))\n(andmap identity tests))\n\n(check count-hehe)", "entry_point": "count-hehe", "signature": "(define (count-hehe matrix)", "docstring": "Counts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\nThe string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n\nArgs:\nmatrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n\nReturns:\ninteger: The number of times \"hehe\" appears in the matrix.\n\nExamples:\n>>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n10\n>>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n1", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCounts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\nThe string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n\nArgs:\nmatrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n\nReturns:\ninteger: The number of times \"hehe\" appears in the matrix.\n\nExamples:\n>>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n10\n>>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n1\n\n* Incomplete Code:\n(define (count-hehe matrix)\n(define (in-bounds? row col)\n(and (>= row 0) (< row (length matrix))\n(>= col 0) (< col (length (first matrix)))))\n(define (check-sequence row col dr dc)\n(and (in-bounds? (+ row (* 3 dr)) (+ col (* 3 dc)))\n(equal? (list-ref (list-ref matrix row) col) \"h\")\n(equal? (list-ref (list-ref matrix (+ row dr)) (+ col dc)) \"e\")\n(equal? (list-ref (list-ref matrix (+ row (* 2 dr))) (+ col (* 2 dc))) \"h\")\n[MASK]\n(define (iter row col count)\n(cond\n[(>= row (length matrix)) count]\n[(>= col (length (first matrix))) (iter (+ row 1) 0 count)]\n[else\n(iter row (+ col 1)\n(+ count\n(for/sum ([dr (in-list '(0 1 1 1))]\n[dc (in-list '(1 1 0 -1))])\n(if (and (in-bounds? row col) (check-sequence row col dr dc)) 1 0))))]))\n(iter 0 0 0))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (in-bounds? row col)\n(and (>= row 0) (< row (length matrix))\n(>= col 0) (< col (length (first matrix)))))\n(define (check-sequence row col dr dc)\n(and (in-bounds? (+ row (* 3 dr)) (+ col (* 3 dc)))\n(equal? (list-ref (list-ref matrix row) col) \"h\")\n(equal? (list-ref (list-ref matrix (+ row dr)) (+ col dc)) \"e\")\n(equal? (list-ref (list-ref matrix (+ row (* 2 dr))) (+ col (* 2 dc))) \"h\")\n[MASK]\n(define (iter row col count)\n(cond\n[(>= row (length matrix)) count]\n[(>= col (length (first matrix))) (iter (+ row 1) 0 count)]\n[else\n(iter row (+ col 1)\n(+ count\n(for/sum ([dr (in-list '(0 1 1 1))]\n[dc (in-list '(1 1 0 -1))])\n(if (and (in-bounds? row col) (check-sequence row col dr dc)) 1 0))))]))\n(iter 0 0 0))"}
{"task_id": "Racket/32-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (count-stairways n)\n;; Calculate the number of different ways to climb a staircase of 'n' steps, \n;; where you can take either one or two steps at a time.\n;; For a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\n;; For a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n;;\n;; Examples:\n;; >>> count-stairways 3\n;; 3\n;; >>> count-stairways 5\n;; 8\n", "canonical_solution": "(cond\n[(<= n 0) 0]\n[(= n 1) 1]\n[(= n 2) 2]\n[else (+ (count-stairways (- n 1)) (count-stairways (- n 2)))]))", "test": "(define (check count-stairways)\n(define tests\n(list (check-equal? (count-stairways 0) 0)\n(check-equal? (count-stairways 1) 1)\n(check-equal? (count-stairways 2) 2)\n(check-equal? (count-stairways 3) 3)\n(check-equal? (count-stairways 4) 5)\n(check-equal? (count-stairways 5) 8)\n(check-equal? (count-stairways 6) 13)))\n(andmap identity tests))\n\n(check count-stairways)", "entry_point": "count-stairways", "signature": "(define (count-stairways n)", "docstring": "Calculate the number of different ways to climb a staircase of 'n' steps, \nwhere you can take either one or two steps at a time.\nFor a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\nFor a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n\nExamples:\n>>> count-stairways 3\n3\n>>> count-stairways 5\n8\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of different ways to climb a staircase of 'n' steps, \nwhere you can take either one or two steps at a time.\nFor a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\nFor a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n\nExamples:\n>>> count-stairways 3\n3\n>>> count-stairways 5\n8\n\n\n* Incomplete Code:\n(define (count-stairways n)\n[MASK]\n[(<= n 0) 0]\n[(= n 1) 1]\n[(= n 2) 2]\n[else (+ (count-stairways (- n 1)) (count-stairways (- n 2)))]))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n[(<= n 0) 0]\n[(= n 1) 1]\n[(= n 2) 2]\n[else (+ (count-stairways (- n 1)) (count-stairways (- n 2)))]))"}
{"task_id": "Racket/32-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (count-stairways n)\n;; Calculate the number of different ways to climb a staircase of 'n' steps, \n;; where you can take either one or two steps at a time.\n;; For a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\n;; For a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n;;\n;; Examples:\n;; >>> count-stairways 3\n;; 3\n;; >>> count-stairways 5\n;; 8\n", "canonical_solution": "(cond\n[(<= n 0) 0]\n[(= n 1) 1]\n[(= n 2) 2]\n[else (+ (count-stairways (- n 1)) (count-stairways (- n 2)))]))", "test": "(define (check count-stairways)\n(define tests\n(list (check-equal? (count-stairways 0) 0)\n(check-equal? (count-stairways 1) 1)\n(check-equal? (count-stairways 2) 2)\n(check-equal? (count-stairways 3) 3)\n(check-equal? (count-stairways 4) 5)\n(check-equal? (count-stairways 5) 8)\n(check-equal? (count-stairways 6) 13)))\n(andmap identity tests))\n\n(check count-stairways)", "entry_point": "count-stairways", "signature": "(define (count-stairways n)", "docstring": "Calculate the number of different ways to climb a staircase of 'n' steps, \nwhere you can take either one or two steps at a time.\nFor a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\nFor a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n\nExamples:\n>>> count-stairways 3\n3\n>>> count-stairways 5\n8\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of different ways to climb a staircase of 'n' steps, \nwhere you can take either one or two steps at a time.\nFor a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\nFor a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n\nExamples:\n>>> count-stairways 3\n3\n>>> count-stairways 5\n8\n\n\n* Incomplete Code:\n(define (count-stairways n)\n(cond\n[MASK]\n[(= n 1) 1]\n[(= n 2) 2]\n[else (+ (count-stairways (- n 1)) (count-stairways (- n 2)))]))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(cond\n[MASK]\n[(= n 1) 1]\n[(= n 2) 2]\n[else (+ (count-stairways (- n 1)) (count-stairways (- n 2)))]))"}
{"task_id": "Racket/33-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (sort-votes candidate-count votes)\n;; Sort the votes for student council elections.\n;; Each vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\n;; The function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n;; \n;; Examples:\n;; >>> sort-votes 3 '(3 1 2 3 2)\n;; '(1 2 2 3 3)\n;; >>> sort-votes 4 '(4 4 1 2 3 2 1)\n;; '(1 1 2 2 3 4 4)", "canonical_solution": "(define (count-votes candidate)\n(length (filter (lambda (vote) (= vote candidate)) votes)))\n(flatten (map (lambda (candidate) (make-list (count-votes candidate) candidate))\n(range 1 (add1 candidate-count)))))", "test": "(define (check sort-votes)\n(define tests\n(list (check-equal? (sort-votes 3 '(3 1 2 3 2)) '(1 2 2 3 3))\n(check-equal? (sort-votes 4 '(4 4 1 2 3 2 1)) '(1 1 2 2 3 4 4))\n(check-equal? (sort-votes 5 '(5 3 1 4 2 5 3 2 4)) '(1 2 2 3 3 4 4 5 5))\n(check-equal? (sort-votes 2 '(2 2 1 1 2)) '(1 1 2 2 2))\n(check-equal? (sort-votes 1 '(1 1 1 1 1)) '(1 1 1 1 1))))\n(andmap identity tests))\n\n(check sort-votes)", "entry_point": "sort-votes", "signature": "(define (sort-votes candidate-count votes)", "docstring": "Sort the votes for student council elections.\nEach vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\nThe function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n\nExamples:\n>>> sort-votes 3 '(3 1 2 3 2)\n'(1 2 2 3 3)\n>>> sort-votes 4 '(4 4 1 2 3 2 1)\n'(1 1 2 2 3 4 4)", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nSort the votes for student council elections.\nEach vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\nThe function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n\nExamples:\n>>> sort-votes 3 '(3 1 2 3 2)\n'(1 2 2 3 3)\n>>> sort-votes 4 '(4 4 1 2 3 2 1)\n'(1 1 2 2 3 4 4)\n\n* Incomplete Code:\n(define (sort-votes candidate-count votes)\n(define (count-votes candidate)\n(length (filter (lambda (vote) (= vote candidate)) votes)))\n(flatten (map (lambda (candidate) (make-list (count-votes candidate) candidate))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(define (count-votes candidate)\n(length (filter (lambda (vote) (= vote candidate)) votes)))\n(flatten (map (lambda (candidate) (make-list (count-votes candidate) candidate))\n[MASK]"}
{"task_id": "Racket/33-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (sort-votes candidate-count votes)\n;; Sort the votes for student council elections.\n;; Each vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\n;; The function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n;; \n;; Examples:\n;; >>> sort-votes 3 '(3 1 2 3 2)\n;; '(1 2 2 3 3)\n;; >>> sort-votes 4 '(4 4 1 2 3 2 1)\n;; '(1 1 2 2 3 4 4)", "canonical_solution": "(define (count-votes candidate)\n(length (filter (lambda (vote) (= vote candidate)) votes)))\n(flatten (map (lambda (candidate) (make-list (count-votes candidate) candidate))\n(range 1 (add1 candidate-count)))))", "test": "(define (check sort-votes)\n(define tests\n(list (check-equal? (sort-votes 3 '(3 1 2 3 2)) '(1 2 2 3 3))\n(check-equal? (sort-votes 4 '(4 4 1 2 3 2 1)) '(1 1 2 2 3 4 4))\n(check-equal? (sort-votes 5 '(5 3 1 4 2 5 3 2 4)) '(1 2 2 3 3 4 4 5 5))\n(check-equal? (sort-votes 2 '(2 2 1 1 2)) '(1 1 2 2 2))\n(check-equal? (sort-votes 1 '(1 1 1 1 1)) '(1 1 1 1 1))))\n(andmap identity tests))\n\n(check sort-votes)", "entry_point": "sort-votes", "signature": "(define (sort-votes candidate-count votes)", "docstring": "Sort the votes for student council elections.\nEach vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\nThe function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n\nExamples:\n>>> sort-votes 3 '(3 1 2 3 2)\n'(1 2 2 3 3)\n>>> sort-votes 4 '(4 4 1 2 3 2 1)\n'(1 1 2 2 3 4 4)", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nSort the votes for student council elections.\nEach vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\nThe function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n\nExamples:\n>>> sort-votes 3 '(3 1 2 3 2)\n'(1 2 2 3 3)\n>>> sort-votes 4 '(4 4 1 2 3 2 1)\n'(1 1 2 2 3 4 4)\n\n* Incomplete Code:\n(define (sort-votes candidate-count votes)\n[MASK]\n(length (filter (lambda (vote) (= vote candidate)) votes)))\n(flatten (map (lambda (candidate) (make-list (count-votes candidate) candidate))\n(range 1 (add1 candidate-count)))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n(length (filter (lambda (vote) (= vote candidate)) votes)))\n(flatten (map (lambda (candidate) (make-list (count-votes candidate) candidate))\n(range 1 (add1 candidate-count)))))"}
{"task_id": "Racket/34-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (count-ball-arrangements n r)\n;; This function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\n;; such that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n;;\n;; Examples:\n;; >>> count-ball-arrangements 4 2\n;; 14\n;; >>> count-ball-arrangements 5 3\n;; 150", "canonical_solution": "(* (stirling n r) (factorial r)))\n(define (factorial n)\n(if (= n 0) 1 (* n (factorial (- n 1)))))\n\n(define (stirling n k)\n(if (= k 0) 0\n(if (= k n) 1\n(+ (* k (stirling (- n 1) k)) (stirling (- n 1) (- k 1))))))", "test": "(define (check count-ball-arrangements)\n(define tests\n(list (check-equal? (count-ball-arrangements 3 2) 6)\n(check-equal? (count-ball-arrangements 4 2) 14)\n(check-equal? (count-ball-arrangements 5 3) 150)\n(check-equal? (count-ball-arrangements 6 3) 540)\n(check-equal? (count-ball-arrangements 5 5) 120)))\n(andmap identity tests))\n\n(check count-ball-arrangements)", "entry_point": "count-ball-arrangements", "signature": "(define (count-ball-arrangements n r)", "docstring": "This function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\nsuch that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n\nExamples:\n>>> count-ball-arrangements 4 2\n14\n>>> count-ball-arrangements 5 3\n150", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\nsuch that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n\nExamples:\n>>> count-ball-arrangements 4 2\n14\n>>> count-ball-arrangements 5 3\n150\n\n* Incomplete Code:\n(define (count-ball-arrangements n r)\n(* (stirling n r) (factorial r)))\n(define (factorial n)\n(if (= n 0) 1 (* n (factorial (- n 1)))))\n\n(define (stirling n k)\n(if (= k 0) 0\n[MASK]\n(+ (* k (stirling (- n 1) k)) (stirling (- n 1) (- k 1))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(* (stirling n r) (factorial r)))\n(define (factorial n)\n(if (= n 0) 1 (* n (factorial (- n 1)))))\n\n(define (stirling n k)\n(if (= k 0) 0\n[MASK]\n(+ (* k (stirling (- n 1) k)) (stirling (- n 1) (- k 1))))))"}
{"task_id": "Racket/34-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (count-ball-arrangements n r)\n;; This function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\n;; such that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n;;\n;; Examples:\n;; >>> count-ball-arrangements 4 2\n;; 14\n;; >>> count-ball-arrangements 5 3\n;; 150", "canonical_solution": "(* (stirling n r) (factorial r)))\n(define (factorial n)\n(if (= n 0) 1 (* n (factorial (- n 1)))))\n\n(define (stirling n k)\n(if (= k 0) 0\n(if (= k n) 1\n(+ (* k (stirling (- n 1) k)) (stirling (- n 1) (- k 1))))))", "test": "(define (check count-ball-arrangements)\n(define tests\n(list (check-equal? (count-ball-arrangements 3 2) 6)\n(check-equal? (count-ball-arrangements 4 2) 14)\n(check-equal? (count-ball-arrangements 5 3) 150)\n(check-equal? (count-ball-arrangements 6 3) 540)\n(check-equal? (count-ball-arrangements 5 5) 120)))\n(andmap identity tests))\n\n(check count-ball-arrangements)", "entry_point": "count-ball-arrangements", "signature": "(define (count-ball-arrangements n r)", "docstring": "This function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\nsuch that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n\nExamples:\n>>> count-ball-arrangements 4 2\n14\n>>> count-ball-arrangements 5 3\n150", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\nsuch that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n\nExamples:\n>>> count-ball-arrangements 4 2\n14\n>>> count-ball-arrangements 5 3\n150\n\n* Incomplete Code:\n(define (count-ball-arrangements n r)\n(* (stirling n r) (factorial r)))\n[MASK]\n(if (= n 0) 1 (* n (factorial (- n 1)))))\n\n(define (stirling n k)\n(if (= k 0) 0\n(if (= k n) 1\n(+ (* k (stirling (- n 1) k)) (stirling (- n 1) (- k 1))))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "(* (stirling n r) (factorial r)))\n[MASK]\n(if (= n 0) 1 (* n (factorial (- n 1)))))\n\n(define (stirling n k)\n(if (= k 0) 0\n(if (= k n) 1\n(+ (* k (stirling (- n 1) k)) (stirling (- n 1) (- k 1))))))"}
{"task_id": "Racket/35-0-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-optimal-meeting-place city-data)\n;; This function finds the optimal meeting place for a reunion, given the number of classmates in various cities \n;; along a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \n;; with the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n;;\n;; Examples:\n;; >>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n;; '(\"CityB\" 1200)\n", "canonical_solution": "(define (total-cost city-distance)\n(apply + (map (lambda (city) \n(* (first city) (abs (- city-distance (second city)))))\ncity-data)))\n(define sorted-cities (sort city-data (lambda (a b) (< (second a) (second b)))))\n(define optimal-city \n(argmin (lambda (city) (total-cost (second city))) sorted-cities))\n(list (third optimal-city) (total-cost (second optimal-city))))", "test": "(define (check find-optimal-meeting-place)\n(define tests\n(list (check-equal? (find-optimal-meeting-place '((7 9289 \"Vladivostok\")\n(5 8523 \"Chabarovsk\")\n(3 5184 \"Irkutsk\")\n(8 2213 \"Yalutorovsk\")\n(10 0 \"Moscow\"))) \n'(\"Yalutorovsk\" 112125))\n(check-equal? (find-optimal-meeting-place '((5 300 \"CityA\")\n(3 100 \"CityB\")\n(2 0 \"Moscow\"))) \n'(\"CityB\" 1200))\n(check-equal? (find-optimal-meeting-place '((4 200 \"CityX\")\n(6 400 \"CityY\")\n(1 0 \"Moscow\"))) \n'(\"CityY\" 1200))))\n(andmap identity tests))\n\n(check find-optimal-meeting-place)", "entry_point": "find-optimal-meeting-place", "signature": "(define (find-optimal-meeting-place city-data)", "docstring": "This function finds the optimal meeting place for a reunion, given the number of classmates in various cities \nalong a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \nwith the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n\nExamples:\n>>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n'(\"CityB\" 1200)\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function finds the optimal meeting place for a reunion, given the number of classmates in various cities \nalong a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \nwith the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n\nExamples:\n>>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n'(\"CityB\" 1200)\n\n\n* Incomplete Code:\n(define (find-optimal-meeting-place city-data)\n(define (total-cost city-distance)\n[MASK]\n(* (first city) (abs (- city-distance (second city)))))\ncity-data)))\n(define sorted-cities (sort city-data (lambda (a b) (< (second a) (second b)))))\n(define optimal-city \n(argmin (lambda (city) (total-cost (second city))) sorted-cities))\n(list (third optimal-city) (total-cost (second optimal-city))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (total-cost city-distance)\n[MASK]\n(* (first city) (abs (- city-distance (second city)))))\ncity-data)))\n(define sorted-cities (sort city-data (lambda (a b) (< (second a) (second b)))))\n(define optimal-city \n(argmin (lambda (city) (total-cost (second city))) sorted-cities))\n(list (third optimal-city) (total-cost (second optimal-city))))"}
{"task_id": "Racket/35-1-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-optimal-meeting-place city-data)\n;; This function finds the optimal meeting place for a reunion, given the number of classmates in various cities \n;; along a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \n;; with the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n;;\n;; Examples:\n;; >>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n;; '(\"CityB\" 1200)\n", "canonical_solution": "(define (total-cost city-distance)\n(apply + (map (lambda (city) \n(* (first city) (abs (- city-distance (second city)))))\ncity-data)))\n(define sorted-cities (sort city-data (lambda (a b) (< (second a) (second b)))))\n(define optimal-city \n(argmin (lambda (city) (total-cost (second city))) sorted-cities))\n(list (third optimal-city) (total-cost (second optimal-city))))", "test": "(define (check find-optimal-meeting-place)\n(define tests\n(list (check-equal? (find-optimal-meeting-place '((7 9289 \"Vladivostok\")\n(5 8523 \"Chabarovsk\")\n(3 5184 \"Irkutsk\")\n(8 2213 \"Yalutorovsk\")\n(10 0 \"Moscow\"))) \n'(\"Yalutorovsk\" 112125))\n(check-equal? (find-optimal-meeting-place '((5 300 \"CityA\")\n(3 100 \"CityB\")\n(2 0 \"Moscow\"))) \n'(\"CityB\" 1200))\n(check-equal? (find-optimal-meeting-place '((4 200 \"CityX\")\n(6 400 \"CityY\")\n(1 0 \"Moscow\"))) \n'(\"CityY\" 1200))))\n(andmap identity tests))\n\n(check find-optimal-meeting-place)", "entry_point": "find-optimal-meeting-place", "signature": "(define (find-optimal-meeting-place city-data)", "docstring": "This function finds the optimal meeting place for a reunion, given the number of classmates in various cities \nalong a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \nwith the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n\nExamples:\n>>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n'(\"CityB\" 1200)\n", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function finds the optimal meeting place for a reunion, given the number of classmates in various cities \nalong a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \nwith the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n\nExamples:\n>>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n'(\"CityB\" 1200)\n\n\n* Incomplete Code:\n(define (find-optimal-meeting-place city-data)\n(define (total-cost city-distance)\n(apply + (map (lambda (city) \n(* (first city) (abs (- city-distance (second city)))))\ncity-data)))\n(define sorted-cities (sort city-data (lambda (a b) (< (second a) (second b)))))\n[MASK]\n(argmin (lambda (city) (total-cost (second city))) sorted-cities))\n(list (third optimal-city) (total-cost (second optimal-city))))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (total-cost city-distance)\n(apply + (map (lambda (city) \n(* (first city) (abs (- city-distance (second city)))))\ncity-data)))\n(define sorted-cities (sort city-data (lambda (a b) (< (second a) (second b)))))\n[MASK]\n(argmin (lambda (city) (total-cost (second city))) sorted-cities))\n(list (third optimal-city) (total-cost (second optimal-city))))"}
{"task_id": "Racket/36-0-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (count-communicating-cows n d cow-positions)\n;; This function calculates the number of pairs of cows that can communicate with each other.\n;; Communication is possible if the cows are within a distance 'd' of each other.\n;; 'n' is the number of cows, 'd' is the maximum distance for communication, \n;; and 'cow-positions' is a list of the positions of the cows.\n;;\n;; Examples:\n;; >>> count-communicating-cows 4 5 '(1 3 6 10)\n;; 4\n;; >>> count-communicating-cows 3 4 '(2 5 9)\n;; 2", "canonical_solution": "(define sorted-positions (sort cow-positions <))\n(define (can-communicate? cow1 cow2)\n(<= (abs (- cow1 cow2)) d))\n(define count 0)\n(for ([i (in-range n)])\n(for ([j (in-range (add1 i) n)])\n(when (can-communicate? (list-ref sorted-positions i) (list-ref sorted-positions j))\n(set! count (add1 count)))))\ncount)", "test": "(define (check count-communicating-cows)\n(define tests\n(list (check-equal? (count-communicating-cows 5 10 '(10 12 16 37 40)) 4)\n(check-equal? (count-communicating-cows 4 5 '(1 3 6 10)) 4)\n(check-equal? (count-communicating-cows 3 4 '(2 5 9)) 2)))\n(andmap identity tests))\n\n(check count-communicating-cows)", "entry_point": "count-communicating-cows", "signature": "(define (count-communicating-cows n d cow-positions)", "docstring": "This function calculates the number of pairs of cows that can communicate with each other.\nCommunication is possible if the cows are within a distance 'd' of each other.\n'n' is the number of cows, 'd' is the maximum distance for communication, \nand 'cow-positions' is a list of the positions of the cows.\n\nExamples:\n>>> count-communicating-cows 4 5 '(1 3 6 10)\n4\n>>> count-communicating-cows 3 4 '(2 5 9)\n2", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of pairs of cows that can communicate with each other.\nCommunication is possible if the cows are within a distance 'd' of each other.\n'n' is the number of cows, 'd' is the maximum distance for communication, \nand 'cow-positions' is a list of the positions of the cows.\n\nExamples:\n>>> count-communicating-cows 4 5 '(1 3 6 10)\n4\n>>> count-communicating-cows 3 4 '(2 5 9)\n2\n\n* Incomplete Code:\n(define (count-communicating-cows n d cow-positions)\n(define sorted-positions (sort cow-positions <))\n[MASK]\n(<= (abs (- cow1 cow2)) d))\n(define count 0)\n(for ([i (in-range n)])\n(for ([j (in-range (add1 i) n)])\n(when (can-communicate? (list-ref sorted-positions i) (list-ref sorted-positions j))\n(set! count (add1 count)))))\ncount)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define sorted-positions (sort cow-positions <))\n[MASK]\n(<= (abs (- cow1 cow2)) d))\n(define count 0)\n(for ([i (in-range n)])\n(for ([j (in-range (add1 i) n)])\n(when (can-communicate? (list-ref sorted-positions i) (list-ref sorted-positions j))\n(set! count (add1 count)))))\ncount)"}
{"task_id": "Racket/36-1-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (count-communicating-cows n d cow-positions)\n;; This function calculates the number of pairs of cows that can communicate with each other.\n;; Communication is possible if the cows are within a distance 'd' of each other.\n;; 'n' is the number of cows, 'd' is the maximum distance for communication, \n;; and 'cow-positions' is a list of the positions of the cows.\n;;\n;; Examples:\n;; >>> count-communicating-cows 4 5 '(1 3 6 10)\n;; 4\n;; >>> count-communicating-cows 3 4 '(2 5 9)\n;; 2", "canonical_solution": "(define sorted-positions (sort cow-positions <))\n(define (can-communicate? cow1 cow2)\n(<= (abs (- cow1 cow2)) d))\n(define count 0)\n(for ([i (in-range n)])\n(for ([j (in-range (add1 i) n)])\n(when (can-communicate? (list-ref sorted-positions i) (list-ref sorted-positions j))\n(set! count (add1 count)))))\ncount)", "test": "(define (check count-communicating-cows)\n(define tests\n(list (check-equal? (count-communicating-cows 5 10 '(10 12 16 37 40)) 4)\n(check-equal? (count-communicating-cows 4 5 '(1 3 6 10)) 4)\n(check-equal? (count-communicating-cows 3 4 '(2 5 9)) 2)))\n(andmap identity tests))\n\n(check count-communicating-cows)", "entry_point": "count-communicating-cows", "signature": "(define (count-communicating-cows n d cow-positions)", "docstring": "This function calculates the number of pairs of cows that can communicate with each other.\nCommunication is possible if the cows are within a distance 'd' of each other.\n'n' is the number of cows, 'd' is the maximum distance for communication, \nand 'cow-positions' is a list of the positions of the cows.\n\nExamples:\n>>> count-communicating-cows 4 5 '(1 3 6 10)\n4\n>>> count-communicating-cows 3 4 '(2 5 9)\n2", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of pairs of cows that can communicate with each other.\nCommunication is possible if the cows are within a distance 'd' of each other.\n'n' is the number of cows, 'd' is the maximum distance for communication, \nand 'cow-positions' is a list of the positions of the cows.\n\nExamples:\n>>> count-communicating-cows 4 5 '(1 3 6 10)\n4\n>>> count-communicating-cows 3 4 '(2 5 9)\n2\n\n* Incomplete Code:\n(define (count-communicating-cows n d cow-positions)\n(define sorted-positions (sort cow-positions <))\n(define (can-communicate? cow1 cow2)\n(<= (abs (- cow1 cow2)) d))\n(define count 0)\n(for ([i (in-range n)])\n[MASK]\n(when (can-communicate? (list-ref sorted-positions i) (list-ref sorted-positions j))\n(set! count (add1 count)))))\ncount)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "(define sorted-positions (sort cow-positions <))\n(define (can-communicate? cow1 cow2)\n(<= (abs (- cow1 cow2)) d))\n(define count 0)\n(for ([i (in-range n)])\n[MASK]\n(when (can-communicate? (list-ref sorted-positions i) (list-ref sorted-positions j))\n(set! count (add1 count)))))\ncount)"}
{"task_id": "Racket/37-0-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-word-and-count word text)\n;; This function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\n;; The search is case-insensitive and looks for complete word matches only.\n;; If the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n;;\n;; Examples:\n;; >>> find-word-and-count \"To\" \"to be or not to be is a question\"\n;; '(2 0)\n;; >>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n;; -1", "canonical_solution": "(define words (string-split (string-downcase text)))\n(define target (string-downcase word))\n(define (find-index lst item [index 0])\n(cond [(null? lst) -1]\n[(equal? (car lst) item) index]\n[else (find-index (cdr lst) item (add1 index))]))\n(define index (find-index words target))\n(if (= index -1)\n-1\n(list (count (lambda (w) (equal? w target)) words) index)))", "test": "(define (check find-word-and-count)\n(define tests\n(list (check-equal? (find-word-and-count \"To\" \"to be or not to be is a question\") '(2 0))\n(check-equal? (find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\") -1)\n(check-equal? (find-word-and-count \"a\" \"A man a plan a canal Panama\") '(3 0))))\n(andmap identity tests))\n\n(check find-word-and-count)", "entry_point": "find-word-and-count", "signature": "(define (find-word-and-count word text)", "docstring": "This function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\nThe search is case-insensitive and looks for complete word matches only.\nIf the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n\nExamples:\n>>> find-word-and-count \"To\" \"to be or not to be is a question\"\n'(2 0)\n>>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n-1", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\nThe search is case-insensitive and looks for complete word matches only.\nIf the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n\nExamples:\n>>> find-word-and-count \"To\" \"to be or not to be is a question\"\n'(2 0)\n>>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n-1\n\n* Incomplete Code:\n(define (find-word-and-count word text)\n(define words (string-split (string-downcase text)))\n(define target (string-downcase word))\n(define (find-index lst item [index 0])\n(cond [(null? lst) -1]\n[(equal? (car lst) item) index]\n[else (find-index (cdr lst) item (add1 index))]))\n[MASK]\n(if (= index -1)\n-1\n(list (count (lambda (w) (equal? w target)) words) index)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define words (string-split (string-downcase text)))\n(define target (string-downcase word))\n(define (find-index lst item [index 0])\n(cond [(null? lst) -1]\n[(equal? (car lst) item) index]\n[else (find-index (cdr lst) item (add1 index))]))\n[MASK]\n(if (= index -1)\n-1\n(list (count (lambda (w) (equal? w target)) words) index)))"}
{"task_id": "Racket/37-1-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-word-and-count word text)\n;; This function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\n;; The search is case-insensitive and looks for complete word matches only.\n;; If the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n;;\n;; Examples:\n;; >>> find-word-and-count \"To\" \"to be or not to be is a question\"\n;; '(2 0)\n;; >>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n;; -1", "canonical_solution": "(define words (string-split (string-downcase text)))\n(define target (string-downcase word))\n(define (find-index lst item [index 0])\n(cond [(null? lst) -1]\n[(equal? (car lst) item) index]\n[else (find-index (cdr lst) item (add1 index))]))\n(define index (find-index words target))\n(if (= index -1)\n-1\n(list (count (lambda (w) (equal? w target)) words) index)))", "test": "(define (check find-word-and-count)\n(define tests\n(list (check-equal? (find-word-and-count \"To\" \"to be or not to be is a question\") '(2 0))\n(check-equal? (find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\") -1)\n(check-equal? (find-word-and-count \"a\" \"A man a plan a canal Panama\") '(3 0))))\n(andmap identity tests))\n\n(check find-word-and-count)", "entry_point": "find-word-and-count", "signature": "(define (find-word-and-count word text)", "docstring": "This function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\nThe search is case-insensitive and looks for complete word matches only.\nIf the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n\nExamples:\n>>> find-word-and-count \"To\" \"to be or not to be is a question\"\n'(2 0)\n>>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n-1", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\nThe search is case-insensitive and looks for complete word matches only.\nIf the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n\nExamples:\n>>> find-word-and-count \"To\" \"to be or not to be is a question\"\n'(2 0)\n>>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n-1\n\n* Incomplete Code:\n(define (find-word-and-count word text)\n(define words (string-split (string-downcase text)))\n(define target (string-downcase word))\n(define (find-index lst item [index 0])\n(cond [(null? lst) -1]\n[(equal? (car lst) item) index]\n[MASK]\n(define index (find-index words target))\n(if (= index -1)\n-1\n(list (count (lambda (w) (equal? w target)) words) index)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define words (string-split (string-downcase text)))\n(define target (string-downcase word))\n(define (find-index lst item [index 0])\n(cond [(null? lst) -1]\n[(equal? (car lst) item) index]\n[MASK]\n(define index (find-index words target))\n(if (= index -1)\n-1\n(list (count (lambda (w) (equal? w target)) words) index)))"}
{"task_id": "Racket/38-0-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (count-card-distributions n m card-distribution)\n;; This function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\n;; where each person gets a specific number of cards as per the 'card-distribution' list.\n;; The result is given modulo 10007.\n;;\n;; Examples:\n;; >>> count-card-distributions 5 2 '(3 1)\n;; 20\n;; >>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n;; 8707", "canonical_solution": "(define (iter remaining-cards distribution)\n(if (null? distribution)\n1\n(let* ([cards (car distribution)]\n[ways (nCr remaining-cards cards)])\n(modulo (* ways (iter (- remaining-cards cards) (cdr distribution))) 10007))))\n(iter n card-distribution))\n(define (factorial n)\n(if (<= n 1) 1 (* n (factorial (- n 1)))))\n\n(define (nCr n r)\n(if (> r n) 0\n(modulo (/ (factorial n) (* (factorial r) (factorial (- n r)))) 10007)))", "test": "(define (check count-card-distributions)\n(define tests\n(list (check-equal? (count-card-distributions 5 2 '(3 1)) 20)\n(check-equal? (count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)) 8707)))\n(andmap identity tests))\n\n(check count-card-distributions)", "entry_point": "count-card-distributions", "signature": "(define (count-card-distributions n m card-distribution)", "docstring": "This function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\nwhere each person gets a specific number of cards as per the 'card-distribution' list.\nThe result is given modulo 10007.\n\nExamples:\n>>> count-card-distributions 5 2 '(3 1)\n20\n>>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n8707", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\nwhere each person gets a specific number of cards as per the 'card-distribution' list.\nThe result is given modulo 10007.\n\nExamples:\n>>> count-card-distributions 5 2 '(3 1)\n20\n>>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n8707\n\n* Incomplete Code:\n(define (count-card-distributions n m card-distribution)\n(define (iter remaining-cards distribution)\n(if (null? distribution)\n1\n(let* ([cards (car distribution)]\n[MASK]\n(modulo (* ways (iter (- remaining-cards cards) (cdr distribution))) 10007))))\n(iter n card-distribution))\n(define (factorial n)\n(if (<= n 1) 1 (* n (factorial (- n 1)))))\n\n(define (nCr n r)\n(if (> r n) 0\n(modulo (/ (factorial n) (* (factorial r) (factorial (- n r)))) 10007)))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (iter remaining-cards distribution)\n(if (null? distribution)\n1\n(let* ([cards (car distribution)]\n[MASK]\n(modulo (* ways (iter (- remaining-cards cards) (cdr distribution))) 10007))))\n(iter n card-distribution))\n(define (factorial n)\n(if (<= n 1) 1 (* n (factorial (- n 1)))))\n\n(define (nCr n r)\n(if (> r n) 0\n(modulo (/ (factorial n) (* (factorial r) (factorial (- n r)))) 10007)))"}
{"task_id": "Racket/38-1-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (count-card-distributions n m card-distribution)\n;; This function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\n;; where each person gets a specific number of cards as per the 'card-distribution' list.\n;; The result is given modulo 10007.\n;;\n;; Examples:\n;; >>> count-card-distributions 5 2 '(3 1)\n;; 20\n;; >>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n;; 8707", "canonical_solution": "(define (iter remaining-cards distribution)\n(if (null? distribution)\n1\n(let* ([cards (car distribution)]\n[ways (nCr remaining-cards cards)])\n(modulo (* ways (iter (- remaining-cards cards) (cdr distribution))) 10007))))\n(iter n card-distribution))\n(define (factorial n)\n(if (<= n 1) 1 (* n (factorial (- n 1)))))\n\n(define (nCr n r)\n(if (> r n) 0\n(modulo (/ (factorial n) (* (factorial r) (factorial (- n r)))) 10007)))", "test": "(define (check count-card-distributions)\n(define tests\n(list (check-equal? (count-card-distributions 5 2 '(3 1)) 20)\n(check-equal? (count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)) 8707)))\n(andmap identity tests))\n\n(check count-card-distributions)", "entry_point": "count-card-distributions", "signature": "(define (count-card-distributions n m card-distribution)", "docstring": "This function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\nwhere each person gets a specific number of cards as per the 'card-distribution' list.\nThe result is given modulo 10007.\n\nExamples:\n>>> count-card-distributions 5 2 '(3 1)\n20\n>>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n8707", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\nwhere each person gets a specific number of cards as per the 'card-distribution' list.\nThe result is given modulo 10007.\n\nExamples:\n>>> count-card-distributions 5 2 '(3 1)\n20\n>>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n8707\n\n* Incomplete Code:\n(define (count-card-distributions n m card-distribution)\n(define (iter remaining-cards distribution)\n(if (null? distribution)\n1\n(let* ([cards (car distribution)]\n[ways (nCr remaining-cards cards)])\n(modulo (* ways (iter (- remaining-cards cards) (cdr distribution))) 10007))))\n(iter n card-distribution))\n(define (factorial n)\n(if (<= n 1) 1 (* n (factorial (- n 1)))))\n\n(define (nCr n r)\n(if (> r n) 0\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define (iter remaining-cards distribution)\n(if (null? distribution)\n1\n(let* ([cards (car distribution)]\n[ways (nCr remaining-cards cards)])\n(modulo (* ways (iter (- remaining-cards cards) (cdr distribution))) 10007))))\n(iter n card-distribution))\n(define (factorial n)\n(if (<= n 1) 1 (* n (factorial (- n 1)))))\n\n(define (nCr n r)\n(if (> r n) 0\n[MASK]"}
{"task_id": "Racket/39-0-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (max-herb-value T M herb-data)\n;; Calculate the maximum total value of herbs that can be collected within a given time constraint.\n;; Each herb has a time requirement and a value.\n;; Args:\n;; T: Total time available for collecting herbs.\n;; M: Number of herbs available.\n;; herb-data: List of pairs, each containing time to collect a herb and its value.\n;; Returns:\n;; Maximum total value of herbs that can be collected within the time constraint.\n;; Example:\n;; (max-herb-value 10 2 '((5 10) (4 7)))\n;; ; Returns 17\n;; (max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n;; ; Returns 17", "canonical_solution": "(define dp (make-vector (add1 T) 0))\n(for ([i (in-range M)])\n(for ([j (in-range (- T 1) -1 -1)])\n(define herb (list-ref herb-data i))\n(define t (car herb))\n(define v (cadr herb))\n(when (<= t (+ j 1))\n(let ((new-index (- (+ j 1) t)))\n(when (and (>= new-index 0) (< new-index T))\n(vector-set! dp (+ j 1) (max (vector-ref dp (+ j 1)) (+ (vector-ref dp new-index) v))))))))\n(vector-ref dp T))", "test": "(define (test-max-herb-value)\n(define tests\n(list (check-equal? (max-herb-value 10 2 '((5 10) (4 7))) 17)\n(check-equal? (max-herb-value 10 3 '((3 6) (4 7) (2 4))) 17)\n(check-equal? (max-herb-value 15 4 '((3 8) (5 15) (6 10) (7 6))) 33)\n(check-equal? (max-herb-value 5 2 '((2 3) (3 4))) 7)\n(check-equal? (max-herb-value 7 3 '((1 2) (2 5) (3 7))) 14)))\n(andmap identity tests))\n\n(test-max-herb-value)", "entry_point": "max-herb-value", "signature": "(define (max-herb-value T M herb-data)", "docstring": "Calculate the maximum total value of herbs that can be collected within a given time constraint.\nEach herb has a time requirement and a value.\nArgs:\nT: Total time available for collecting herbs.\nM: Number of herbs available.\nherb-data: List of pairs, each containing time to collect a herb and its value.\nReturns:\nMaximum total value of herbs that can be collected within the time constraint.\nExample:\n(max-herb-value 10 2 '((5 10) (4 7)))\n; Returns 17\n(max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n; Returns 17", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum total value of herbs that can be collected within a given time constraint.\nEach herb has a time requirement and a value.\nArgs:\nT: Total time available for collecting herbs.\nM: Number of herbs available.\nherb-data: List of pairs, each containing time to collect a herb and its value.\nReturns:\nMaximum total value of herbs that can be collected within the time constraint.\nExample:\n(max-herb-value 10 2 '((5 10) (4 7)))\n; Returns 17\n(max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n; Returns 17\n\n* Incomplete Code:\n(define (max-herb-value T M herb-data)\n[MASK]\n(for ([i (in-range M)])\n(for ([j (in-range (- T 1) -1 -1)])\n(define herb (list-ref herb-data i))\n(define t (car herb))\n(define v (cadr herb))\n(when (<= t (+ j 1))\n(let ((new-index (- (+ j 1) t)))\n(when (and (>= new-index 0) (< new-index T))\n(vector-set! dp (+ j 1) (max (vector-ref dp (+ j 1)) (+ (vector-ref dp new-index) v))))))))\n(vector-ref dp T))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n(for ([i (in-range M)])\n(for ([j (in-range (- T 1) -1 -1)])\n(define herb (list-ref herb-data i))\n(define t (car herb))\n(define v (cadr herb))\n(when (<= t (+ j 1))\n(let ((new-index (- (+ j 1) t)))\n(when (and (>= new-index 0) (< new-index T))\n(vector-set! dp (+ j 1) (max (vector-ref dp (+ j 1)) (+ (vector-ref dp new-index) v))))))))\n(vector-ref dp T))"}
{"task_id": "Racket/39-1-single", "prompt": "#lang racket\n(require rackunit)\n\n(define (max-herb-value T M herb-data)\n;; Calculate the maximum total value of herbs that can be collected within a given time constraint.\n;; Each herb has a time requirement and a value.\n;; Args:\n;; T: Total time available for collecting herbs.\n;; M: Number of herbs available.\n;; herb-data: List of pairs, each containing time to collect a herb and its value.\n;; Returns:\n;; Maximum total value of herbs that can be collected within the time constraint.\n;; Example:\n;; (max-herb-value 10 2 '((5 10) (4 7)))\n;; ; Returns 17\n;; (max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n;; ; Returns 17", "canonical_solution": "(define dp (make-vector (add1 T) 0))\n(for ([i (in-range M)])\n(for ([j (in-range (- T 1) -1 -1)])\n(define herb (list-ref herb-data i))\n(define t (car herb))\n(define v (cadr herb))\n(when (<= t (+ j 1))\n(let ((new-index (- (+ j 1) t)))\n(when (and (>= new-index 0) (< new-index T))\n(vector-set! dp (+ j 1) (max (vector-ref dp (+ j 1)) (+ (vector-ref dp new-index) v))))))))\n(vector-ref dp T))", "test": "(define (test-max-herb-value)\n(define tests\n(list (check-equal? (max-herb-value 10 2 '((5 10) (4 7))) 17)\n(check-equal? (max-herb-value 10 3 '((3 6) (4 7) (2 4))) 17)\n(check-equal? (max-herb-value 15 4 '((3 8) (5 15) (6 10) (7 6))) 33)\n(check-equal? (max-herb-value 5 2 '((2 3) (3 4))) 7)\n(check-equal? (max-herb-value 7 3 '((1 2) (2 5) (3 7))) 14)))\n(andmap identity tests))\n\n(test-max-herb-value)", "entry_point": "max-herb-value", "signature": "(define (max-herb-value T M herb-data)", "docstring": "Calculate the maximum total value of herbs that can be collected within a given time constraint.\nEach herb has a time requirement and a value.\nArgs:\nT: Total time available for collecting herbs.\nM: Number of herbs available.\nherb-data: List of pairs, each containing time to collect a herb and its value.\nReturns:\nMaximum total value of herbs that can be collected within the time constraint.\nExample:\n(max-herb-value 10 2 '((5 10) (4 7)))\n; Returns 17\n(max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n; Returns 17", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum total value of herbs that can be collected within a given time constraint.\nEach herb has a time requirement and a value.\nArgs:\nT: Total time available for collecting herbs.\nM: Number of herbs available.\nherb-data: List of pairs, each containing time to collect a herb and its value.\nReturns:\nMaximum total value of herbs that can be collected within the time constraint.\nExample:\n(max-herb-value 10 2 '((5 10) (4 7)))\n; Returns 17\n(max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n; Returns 17\n\n* Incomplete Code:\n(define (max-herb-value T M herb-data)\n(define dp (make-vector (add1 T) 0))\n(for ([i (in-range M)])\n(for ([j (in-range (- T 1) -1 -1)])\n(define herb (list-ref herb-data i))\n(define t (car herb))\n(define v (cadr herb))\n(when (<= t (+ j 1))\n(let ((new-index (- (+ j 1) t)))\n(when (and (>= new-index 0) (< new-index T))\n(vector-set! dp (+ j 1) (max (vector-ref dp (+ j 1)) (+ (vector-ref dp new-index) v))))))))\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "(define dp (make-vector (add1 T) 0))\n(for ([i (in-range M)])\n(for ([j (in-range (- T 1) -1 -1)])\n(define herb (list-ref herb-data i))\n(define t (car herb))\n(define v (cadr herb))\n(when (<= t (+ j 1))\n(let ((new-index (- (+ j 1) t)))\n(when (and (>= new-index 0) (< new-index T))\n(vector-set! dp (+ j 1) (max (vector-ref dp (+ j 1)) (+ (vector-ref dp new-index) v))))))))\n[MASK]"}
{"task_id": "Racket/49-0-single", "prompt": "#lang racket\n(require rackunit)\n(define (sign-of-n n)\n;; Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n;; Args:\n;;   n: An integer, where -10^9 <= n <= 10^9.\n;; Returns:\n;;   A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n;;\n;; Examples:\n;; >>> (sign-of-n -1)\n;; \"negative\"\n;; >>> (sign-of-n 1)\n;; \"positive\"\n;; >>> (sign-of-n 0)\n;; \"zero\"", "canonical_solution": "  (cond\n    [(> n 0) \"positive\"]\n    [(< n 0) \"negative\"]\n    [else \"zero\"]))", "test": "(define (check sign-of-n)\n  (define tests\n    (list (check-equal? (sign-of-n -100) \"negative\")\n          (check-equal? (sign-of-n 100) \"positive\")\n          (check-equal? (sign-of-n 0) \"zero\")\n          (check-equal? (sign-of-n -999999999) \"negative\")\n          (check-equal? (sign-of-n 999999999) \"positive\")\n          (check-equal? (sign-of-n -1) \"negative\")\n          (check-equal? (sign-of-n 1) \"positive\")))\n  (andmap identity tests))\n\n(check sign-of-n)", "entry_point": "sign-of-n", "signature": "(define (sign-of-n n)", "docstring": " Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n Args:\n n: An integer, where -10^9 <= n <= 10^9.\n Returns:\n A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n\n Examples:\n >>> (sign-of-n -1)\n \"negative\"\n >>> (sign-of-n 1)\n \"positive\"\n >>> (sign-of-n 0)\n \"zero\"", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \n Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n Args:\n n: An integer, where -10^9 <= n <= 10^9.\n Returns:\n A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n\n Examples:\n >>> (sign-of-n -1)\n \"negative\"\n >>> (sign-of-n 1)\n \"positive\"\n >>> (sign-of-n 0)\n \"zero\"\n\n* Incomplete Code:\n(define (sign-of-n n)\n  (cond\n    [(> n 0) \"positive\"]\n[MASK]\n    [else \"zero\"]))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "  (cond\n    [(> n 0) \"positive\"]\n[MASK]\n    [else \"zero\"]))"}
{"task_id": "Racket/49-1-single", "prompt": "#lang racket\n(require rackunit)\n(define (sign-of-n n)\n;; Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n;; Args:\n;;   n: An integer, where -10^9 <= n <= 10^9.\n;; Returns:\n;;   A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n;;\n;; Examples:\n;; >>> (sign-of-n -1)\n;; \"negative\"\n;; >>> (sign-of-n 1)\n;; \"positive\"\n;; >>> (sign-of-n 0)\n;; \"zero\"", "canonical_solution": "  (cond\n    [(> n 0) \"positive\"]\n    [(< n 0) \"negative\"]\n    [else \"zero\"]))", "test": "(define (check sign-of-n)\n  (define tests\n    (list (check-equal? (sign-of-n -100) \"negative\")\n          (check-equal? (sign-of-n 100) \"positive\")\n          (check-equal? (sign-of-n 0) \"zero\")\n          (check-equal? (sign-of-n -999999999) \"negative\")\n          (check-equal? (sign-of-n 999999999) \"positive\")\n          (check-equal? (sign-of-n -1) \"negative\")\n          (check-equal? (sign-of-n 1) \"positive\")))\n  (andmap identity tests))\n\n(check sign-of-n)", "entry_point": "sign-of-n", "signature": "(define (sign-of-n n)", "docstring": " Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n Args:\n n: An integer, where -10^9 <= n <= 10^9.\n Returns:\n A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n\n Examples:\n >>> (sign-of-n -1)\n \"negative\"\n >>> (sign-of-n 1)\n \"positive\"\n >>> (sign-of-n 0)\n \"zero\"", "instruction": "Below is a explanation of Racket code and incomplete code implementation.\n\n* Docstring: \n Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n Args:\n n: An integer, where -10^9 <= n <= 10^9.\n Returns:\n A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n\n Examples:\n >>> (sign-of-n -1)\n \"negative\"\n >>> (sign-of-n 1)\n \"positive\"\n >>> (sign-of-n 0)\n \"zero\"\n\n* Incomplete Code:\n(define (sign-of-n n)\n  (cond\n    [(> n 0) \"positive\"]\n    [(< n 0) \"negative\"]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "  (cond\n    [(> n 0) \"positive\"]\n    [(< n 0) \"negative\"]\n[MASK]"}
