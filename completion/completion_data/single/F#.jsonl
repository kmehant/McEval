{"task_id": "F#/1-0-single", "prompt": "open System\n\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    (*\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    *)", "canonical_solution": "    let rec checkCloseElements = function\n        | [], _ -> false\n        | x::xs, y ->\n            if List.exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)", "test": "// Test cases\nlet check () =\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.3 <> true then\n        failwith \"Test Case 1 failed\"\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.05 <> false then\n        failwith \"Test Case 2 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.95 <> true then\n        failwith \"Test Case 3 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.8 <> false then\n        failwith \"Test Case 4 failed\"\n    if hasCloseElements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0] 0.1 <> true then\n        failwith \"Test Case 5 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 1.0 <> true then\n        failwith \"Test Case 6 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 0.5 <> false then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "hasCloseElements", "signature": "let hasCloseElements (numbers: float list) (threshold: float) =", "docstring": "\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n\n* Incomplete Code:\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    let rec checkCloseElements = function\n        | [], _ -> false\n[MASK]\n            if List.exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkCloseElements = function\n        | [], _ -> false\n[MASK]\n            if List.exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)"}
{"task_id": "F#/1-1-single", "prompt": "open System\n\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    (*\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    *)", "canonical_solution": "    let rec checkCloseElements = function\n        | [], _ -> false\n        | x::xs, y ->\n            if List.exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)", "test": "// Test cases\nlet check () =\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.3 <> true then\n        failwith \"Test Case 1 failed\"\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.05 <> false then\n        failwith \"Test Case 2 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.95 <> true then\n        failwith \"Test Case 3 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.8 <> false then\n        failwith \"Test Case 4 failed\"\n    if hasCloseElements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0] 0.1 <> true then\n        failwith \"Test Case 5 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 1.0 <> true then\n        failwith \"Test Case 6 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 0.5 <> false then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "hasCloseElements", "signature": "let hasCloseElements (numbers: float list) (threshold: float) =", "docstring": "\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n\n* Incomplete Code:\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    let rec checkCloseElements = function\n        | [], _ -> false\n        | x::xs, y ->\n[MASK]\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkCloseElements = function\n        | [], _ -> false\n        | x::xs, y ->\n[MASK]\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)"}
{"task_id": "F#/2-0-single", "prompt": "open System\n\nlet existsDouble (arr: int list) =\n    (*\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    *)", "canonical_solution": "    let checkForDouble = function\n        | [] -> false\n        | xs ->\n            List.exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr", "test": "let test () =\n    if existsDouble [1; 2; 3; 4] <> true then\n        failwith \"Test Case 1 failed\"\n    if existsDouble [1; 3; 5; 7] <> false then\n        failwith \"Test Case 2 failed\"\n    if existsDouble [10; 5; 3; 2] <> true then\n        failwith \"Test Case 3 failed\"\n    if existsDouble [6; 7; 9; 12] <> true then\n        failwith \"Test Case 4 failed\"\n    if existsDouble [20; 5; 10; 15] <> true then\n        failwith \"Test Case 5 failed\"\n    if existsDouble [4; 2; 1; 8] <> true then\n        failwith \"Test Case 6 failed\"\n    if existsDouble [11; 22; 33; 44] <> true then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "existsDouble", "signature": "let existsDouble (arr: int list) =", "docstring": "\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    \n\n* Incomplete Code:\nlet existsDouble (arr: int list) =\n    let checkForDouble = function\n[MASK]\n        | xs ->\n            List.exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let checkForDouble = function\n[MASK]\n        | xs ->\n            List.exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr"}
{"task_id": "F#/2-1-single", "prompt": "open System\n\nlet existsDouble (arr: int list) =\n    (*\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    *)", "canonical_solution": "    let checkForDouble = function\n        | [] -> false\n        | xs ->\n            List.exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr", "test": "let test () =\n    if existsDouble [1; 2; 3; 4] <> true then\n        failwith \"Test Case 1 failed\"\n    if existsDouble [1; 3; 5; 7] <> false then\n        failwith \"Test Case 2 failed\"\n    if existsDouble [10; 5; 3; 2] <> true then\n        failwith \"Test Case 3 failed\"\n    if existsDouble [6; 7; 9; 12] <> true then\n        failwith \"Test Case 4 failed\"\n    if existsDouble [20; 5; 10; 15] <> true then\n        failwith \"Test Case 5 failed\"\n    if existsDouble [4; 2; 1; 8] <> true then\n        failwith \"Test Case 6 failed\"\n    if existsDouble [11; 22; 33; 44] <> true then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "existsDouble", "signature": "let existsDouble (arr: int list) =", "docstring": "\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    \n\n* Incomplete Code:\nlet existsDouble (arr: int list) =\n    let checkForDouble = function\n        | [] -> false\n        | xs ->\n[MASK]\n\n    checkForDouble arr\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let checkForDouble = function\n        | [] -> false\n        | xs ->\n[MASK]\n\n    checkForDouble arr"}
{"task_id": "F#/4-0-single", "prompt": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    (*\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    *)", "canonical_solution": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "test": "let test () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "sortByBinaryOnes", "signature": "let sortByBinaryOnes (arr: int list) =", "docstring": "\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    \n\n* Incomplete Code:\nlet sortByBinaryOnes (arr: int list) =\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n[MASK]\n        if onesX = onesY then compare x y\n        else compare onesX onesY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n[MASK]\n        if onesX = onesY then compare x y\n        else compare onesX onesY)"}
{"task_id": "F#/4-1-single", "prompt": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    (*\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    *)", "canonical_solution": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "test": "let test () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "sortByBinaryOnes", "signature": "let sortByBinaryOnes (arr: int list) =", "docstring": "\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    \n\n* Incomplete Code:\nlet sortByBinaryOnes (arr: int list) =\n[MASK]\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)"}
{"task_id": "F#/6-0-single", "prompt": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    (*\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    *)", "canonical_solution": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "test": "let test () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findLuckyNumbers", "signature": "let findLuckyNumbers (matrix: int list list) =", "docstring": "\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    \n\n* Incomplete Code:\nlet findLuckyNumbers (matrix: int list list) =\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n[MASK]\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n[MASK]\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]"}
{"task_id": "F#/6-1-single", "prompt": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    (*\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    *)", "canonical_solution": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "test": "let test () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findLuckyNumbers", "signature": "let findLuckyNumbers (matrix: int list list) =", "docstring": "\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    \n\n* Incomplete Code:\nlet findLuckyNumbers (matrix: int list list) =\n    let rowMins = matrix |> List.map List.min\n[MASK]\n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let rowMins = matrix |> List.map List.min\n[MASK]\n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]"}
{"task_id": "F#/8-0-single", "prompt": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    (*\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    *)", "canonical_solution": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "test": "let test () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "createTargetArray", "signature": "let createTargetArray (nums: int list) (index: int list) =", "docstring": "\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    \n\n* Incomplete Code:\nlet createTargetArray (nums: int list) (index: int list) =\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n[MASK]\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n[MASK]\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target"}
{"task_id": "F#/8-1-single", "prompt": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    (*\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    *)", "canonical_solution": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "test": "let test () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "createTargetArray", "signature": "let createTargetArray (nums: int list) (index: int list) =", "docstring": "\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    \n\n* Incomplete Code:\nlet createTargetArray (nums: int list) (index: int list) =\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // 当列表为空时，直接返回包含 x 的新列表\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // 如果索引等于列表长度，则在末尾添加元素\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n[MASK]"}
{"task_id": "F#/11-0-single", "prompt": "open System\n\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    (*\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    *)", "canonical_solution": "    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0", "test": "// Test cases\nlet test () =\n    if homeworkAtQueryTime [1; 2; 3] [3; 2; 7] 4 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if homeworkAtQueryTime [4; 2; 2; 1] [4; 3; 7; 8] 3 <> 3 then\n        failwith \"Test Case 2 failed\"\n    if homeworkAtQueryTime [5; 1; 1; 1] [10; 3; 2; 2] 5 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if homeworkAtQueryTime [1; 1; 1; 1] [4; 4; 4; 4] 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if homeworkAtQueryTime [2; 2; 2] [3; 3; 3] 1 <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "homeworkAtQueryTime", "signature": "let homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =", "docstring": "\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    \n\n* Incomplete Code:\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    List.zip startTime endTime\n[MASK]\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    List.zip startTime endTime\n[MASK]\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0"}
{"task_id": "F#/11-1-single", "prompt": "open System\n\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    (*\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    *)", "canonical_solution": "    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0", "test": "// Test cases\nlet test () =\n    if homeworkAtQueryTime [1; 2; 3] [3; 2; 7] 4 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if homeworkAtQueryTime [4; 2; 2; 1] [4; 3; 7; 8] 3 <> 3 then\n        failwith \"Test Case 2 failed\"\n    if homeworkAtQueryTime [5; 1; 1; 1] [10; 3; 2; 2] 5 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if homeworkAtQueryTime [1; 1; 1; 1] [4; 4; 4; 4] 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if homeworkAtQueryTime [2; 2; 2] [3; 3; 3] 1 <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "homeworkAtQueryTime", "signature": "let homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =", "docstring": "\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    \n\n* Incomplete Code:\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n[MASK]\n       | None -> 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n[MASK]\n       | None -> 0"}
{"task_id": "F#/13-0-single", "prompt": "open System\n\nlet maxProduct (nums: int list) =\n    (*\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    *)", "canonical_solution": "    let sorted = List.sortDescending nums\n    match sorted with\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0", "test": "let test () =\n    if maxProduct [3; 4; 5; 2] <> 12 then\n        failwith \"Test Case 1 failed\"\n    if maxProduct [1; 5; 4; 5] <> 16 then\n        failwith \"Test Case 2 failed\"\n    if maxProduct [1; 2; 3] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxProduct [10; 2; 5; 2] <> 36 then\n        failwith \"Test Case 4 failed\"\n    if maxProduct [1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "maxProduct", "signature": "let maxProduct (nums: int list) =", "docstring": "\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    \n\n* Incomplete Code:\nlet maxProduct (nums: int list) =\n    let sorted = List.sortDescending nums\n    match sorted with\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sorted = List.sortDescending nums\n    match sorted with\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n[MASK]"}
{"task_id": "F#/13-1-single", "prompt": "open System\n\nlet maxProduct (nums: int list) =\n    (*\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    *)", "canonical_solution": "    let sorted = List.sortDescending nums\n    match sorted with\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0", "test": "let test () =\n    if maxProduct [3; 4; 5; 2] <> 12 then\n        failwith \"Test Case 1 failed\"\n    if maxProduct [1; 5; 4; 5] <> 16 then\n        failwith \"Test Case 2 failed\"\n    if maxProduct [1; 2; 3] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxProduct [10; 2; 5; 2] <> 36 then\n        failwith \"Test Case 4 failed\"\n    if maxProduct [1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "maxProduct", "signature": "let maxProduct (nums: int list) =", "docstring": "\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    \n\n* Incomplete Code:\nlet maxProduct (nums: int list) =\n    let sorted = List.sortDescending nums\n[MASK]\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let sorted = List.sortDescending nums\n[MASK]\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0"}
{"task_id": "F#/15-0-single", "prompt": "open System\n\nlet finalPrices (prices: int list) =\n    (*\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let findDiscount i price =\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices", "test": "let test () =\n    if finalPrices [8; 4; 6; 2; 3] <> [4; 2; 4; 2; 3] then\n        failwith \"Test Case 1 failed\"\n    if finalPrices [1; 2; 3; 4; 5] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if finalPrices [10; 1; 1; 6] <> [9; 0; 1; 6] then\n        failwith \"Test Case 3 failed\"\n    if finalPrices [4; 2; 4; 2; 3] <> [2; 0; 2; 2; 3] then\n        failwith \"Test Case 4 failed\"\n    if finalPrices [7; 7; 7; 7; 7] <> [0; 0; 0; 0; 7] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "finalPrices", "signature": "let finalPrices (prices: int list) =", "docstring": "\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet finalPrices (prices: int list) =\n[MASK]\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices"}
{"task_id": "F#/15-1-single", "prompt": "open System\n\nlet finalPrices (prices: int list) =\n    (*\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let findDiscount i price =\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices", "test": "let test () =\n    if finalPrices [8; 4; 6; 2; 3] <> [4; 2; 4; 2; 3] then\n        failwith \"Test Case 1 failed\"\n    if finalPrices [1; 2; 3; 4; 5] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if finalPrices [10; 1; 1; 6] <> [9; 0; 1; 6] then\n        failwith \"Test Case 3 failed\"\n    if finalPrices [4; 2; 4; 2; 3] <> [2; 0; 2; 2; 3] then\n        failwith \"Test Case 4 failed\"\n    if finalPrices [7; 7; 7; 7; 7] <> [0; 0; 0; 0; 7] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "finalPrices", "signature": "let finalPrices (prices: int list) =", "docstring": "\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet finalPrices (prices: int list) =\n    let findDiscount i price =\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n[MASK]\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let findDiscount i price =\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n[MASK]\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices"}
{"task_id": "F#/16-0-single", "prompt": "open System\n\nlet runningSum (nums: int list) =\n    (*\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let rec calcRunningSum acc sumSoFar =\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0", "test": "let test () =\n    if runningSum [1; 2; 3; 4] <> [1; 3; 6; 10] then\n        failwith \"Test Case 1 failed\"\n    if runningSum [1; 1; 1; 1; 1] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if runningSum [3; 1; 2; 10; 1] <> [3; 4; 6; 16; 17] then\n        failwith \"Test Case 3 failed\"\n    if runningSum [0; 0; 0; 0] <> [0; 0; 0; 0] then\n        failwith \"Test Case 4 failed\"\n    if runningSum [5; -1; -2; 3] <> [5; 4; 2; 5] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "runningSum", "signature": "let runningSum (nums: int list) =", "docstring": "\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet runningSum (nums: int list) =\n[MASK]\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0"}
{"task_id": "F#/16-1-single", "prompt": "open System\n\nlet runningSum (nums: int list) =\n    (*\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let rec calcRunningSum acc sumSoFar =\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0", "test": "let test () =\n    if runningSum [1; 2; 3; 4] <> [1; 3; 6; 10] then\n        failwith \"Test Case 1 failed\"\n    if runningSum [1; 1; 1; 1; 1] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if runningSum [3; 1; 2; 10; 1] <> [3; 4; 6; 16; 17] then\n        failwith \"Test Case 3 failed\"\n    if runningSum [0; 0; 0; 0] <> [0; 0; 0; 0] then\n        failwith \"Test Case 4 failed\"\n    if runningSum [5; -1; -2; 3] <> [5; 4; 2; 5] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "runningSum", "signature": "let runningSum (nums: int list) =", "docstring": "\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    \n\n* Incomplete Code:\nlet runningSum (nums: int list) =\n    let rec calcRunningSum acc sumSoFar =\n        match acc with\n[MASK]\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec calcRunningSum acc sumSoFar =\n        match acc with\n[MASK]\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0"}
{"task_id": "F#/19-0-single", "prompt": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    (*\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    *)", "canonical_solution": "    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "test": "let test () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "countGoodTriplets", "signature": "let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =", "docstring": "\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    \n\n* Incomplete Code:\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n[MASK]\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n[MASK]\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0"}
{"task_id": "F#/19-1-single", "prompt": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    (*\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    *)", "canonical_solution": "    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "test": "let test () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "countGoodTriplets", "signature": "let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =", "docstring": "\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    \n\n* Incomplete Code:\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n[MASK]\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0"}
{"task_id": "F#/20-0-single", "prompt": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    (*\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    *)", "canonical_solution": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "test": "let test () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "hasThreeConsecutiveOdds", "signature": "let hasThreeConsecutiveOdds (arr: int list) =", "docstring": "\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    \n\n* Incomplete Code:\nlet hasThreeConsecutiveOdds (arr: int list) =\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n[MASK]\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n[MASK]\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0"}
{"task_id": "F#/20-1-single", "prompt": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    (*\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    *)", "canonical_solution": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "test": "let test () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "hasThreeConsecutiveOdds", "signature": "let hasThreeConsecutiveOdds (arr: int list) =", "docstring": "\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    \n\n* Incomplete Code:\nlet hasThreeConsecutiveOdds (arr: int list) =\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n[MASK]"}
{"task_id": "F#/21-0-single", "prompt": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n(*\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n*)", "canonical_solution": "    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateSwimmingTime", "signature": "let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =", "docstring": "\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n\n\n* Incomplete Code:\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n[MASK]\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)"}
{"task_id": "F#/21-1-single", "prompt": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n(*\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n*)", "canonical_solution": "    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateSwimmingTime", "signature": "let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =", "docstring": "\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n\n\n* Incomplete Code:\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n[MASK]"}
{"task_id": "F#/23-0-single", "prompt": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n(*\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n*)", "canonical_solution": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "mostUnhappyDay", "signature": "let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =", "docstring": "\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n\n\n* Incomplete Code:\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n[MASK]"}
{"task_id": "F#/23-1-single", "prompt": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n(*\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n*)", "canonical_solution": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "mostUnhappyDay", "signature": "let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =", "docstring": "\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n\n\n* Incomplete Code:\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n[MASK]\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n[MASK]\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1"}
{"task_id": "F#/24-0-single", "prompt": "open System\n\nlet findLargerPrimeFactor (n: int) =\n(*\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n*)", "canonical_solution": "    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "test": "let testFindLargerPrimeFactor () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ntestFindLargerPrimeFactor ()", "entry_point": "findLargerPrimeFactor", "signature": "let findLargerPrimeFactor (n: int) =", "docstring": "\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n\n\n* Incomplete Code:\nlet findLargerPrimeFactor (n: int) =\n    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n[MASK]\n\n    findFactor 2\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n[MASK]\n\n    findFactor 2"}
{"task_id": "F#/24-1-single", "prompt": "open System\n\nlet findLargerPrimeFactor (n: int) =\n(*\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n*)", "canonical_solution": "    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "test": "let testFindLargerPrimeFactor () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ntestFindLargerPrimeFactor ()", "entry_point": "findLargerPrimeFactor", "signature": "let findLargerPrimeFactor (n: int) =", "docstring": "\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n\n\n* Incomplete Code:\nlet findLargerPrimeFactor (n: int) =\n    let rec findFactor i =\n        if i * i > n then\n            n\n[MASK]\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec findFactor i =\n        if i * i > n then\n            n\n[MASK]\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2"}
{"task_id": "F#/25-0-single", "prompt": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  (*\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  *)", "canonical_solution": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "longestConsecutiveSequence", "signature": "let longestConsecutiveSequence (numbers: int list) =", "docstring": "\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  \n\n* Incomplete Code:\nlet longestConsecutiveSequence (numbers: int list) =\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n[MASK]\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n[MASK]\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0"}
{"task_id": "F#/25-1-single", "prompt": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  (*\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  *)", "canonical_solution": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "longestConsecutiveSequence", "signature": "let longestConsecutiveSequence (numbers: int list) =", "docstring": "\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  \n\n* Incomplete Code:\nlet longestConsecutiveSequence (numbers: int list) =\n        let numbersSet = Set.ofList numbers\n[MASK]\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "        let numbersSet = Set.ofList numbers\n[MASK]\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0"}
{"task_id": "F#/26-0-single", "prompt": "open System\nlet reverseDigits (n: int) =\n(*\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n*)", "canonical_solution": "    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "test": "let testReverseDigits () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ntestReverseDigits ()", "entry_point": "reverseDigits", "signature": "let reverseDigits (n: int) =", "docstring": "\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n\n\n* Incomplete Code:\nlet reverseDigits (n: int) =\n[MASK]\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt"}
{"task_id": "F#/26-1-single", "prompt": "open System\nlet reverseDigits (n: int) =\n(*\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n*)", "canonical_solution": "    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "test": "let testReverseDigits () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ntestReverseDigits ()", "entry_point": "reverseDigits", "signature": "let reverseDigits (n: int) =", "docstring": "\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n\n\n* Incomplete Code:\nlet reverseDigits (n: int) =\n    let reversedStr =\n        string n\n[MASK]\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let reversedStr =\n        string n\n[MASK]\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt"}
{"task_id": "F#/27-0-single", "prompt": "open System\nlet rec calculateBessieScore (n: int) : int =\n(*\n    This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n*)", "canonical_solution": "    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n    | _ -> 1 + calculateBessieScore (3 * n + 1)", "test": "let test () =\n    if calculateBessieScore 6 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if calculateBessieScore 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if calculateBessieScore 7 <> 16 then\n        failwith \"Test Case 3 failed\"\n    if calculateBessieScore 15 <> 17 then\n        failwith \"Test Case 4 failed\"\n    if calculateBessieScore 22 <> 15 then\n        failwith \"Test Case 5 failed\"\n    if calculateBessieScore 2 <> 1 then\n        failwith \"Test Case 6 failed\"\n    if calculateBessieScore 10 <> 6 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "signature": "let rec calculateBessieScore (n: int) : int =", "docstring": "This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)", "entry_point": "calculateBessieScore", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n\n* Incomplete Code:\nlet rec calculateBessieScore (n: int) : int =\n    match n with\n    | 1 -> 0\n[MASK]\n    | _ -> 1 + calculateBessieScore (3 * n + 1)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    match n with\n    | 1 -> 0\n[MASK]\n    | _ -> 1 + calculateBessieScore (3 * n + 1)"}
{"task_id": "F#/27-1-single", "prompt": "open System\nlet rec calculateBessieScore (n: int) : int =\n(*\n    This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n*)", "canonical_solution": "    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n    | _ -> 1 + calculateBessieScore (3 * n + 1)", "test": "let test () =\n    if calculateBessieScore 6 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if calculateBessieScore 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if calculateBessieScore 7 <> 16 then\n        failwith \"Test Case 3 failed\"\n    if calculateBessieScore 15 <> 17 then\n        failwith \"Test Case 4 failed\"\n    if calculateBessieScore 22 <> 15 then\n        failwith \"Test Case 5 failed\"\n    if calculateBessieScore 2 <> 1 then\n        failwith \"Test Case 6 failed\"\n    if calculateBessieScore 10 <> 6 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "signature": "let rec calculateBessieScore (n: int) : int =", "docstring": "This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)", "entry_point": "calculateBessieScore", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n\n* Incomplete Code:\nlet rec calculateBessieScore (n: int) : int =\n    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n[MASK]"}
{"task_id": "F#/30-0-single", "prompt": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n(*\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n*)", "canonical_solution": "    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "findFourthVertex", "signature": "let findFourthVertex (coordinates: (int * int) list) : int * int =", "docstring": "\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n\n\n* Incomplete Code:\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n[MASK]\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n[MASK]\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)"}
{"task_id": "F#/30-1-single", "prompt": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n(*\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n*)", "canonical_solution": "    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "findFourthVertex", "signature": "let findFourthVertex (coordinates: (int * int) list) : int * int =", "docstring": "\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n\n\n* Incomplete Code:\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n[MASK]\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)"}
{"task_id": "F#/31-0-single", "prompt": "open System\n\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n(*\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n*)", "canonical_solution": "    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n    let totalMinutes = timeToSchool + 10 // Additional 10 minutes for garbage sorting\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")", "test": "let check () =\n    if calculateDepartureTime 500 50 <> \"07:40\" then\n        failwith \"Test Case 1 failed\"\n    if calculateDepartureTime 300 30 <> \"07:40\" then\n        failwith \"Test Case 2 failed\"\n    if calculateDepartureTime 600 60 <> \"07:40\" then\n        failwith \"Test Case 3 failed\"\n    if calculateDepartureTime 720 80 <> \"07:41\" then\n        failwith \"Test Case 4 failed\"\n    if calculateDepartureTime 100 10 <> \"07:40\" then\n        failwith \"Test Case 5 failed\"\n    if calculateDepartureTime 1000 100 <> \"07:40\" then\n        failwith \"Test Case 6 failed\"\n    if calculateDepartureTime 150 25 <> \"07:44\" then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateDepartureTime", "signature": "let calculateDepartureTime (distance: int) (speed: int) : string =", "docstring": "\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n\n\n* Incomplete Code:\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n[MASK]\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n[MASK]\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")"}
{"task_id": "F#/31-1-single", "prompt": "open System\n\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n(*\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n*)", "canonical_solution": "    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n    let totalMinutes = timeToSchool + 10 // Additional 10 minutes for garbage sorting\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")", "test": "let check () =\n    if calculateDepartureTime 500 50 <> \"07:40\" then\n        failwith \"Test Case 1 failed\"\n    if calculateDepartureTime 300 30 <> \"07:40\" then\n        failwith \"Test Case 2 failed\"\n    if calculateDepartureTime 600 60 <> \"07:40\" then\n        failwith \"Test Case 3 failed\"\n    if calculateDepartureTime 720 80 <> \"07:41\" then\n        failwith \"Test Case 4 failed\"\n    if calculateDepartureTime 100 10 <> \"07:40\" then\n        failwith \"Test Case 5 failed\"\n    if calculateDepartureTime 1000 100 <> \"07:40\" then\n        failwith \"Test Case 6 failed\"\n    if calculateDepartureTime 150 25 <> \"07:44\" then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateDepartureTime", "signature": "let calculateDepartureTime (distance: int) (speed: int) : string =", "docstring": "\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n\n\n* Incomplete Code:\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n[MASK]\n    let totalMinutes = timeToSchool + 10 // Additional 10 minutes for garbage sorting\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n    let totalMinutes = timeToSchool + 10 // Additional 10 minutes for garbage sorting\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")"}
{"task_id": "F#/32-0-single", "prompt": "open System\nlet validateISBN (isbnInput: string) : string =\n(*\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n*)", "canonical_solution": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actualCheckDigitChar = isbnInput.[isbnInput.Length - 1]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()", "test": "let checkISBNValidation () =\n    assert (validateISBN(\"0-670-82162-4\") = \"Right\")\n    assert (validateISBN(\"0-123-45678-9\") = \"Right\")\n    assert (validateISBN(\"0-670-82162-0\") = \"0-670-82162-4\")\n    assert (validateISBN(\"1-234-56789-5\") = \"1-234-56789-X\")\n    assert (validateISBN(\"9-876-54321-1\") = \"9-876-54321-0\")\n    assert (validateISBN(\"5-555-55555-5\") = \"Right\")\n\ncheckISBNValidation()", "entry_point": "validateISBN", "signature": "let validateISBN (isbnInput: string) : string =", "docstring": "\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n\n\n* Incomplete Code:\nlet validateISBN (isbnInput: string) : string =\n    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n[MASK]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n[MASK]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()"}
{"task_id": "F#/32-1-single", "prompt": "open System\nlet validateISBN (isbnInput: string) : string =\n(*\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n*)", "canonical_solution": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actualCheckDigitChar = isbnInput.[isbnInput.Length - 1]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()", "test": "let checkISBNValidation () =\n    assert (validateISBN(\"0-670-82162-4\") = \"Right\")\n    assert (validateISBN(\"0-123-45678-9\") = \"Right\")\n    assert (validateISBN(\"0-670-82162-0\") = \"0-670-82162-4\")\n    assert (validateISBN(\"1-234-56789-5\") = \"1-234-56789-X\")\n    assert (validateISBN(\"9-876-54321-1\") = \"9-876-54321-0\")\n    assert (validateISBN(\"5-555-55555-5\") = \"Right\")\n\ncheckISBNValidation()", "entry_point": "validateISBN", "signature": "let validateISBN (isbnInput: string) : string =", "docstring": "\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n\n\n* Incomplete Code:\nlet validateISBN (isbnInput: string) : string =\n    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n[MASK]\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actualCheckDigitChar = isbnInput.[isbnInput.Length - 1]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n[MASK]\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actualCheckDigitChar = isbnInput.[isbnInput.Length - 1]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()"}
{"task_id": "F#/33-0-single", "prompt": "open System\nlet calculateFinalScore (scores: int list) =\n(*\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n*)", "canonical_solution": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "test": "let testCalculateFinalScore () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ntestCalculateFinalScore ()", "entry_point": "calculateFinalScore", "signature": "let calculateFinalScore (scores: int list) =", "docstring": "\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n\n\n* Incomplete Code:\nlet calculateFinalScore (scores: int list) =\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n[MASK]"}
{"task_id": "F#/33-1-single", "prompt": "open System\nlet calculateFinalScore (scores: int list) =\n(*\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n*)", "canonical_solution": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "test": "let testCalculateFinalScore () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ntestCalculateFinalScore ()", "entry_point": "calculateFinalScore", "signature": "let calculateFinalScore (scores: int list) =", "docstring": "\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n\n\n* Incomplete Code:\nlet calculateFinalScore (scores: int list) =\n[MASK]\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)"}
{"task_id": "F#/34-0-single", "prompt": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    (*\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    *)", "canonical_solution": "    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "finalPosition", "signature": "let finalPosition (commands: string) (time: int) : (int * int) =", "docstring": "\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    \n\n* Incomplete Code:\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n[MASK]\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n[MASK]\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time"}
{"task_id": "F#/34-1-single", "prompt": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    (*\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    *)", "canonical_solution": "    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "finalPosition", "signature": "let finalPosition (commands: string) (time: int) : (int * int) =", "docstring": "\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    ", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    \n\n* Incomplete Code:\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n[MASK]\n\n    moveRobot (0, 0) commands time\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n[MASK]\n\n    moveRobot (0, 0) commands time"}
{"task_id": "F#/35-0-single", "prompt": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n(*\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n*)", "canonical_solution": "    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "test": "let test () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ntest ()", "entry_point": "maxGroupedKnapsackValue", "signature": "let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =", "docstring": "\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n\n\n* Incomplete Code:\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n[MASK]"}
{"task_id": "F#/35-1-single", "prompt": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n(*\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n*)", "canonical_solution": "    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "test": "let test () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ntest ()", "entry_point": "maxGroupedKnapsackValue", "signature": "let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =", "docstring": "\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n\n\n* Incomplete Code:\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n[MASK]\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])"}
{"task_id": "F#/36-0-single", "prompt": "open System\nlet hanoiTowerSteps (n: int) =\n(*\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n*)", "canonical_solution": "    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"", "test": "let checkHanoi () =\n    if hanoiTowerSteps 1 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if hanoiTowerSteps 3 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if hanoiTowerSteps 4 <> 15 then\n        failwith \"Test Case 3 failed\"\n    if hanoiTowerSteps 5 <> 31 then\n        failwith \"Test Case 4 failed\"\n    if hanoiTowerSteps 6 <> 63 then\n        failwith \"Test Case 5 failed\"\n    if hanoiTowerSteps 10 <> 1023 then\n        failwith \"Test Case 6 failed\"\n    if hanoiTowerSteps 0 <> 0 then\n        failwith \"Test Case 7 failed\"\n\ncheckHanoi ()", "entry_point": "hanoiTowerSteps", "signature": "let hanoiTowerSteps (n: int) =", "docstring": "\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n\n\n* Incomplete Code:\nlet hanoiTowerSteps (n: int) =\n    let rec solveHanoi n a b c =\n        match n with\n[MASK]\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec solveHanoi n a b c =\n        match n with\n[MASK]\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\""}
{"task_id": "F#/36-1-single", "prompt": "open System\nlet hanoiTowerSteps (n: int) =\n(*\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n*)", "canonical_solution": "    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"", "test": "let checkHanoi () =\n    if hanoiTowerSteps 1 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if hanoiTowerSteps 3 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if hanoiTowerSteps 4 <> 15 then\n        failwith \"Test Case 3 failed\"\n    if hanoiTowerSteps 5 <> 31 then\n        failwith \"Test Case 4 failed\"\n    if hanoiTowerSteps 6 <> 63 then\n        failwith \"Test Case 5 failed\"\n    if hanoiTowerSteps 10 <> 1023 then\n        failwith \"Test Case 6 failed\"\n    if hanoiTowerSteps 0 <> 0 then\n        failwith \"Test Case 7 failed\"\n\ncheckHanoi ()", "entry_point": "hanoiTowerSteps", "signature": "let hanoiTowerSteps (n: int) =", "docstring": "\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n\n\n* Incomplete Code:\nlet hanoiTowerSteps (n: int) =\n    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n[MASK]"}
{"task_id": "F#/37-0-single", "prompt": "open System\n\nlet maxContests (contests: (int * int) list) =\n(*\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n*)", "canonical_solution": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maxContests", "signature": "let maxContests (contests: (int * int) list) =", "docstring": "\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n\n\n* Incomplete Code:\nlet maxContests (contests: (int * int) list) =\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n[MASK]\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n[MASK]\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0"}
{"task_id": "F#/37-1-single", "prompt": "open System\n\nlet maxContests (contests: (int * int) list) =\n(*\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n*)", "canonical_solution": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maxContests", "signature": "let maxContests (contests: (int * int) list) =", "docstring": "\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n\n\n* Incomplete Code:\nlet maxContests (contests: (int * int) list) =\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n[MASK]\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n[MASK]\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0"}
{"task_id": "F#/38-0-single", "prompt": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n(*\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n*)", "canonical_solution": "    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "test": "let testCountWordClasses () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ntestCountWordClasses ()", "entry_point": "countWordClasses", "signature": "let countWordClasses (words: string list) =", "docstring": "\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n\n\n* Incomplete Code:\nlet countWordClasses (words: string list) =\n    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n[MASK]\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n[MASK]\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count"}
{"task_id": "F#/38-1-single", "prompt": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n(*\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n*)", "canonical_solution": "    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "test": "let testCountWordClasses () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ntestCountWordClasses ()", "entry_point": "countWordClasses", "signature": "let countWordClasses (words: string list) =", "docstring": "\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n\n\n* Incomplete Code:\nlet countWordClasses (words: string list) =\n    let getLetterFrequency word =\n[MASK]\n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    let getLetterFrequency word =\n[MASK]\n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count"}
{"task_id": "F#/39-0-single", "prompt": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n(*\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n*)", "canonical_solution": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maximumMinimumDistance", "signature": "let maximumMinimumDistance (stalls: int list) (cows: int) : int =", "docstring": "\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n\n\n* Incomplete Code:\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n[MASK]\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n[MASK]\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)"}
{"task_id": "F#/39-1-single", "prompt": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n(*\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n*)", "canonical_solution": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maximumMinimumDistance", "signature": "let maximumMinimumDistance (stalls: int list) (cows: int) : int =", "docstring": "\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n\n\n* Incomplete Code:\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n[MASK]\n\n    binarySearch 0 (List.max sortedStalls)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n[MASK]\n\n    binarySearch 0 (List.max sortedStalls)"}
{"task_id": "F#/49-0-single", "prompt": "let determineSign (n: int): string =\n(*\n    Determines the sign of a given integer N. The function returns \"positive\" if N is greater \n    than zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \n    provides a straightforward way to categorize an integer according to its sign.\n\n    Example:\n    >>> determineSign 10\n    \"positive\"\n\n    >>> determineSign 0\n    \"zero\"\n\n    >>> determineSign -5\n    \"negative\"\n\n    Note: The function takes a single argument, n, which represents the integer whose sign \n    is to be determined, and returns a string indicating the sign of the integer.\n*)", "canonical_solution": "    match n with\n    | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n    | _ -> \"negative\"", "test": "let check () =\n    if determineSign 10 <> \"positive\" then\n        failwith \"Test Case 1 failed\"\n    if determineSign 0 <> \"zero\" then\n        failwith \"Test Case 2 failed\"\n    if determineSign -5 <> \"negative\" then\n        failwith \"Test Case 3 failed\"\n    if determineSign 100 <> \"positive\" then\n        failwith \"Test Case 4 failed\"\n    if determineSign -100 <> \"negative\" then\n        failwith \"Test Case 5 failed\"\n    if determineSign 1 <> \"positive\" then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "determineSign", "signature": "let determineSign (n: int): string =", "docstring": "\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n\n\n* Incomplete Code:\nlet determineSign (n: int): string =\n    match n with\n    | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    match n with\n    | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n[MASK]"}
{"task_id": "F#/49-1-single", "prompt": "let determineSign (n: int): string =\n(*\n    Determines the sign of a given integer N. The function returns \"positive\" if N is greater \n    than zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \n    provides a straightforward way to categorize an integer according to its sign.\n\n    Example:\n    >>> determineSign 10\n    \"positive\"\n\n    >>> determineSign 0\n    \"zero\"\n\n    >>> determineSign -5\n    \"negative\"\n\n    Note: The function takes a single argument, n, which represents the integer whose sign \n    is to be determined, and returns a string indicating the sign of the integer.\n*)", "canonical_solution": "    match n with\n    | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n    | _ -> \"negative\"", "test": "let check () =\n    if determineSign 10 <> \"positive\" then\n        failwith \"Test Case 1 failed\"\n    if determineSign 0 <> \"zero\" then\n        failwith \"Test Case 2 failed\"\n    if determineSign -5 <> \"negative\" then\n        failwith \"Test Case 3 failed\"\n    if determineSign 100 <> \"positive\" then\n        failwith \"Test Case 4 failed\"\n    if determineSign -100 <> \"negative\" then\n        failwith \"Test Case 5 failed\"\n    if determineSign 1 <> \"positive\" then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "determineSign", "signature": "let determineSign (n: int): string =", "docstring": "\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n", "instruction": "Below is a explanation of F# code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n\n\n* Incomplete Code:\nlet determineSign (n: int): string =\n    match n with\n    | _ when n > 0 -> \"positive\"\n[MASK]\n    | _ -> \"negative\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    match n with\n    | _ when n > 0 -> \"positive\"\n[MASK]\n    | _ -> \"negative\""}
