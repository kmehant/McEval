{"task_id": "Swift/1-0-single", "prompt": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/", "canonical_solution": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}", "test": "func check(_ hasCloseElements: ([Double], Double) -> Bool) {\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\nassert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\n}\n\ncheck(hasCloseElements)", "entry_point": "hasCloseElements", "signature": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {", "docstring": "\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\n[MASK]\n}\n}\n}\n}\nreturn false\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\n[MASK]\n}\n}\n}\n}\nreturn false\n}"}
{"task_id": "Swift/1-1-single", "prompt": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/", "canonical_solution": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}", "test": "func check(_ hasCloseElements: ([Double], Double) -> Bool) {\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\nassert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\n}\n\ncheck(hasCloseElements)", "entry_point": "hasCloseElements", "signature": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {", "docstring": "\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\n[MASK]\n}"}
{"task_id": "Swift/2-0-single", "prompt": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/", "canonical_solution": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}", "test": "func checkFirstPalindrome(_ firstPalindrome: ([String]) -> String) {\nassert(firstPalindrome([\"apple\", \"banana\", \"civic\"]) == \"civic\", \"Test failed: Expected 'civic'\")\nassert(firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"]) == \"ada\", \"Test failed: Expected 'ada'\")\nassert(firstPalindrome([\"hello\", \"world\"]) == \"\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"radar\", \"rotor\", \"level\"]) == \"radar\", \"Test failed: Expected 'radar'\")\nassert(firstPalindrome([\"not\", \"a\", \"single\", \"palindrome\"]) == \"a\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"A\", \"B\", \"C\", \"D\"]) == \"A\", \"Test failed: Expected 'A'\")\nassert(firstPalindrome([\"noon\", \"evening\", \"morning\"]) == \"noon\", \"Test failed: Expected 'noon'\")\n}\n\n\ncheckFirstPalindrome(firstPalindrome)", "entry_point": "firstPalindrome", "signature": "func firstPalindrome(_ words: [String]) -> String {", "docstring": "\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n\n\n* Incomplete Code:\nfunc firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\n[MASK]\n}"}
{"task_id": "Swift/2-1-single", "prompt": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/", "canonical_solution": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}", "test": "func checkFirstPalindrome(_ firstPalindrome: ([String]) -> String) {\nassert(firstPalindrome([\"apple\", \"banana\", \"civic\"]) == \"civic\", \"Test failed: Expected 'civic'\")\nassert(firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"]) == \"ada\", \"Test failed: Expected 'ada'\")\nassert(firstPalindrome([\"hello\", \"world\"]) == \"\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"radar\", \"rotor\", \"level\"]) == \"radar\", \"Test failed: Expected 'radar'\")\nassert(firstPalindrome([\"not\", \"a\", \"single\", \"palindrome\"]) == \"a\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"A\", \"B\", \"C\", \"D\"]) == \"A\", \"Test failed: Expected 'A'\")\nassert(firstPalindrome([\"noon\", \"evening\", \"morning\"]) == \"noon\", \"Test failed: Expected 'noon'\")\n}\n\n\ncheckFirstPalindrome(firstPalindrome)", "entry_point": "firstPalindrome", "signature": "func firstPalindrome(_ words: [String]) -> String {", "docstring": "\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n\n\n* Incomplete Code:\nfunc firstPalindrome(_ words: [String]) -> String {\n[MASK]\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}"}
{"task_id": "Swift/3-0-single", "prompt": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/", "canonical_solution": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}", "test": "func checkMaxWordCount(_ maxWordCount: ([String]) -> Int) {\nassert(maxWordCount([\"Hello world\", \"Swift is amazing\"]) == 3)\nassert(maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"]) == 5)\nassert(maxWordCount([\"single\"]) == 1)\nassert(maxWordCount([\"\", \"one two\", \"one two three\"]) == 3)\nassert(maxWordCount([\"This is a test sentence\", \"This is another\"]) == 5)\nassert(maxWordCount([\"Sentence with five words\", \"Shorter one\"]) == 4)\n}\n\ncheckMaxWordCount(maxWordCount)", "entry_point": "maxWordCount", "signature": "func maxWordCount(_ sentences: [String]) -> Int {", "docstring": "\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n\n\n* Incomplete Code:\nfunc maxWordCount(_ sentences: [String]) -> Int {\n[MASK]\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}"}
{"task_id": "Swift/3-1-single", "prompt": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/", "canonical_solution": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}", "test": "func checkMaxWordCount(_ maxWordCount: ([String]) -> Int) {\nassert(maxWordCount([\"Hello world\", \"Swift is amazing\"]) == 3)\nassert(maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"]) == 5)\nassert(maxWordCount([\"single\"]) == 1)\nassert(maxWordCount([\"\", \"one two\", \"one two three\"]) == 3)\nassert(maxWordCount([\"This is a test sentence\", \"This is another\"]) == 5)\nassert(maxWordCount([\"Sentence with five words\", \"Shorter one\"]) == 4)\n}\n\ncheckMaxWordCount(maxWordCount)", "entry_point": "maxWordCount", "signature": "func maxWordCount(_ sentences: [String]) -> Int {", "docstring": "\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n\n\n* Incomplete Code:\nfunc maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\n[MASK]\n}"}
{"task_id": "Swift/4-0-single", "prompt": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/", "canonical_solution": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}", "test": "func checkIsValidMatrix(_ isValidMatrix: ([[Int]]) -> Bool) {\nassert(isValidMatrix([[1,2,3],[3,1,2],[2,3,1]]) == true)\nassert(isValidMatrix([[1,2,3],[3,2,1],[1,2,3]]) == false)\nassert(isValidMatrix([[1]]) == true)\nassert(isValidMatrix([[1,2],[2,1]]) == true)\nassert(isValidMatrix([[1,2],[1,2]]) == false)\nassert(isValidMatrix([[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]) == true)\nassert(isValidMatrix([[4,3,2,1],[3,2,1,4],[2,1,4,3],[1,4,3,2]]) == true)\nassert(isValidMatrix([[1,2,3],[3,1,2],[3,2,1]]) == false)\n}\n\ncheckIsValidMatrix(isValidMatrix)", "entry_point": "isValidMatrix", "signature": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {", "docstring": "\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n\n\n* Incomplete Code:\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\n[MASK]\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\n[MASK]\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}"}
{"task_id": "Swift/4-1-single", "prompt": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/", "canonical_solution": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}", "test": "func checkIsValidMatrix(_ isValidMatrix: ([[Int]]) -> Bool) {\nassert(isValidMatrix([[1,2,3],[3,1,2],[2,3,1]]) == true)\nassert(isValidMatrix([[1,2,3],[3,2,1],[1,2,3]]) == false)\nassert(isValidMatrix([[1]]) == true)\nassert(isValidMatrix([[1,2],[2,1]]) == true)\nassert(isValidMatrix([[1,2],[1,2]]) == false)\nassert(isValidMatrix([[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]) == true)\nassert(isValidMatrix([[4,3,2,1],[3,2,1,4],[2,1,4,3],[1,4,3,2]]) == true)\nassert(isValidMatrix([[1,2,3],[3,1,2],[3,2,1]]) == false)\n}\n\ncheckIsValidMatrix(isValidMatrix)", "entry_point": "isValidMatrix", "signature": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {", "docstring": "\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n\n\n* Incomplete Code:\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\n[MASK]\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "let n = matrix.count\nfor i in 0..<n {\n[MASK]\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}"}
{"task_id": "Swift/5-0-single", "prompt": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n*/", "canonical_solution": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}", "test": "func checkMinCostToBuyCandies(_ minCostToBuyCandies: ([Int]) -> Int) {\nassert(minCostToBuyCandies([1, 2, 3, 4]) == 8)\nassert(minCostToBuyCandies([1, 2]) == 3)\nassert(minCostToBuyCandies([1, 6, 3, 5, 2, 4]) == 16)\nassert(minCostToBuyCandies([5, 5, 5, 5, 5, 5]) == 20)\nassert(minCostToBuyCandies([7, 1, 2, 9, 6, 4]) == 22)\nassert(minCostToBuyCandies([1]) == 1)\nassert(minCostToBuyCandies([]) == 0)\n}\n\ncheckMinCostToBuyCandies(minCostToBuyCandies)", "entry_point": "minCostToBuyCandies", "signature": "func minCostToBuyCandies(_ costs: [Int]) -> Int {", "docstring": "\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n\n\n* Incomplete Code:\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\n[MASK]\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\n[MASK]\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}"}
{"task_id": "Swift/5-1-single", "prompt": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n*/", "canonical_solution": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}", "test": "func checkMinCostToBuyCandies(_ minCostToBuyCandies: ([Int]) -> Int) {\nassert(minCostToBuyCandies([1, 2, 3, 4]) == 8)\nassert(minCostToBuyCandies([1, 2]) == 3)\nassert(minCostToBuyCandies([1, 6, 3, 5, 2, 4]) == 16)\nassert(minCostToBuyCandies([5, 5, 5, 5, 5, 5]) == 20)\nassert(minCostToBuyCandies([7, 1, 2, 9, 6, 4]) == 22)\nassert(minCostToBuyCandies([1]) == 1)\nassert(minCostToBuyCandies([]) == 0)\n}\n\ncheckMinCostToBuyCandies(minCostToBuyCandies)", "entry_point": "minCostToBuyCandies", "signature": "func minCostToBuyCandies(_ costs: [Int]) -> Int {", "docstring": "\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n\n\n* Incomplete Code:\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\n[MASK]\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\n[MASK]\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}"}
{"task_id": "Swift/7-0-single", "prompt": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n*/", "canonical_solution": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}", "test": "func checkFindFinalValue(_ findFinalValue: ([Int], Int) -> Int) {\nassert(findFinalValue([5, 3, 6, 1, 12], 3) == 24)\nassert(findFinalValue([2, 7, 9], 4) == 4)\nassert(findFinalValue([1, 2, 4, 8, 16], 1) == 32)\nassert(findFinalValue([10, 20, 30, 40], 10) == 80)\nassert(findFinalValue([5, 10, 20, 40], 2) == 2)\nassert(findFinalValue([], 1) == 1)\nassert(findFinalValue([100, 200, 300], 100) == 400)\n}\n\ncheckFindFinalValue(findFinalValue)", "entry_point": "findFinalValue", "signature": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {", "docstring": "\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n\n\n* Incomplete Code:\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\n[MASK]\ncurrent *= 2\n}\nreturn current\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\n[MASK]\ncurrent *= 2\n}\nreturn current\n}"}
{"task_id": "Swift/7-1-single", "prompt": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n*/", "canonical_solution": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}", "test": "func checkFindFinalValue(_ findFinalValue: ([Int], Int) -> Int) {\nassert(findFinalValue([5, 3, 6, 1, 12], 3) == 24)\nassert(findFinalValue([2, 7, 9], 4) == 4)\nassert(findFinalValue([1, 2, 4, 8, 16], 1) == 32)\nassert(findFinalValue([10, 20, 30, 40], 10) == 80)\nassert(findFinalValue([5, 10, 20, 40], 2) == 2)\nassert(findFinalValue([], 1) == 1)\nassert(findFinalValue([100, 200, 300], 100) == 400)\n}\n\ncheckFindFinalValue(findFinalValue)", "entry_point": "findFinalValue", "signature": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {", "docstring": "\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n\n\n* Incomplete Code:\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\n[MASK]\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var current = original\n[MASK]\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}"}
{"task_id": "Swift/8-0-single", "prompt": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/", "canonical_solution": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}", "test": "func checkReorderArray(_ reorderArray: ([Int]) -> [Int]) {\nassert(reorderArray([4, 1, 2, 3]) == [2, 3, 4, 1])\nassert(reorderArray([6, 5, 4, 3, 2, 1]) == [2, 5, 4, 3, 6, 1])\nassert(reorderArray([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2])\nassert(reorderArray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1])\nassert(reorderArray([1]) == [1])\nassert(reorderArray([1, 2]) == [1, 2])\nassert(reorderArray([]) == [])\n}\n\ncheckReorderArray(reorderArray)", "entry_point": "reorderArray", "signature": "func reorderArray(_ nums: [Int]) -> [Int] {", "docstring": "\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n\n\n* Incomplete Code:\nfunc reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\n[MASK]\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\n[MASK]\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}"}
{"task_id": "Swift/8-1-single", "prompt": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/", "canonical_solution": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}", "test": "func checkReorderArray(_ reorderArray: ([Int]) -> [Int]) {\nassert(reorderArray([4, 1, 2, 3]) == [2, 3, 4, 1])\nassert(reorderArray([6, 5, 4, 3, 2, 1]) == [2, 5, 4, 3, 6, 1])\nassert(reorderArray([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2])\nassert(reorderArray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1])\nassert(reorderArray([1]) == [1])\nassert(reorderArray([1, 2]) == [1, 2])\nassert(reorderArray([]) == [])\n}\n\ncheckReorderArray(reorderArray)", "entry_point": "reorderArray", "signature": "func reorderArray(_ nums: [Int]) -> [Int] {", "docstring": "\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n\n\n* Incomplete Code:\nfunc reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\n[MASK]\n}\nreturn result\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\n[MASK]\n}\nreturn result\n}"}
{"task_id": "Swift/9-0-single", "prompt": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n*/", "canonical_solution": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}", "test": "func checkCountDivisiblePairs(_ countDivisiblePairs: ([Int], Int) -> Int) {\nassert(countDivisiblePairs([1, 2, 3, 1, 2, 3], 3) == 1)\nassert(countDivisiblePairs([1, 1, 1, 1], 1) == 6)\nassert(countDivisiblePairs([1, 2, 3, 4, 5, 6], 7) == 0)\nassert(countDivisiblePairs([1, 2, 2, 1, 2], 2) == 4)\nassert(countDivisiblePairs([4, 4, 4, 4], 4) == 3)\nassert(countDivisiblePairs([], 5) == 0)\nassert(countDivisiblePairs([2, 2, 2, 2, 2], 3) == 7 )\n}\n\ncheckCountDivisiblePairs(countDivisiblePairs)", "entry_point": "countDivisiblePairs", "signature": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {", "docstring": "\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n\n\n* Incomplete Code:\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\n[MASK]\n}"}
{"task_id": "Swift/9-1-single", "prompt": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n*/", "canonical_solution": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}", "test": "func checkCountDivisiblePairs(_ countDivisiblePairs: ([Int], Int) -> Int) {\nassert(countDivisiblePairs([1, 2, 3, 1, 2, 3], 3) == 1)\nassert(countDivisiblePairs([1, 1, 1, 1], 1) == 6)\nassert(countDivisiblePairs([1, 2, 3, 4, 5, 6], 7) == 0)\nassert(countDivisiblePairs([1, 2, 2, 1, 2], 2) == 4)\nassert(countDivisiblePairs([4, 4, 4, 4], 4) == 3)\nassert(countDivisiblePairs([], 5) == 0)\nassert(countDivisiblePairs([2, 2, 2, 2, 2], 3) == 7 )\n}\n\ncheckCountDivisiblePairs(countDivisiblePairs)", "entry_point": "countDivisiblePairs", "signature": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {", "docstring": "\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n\n\n* Incomplete Code:\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\n[MASK]\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var count = 0\n[MASK]\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}"}
{"task_id": "Swift/11-0-single", "prompt": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n*/", "canonical_solution": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}", "test": "func checkRemoveAnagramWords(_ removeAnagramWords: ([String]) -> [String]) {\nassert(removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) == [\"ab\", \"cd\", \"e\"])\nassert(removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) == [\"abc\"])\nassert(removeAnagramWords([\"word\", \"drow\", \"hello\", \"world\"]) == [\"word\", \"hello\",\"world\"])\nassert(removeAnagramWords([\"a\", \"b\", \"c\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(removeAnagramWords([\"zzz\", \"zzz\", \"zzz\"]) == [\"zzz\"])\nassert(removeAnagramWords([\"abcd\", \"dbca\", \"dcba\"]) == [\"abcd\"])\n}\n\ncheckRemoveAnagramWords(removeAnagramWords)", "entry_point": "removeAnagramWords", "signature": "func removeAnagramWords(_ words: [String]) -> [String] {", "docstring": "\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n\n\n* Incomplete Code:\nfunc removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\n[MASK]\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var result = words\n[MASK]\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}"}
{"task_id": "Swift/11-1-single", "prompt": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n*/", "canonical_solution": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}", "test": "func checkRemoveAnagramWords(_ removeAnagramWords: ([String]) -> [String]) {\nassert(removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) == [\"ab\", \"cd\", \"e\"])\nassert(removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) == [\"abc\"])\nassert(removeAnagramWords([\"word\", \"drow\", \"hello\", \"world\"]) == [\"word\", \"hello\",\"world\"])\nassert(removeAnagramWords([\"a\", \"b\", \"c\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(removeAnagramWords([\"zzz\", \"zzz\", \"zzz\"]) == [\"zzz\"])\nassert(removeAnagramWords([\"abcd\", \"dbca\", \"dcba\"]) == [\"abcd\"])\n}\n\ncheckRemoveAnagramWords(removeAnagramWords)", "entry_point": "removeAnagramWords", "signature": "func removeAnagramWords(_ words: [String]) -> [String] {", "docstring": "\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n\n\n* Incomplete Code:\nfunc removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\n[MASK]\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\n[MASK]\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}"}
{"task_id": "Swift/12-0-single", "prompt": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n*/", "canonical_solution": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}", "test": "func checkMostFrequentTargetAfterKey(_ mostFrequentTargetAfterKey: ([Int], Int) -> Int) {\nassert(mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1) == 2)\nassert(mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1) == 1)\nassert(mostFrequentTargetAfterKey([1, 2, 3, 1, 2, 3, 1, 2], 2) == 3)\nassert(mostFrequentTargetAfterKey([7, 7, 7, 8, 8, 9, 7, 9, 9], 7) == 7)\nassert(mostFrequentTargetAfterKey([1], 1) == 1)\nassert(mostFrequentTargetAfterKey([2, 2, 2, 2, 2, 3], 2) == 2)\n}\n\ncheckMostFrequentTargetAfterKey(mostFrequentTargetAfterKey)", "entry_point": "mostFrequentTargetAfterKey", "signature": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {", "docstring": "\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n\n\n* Incomplete Code:\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\n[MASK]\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\n[MASK]\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}"}
{"task_id": "Swift/12-1-single", "prompt": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n*/", "canonical_solution": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}", "test": "func checkMostFrequentTargetAfterKey(_ mostFrequentTargetAfterKey: ([Int], Int) -> Int) {\nassert(mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1) == 2)\nassert(mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1) == 1)\nassert(mostFrequentTargetAfterKey([1, 2, 3, 1, 2, 3, 1, 2], 2) == 3)\nassert(mostFrequentTargetAfterKey([7, 7, 7, 8, 8, 9, 7, 9, 9], 7) == 7)\nassert(mostFrequentTargetAfterKey([1], 1) == 1)\nassert(mostFrequentTargetAfterKey([2, 2, 2, 2, 2, 3], 2) == 2)\n}\n\ncheckMostFrequentTargetAfterKey(mostFrequentTargetAfterKey)", "entry_point": "mostFrequentTargetAfterKey", "signature": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {", "docstring": "\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n\n\n* Incomplete Code:\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\n[MASK]\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\n[MASK]\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}"}
{"task_id": "Swift/13-0-single", "prompt": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n*/", "canonical_solution": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}", "test": "func checkKCloseNeighbors(_ kCloseNeighbors: ([Int], Int, Int) -> [Int]) {\nassert(kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2) == [0, 1, 2, 3, 4, 5, 6])\nassert(kCloseNeighbors([1, 2, 3, 4, 5], 3, 1) == [1, 2, 3])\nassert(kCloseNeighbors([1, 1, 1, 1, 1], 1, 0) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([5, 4, 3, 2, 1], 3, 2) == [0,1, 2, 3, 4])\nassert(kCloseNeighbors([7, 7, 7, 7, 7], 7, 3) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([], 1, 1) == [])\nassert(kCloseNeighbors([1, 2, 3, 4, 5, 6], 4, 1) == [2, 3, 4])\n}\n\ncheckKCloseNeighbors(kCloseNeighbors)", "entry_point": "kCloseNeighbors", "signature": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {", "docstring": "\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n\n\n* Incomplete Code:\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\n[MASK]\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\n[MASK]\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}"}
{"task_id": "Swift/13-1-single", "prompt": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n*/", "canonical_solution": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}", "test": "func checkKCloseNeighbors(_ kCloseNeighbors: ([Int], Int, Int) -> [Int]) {\nassert(kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2) == [0, 1, 2, 3, 4, 5, 6])\nassert(kCloseNeighbors([1, 2, 3, 4, 5], 3, 1) == [1, 2, 3])\nassert(kCloseNeighbors([1, 1, 1, 1, 1], 1, 0) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([5, 4, 3, 2, 1], 3, 2) == [0,1, 2, 3, 4])\nassert(kCloseNeighbors([7, 7, 7, 7, 7], 7, 3) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([], 1, 1) == [])\nassert(kCloseNeighbors([1, 2, 3, 4, 5, 6], 4, 1) == [2, 3, 4])\n}\n\ncheckKCloseNeighbors(kCloseNeighbors)", "entry_point": "kCloseNeighbors", "signature": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {", "docstring": "\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n\n\n* Incomplete Code:\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\n[MASK]\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\n[MASK]\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}"}
{"task_id": "Swift/14-0-single", "prompt": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n*/", "canonical_solution": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}", "test": "func checkCanFormPairs(_ canFormPairs: ([Int]) -> Bool) {\nassert(canFormPairs([1, 2, 2, 1]) == true)\nassert(canFormPairs([1, 2, 3, 4, 5, 6]) == false)\nassert(canFormPairs([3, 3, 3, 3, 3, 3]) == true)\nassert(canFormPairs([0, 0]) == true)\nassert(canFormPairs([1, 1, 2, 2, 2, 2, 3, 3]) == true)\nassert(canFormPairs([1, 2, 3, 4, 4, 3, 2, 1, 5]) == false)\nassert(canFormPairs([]) == true)\n}\n\ncheckCanFormPairs(canFormPairs)", "entry_point": "canFormPairs", "signature": "func canFormPairs(_ nums: [Int]) -> Bool {", "docstring": "\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n\n\n* Incomplete Code:\nfunc canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\n[MASK]\nreturn false\n}\n}\n\nreturn true\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\n[MASK]\nreturn false\n}\n}\n\nreturn true\n}"}
{"task_id": "Swift/14-1-single", "prompt": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n*/", "canonical_solution": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}", "test": "func checkCanFormPairs(_ canFormPairs: ([Int]) -> Bool) {\nassert(canFormPairs([1, 2, 2, 1]) == true)\nassert(canFormPairs([1, 2, 3, 4, 5, 6]) == false)\nassert(canFormPairs([3, 3, 3, 3, 3, 3]) == true)\nassert(canFormPairs([0, 0]) == true)\nassert(canFormPairs([1, 1, 2, 2, 2, 2, 3, 3]) == true)\nassert(canFormPairs([1, 2, 3, 4, 4, 3, 2, 1, 5]) == false)\nassert(canFormPairs([]) == true)\n}\n\ncheckCanFormPairs(canFormPairs)", "entry_point": "canFormPairs", "signature": "func canFormPairs(_ nums: [Int]) -> Bool {", "docstring": "\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n\n\n* Incomplete Code:\nfunc canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\n[MASK]\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\n[MASK]\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}"}
{"task_id": "Swift/15-0-single", "prompt": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n*/", "canonical_solution": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}", "test": "func checkFindUniqueElements(_ findUniqueElements: ([Int], [Int]) -> [[Int]]) {\nassert(findUniqueElements([1, 2, 3], [2, 3, 4]) == [[1], [4]])\nassert(findUniqueElements( [1, 1, 2, 3], [3, 4, 4, 5]) == [[1, 2], [4, 5]])\nassert(findUniqueElements( [1, 2, 2], [1, 1, 1]) == [[2], []])\nassert(findUniqueElements( [], [1, 2, 3]) == [[], [1, 2, 3]])\nassert(findUniqueElements( [4, 5, 6], [4, 5, 6]) == [[], []])\nassert(findUniqueElements( [10], [10, 20]) == [[], [20]])\n}\n\ncheckFindUniqueElements(findUniqueElements)", "entry_point": "findUniqueElements", "signature": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {", "docstring": "\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n\n\n* Incomplete Code:\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\n[MASK]\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "let set1 = Set(nums1)\n[MASK]\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}"}
{"task_id": "Swift/15-1-single", "prompt": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n*/", "canonical_solution": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}", "test": "func checkFindUniqueElements(_ findUniqueElements: ([Int], [Int]) -> [[Int]]) {\nassert(findUniqueElements([1, 2, 3], [2, 3, 4]) == [[1], [4]])\nassert(findUniqueElements( [1, 1, 2, 3], [3, 4, 4, 5]) == [[1, 2], [4, 5]])\nassert(findUniqueElements( [1, 2, 2], [1, 1, 1]) == [[2], []])\nassert(findUniqueElements( [], [1, 2, 3]) == [[], [1, 2, 3]])\nassert(findUniqueElements( [4, 5, 6], [4, 5, 6]) == [[], []])\nassert(findUniqueElements( [10], [10, 20]) == [[], [20]])\n}\n\ncheckFindUniqueElements(findUniqueElements)", "entry_point": "findUniqueElements", "signature": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {", "docstring": "\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n\n\n* Incomplete Code:\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\n[MASK]\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\n[MASK]\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}"}
{"task_id": "Swift/16-0-single", "prompt": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n*/", "canonical_solution": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}", "test": "func checkClosestToZero(_ closestToZero: ([Int]) -> Int) {\nassert(closestToZero([2, -1, 1]) == 1)\nassert(closestToZero([-3, -2, -1]) == -1)\nassert(closestToZero([0, 10, 20]) == 0)\nassert(closestToZero([5, 6, 7]) == 5)\nassert(closestToZero([-5, 5]) == 5)\nassert(closestToZero([-10, -5, 0, 5, 10]) == 0)\nassert(closestToZero([]) == 0)\n}\n\ncheckClosestToZero(closestToZero)", "entry_point": "closestToZero", "signature": "func closestToZero(_ nums: [Int]) -> Int {", "docstring": "\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n\n\n* Incomplete Code:\nfunc closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\n[MASK]\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\n[MASK]\nclosestNumber = num\n}\n}\nreturn closestNumber\n}"}
{"task_id": "Swift/16-1-single", "prompt": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n*/", "canonical_solution": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}", "test": "func checkClosestToZero(_ closestToZero: ([Int]) -> Int) {\nassert(closestToZero([2, -1, 1]) == 1)\nassert(closestToZero([-3, -2, -1]) == -1)\nassert(closestToZero([0, 10, 20]) == 0)\nassert(closestToZero([5, 6, 7]) == 5)\nassert(closestToZero([-5, 5]) == 5)\nassert(closestToZero([-10, -5, 0, 5, 10]) == 0)\nassert(closestToZero([]) == 0)\n}\n\ncheckClosestToZero(closestToZero)", "entry_point": "closestToZero", "signature": "func closestToZero(_ nums: [Int]) -> Int {", "docstring": "\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n\n\n* Incomplete Code:\nfunc closestToZero(_ nums: [Int]) -> Int {\n[MASK]\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}"}
{"task_id": "Swift/17-0-single", "prompt": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n*/", "canonical_solution": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}", "test": "func checkCommonElementsInAllArrays(_ commonElementsInAllArrays: ([[Int]]) -> [Int]) {\nassert(commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == [3])\nassert(commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]]) == [2])\nassert(commonElementsInAllArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [])\nassert(commonElementsInAllArrays([[10, 20], [20, 30], [20, 40]]) == [20])\nassert(commonElementsInAllArrays([[1]]) == [1])\nassert(commonElementsInAllArrays([]) == [])\nassert(commonElementsInAllArrays([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == [4])\n}\n\ncheckCommonElementsInAllArrays(commonElementsInAllArrays)", "entry_point": "commonElementsInAllArrays", "signature": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {", "docstring": "\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n\n\n* Incomplete Code:\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\n[MASK]\n}\n\nreturn Array(common).sorted()\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\n[MASK]\n}\n\nreturn Array(common).sorted()\n}"}
{"task_id": "Swift/17-1-single", "prompt": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n*/", "canonical_solution": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}", "test": "func checkCommonElementsInAllArrays(_ commonElementsInAllArrays: ([[Int]]) -> [Int]) {\nassert(commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == [3])\nassert(commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]]) == [2])\nassert(commonElementsInAllArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [])\nassert(commonElementsInAllArrays([[10, 20], [20, 30], [20, 40]]) == [20])\nassert(commonElementsInAllArrays([[1]]) == [1])\nassert(commonElementsInAllArrays([]) == [])\nassert(commonElementsInAllArrays([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == [4])\n}\n\ncheckCommonElementsInAllArrays(commonElementsInAllArrays)", "entry_point": "commonElementsInAllArrays", "signature": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {", "docstring": "\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n\n\n* Incomplete Code:\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n[MASK]\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}"}
{"task_id": "Swift/18-0-single", "prompt": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n*/", "canonical_solution": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}", "test": "func checkPerformAlgorithmOnNums(_ performAlgorithmOnNums: ([Int]) -> Int) {\nassert(performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8]) == 1)\nassert(performAlgorithmOnNums([10, 100, 30, 20]) == 10)\nassert(performAlgorithmOnNums([2, 4]) == 2)\nassert(performAlgorithmOnNums([7]) == 7)\n}\n\ncheckPerformAlgorithmOnNums(performAlgorithmOnNums)", "entry_point": "performAlgorithmOnNums", "signature": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {", "docstring": "\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n\n\n* Incomplete Code:\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n[MASK]\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n[MASK]\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}"}
{"task_id": "Swift/18-1-single", "prompt": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n*/", "canonical_solution": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}", "test": "func checkPerformAlgorithmOnNums(_ performAlgorithmOnNums: ([Int]) -> Int) {\nassert(performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8]) == 1)\nassert(performAlgorithmOnNums([10, 100, 30, 20]) == 10)\nassert(performAlgorithmOnNums([2, 4]) == 2)\nassert(performAlgorithmOnNums([7]) == 7)\n}\n\ncheckPerformAlgorithmOnNums(performAlgorithmOnNums)", "entry_point": "performAlgorithmOnNums", "signature": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {", "docstring": "\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n\n\n* Incomplete Code:\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\n[MASK]\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\n[MASK]\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}"}
{"task_id": "Swift/20-0-single", "prompt": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/", "canonical_solution": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}", "test": "func checkTwoSum(_ twoSum: ([Int], Int) -> [Int]) {\nassert(twoSum([2, 7, 11, 15], 9) == [0, 1])\nassert(twoSum([3, 2, 4], 6) == [1, 2])\nassert(twoSum([3, 3], 6) == [0, 1])\nassert(twoSum([1, 5, 4, 7], 8) == [0, 3])\nassert(twoSum([1, 2, 3, 4], 7) == [2, 3])\nassert(twoSum([4, 4], 8) == [0, 1])\nassert(twoSum([-1, -2, -3, -4, -5], -8) == [2, 4])\n}\n\ncheckTwoSum(twoSum)", "entry_point": "twoSum", "signature": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {", "docstring": "\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n\n\n* Incomplete Code:\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\n[MASK]\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\n[MASK]\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}"}
{"task_id": "Swift/20-1-single", "prompt": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/", "canonical_solution": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}", "test": "func checkTwoSum(_ twoSum: ([Int], Int) -> [Int]) {\nassert(twoSum([2, 7, 11, 15], 9) == [0, 1])\nassert(twoSum([3, 2, 4], 6) == [1, 2])\nassert(twoSum([3, 3], 6) == [0, 1])\nassert(twoSum([1, 5, 4, 7], 8) == [0, 3])\nassert(twoSum([1, 2, 3, 4], 7) == [2, 3])\nassert(twoSum([4, 4], 8) == [0, 1])\nassert(twoSum([-1, -2, -3, -4, -5], -8) == [2, 4])\n}\n\ncheckTwoSum(twoSum)", "entry_point": "twoSum", "signature": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {", "docstring": "\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n\n\n* Incomplete Code:\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\n[MASK]\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var numToIndex = [Int: Int]()\n\n[MASK]\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}"}
{"task_id": "Swift/21-0-single", "prompt": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/", "canonical_solution": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}", "test": "func check(_ findFourthVertex: ((Int, Int), (Int, Int), (Int, Int)) -> (Int, Int)) {\nassert(findFourthVertex((5, 5), (5, 7), (7, 5)) == (7, 7))\nassert(findFourthVertex((2, 3), (2, 5), (4, 5)) == (4, 3))\nassert(findFourthVertex((10, 10), (10, 20), (20, 10)) == (20, 20))\nassert(findFourthVertex((15, 15), (10, 15), (10, 10)) == (15, 10))\nassert(findFourthVertex((3, 4), (5, 4), (3, 2)) == (5, 2))\nassert(findFourthVertex((8, 9), (8, 12), (11, 12)) == (11, 9))\n}\n\ncheck(findFourthVertex)", "entry_point": "findFourthVertex", "signature": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {", "docstring": "\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n\n\n* Incomplete Code:\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\n[MASK]\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\n[MASK]\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}"}
{"task_id": "Swift/21-1-single", "prompt": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/", "canonical_solution": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}", "test": "func check(_ findFourthVertex: ((Int, Int), (Int, Int), (Int, Int)) -> (Int, Int)) {\nassert(findFourthVertex((5, 5), (5, 7), (7, 5)) == (7, 7))\nassert(findFourthVertex((2, 3), (2, 5), (4, 5)) == (4, 3))\nassert(findFourthVertex((10, 10), (10, 20), (20, 10)) == (20, 20))\nassert(findFourthVertex((15, 15), (10, 15), (10, 10)) == (15, 10))\nassert(findFourthVertex((3, 4), (5, 4), (3, 2)) == (5, 2))\nassert(findFourthVertex((8, 9), (8, 12), (11, 12)) == (11, 9))\n}\n\ncheck(findFourthVertex)", "entry_point": "findFourthVertex", "signature": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {", "docstring": "\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n\n\n* Incomplete Code:\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n[MASK]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}"}
{"task_id": "Swift/22-0-single", "prompt": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n*/", "canonical_solution": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}", "test": "func testAdjustChessPieces() {\nassert(adjustChessPieces([1, 1, 2, 2, 2, 8]) == [0, 0, 0, 0, 0, 0], \"Test Case 1 Failed\")\nassert(adjustChessPieces([0, 2, 1, 2, 2, 5]) == [1, -1, 1, 0, 0, 3], \"Test Case 2 Failed\")\nassert(adjustChessPieces([1, 0, 2, 1, 3, 8]) == [0, 1, 0, 1, -1, 0], \"Test Case 3 Failed\")\nassert(adjustChessPieces([0, 1, 0, 0, 0, 0]) == [1, 0, 2, 2, 2, 8], \"Test Case 4 Failed\")\nassert(adjustChessPieces([2, 2, 3, 3, 3, 10]) == [-1, -1, -1, -1, -1, -2], \"Test Case 5 Failed\")\n}\n\ntestAdjustChessPieces()", "entry_point": "adjustChessPieces", "signature": "func adjustChessPieces(_ counts: [Int]) -> [Int] {", "docstring": "\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n\n\n* Incomplete Code:\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n[MASK]\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}"}
{"task_id": "Swift/22-1-single", "prompt": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n*/", "canonical_solution": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}", "test": "func testAdjustChessPieces() {\nassert(adjustChessPieces([1, 1, 2, 2, 2, 8]) == [0, 0, 0, 0, 0, 0], \"Test Case 1 Failed\")\nassert(adjustChessPieces([0, 2, 1, 2, 2, 5]) == [1, -1, 1, 0, 0, 3], \"Test Case 2 Failed\")\nassert(adjustChessPieces([1, 0, 2, 1, 3, 8]) == [0, 1, 0, 1, -1, 0], \"Test Case 3 Failed\")\nassert(adjustChessPieces([0, 1, 0, 0, 0, 0]) == [1, 0, 2, 2, 2, 8], \"Test Case 4 Failed\")\nassert(adjustChessPieces([2, 2, 3, 3, 3, 10]) == [-1, -1, -1, -1, -1, -2], \"Test Case 5 Failed\")\n}\n\ntestAdjustChessPieces()", "entry_point": "adjustChessPieces", "signature": "func adjustChessPieces(_ counts: [Int]) -> [Int] {", "docstring": "\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n\n\n* Incomplete Code:\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\n[MASK]\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\n[MASK]\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}"}
{"task_id": "Swift/24-0-single", "prompt": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/", "canonical_solution": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}", "test": "func testFindSmallestWordInMatrix() {\nassert(findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]]) == \"abc\")\nassert(findSmallestWordInMatrix([[\"a\", \"#\", \"c\"], [\"#\", \"d\", \"e\"], [\"f\", \"g\", \"#\"]]) == \"ce\")\nassert(findSmallestWordInMatrix([[\"#\", \"a\", \"#\"], [\"#\", \"b\", \"c\"], [\"#\", \"#\", \"d\"]]) == \"ab\")\nassert(findSmallestWordInMatrix([[\"m\", \"n\", \"o\"], [\"#\", \"#\", \"#\"], [\"p\", \"q\", \"r\"]]) == \"mno\")\nassert(findSmallestWordInMatrix([[\"x\", \"y\", \"#\"], [\"#\", \"z\", \"a\"], [\"b\", \"c\", \"d\"]]) == \"ad\")\n}\n\ntestFindSmallestWordInMatrix()", "entry_point": "findSmallestWordInMatrix", "signature": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {", "docstring": "\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n\n\n* Incomplete Code:\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n[MASK]\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}"}
{"task_id": "Swift/24-1-single", "prompt": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/", "canonical_solution": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}", "test": "func testFindSmallestWordInMatrix() {\nassert(findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]]) == \"abc\")\nassert(findSmallestWordInMatrix([[\"a\", \"#\", \"c\"], [\"#\", \"d\", \"e\"], [\"f\", \"g\", \"#\"]]) == \"ce\")\nassert(findSmallestWordInMatrix([[\"#\", \"a\", \"#\"], [\"#\", \"b\", \"c\"], [\"#\", \"#\", \"d\"]]) == \"ab\")\nassert(findSmallestWordInMatrix([[\"m\", \"n\", \"o\"], [\"#\", \"#\", \"#\"], [\"p\", \"q\", \"r\"]]) == \"mno\")\nassert(findSmallestWordInMatrix([[\"x\", \"y\", \"#\"], [\"#\", \"z\", \"a\"], [\"b\", \"c\", \"d\"]]) == \"ad\")\n}\n\ntestFindSmallestWordInMatrix()", "entry_point": "findSmallestWordInMatrix", "signature": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {", "docstring": "\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n\n\n* Incomplete Code:\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\n[MASK]\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\n[MASK]\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}"}
{"task_id": "Swift/25-0-single", "prompt": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n*/", "canonical_solution": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}", "test": "func testFindMissingNumber() {\nassert(findMissingNumber(in: [3, 7, 5]) == 1 || findMissingNumber(in: [3, 7, 5]) == 9)\nassert(findMissingNumber(in: [20, 14, 8]) == 26 || findMissingNumber(in: [20, 14, 8]) == 2)\nassert(findMissingNumber(in: [12, 6, 18]) == 0 || findMissingNumber(in: [12, 6, 18]) == 24)\nassert(findMissingNumber(in: [-4, 0, -8]) == -12 || findMissingNumber(in: [-4, 0, -8]) == 4)\nassert(findMissingNumber(in: [15, 5, 10]) == 0 || findMissingNumber(in: [15, 5, 10]) == 20)\n}\n\ntestFindMissingNumber()", "entry_point": "findMissingNumber", "signature": "func findMissingNumber(in numbers: [Int]) -> Int {", "docstring": "\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n\n\n* Incomplete Code:\nfunc findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\n[MASK]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "let sortedNumbers = numbers.sorted()\n[MASK]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}"}
{"task_id": "Swift/25-1-single", "prompt": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n*/", "canonical_solution": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}", "test": "func testFindMissingNumber() {\nassert(findMissingNumber(in: [3, 7, 5]) == 1 || findMissingNumber(in: [3, 7, 5]) == 9)\nassert(findMissingNumber(in: [20, 14, 8]) == 26 || findMissingNumber(in: [20, 14, 8]) == 2)\nassert(findMissingNumber(in: [12, 6, 18]) == 0 || findMissingNumber(in: [12, 6, 18]) == 24)\nassert(findMissingNumber(in: [-4, 0, -8]) == -12 || findMissingNumber(in: [-4, 0, -8]) == 4)\nassert(findMissingNumber(in: [15, 5, 10]) == 0 || findMissingNumber(in: [15, 5, 10]) == 20)\n}\n\ntestFindMissingNumber()", "entry_point": "findMissingNumber", "signature": "func findMissingNumber(in numbers: [Int]) -> Int {", "docstring": "\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n\n\n* Incomplete Code:\nfunc findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\n[MASK]\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\n[MASK]\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}"}
{"task_id": "Swift/26-0-single", "prompt": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/", "canonical_solution": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}", "test": "func testCountUnfairReminders() {\nassert(countUnfairReminders([\"mirko\", \"stanko\", \"stanko\", \"stanko\"]) == 1)\nassert(countUnfairReminders([\"a\", \"b\", \"b\", \"a\", \"a\", \"a\", \"c\", \"a\", \"b\", \"b\", \"c\", \"b\"]) == 0)\nassert(countUnfairReminders([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 10)\nassert(countUnfairReminders([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\"]) == 0)\nprint(\"All test cases pass.\")\n}\n\ntestCountUnfairReminders()", "entry_point": "countUnfairReminders", "signature": "func countUnfairReminders(_ children: [String]) -> Int {", "docstring": "\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n\n\n* Incomplete Code:\nfunc countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\n[MASK]\n}\n}\n\nreturn reminders\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\n[MASK]\n}\n}\n\nreturn reminders\n}"}
{"task_id": "Swift/26-1-single", "prompt": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/", "canonical_solution": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}", "test": "func testCountUnfairReminders() {\nassert(countUnfairReminders([\"mirko\", \"stanko\", \"stanko\", \"stanko\"]) == 1)\nassert(countUnfairReminders([\"a\", \"b\", \"b\", \"a\", \"a\", \"a\", \"c\", \"a\", \"b\", \"b\", \"c\", \"b\"]) == 0)\nassert(countUnfairReminders([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 10)\nassert(countUnfairReminders([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\"]) == 0)\nprint(\"All test cases pass.\")\n}\n\ntestCountUnfairReminders()", "entry_point": "countUnfairReminders", "signature": "func countUnfairReminders(_ children: [String]) -> Int {", "docstring": "\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n\n\n* Incomplete Code:\nfunc countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\n[MASK]\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var foodCounts = [String: Int]()\nvar reminders = 0\n\n[MASK]\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}"}
{"task_id": "Swift/28-0-single", "prompt": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/", "canonical_solution": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}", "test": "func testCheckLikes(_ checkLikes: (Int) -> (Int, Int, Int, Int)) {\nassert(checkLikes(12) == (0, 1, 1, 0))\nassert(checkLikes(5) == (0, 1, 1, 0))\nassert(checkLikes(6) == (1, 1, 0, 0))\nassert(checkLikes(3) == (0, 0, 0, 1))\nassert(checkLikes(13) == (0, 0, 0, 1))\nassert(checkLikes(4) == (0, 1, 1, 0))\nassert(checkLikes(11) == (0, 1, 1, 0))\nassert(checkLikes(7) == (0, 1, 1, 0))\nassert(checkLikes(2) == (0, 1, 1, 0))\n}\n\ntestCheckLikes(checkLikes)", "entry_point": "checkLikes", "signature": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {", "docstring": "\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n\n\n* Incomplete Code:\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n[MASK]\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}"}
{"task_id": "Swift/28-1-single", "prompt": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/", "canonical_solution": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}", "test": "func testCheckLikes(_ checkLikes: (Int) -> (Int, Int, Int, Int)) {\nassert(checkLikes(12) == (0, 1, 1, 0))\nassert(checkLikes(5) == (0, 1, 1, 0))\nassert(checkLikes(6) == (1, 1, 0, 0))\nassert(checkLikes(3) == (0, 0, 0, 1))\nassert(checkLikes(13) == (0, 0, 0, 1))\nassert(checkLikes(4) == (0, 1, 1, 0))\nassert(checkLikes(11) == (0, 1, 1, 0))\nassert(checkLikes(7) == (0, 1, 1, 0))\nassert(checkLikes(2) == (0, 1, 1, 0))\n}\n\ntestCheckLikes(checkLikes)", "entry_point": "checkLikes", "signature": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {", "docstring": "\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n\n\n* Incomplete Code:\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\n[MASK]\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\n[MASK]\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}"}
{"task_id": "Swift/29-0-single", "prompt": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/", "canonical_solution": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}", "test": "func check(_ isLeapYear: (Int) -> Int) {\nassert(isLeapYear(1926) == 0)\nassert(isLeapYear(1900) == 0)\nassert(isLeapYear(2000) == 1)\nassert(isLeapYear(1996) == 1)\nassert(isLeapYear(2020) == 1)\nassert(isLeapYear(2021) == 0)\nassert(isLeapYear(2022) == 0)\nassert(isLeapYear(2023) == 0)\nassert(isLeapYear(2024) == 1)\n}\n\ncheck(isLeapYear)", "entry_point": "isLeapYear", "signature": "func isLeapYear(_ year: Int) -> Int {", "docstring": "\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n\n\n* Incomplete Code:\nfunc isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\n[MASK]\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\n[MASK]\n}\n}"}
{"task_id": "Swift/29-1-single", "prompt": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/", "canonical_solution": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}", "test": "func check(_ isLeapYear: (Int) -> Int) {\nassert(isLeapYear(1926) == 0)\nassert(isLeapYear(1900) == 0)\nassert(isLeapYear(2000) == 1)\nassert(isLeapYear(1996) == 1)\nassert(isLeapYear(2020) == 1)\nassert(isLeapYear(2021) == 0)\nassert(isLeapYear(2022) == 0)\nassert(isLeapYear(2023) == 0)\nassert(isLeapYear(2024) == 1)\n}\n\ncheck(isLeapYear)", "entry_point": "isLeapYear", "signature": "func isLeapYear(_ year: Int) -> Int {", "docstring": "\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n\n\n* Incomplete Code:\nfunc isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n[MASK]\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n[MASK]\nreturn 1\n}\n} else {\nreturn 0\n}\n}"}
{"task_id": "Swift/30-0-single", "prompt": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/", "canonical_solution": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}", "test": "func testDaysInMonth() {\n// Non-leap years\nassert(daysInMonth(1926, 8) == 31)\nassert(daysInMonth(1999, 12) == 31)\n\n// Leap years\nassert(daysInMonth(2000, 2) == 29)\nassert(daysInMonth(2020, 2) == 29)\n\n// Months with 30 days\nassert(daysInMonth(2022, 4) == 30)\nassert(daysInMonth(2022, 6) == 30)\n\n// Months with 31 days\nassert(daysInMonth(2022, 1) == 31)\nassert(daysInMonth(2022, 3) == 31)\n}\n\ntestDaysInMonth()", "entry_point": "daysInMonth", "signature": "func daysInMonth(_ year: Int, _ month: Int) -> Int {", "docstring": "\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n\n\n* Incomplete Code:\nfunc daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\n[MASK]\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\n[MASK]\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}"}
{"task_id": "Swift/30-1-single", "prompt": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/", "canonical_solution": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}", "test": "func testDaysInMonth() {\n// Non-leap years\nassert(daysInMonth(1926, 8) == 31)\nassert(daysInMonth(1999, 12) == 31)\n\n// Leap years\nassert(daysInMonth(2000, 2) == 29)\nassert(daysInMonth(2020, 2) == 29)\n\n// Months with 30 days\nassert(daysInMonth(2022, 4) == 30)\nassert(daysInMonth(2022, 6) == 30)\n\n// Months with 31 days\nassert(daysInMonth(2022, 1) == 31)\nassert(daysInMonth(2022, 3) == 31)\n}\n\ntestDaysInMonth()", "entry_point": "daysInMonth", "signature": "func daysInMonth(_ year: Int, _ month: Int) -> Int {", "docstring": "\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n\n\n* Incomplete Code:\nfunc daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\n[MASK]\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\n[MASK]\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}"}
{"task_id": "Swift/31-0-single", "prompt": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/", "canonical_solution": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}", "test": "func check(_ minimumSwapsToOrder: ([Int]) -> Int) {\nassert(minimumSwapsToOrder([2, 3, 1]) == 2)\nassert(minimumSwapsToOrder([1, 4, 3, 2]) == 3)\nassert(minimumSwapsToOrder([5, 4, 3, 2, 1]) == 10)\nassert(minimumSwapsToOrder([1, 2, 3, 4, 5]) == 0)\nassert(minimumSwapsToOrder([3, 1, 2]) == 2)\nassert(minimumSwapsToOrder([4, 5, 1, 3, 2]) == 7)\nassert(minimumSwapsToOrder([1]) == 0)\n}\n\ncheck(minimumSwapsToOrder)", "entry_point": "minimumSwapsToOrder", "signature": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {", "docstring": "\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n\n\n* Incomplete Code:\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\n[MASK]\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\n[MASK]\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}"}
{"task_id": "Swift/31-1-single", "prompt": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/", "canonical_solution": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}", "test": "func check(_ minimumSwapsToOrder: ([Int]) -> Int) {\nassert(minimumSwapsToOrder([2, 3, 1]) == 2)\nassert(minimumSwapsToOrder([1, 4, 3, 2]) == 3)\nassert(minimumSwapsToOrder([5, 4, 3, 2, 1]) == 10)\nassert(minimumSwapsToOrder([1, 2, 3, 4, 5]) == 0)\nassert(minimumSwapsToOrder([3, 1, 2]) == 2)\nassert(minimumSwapsToOrder([4, 5, 1, 3, 2]) == 7)\nassert(minimumSwapsToOrder([1]) == 0)\n}\n\ncheck(minimumSwapsToOrder)", "entry_point": "minimumSwapsToOrder", "signature": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {", "docstring": "\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n\n\n* Incomplete Code:\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\n[MASK]\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "var cars = trainCars\n[MASK]\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}"}
{"task_id": "Swift/32-0-single", "prompt": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/", "canonical_solution": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}", "test": "func testIsLuckyWord() {\nassert(isLuckyWord(\"hello\") == (false, 0))\nassert(isLuckyWord(\"swift\") == (false, 0))\nassert(isLuckyWord(\"programming\") == (false, 0))\nassert(isLuckyWord(\"apple\") == (false, 0))\nassert(isLuckyWord(\"banana\") == (true, 2))\nassert(isLuckyWord(\"challenge\") == (false, 0))\nassert(isLuckyWord(\"developer\") == (true, 2))\n}\n\ntestIsLuckyWord()", "entry_point": "isLuckyWord", "signature": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {", "docstring": "\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n\n\n* Incomplete Code:\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\n[MASK]\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\n[MASK]\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}"}
{"task_id": "Swift/32-1-single", "prompt": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/", "canonical_solution": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}", "test": "func testIsLuckyWord() {\nassert(isLuckyWord(\"hello\") == (false, 0))\nassert(isLuckyWord(\"swift\") == (false, 0))\nassert(isLuckyWord(\"programming\") == (false, 0))\nassert(isLuckyWord(\"apple\") == (false, 0))\nassert(isLuckyWord(\"banana\") == (true, 2))\nassert(isLuckyWord(\"challenge\") == (false, 0))\nassert(isLuckyWord(\"developer\") == (true, 2))\n}\n\ntestIsLuckyWord()", "entry_point": "isLuckyWord", "signature": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {", "docstring": "\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n\n\n* Incomplete Code:\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\n[MASK]\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\n[MASK]\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}"}
{"task_id": "Swift/33-0-single", "prompt": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n*/", "canonical_solution": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}", "test": "func check(_ maxSubArraySum: ([Int]) -> Int) {\nassert(maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9)\nassert(maxSubArraySum([-2, -3, -1]) == -1)\nassert(maxSubArraySum([5, -3, 5]) == 7)\nassert(maxSubArraySum([-1, -2, -3, -4]) == -1)\nassert(maxSubArraySum([2, 3, -2, 5, -3]) == 8)\nassert(maxSubArraySum([10, -11, 12]) == 12)\nassert(maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6)\n}\n\ncheck(maxSubArraySum)", "entry_point": "maxSubArraySum", "signature": "func maxSubArraySum(_ nums: [Int]) -> Int {", "docstring": "\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n\n\n* Incomplete Code:\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\n[MASK]\n}\n\nreturn maxSoFar\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\n[MASK]\n}\n\nreturn maxSoFar\n}"}
{"task_id": "Swift/33-1-single", "prompt": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n*/", "canonical_solution": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}", "test": "func check(_ maxSubArraySum: ([Int]) -> Int) {\nassert(maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9)\nassert(maxSubArraySum([-2, -3, -1]) == -1)\nassert(maxSubArraySum([5, -3, 5]) == 7)\nassert(maxSubArraySum([-1, -2, -3, -4]) == -1)\nassert(maxSubArraySum([2, 3, -2, 5, -3]) == 8)\nassert(maxSubArraySum([10, -11, 12]) == 12)\nassert(maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6)\n}\n\ncheck(maxSubArraySum)", "entry_point": "maxSubArraySum", "signature": "func maxSubArraySum(_ nums: [Int]) -> Int {", "docstring": "\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n\n\n* Incomplete Code:\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\n[MASK]\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\n[MASK]\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}"}
{"task_id": "Swift/35-0-single", "prompt": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/", "canonical_solution": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}", "test": "func testKthUniqueSmallestNumber() {\nassert(kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2) == \"3\")\nassert(kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4) == \"4\")\nassert(kthUniqueSmallestNumber([10, 20, 30], 4) == \"NO RESULT\")\nassert(kthUniqueSmallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == \"7\")\nassert(kthUniqueSmallestNumber([12, 15, 12, 18, 20, 22, 15, 18], 3) == \"18\")\nassert(kthUniqueSmallestNumber([3, 3, 3, 3, 3], 1) == \"3\")\nassert(kthUniqueSmallestNumber([40, 30, 20, 10], 2) == \"20\")\n}\n\ntestKthUniqueSmallestNumber()", "entry_point": "kthUniqueSmallestNumber", "signature": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {", "docstring": "\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n\n\n* Incomplete Code:\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\n[MASK]\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\n[MASK]\n} else {\nreturn \"NO RESULT\"\n}\n}"}
{"task_id": "Swift/35-1-single", "prompt": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/", "canonical_solution": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}", "test": "func testKthUniqueSmallestNumber() {\nassert(kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2) == \"3\")\nassert(kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4) == \"4\")\nassert(kthUniqueSmallestNumber([10, 20, 30], 4) == \"NO RESULT\")\nassert(kthUniqueSmallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == \"7\")\nassert(kthUniqueSmallestNumber([12, 15, 12, 18, 20, 22, 15, 18], 3) == \"18\")\nassert(kthUniqueSmallestNumber([3, 3, 3, 3, 3], 1) == \"3\")\nassert(kthUniqueSmallestNumber([40, 30, 20, 10], 2) == \"20\")\n}\n\ntestKthUniqueSmallestNumber()", "entry_point": "kthUniqueSmallestNumber", "signature": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {", "docstring": "\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n\n\n* Incomplete Code:\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\n[MASK]\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "let uniqueNumbers = Set(numbers).sorted()\n[MASK]\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}"}
{"task_id": "Swift/36-0-single", "prompt": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/", "canonical_solution": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}", "test": "func check(_ findShortestDistanceAmongPoints: ([(Double, Double)]) -> Double) {\nassert(findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]) == 1.0000)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)]) == 1.4142)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (5.0, 5.0), (1.0, 6.0), (2.0, 1.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(2.0, 3.0), (4.0, 4.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(1.5, 1.5), (3.5, 3.5), (5.5, 5.5)]) == 2.8284)\n}\n\ncheck(findShortestDistanceAmongPoints)", "entry_point": "findShortestDistanceAmongPoints", "signature": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {", "docstring": "\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n\n\n* Incomplete Code:\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n[MASK]\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}"}
{"task_id": "Swift/36-1-single", "prompt": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/", "canonical_solution": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}", "test": "func check(_ findShortestDistanceAmongPoints: ([(Double, Double)]) -> Double) {\nassert(findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]) == 1.0000)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)]) == 1.4142)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (5.0, 5.0), (1.0, 6.0), (2.0, 1.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(2.0, 3.0), (4.0, 4.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(1.5, 1.5), (3.5, 3.5), (5.5, 5.5)]) == 2.8284)\n}\n\ncheck(findShortestDistanceAmongPoints)", "entry_point": "findShortestDistanceAmongPoints", "signature": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {", "docstring": "\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n\n\n* Incomplete Code:\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\n[MASK]\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\n[MASK]\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}"}
{"task_id": "Swift/37-0-single", "prompt": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/", "canonical_solution": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}", "test": "func check(_ countMealCombinations: ([Int], Int) -> Int) {\nassert(countMealCombinations([1, 2, 3], 4) == 1)\nassert(countMealCombinations([1, 1, 3, 4, 5], 5) == 4)\nassert(countMealCombinations([2, 2, 2, 2], 8) == 1)\nassert(countMealCombinations([1, 1, 1, 1, 1], 3) == 10)\nassert(countMealCombinations([5, 5, 5, 5, 5], 10) == 10)\nassert(countMealCombinations([10, 15, 20], 25) == 1)\nassert(countMealCombinations([1, 3, 4, 6], 9) == 1)\n}\n\ncheck(countMealCombinations)", "entry_point": "countMealCombinations", "signature": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {", "docstring": "\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n\n\n* Incomplete Code:\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n[MASK]\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "[MASK]\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}"}
{"task_id": "Swift/37-1-single", "prompt": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/", "canonical_solution": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}", "test": "func check(_ countMealCombinations: ([Int], Int) -> Int) {\nassert(countMealCombinations([1, 2, 3], 4) == 1)\nassert(countMealCombinations([1, 1, 3, 4, 5], 5) == 4)\nassert(countMealCombinations([2, 2, 2, 2], 8) == 1)\nassert(countMealCombinations([1, 1, 1, 1, 1], 3) == 10)\nassert(countMealCombinations([5, 5, 5, 5, 5], 10) == 10)\nassert(countMealCombinations([10, 15, 20], 25) == 1)\nassert(countMealCombinations([1, 3, 4, 6], 9) == 1)\n}\n\ncheck(countMealCombinations)", "entry_point": "countMealCombinations", "signature": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {", "docstring": "\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n\n\n* Incomplete Code:\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\n[MASK]\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\n[MASK]\n}"}
{"task_id": "Swift/38-0-single", "prompt": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/", "canonical_solution": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}", "test": "func check(_ latestDepartureTime: (Int, Int) -> String) {\nassert(latestDepartureTime(100, 10) == \"07:40\")\nassert(latestDepartureTime(50, 25) == \"07:48\")\nassert(latestDepartureTime(120, 60) == \"07:48\")\nassert(latestDepartureTime(80, 20) == \"07:46\")\nassert(latestDepartureTime(200, 40) == \"07:45\")\nassert(latestDepartureTime(90, 30) == \"07:47\")\n}\n\ncheck(latestDepartureTime)", "entry_point": "latestDepartureTime", "signature": "func latestDepartureTime(distance: Int, speed: Int) -> String {", "docstring": "\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n\n\n* Incomplete Code:\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\n[MASK]\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\n[MASK]\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}"}
{"task_id": "Swift/38-1-single", "prompt": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/", "canonical_solution": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}", "test": "func check(_ latestDepartureTime: (Int, Int) -> String) {\nassert(latestDepartureTime(100, 10) == \"07:40\")\nassert(latestDepartureTime(50, 25) == \"07:48\")\nassert(latestDepartureTime(120, 60) == \"07:48\")\nassert(latestDepartureTime(80, 20) == \"07:46\")\nassert(latestDepartureTime(200, 40) == \"07:45\")\nassert(latestDepartureTime(90, 30) == \"07:47\")\n}\n\ncheck(latestDepartureTime)", "entry_point": "latestDepartureTime", "signature": "func latestDepartureTime(distance: Int, speed: Int) -> String {", "docstring": "\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n\n\n* Incomplete Code:\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\n[MASK]\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\n[MASK]\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}"}
{"task_id": "Swift/39-0-single", "prompt": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/", "canonical_solution": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}", "test": "func testCalculateFinalScore() {\nassert(calculateFinalScore([10.0, 8.5, 9.0, 9.5, 10.0]) == 9.50)\nassert(calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5]) == 7.00)\nassert(calculateFinalScore([5.0, 5.5, 6.0, 5.5, 5.0]) == 5.33)\nassert(calculateFinalScore([]) == 0.0)\n}\n\ntestCalculateFinalScore()", "entry_point": "calculateFinalScore", "signature": "func calculateFinalScore(_ scores: [Double]) -> Double {", "docstring": "\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n\n\n* Incomplete Code:\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n[MASK]\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}"}
{"task_id": "Swift/39-1-single", "prompt": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/", "canonical_solution": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}", "test": "func testCalculateFinalScore() {\nassert(calculateFinalScore([10.0, 8.5, 9.0, 9.5, 10.0]) == 9.50)\nassert(calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5]) == 7.00)\nassert(calculateFinalScore([5.0, 5.5, 6.0, 5.5, 5.0]) == 5.33)\nassert(calculateFinalScore([]) == 0.0)\n}\n\ntestCalculateFinalScore()", "entry_point": "calculateFinalScore", "signature": "func calculateFinalScore(_ scores: [Double]) -> Double {", "docstring": "\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n\n\n* Incomplete Code:\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\n[MASK]\nreturn Double(round(100 * averageScore) / 100)\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\n[MASK]\nreturn Double(round(100 * averageScore) / 100)\n}"}
{"task_id": "Swift/40-0-single", "prompt": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/", "canonical_solution": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}", "test": "func testMinimumTasteDifference() {\nassert(minimumTasteDifference([(3, 10)]) == 7)\nassert(minimumTasteDifference([(3, 8), (5, 8)]) == 1)\nassert(minimumTasteDifference([(1, 2), (2, 3), (3, 4)]) == 1)\nassert(minimumTasteDifference([(2, 4), (3, 6)]) == 2)\nassert(minimumTasteDifference([(1, 3), (2, 5), (4, 1)]) == 0)\n}\n\ntestMinimumTasteDifference()", "entry_point": "minimumTasteDifference", "signature": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {", "docstring": "\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n\n\n* Incomplete Code:\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\n[MASK]\nreturn minDifference\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\n[MASK]\nreturn minDifference\n}"}
{"task_id": "Swift/40-1-single", "prompt": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/", "canonical_solution": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}", "test": "func testMinimumTasteDifference() {\nassert(minimumTasteDifference([(3, 10)]) == 7)\nassert(minimumTasteDifference([(3, 8), (5, 8)]) == 1)\nassert(minimumTasteDifference([(1, 2), (2, 3), (3, 4)]) == 1)\nassert(minimumTasteDifference([(2, 4), (3, 6)]) == 2)\nassert(minimumTasteDifference([(1, 3), (2, 5), (4, 1)]) == 0)\n}\n\ntestMinimumTasteDifference()", "entry_point": "minimumTasteDifference", "signature": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {", "docstring": "\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n\n\n* Incomplete Code:\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n[MASK]\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "[MASK]\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}"}
{"task_id": "Swift/45-0-single", "prompt": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Reverses a three-digit number and returns the result.\n\n    - Parameters:\n        - number: A three-digit integer to be reversed.\n\n    - Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n    ### Examples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Note: The function assumes the input is always a three-digit number.\n    */", "canonical_solution": "    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}", "test": "func testReverseThreeDigitNumber() {\n    assert(reverseThreeDigitNumber(123) == 321, \"Reverse of 123 should be 321.\")\n    assert(reverseThreeDigitNumber(456) == 654, \"Reverse of 456 should be 654.\")\n    assert(reverseThreeDigitNumber(789) == 987, \"Reverse of 789 should be 987.\")\n    assert(reverseThreeDigitNumber(100) == 1, \"Reverse of 100 should be 1.\")\n    assert(reverseThreeDigitNumber(905) == 509, \"Reverse of 905 should be 509.\")\n    assert(reverseThreeDigitNumber(999) == 999, \"Reverse of 999 should be 999.\")\n    assert(reverseThreeDigitNumber(210) == 12, \"Reverse of 210 should be 12.\")\n}\n\n// Call the test function to verify the functionality\ntestReverseThreeDigitNumber()", "entry_point": "reverseThreeDigitNumber", "signature": "func reverseThreeDigitNumber(_ number: Int) -> Int {", "docstring": "\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n\n\n* Incomplete Code:\nfunc reverseThreeDigitNumber(_ number: Int) -> Int {\n[MASK]\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "[MASK]\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}"}
{"task_id": "Swift/45-1-single", "prompt": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Reverses a three-digit number and returns the result.\n\n    - Parameters:\n        - number: A three-digit integer to be reversed.\n\n    - Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n    ### Examples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Note: The function assumes the input is always a three-digit number.\n    */", "canonical_solution": "    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}", "test": "func testReverseThreeDigitNumber() {\n    assert(reverseThreeDigitNumber(123) == 321, \"Reverse of 123 should be 321.\")\n    assert(reverseThreeDigitNumber(456) == 654, \"Reverse of 456 should be 654.\")\n    assert(reverseThreeDigitNumber(789) == 987, \"Reverse of 789 should be 987.\")\n    assert(reverseThreeDigitNumber(100) == 1, \"Reverse of 100 should be 1.\")\n    assert(reverseThreeDigitNumber(905) == 509, \"Reverse of 905 should be 509.\")\n    assert(reverseThreeDigitNumber(999) == 999, \"Reverse of 999 should be 999.\")\n    assert(reverseThreeDigitNumber(210) == 12, \"Reverse of 210 should be 12.\")\n}\n\n// Call the test function to verify the functionality\ntestReverseThreeDigitNumber()", "entry_point": "reverseThreeDigitNumber", "signature": "func reverseThreeDigitNumber(_ number: Int) -> Int {", "docstring": "\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n\n\n* Incomplete Code:\nfunc reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n[MASK]\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    guard number >= 100 && number <= 999 else {\n[MASK]\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}"}
{"task_id": "Swift/49-0-single", "prompt": "func determineSign(_ n: Int) -> String {\n    /**\n    Determines if a given integer is positive, zero, or negative.\n\n    - Parameters:\n        - n: An integer value that can range from -10^9 to 10^9.\n\n    - Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n    ### Example:\n    - `determineSign(3)` returns `\"positive\"`.\n    - `determineSign(0)` returns `\"zero\"`.\n    - `determineSign(-5)` returns `\"negative\"`.\n\n    Note: This function accurately classifies any integer within the specified range into one of the three categories.\n    */", "canonical_solution": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}", "test": "func testDetermineSign() {\n    assert(determineSign(3) == \"positive\", \"3 should be positive.\")\n    assert(determineSign(0) == \"zero\", \"0 should be zero.\")\n    assert(determineSign(-5) == \"negative\", \"-5 should be negative.\")\n    assert(determineSign(1000000000) == \"positive\", \"1000000000 should be positive.\")\n    assert(determineSign(-1000000000) == \"negative\", \"-1000000000 should be negative.\")\n    assert(determineSign(1) == \"positive\", \"1 should be positive.\")\n}\n\n// Call the test function to verify the functionality\ntestDetermineSign()", "entry_point": "determineSign", "signature": "func determineSign(_ n: Int) -> String {", "docstring": "\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n\n\n* Incomplete Code:\nfunc determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n[MASK]\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n[MASK]\n    }\n}"}
{"task_id": "Swift/49-1-single", "prompt": "func determineSign(_ n: Int) -> String {\n    /**\n    Determines if a given integer is positive, zero, or negative.\n\n    - Parameters:\n        - n: An integer value that can range from -10^9 to 10^9.\n\n    - Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n    ### Example:\n    - `determineSign(3)` returns `\"positive\"`.\n    - `determineSign(0)` returns `\"zero\"`.\n    - `determineSign(-5)` returns `\"negative\"`.\n\n    Note: This function accurately classifies any integer within the specified range into one of the three categories.\n    */", "canonical_solution": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}", "test": "func testDetermineSign() {\n    assert(determineSign(3) == \"positive\", \"3 should be positive.\")\n    assert(determineSign(0) == \"zero\", \"0 should be zero.\")\n    assert(determineSign(-5) == \"negative\", \"-5 should be negative.\")\n    assert(determineSign(1000000000) == \"positive\", \"1000000000 should be positive.\")\n    assert(determineSign(-1000000000) == \"negative\", \"-1000000000 should be negative.\")\n    assert(determineSign(1) == \"positive\", \"1 should be positive.\")\n}\n\n// Call the test function to verify the functionality\ntestDetermineSign()", "entry_point": "determineSign", "signature": "func determineSign(_ n: Int) -> String {", "docstring": "\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n", "instruction": "Below is a explanation of Swift code and incomplete code implementation.\n\n* Docstring: \n\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n\n\n* Incomplete Code:\nfunc determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n[MASK]\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if n > 0 {\n        return \"positive\"\n[MASK]\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}"}
