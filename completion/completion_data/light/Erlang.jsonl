{"task_id": "Erlang/1-0-light-span", "prompt": "-module(has_close_elements).\n-export([has_close_elements/2, test/0]).\n\n%Check if in given list of numbers, are any two numbers closer to each other than\n%given threshold.\n%>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n%False\n%>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n%True\nhas_close_elements(Numbers, Threshold) ->", "canonical_solution": "has_close_elements_helper(Numbers, Threshold, []).\n\nhas_close_elements_helper([], _, _) -> false;\nhas_close_elements_helper([H|T], Threshold, Checked) ->\ncase check_distance(H, Checked, Threshold) of\ntrue -> true;\nfalse -> has_close_elements_helper(T, Threshold, [H|Checked])\nend.\n\ncheck_distance(_, [], _) -> false;\ncheck_distance(Number, [H|T], Threshold) ->\nDistance = abs(Number - H),\nif\nDistance < Threshold -> true;\ntrue -> check_distance(Number, T, Threshold)\nend.", "test": "test() ->\ntrue = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),\nfalse = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),\ntrue = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\nfalse = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),\ntrue = has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),\ntrue = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\nfalse = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\nok.", "module": "has_close_elements", "entry_point": "has_close_elements", "signature": "has_close_elements(Numbers, Threshold) ->", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n\n* Incomplete Code:\nhas_close_elements(Numbers, Threshold) ->\nhas_close_elements_helper(Numbers, Threshold, []).\n\nhas_close_elements_helper([], _, _) -> false;\nhas_close_elements_helper([H|T], Threshold, Checked) ->\ncase check_distance(H, Checked[MASK];\ncheck_distance(Number, [H|T], Threshold) ->\nDistance = abs(Number - H),\nif\nDistance < Threshold -> true;\ntrue -> check_distance(Number, T, Threshold)\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "has_close_elements_helper(Numbers, Threshold, []).\n\nhas_close_elements_helper([], _, _) -> false;\nhas_close_elements_helper([H|T], Threshold, Checked) ->\ncase check_distance(H, Checked[MASK];\ncheck_distance(Number, [H|T], Threshold) ->\nDistance = abs(Number - H),\nif\nDistance < Threshold -> true;\ntrue -> check_distance(Number, T, Threshold)\nend."}
{"task_id": "Erlang/2-0-light-span", "prompt": "-module(arithmetic_sequence).\n-export([nth_term/3, test/0]).\n\nnth_term(A1, A2, N) ->\n% This function calculates the nth term of an arithmetic sequence given the first two terms.\n% An arithmetic sequence is a sequence of numbers in which the difference of any two successive members is a constant.\n% Given the first term (A1), the second term (A2), and the term number (N),\n% the function returns the value of the nth term in the sequence.\n%\n% Example:\n% nth_term(2, 5, 4) returns 11 (The sequence is 2, 5, 8, 11)\n% nth_term(-3, 0, 10) returns 24 (The sequence is -3, 0, 3, 6, ..., 24)", "canonical_solution": "D = A2 - A1,\nA1 + (N - 1) * D.", "test": "test() ->\n11 = nth_term(2, 5, 4),\n24 = nth_term(-3, 0, 10),\n0 = nth_term(0, 0, 100),\n-9 = nth_term(-1, -3, 5),\n100 = nth_term(1, 2, 100),\nok.", "module": "arithmetic_sequence", "entry_point": "nth_term", "signature": "nth_term/3, test/0]).nth_term(A1, A2, N) ->", "docstring": "This function calculates the nth term of an arithmetic sequence given the first two terms.\nAn arithmetic sequence is a sequence of numbers in which the difference of any two successive members is a constant.\nGiven the first term (A1), the second term (A2), and the term number (N),\nthe function returns the value of the nth term in the sequence.\n\nExample:\nnth_term(2, 5, 4) returns 11 (The sequence is 2, 5, 8, 11)\nnth_term(-3, 0, 10) returns 24 (The sequence is -3, 0, 3, 6, ..., 24)", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the nth term of an arithmetic sequence given the first two terms.\nAn arithmetic sequence is a sequence of numbers in which the difference of any two successive members is a constant.\nGiven the first term (A1), the second term (A2), and the term number (N),\nthe function returns the value of the nth term in the sequence.\n\nExample:\nnth_term(2, 5, 4) returns 11 (The sequence is 2, 5, 8, 11)\nnth_term(-3, 0, 10) returns 24 (The sequence is -3, 0, 3, 6, ..., 24)\n\n* Incomplete Code:\nnth_term/3, test/0]).nth_term(A1, A2, N) ->\nD = A2 - A1,\nA1 +[MASK]1) * D.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "D = A2 - A1,\nA1 +[MASK]1) * D."}
{"task_id": "Erlang/3-0-light-span", "prompt": "-module(array_intersection).\n-export([find_intersection/2, test/0]).\n\n% Return the intersection of two arrays nums1 and nums2.\n% Output contains unique elements and is sorted in lexicographical order.\n% >>> find_intersection([1, 2, 3, 4], [2, 3, 5, 6])\n% [2, 3]\n% >>> find_intersection([7, 8, 9], [10, 11, 12])\n% []\nfind_intersection(Nums1, Nums2) ->", "canonical_solution": "Sorted1 = lists:usort(Nums1),\nSorted2 = lists:usort(Nums2),\nlists:sort(lists:usort(lists:filter(fun(X) -> lists:member(X, Sorted2) end, Sorted1))).", "test": "test() ->\n[2, 3] = find_intersection([1, 2, 3, 4], [2, 3, 5, 6]),\n[] = find_intersection([7, 8, 9], [10, 11, 12]),\n[1, 2, 3] = find_intersection([1, 2, 3], [1, 2, 3, 4]),\n[] = find_intersection([], [1, 2, 3]),\n[] = find_intersection([1, 2, 3], []),\nok.", "module": "array_intersection", "entry_point": "find_intersection", "signature": "find_intersection(Nums1, Nums2) ->", "docstring": "Return the intersection of two arrays nums1 and nums2.\nOutput contains unique elements and is sorted in lexicographical order.\n>>> find_intersection([1, 2, 3, 4], [2, 3, 5, 6])\n[2, 3]\n>>> find_intersection([7, 8, 9], [10, 11, 12])\n[]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nReturn the intersection of two arrays nums1 and nums2.\nOutput contains unique elements and is sorted in lexicographical order.\n>>> find_intersection([1, 2, 3, 4], [2, 3, 5, 6])\n[2, 3]\n>>> find_intersection([7, 8, 9], [10, 11, 12])\n[]\n\n\n* Incomplete Code:\nfind_intersection(Nums1, Nums2) ->\nSorted1 = lists:usort(Nums1),\nSorted2 = lists:usort(Nums2),\nlists:sort(lis[MASK]sts:member(X, Sorted2) end, Sorted1))).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Sorted1 = lists:usort(Nums1),\nSorted2 = lists:usort(Nums2),\nlists:sort(lis[MASK]sts:member(X, Sorted2) end, Sorted1)))."}
{"task_id": "Erlang/4-0-light-span", "prompt": "-module(automorphic_numbers).\n-export([automorphic_numbers_up_to/1, test/0]).\n\nautomorphic_numbers_up_to(N) ->\n\n% This function calculates all automorphic numbers from 1 up to a given number N.\n% An automorphic number is a number whose square ends in the same digits as the number itself.\n% For example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\n% The function takes an integer N and returns a list of all automorphic numbers up to N.\n%\n% Example:\n% automorphic_numbers_up_to(10) returns [1, 5, 6]\n% automorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]", "canonical_solution": "lists:filter(fun(X) -> is_automorphic(X) end, lists:seq(1, N)).\n\nis_automorphic(X) ->\nSqr = X * X,\nSuffix = integer_to_list(X),\nlists:suffix(Suffix, integer_to_list(Sqr)).", "test": "test() ->\n[1, 5, 6] = automorphic_numbers_up_to(10),\n[1, 5, 6, 25, 76] = automorphic_numbers_up_to(100),\n[] = automorphic_numbers_up_to(0),\n[1] = automorphic_numbers_up_to(1),\n[1, 5, 6, 25, 76, 376, 625] = automorphic_numbers_up_to(1000),\nok.", "module": "automorphic_numbers", "entry_point": "automorphic_numbers_up_to", "signature": "automorphic_numbers_up_to/1, test/0]).automorphic_numbers_up_to(N) ->", "docstring": "This function calculates all automorphic numbers from 1 up to a given number N.\nAn automorphic number is a number whose square ends in the same digits as the number itself.\nFor example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\nThe function takes an integer N and returns a list of all automorphic numbers up to N.\n\nExample:\nautomorphic_numbers_up_to(10) returns [1, 5, 6]\nautomorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates all automorphic numbers from 1 up to a given number N.\nAn automorphic number is a number whose square ends in the same digits as the number itself.\nFor example, 25 is an automorphic number because 25^2 = 625, which ends in 25.\nThe function takes an integer N and returns a list of all automorphic numbers up to N.\n\nExample:\nautomorphic_numbers_up_to(10) returns [1, 5, 6]\nautomorphic_numbers_up_to(100) returns [1, 5, 6, 25, 76]\n\n* Incomplete Code:\nautomorphic_numbers_up_to/1, test/0]).automorphic_numbers_up_to(N) ->\nlists:filter(fun(X) -> is_auto[MASK]hic(X) ->\nSqr = X * X,\nSuffix = integer_to_list(X),\nlists:suffix(Suffix, integer_to_list(Sqr)).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "lists:filter(fun(X) -> is_auto[MASK]hic(X) ->\nSqr = X * X,\nSuffix = integer_to_list(X),\nlists:suffix(Suffix, integer_to_list(Sqr))."}
{"task_id": "Erlang/5-0-light-span", "prompt": "-module(average_without_extremes).\n-export([average_without_max_min/1, test/0]).\n\n% This function calculates the average of a list of numbers after removing the largest and smallest values.\n% It first sorts the list, then removes the first (minimum) and last (maximum) elements, and finally calculates the average of the remaining elements.\n% The function takes a list of integers or floats and returns the average of the list excluding the maximum and minimum values.\n% If the list has fewer than 3 elements, the function returns 'undefined' since it's not possible to remove both extremes.\n%\n% Example:\n% average_without_max_min([1, 2, 3, 4, 5]) returns 3.0\n% average_without_max_min([10, 20, 30, 40, 50]) returns 30.0\n\n\naverage_without_max_min(Numbers) when length(Numbers) < 3 ->\nundefined;\naverage_without_max_min(Numbers) ->", "canonical_solution": "Sorted = lists:sort(Numbers),\n{Sum, Count} = lists:foldl(fun(X, {Sum, Count}) -> {Sum + X, Count + 1} end, {0, 0}, tl(lists:droplast(Sorted))),\nSum / Count.", "test": "test() ->\n3.0 = average_without_max_min([1, 2, 3, 4, 5]),\n30.0 = average_without_max_min([10, 20, 30, 40, 50]),\nundefined = average_without_max_min([1, 2]),\nundefined = average_without_max_min([]),\n5.0 = average_without_max_min([5, 5, 5, 5, 5, 5]),\nok.", "module": "average_without_extremes", "entry_point": "average_without_max_min", "signature": "average_without_max_min(Numbers) ->", "docstring": "This function calculates the average of a list of numbers after removing the largest and smallest values.\nIt first sorts the list, then removes the first (minimum) and last (maximum) elements, and finally calculates the average of the remaining elements.\nThe function takes a list of integers or floats and returns the average of the list excluding the maximum and minimum values.\nIf the list has fewer than 3 elements, the function returns 'undefined' since it's not possible to remove both extremes.\n\nExample:\naverage_without_max_min([1, 2, 3, 4, 5]) returns 3.0\naverage_without_max_min([10, 20, 30, 40, 50]) returns 30.0\n\n\naverage_without_max_min(Numbers) when length(Numbers) < 3 ->\nundefined;\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the average of a list of numbers after removing the largest and smallest values.\nIt first sorts the list, then removes the first (minimum) and last (maximum) elements, and finally calculates the average of the remaining elements.\nThe function takes a list of integers or floats and returns the average of the list excluding the maximum and minimum values.\nIf the list has fewer than 3 elements, the function returns 'undefined' since it's not possible to remove both extremes.\n\nExample:\naverage_without_max_min([1, 2, 3, 4, 5]) returns 3.0\naverage_without_max_min([10, 20, 30, 40, 50]) returns 30.0\n\n\naverage_without_max_min(Numbers) when length(Numbers) < 3 ->\nundefined;\n\n\n* Incomplete Code:\naverage_without_max_min(Numbers) ->\nSorted = lists:sort(Numbers),\n{Sum, Count} = lists:foldl(fun(X, {Sum, Count}) -> {Sum + X, Count + 1} end, {0, 0}, tl(lists:droplast(Sorted))),\nSum /[MASK]nt.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Sorted = lists:sort(Numbers),\n{Sum, Count} = lists:foldl(fun(X, {Sum, Count}) -> {Sum + X, Count + 1} end, {0, 0}, tl(lists:droplast(Sorted))),\nSum /[MASK]nt."}
{"task_id": "Erlang/6-0-light-span", "prompt": "-module(binary_to_hex).\n-export([binary_to_hex/1, test/0]).\n\n% Convert binary data to a hexadecimal representation string.\n% >>> binary_to_hex(<<16#DEADBEEF:32>>)\n% \"DEADBEEF\"\n% >>> binary_to_hex(<<16#ABCDEF:24>>)\n% \"ABCDEF\"\nbinary_to_hex(Binary) ->", "canonical_solution": "lists:flatten([io_lib:format(\"~2.16.0B\", [Byte]) || <<Byte:8>> <= Binary]).", "test": "test() ->\n\"DEADBEEF\" = binary_to_hex(<<16#DEADBEEF:32>>),\n\"ABCDEF\" = binary_to_hex(<<16#ABCDEF:24>>),\n\"00\" = binary_to_hex(<<0:8>>),\n\"FF\" = binary_to_hex(<<255:8>>),\n\"\" = binary_to_hex(<<>>),\nok.", "module": "binary_to_hex", "entry_point": "binary_to_hex", "signature": "binary_to_hex(Binary) ->", "docstring": "Convert binary data to a hexadecimal representation string.\n>>> binary_to_hex(<<16#DEADBEEF:32>>)\n\"DEADBEEF\"\n>>> binary_to_hex(<<16#ABCDEF:24>>)\n\"ABCDEF\"\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nConvert binary data to a hexadecimal representation string.\n>>> binary_to_hex(<<16#DEADBEEF:32>>)\n\"DEADBEEF\"\n>>> binary_to_hex(<<16#ABCDEF:24>>)\n\"ABCDEF\"\n\n\n* Incomplete Code:\nbinary_to_hex(Binary) ->\nlists:flatten([io_lib:form[MASK]te:8>> <= Binary]).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "lists:flatten([io_lib:form[MASK]te:8>> <= Binary])."}
{"task_id": "Erlang/7-0-light-span", "prompt": "-module(bit_shift).\n-export([extract_bits/1, test/0]).\n\n% Perform bit shift operations on an integer to extract the data from 0 to 16 bits\n% and 16 to 32 bits, and output these two numbers.\n% >>> extract_bits(4294967295)\n% {65535, 65535}\n% >>> extract_bits(16777215)\n% {65535, 255}\nextract_bits(Int) ->", "canonical_solution": "Lower16 = Int band 16#FFFF,\nUpper16 = (Int bsr 16) band 16#FFFF,\n{Lower16, Upper16}.", "test": "test() ->\n{65535, 65535} = extract_bits(4294967295),\n{65535, 255} = extract_bits(16777215),\n{0, 0} = extract_bits(0),\n{1, 0} = extract_bits(1),\n{0, 1} = extract_bits(65536),\nok.", "module": "bit_shift", "entry_point": "extract_bits", "signature": "extract_bits(Int) ->", "docstring": "Perform bit shift operations on an integer to extract the data from 0 to 16 bits\nand 16 to 32 bits, and output these two numbers.\n>>> extract_bits(4294967295)\n{65535, 65535}\n>>> extract_bits(16777215)\n{65535, 255}\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nPerform bit shift operations on an integer to extract the data from 0 to 16 bits\nand 16 to 32 bits, and output these two numbers.\n>>> extract_bits(4294967295)\n{65535, 65535}\n>>> extract_bits(16777215)\n{65535, 255}\n\n\n* Incomplete Code:\nextract_bits(Int) ->\nLower16 = Int band 16#FFFF,\nUpper16[MASK]) band 16#FFFF,\n{Lower16, Upper16}.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Lower16 = Int band 16#FFFF,\nUpper16[MASK]) band 16#FFFF,\n{Lower16, Upper16}."}
{"task_id": "Erlang/8-0-light-span", "prompt": "-module(convert_and_concat).\n-export([convert_and_concat/1, test/0]).\n\n% Convert integers, floats, and atoms in a list to strings and concatenate them.\n% >>> convert_and_concat([1, 2.5, hello, 3])\n% \"12.5hello3\"\n% >>> convert_and_concat([apple, 42, 3.1415])\n% \"apple423.1415\"\nconvert_and_concat(List) ->", "canonical_solution": "StringList = lists:map(fun convert_to_string/1, List),\nlists:flatten(StringList).\n\nconvert_to_string(Item) when is_integer(Item); is_float(Item) ->\nio_lib:format(\"~p\", [Item]);\nconvert_to_string(Item) when is_atom(Item) ->\natom_to_list(Item).", "test": "test() ->\n\"12.5hello3\" = convert_and_concat([1, 2.5, hello, 3]),\n\"apple423.1415\" = convert_and_concat([apple, 42, 3.1415]),\n\"\" = convert_and_concat([]),\n\"42\" = convert_and_concat([42]),\nok.", "module": "convert_and_concat", "entry_point": "convert_and_concat", "signature": "convert_and_concat(List) ->", "docstring": "Convert integers, floats, and atoms in a list to strings and concatenate them.\n>>> convert_and_concat([1, 2.5, hello, 3])\n\"12.5hello3\"\n>>> convert_and_concat([apple, 42, 3.1415])\n\"apple423.1415\"\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nConvert integers, floats, and atoms in a list to strings and concatenate them.\n>>> convert_and_concat([1, 2.5, hello, 3])\n\"12.5hello3\"\n>>> convert_and_concat([apple, 42, 3.1415])\n\"apple423.1415\"\n\n\n* Incomplete Code:\nconvert_and_concat(List) ->\nStringList = lists:map(fun con[MASK]rt_to_string(Item) when is_integer(Item); is_float(Item) ->\nio_lib:format(\"~p\", [Item]);\nconvert_to_string(Item) when is_atom(Item) ->\natom_to_list(Item).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "StringList = lists:map(fun con[MASK]rt_to_string(Item) when is_integer(Item); is_float(Item) ->\nio_lib:format(\"~p\", [Item]);\nconvert_to_string(Item) when is_atom(Item) ->\natom_to_list(Item)."}
{"task_id": "Erlang/9-0-light-span", "prompt": "-module(cow_conference).\n-export([find_abc/1, test/0]).\n\nfind_abc(Numbers) ->\n% This function finds the original three numbers (A, B, C) from a list of seven numbers.\n% The input list consists of the numbers A, B, C, A+B, B+C, C+A, and A+B+C in some permutation.\n% A, B, and C are positive integers and the function returns them in increasing order.\n% It is guaranteed that the solution is unique.\n%\n% Example:\n% find_abc([3, 6, 11, 9, 14, 5, 8]) returns [3, 5, 6]\n% find_abc([10, 30, 20, 50, 40, 60, 70]) returns [10, 20, 30]", "canonical_solution": "Sorted = lists:sort(Numbers),\n[A, B, C, _, _, _, _] = Sorted,\n[A, B, C].", "test": "test() ->\n[3, 5, 6] = find_abc([3, 6, 11, 9, 14, 5, 8]),\n[10, 20, 30] = find_abc([10, 30, 20, 50, 40, 60, 70]),\n[7, 14, 21] = find_abc([7, 28, 42, 35, 21, 49, 14]),\nok.", "module": "cow_conference", "entry_point": "find_abc", "signature": "find_abc/1, test/0]).find_abc(Numbers) ->", "docstring": "This function finds the original three numbers (A, B, C) from a list of seven numbers.\nThe input list consists of the numbers A, B, C, A+B, B+C, C+A, and A+B+C in some permutation.\nA, B, and C are positive integers and the function returns them in increasing order.\nIt is guaranteed that the solution is unique.\n\nExample:\nfind_abc([3, 6, 11, 9, 14, 5, 8]) returns [3, 5, 6]\nfind_abc([10, 30, 20, 50, 40, 60, 70]) returns [10, 20, 30]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function finds the original three numbers (A, B, C) from a list of seven numbers.\nThe input list consists of the numbers A, B, C, A+B, B+C, C+A, and A+B+C in some permutation.\nA, B, and C are positive integers and the function returns them in increasing order.\nIt is guaranteed that the solution is unique.\n\nExample:\nfind_abc([3, 6, 11, 9, 14, 5, 8]) returns [3, 5, 6]\nfind_abc([10, 30, 20, 50, 40, 60, 70]) returns [10, 20, 30]\n\n* Incomplete Code:\nfind_abc/1, test/0]).find_abc(Numbers) ->\nSorted = lists:sort(Numbers),\n[A, B, C, _, _, _, _] = Sorted,\n[A,[MASK]C].\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Sorted = lists:sort(Numbers),\n[A, B, C, _, _, _, _] = Sorted,\n[A,[MASK]C]."}
{"task_id": "Erlang/10-0-light-span", "prompt": "-module(extract_numbers).\n-export([extract_numbers/1, test/0]).\n\nextract_numbers(String) ->\n% This function extracts all the numbers from a given string.\n% The numbers in the string are assumed to be non-negative integers separated by non-digit characters.\n% The function returns a list of integers found in the string.\n% If there are no numbers in the string, it returns an empty list.\n%\n% Example:\n% extract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\n% extract_numbers(\"no numbers\") returns []", "canonical_solution": "extract_numbers(String, [], []).\n\nextract_numbers([], CurrentNumber, Acc) when CurrentNumber =/= [] ->\nlists:reverse([list_to_integer(lists:reverse(CurrentNumber)) | Acc]);\nextract_numbers([], [], Acc) ->\nlists:reverse(Acc);\nextract_numbers([Char|Rest], CurrentNumber, Acc) when Char >= $0, Char =< $9 ->\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\nextract_numbers(Rest, [], Acc);\nextract_numbers([_|Rest], CurrentNumber, Acc) ->\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc]).", "test": "test() ->\n[123, 45, 6] = extract_numbers(\"abc123def45ghi6\"),\n[] = extract_numbers(\"no numbers\"),\n[2023] = extract_numbers(\"year2023\"),\n[1, 2, 3] = extract_numbers(\"1a2b3c\"),\n[] = extract_numbers(\"\"),\nok.", "module": "extract_numbers", "entry_point": "extract_numbers", "signature": "extract_numbers).-export([extract_numbers/1, test/0]).extract_numbers(String) ->", "docstring": "This function extracts all the numbers from a given string.\nThe numbers in the string are assumed to be non-negative integers separated by non-digit characters.\nThe function returns a list of integers found in the string.\nIf there are no numbers in the string, it returns an empty list.\n\nExample:\nextract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\nextract_numbers(\"no numbers\") returns []", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function extracts all the numbers from a given string.\nThe numbers in the string are assumed to be non-negative integers separated by non-digit characters.\nThe function returns a list of integers found in the string.\nIf there are no numbers in the string, it returns an empty list.\n\nExample:\nextract_numbers(\"abc123def45ghi6\") returns [123, 45, 6]\nextract_numbers(\"no numbers\") returns []\n\n* Incomplete Code:\nextract_numbers).-export([extract_numbers/1, test/0]).extract_numbers(String) ->\nextract_numbers(String, [], []).\n\nextract_number[MASK]], Acc) ->\nlists:reverse(Acc);\nextract_numbers([Char|Rest], CurrentNumber, Acc) when Char >= $0, Char =< $9 ->\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\nextract_numbers(Rest, [], Acc);\nextract_numbers([_|Rest], CurrentNumber, Acc) ->\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc]).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "extract_numbers(String, [], []).\n\nextract_number[MASK]], Acc) ->\nlists:reverse(Acc);\nextract_numbers([Char|Rest], CurrentNumber, Acc) when Char >= $0, Char =< $9 ->\nextract_numbers(Rest, [Char | CurrentNumber], Acc);\nextract_numbers([_|Rest], [], Acc) ->\nextract_numbers(Rest, [], Acc);\nextract_numbers([_|Rest], CurrentNumber, Acc) ->\nextract_numbers(Rest, [], [list_to_integer(lists:reverse(CurrentNumber)) | Acc])."}
{"task_id": "Erlang/11-0-light-span", "prompt": "-module(fibonacci).\n-export([fib/1, test/0]).\n\n% This function computes the Nth term of the Fibonacci sequence.\n% The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\n% usually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\n% This function takes an integer N and returns the Nth term of the Fibonacci sequence.\n%\n% Example:\n% fib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\n% fib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)", "canonical_solution": "fib(0) -> 0;\nfib(1) -> 1;\nfib(N) when N > 1 ->\nfib(N - 1) + fib(N - 2).", "test": "test() ->\n0 = fib(0),\n1 = fib(1),\n1 = fib(2),\n2 = fib(3),\n3 = fib(4),\n5 = fib(5),\n8 = fib(6),\n13 = fib(7),\n21 = fib(8),\n34 = fib(9),\n55 = fib(10),\nok.", "module": "fibonacci", "entry_point": "fib", "signature": "fib(n)->", "docstring": "This function computes the Nth term of the Fibonacci sequence.\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\nusually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\nThis function takes an integer N and returns the Nth term of the Fibonacci sequence.\n\nExample:\nfib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\nfib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function computes the Nth term of the Fibonacci sequence.\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones,\nusually starting with 0 and 1. That is, fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1.\nThis function takes an integer N and returns the Nth term of the Fibonacci sequence.\n\nExample:\nfib(5) returns 5 (The sequence is 0, 1, 1, 2, 3, 5)\nfib(8) returns 21 (The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21)\n\n* Incomplete Code:\nfib(n)->\nfib(0) -> 0;\nfi[MASK] 1 ->\nfib(N - 1) + fib(N - 2).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "fib(0) -> 0;\nfi[MASK] 1 ->\nfib(N - 1) + fib(N - 2)."}
{"task_id": "Erlang/12-0-light-span", "prompt": "-module(filter_odds).\n-export([filter_odds/1, test/0]).\n\n% Filter out all the odd numbers from a given list.\n% >>> filter_odds([1, 2, 3, 4, 5, 6])\n% [1, 3, 5]\n% >>> filter_odds([10, 23, 35, 42, 55])\n% [23, 35, 55]", "canonical_solution": "filter_odds(List) ->\nlists:filter(fun(X) -> X rem 2 =/= 0 end, List).", "test": "test() ->\n[1, 3, 5] = filter_odds([1, 2, 3, 4, 5, 6]),\n[23, 35, 55] = filter_odds([10, 23, 35, 42, 55]),\n[] = filter_odds([2, 4, 6, 8, 10]),\n[1] = filter_odds([1]),\nok.", "module": "filter_odds", "entry_point": "filter_odds", "signature": "filter_odds(List) ->", "docstring": "Filter out all the odd numbers from a given list.\n>>> filter_odds([1, 2, 3, 4, 5, 6])\n[1, 3, 5]\n>>> filter_odds([10, 23, 35, 42, 55])\n[23, 35, 55]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFilter out all the odd numbers from a given list.\n>>> filter_odds([1, 2, 3, 4, 5, 6])\n[1, 3, 5]\n>>> filter_odds([10, 23, 35, 42, 55])\n[23, 35, 55]\n\n* Incomplete Code:\nfilter_odds(List) ->\nfilter_odds(List) ->\nlists:filt[MASK]2 =/= 0 end, List).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "filter_odds(List) ->\nlists:filt[MASK]2 =/= 0 end, List)."}
{"task_id": "Erlang/13-0-light-span", "prompt": "-module(find_duplicates).\n-export([sorted_duplicates_in_list/1, test/0]).\n\n% Find all duplicate elements in a list and sort them in dictionary order.\n% >>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n% [1, 2]\n% >>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n% [\"apple\"]\nsorted_duplicates_in_list(List) ->", "canonical_solution": "Duplicates = duplicates_in_list_helper(List, []),\nlists:sort(Duplicates).\n\nduplicates_in_list_helper([], _) -> [];\nduplicates_in_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\nfalse -> duplicates_in_list_helper(T, [H|Checked])\nend.", "test": "test() ->\n[1, 2] = sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1]),\n[\"apple\"] = sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"]),\n[] = sorted_duplicates_in_list([1, 2, 3, 4, 5]),\nok.", "module": "find_duplicates", "entry_point": "sorted_duplicates_in_list", "signature": "sorted_duplicates_in_list(List) ->", "docstring": "Find all duplicate elements in a list and sort them in dictionary order.\n>>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n[1, 2]\n>>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n[\"apple\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind all duplicate elements in a list and sort them in dictionary order.\n>>> sorted_duplicates_in_list([1, 2, 3, 2, 4, 5, 1])\n[1, 2]\n>>> sorted_duplicates_in_list([\"banana\", \"apple\", \"apple\", \"cherry\"])\n[\"apple\"]\n\n\n* Incomplete Code:\nsorted_duplicates_in_list(List) ->\nDuplicates = duplicates_in_list_helper(List, []),\nlists:sort(Duplicates).\n\ndu[MASK]cates_in_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\nfalse -> duplicates_in_list_helper(T, [H|Checked])\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "Duplicates = duplicates_in_list_helper(List, []),\nlists:sort(Duplicates).\n\ndu[MASK]cates_in_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> [H | duplicates_in_list_helper(T, Checked)];\nfalse -> duplicates_in_list_helper(T, [H|Checked])\nend."}
{"task_id": "Erlang/14-0-light-span", "prompt": "-module(insert_element).\n-export([insert_in_list/3, test/0]).\n\n% Insert an element at a specified position in a list.\n% Elements after the position are shifted right.\n% >>> insert_in_list([1, 2, 3, 4, 5], 3, 99)\n% [1, 2, 3, 99, 4, 5]\n% >>> insert_in_list([\"a\", \"b\", \"c\", \"d\"], 2, \"z\")\n% [\"a\", \"b\", \"z\", \"c\", \"d\"]\ninsert_in_list(List, Position, Element) ->", "canonical_solution": "{Left, Right} = lists:split(Position, List),\nLeft ++ [Element] ++ Right.", "test": "test() ->\n[1, 2, 3, 99, 4, 5] = insert_in_list([1, 2, 3, 4, 5], 3, 99),\n[\"a\", \"b\", \"z\", \"c\", \"d\"] = insert_in_list([\"a\", \"b\", \"c\", \"d\"], 2, \"z\"),\nok.", "module": "insert_element", "entry_point": "insert_in_list", "signature": "insert_in_list(List, Position, Element) ->", "docstring": "Insert an element at a specified position in a list.\nElements after the position are shifted right.\n>>> insert_in_list([1, 2, 3, 4, 5], 3, 99)\n[1, 2, 3, 99, 4, 5]\n>>> insert_in_list([\"a\", \"b\", \"c\", \"d\"], 2, \"z\")\n[\"a\", \"b\", \"z\", \"c\", \"d\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nInsert an element at a specified position in a list.\nElements after the position are shifted right.\n>>> insert_in_list([1, 2, 3, 4, 5], 3, 99)\n[1, 2, 3, 99, 4, 5]\n>>> insert_in_list([\"a\", \"b\", \"c\", \"d\"], 2, \"z\")\n[\"a\", \"b\", \"z\", \"c\", \"d\"]\n\n\n* Incomplete Code:\ninsert_in_list(List, Position, Element) ->\n{Left, Right} = li[MASK]n, List),\nLeft ++ [Element] ++ Right.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "{Left, Right} = li[MASK]n, List),\nLeft ++ [Element] ++ Right."}
{"task_id": "Erlang/15-0-light-span", "prompt": "-module(is_prefix).\n-export([is_prefix/2, test/0]).\n\n% Check if List1 is a prefix of List2.\n% >>> is_prefix([1, 2], [1, 2, 3, 4])\n% true\n% >>> is_prefix([1, 3], [1, 2, 3, 4])\n% false", "canonical_solution": "is_prefix([], _) -> true;\nis_prefix(_, []) -> false;\nis_prefix([H1|T1], [H2|T2]) ->\nH1 == H2 andalso is_prefix(T1, T2).", "test": "test() ->\ntrue = is_prefix([1, 2], [1, 2, 3, 4]),\nfalse = is_prefix([1, 3], [1, 2, 3, 4]),\ntrue = is_prefix([], [1, 2, 3, 4]),\nfalse = is_prefix([1, 2, 3, 4], [1, 2]),\ntrue = is_prefix([], []),\nfalse = is_prefix([1], []),\nok.", "module": "is_prefix", "entry_point": "is_prefix", "signature": "is_prefix()->", "docstring": "Check if List1 is a prefix of List2.\n>>> is_prefix([1, 2], [1, 2, 3, 4])\ntrue\n>>> is_prefix([1, 3], [1, 2, 3, 4])\nfalse", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if List1 is a prefix of List2.\n>>> is_prefix([1, 2], [1, 2, 3, 4])\ntrue\n>>> is_prefix([1, 3], [1, 2, 3, 4])\nfalse\n\n* Incomplete Code:\nis_prefix()->\nis_prefix([], _[MASK]e;\nis_prefix([H1|T1], [H2|T2]) ->\nH1 == H2 andalso is_prefix(T1, T2).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "is_prefix([], _[MASK]e;\nis_prefix([H1|T1], [H2|T2]) ->\nH1 == H2 andalso is_prefix(T1, T2)."}
{"task_id": "Erlang/16-0-light-span", "prompt": "-module(leap_year_sum).\n-export([sum_leap_years/2, test/0]).\n\nsum_leap_years(StartYear, EndYear) ->\n% This function calculates the sum of all leap years between two given years (exclusive).\n% A leap year is a year that is divisible by 4 but not by 100, unless it is also divisible by 400.\n% The function takes two integers representing the start and end years and returns the sum of all leap years in between.\n% If the start year is greater than or equal to the end year, or if there are no leap years in the range, it returns 0.\n%\n% Example:\n% sum_leap_years(2000, 2020) returns 8040 (2004 + 2008 + 2012 + 2016)\n% sum_leap_years(1900, 2000) returns 25820 (1904 + 1908 + ... + 1996)", "canonical_solution": "lists:sum([Year || Year <- lists:seq(StartYear + 1, EndYear - 1), is_leap_year(Year)]).\n\nis_leap_year(Year) ->\n(Year rem 4 == 0 andalso Year rem 100 /= 0) orelse Year rem 400 == 0.", "test": "test() ->\n8040 = sum_leap_years(2000, 2020),\n2020 = sum_leap_years(2018, 2022),\n0= sum_leap_years(2021, 2022),\n0 = sum_leap_years(2001, 2003),\nok.", "module": "leap_year_sum", "entry_point": "sum_leap_years", "signature": "sum_leap_years/2, test/0]).sum_leap_years(StartYear, EndYear) ->", "docstring": "This function calculates the sum of all leap years between two given years (exclusive).\nA leap year is a year that is divisible by 4 but not by 100, unless it is also divisible by 400.\nThe function takes two integers representing the start and end years and returns the sum of all leap years in between.\nIf the start year is greater than or equal to the end year, or if there are no leap years in the range, it returns 0.\n\nExample:\nsum_leap_years(2000, 2020) returns 8040 (2004 + 2008 + 2012 + 2016)\nsum_leap_years(1900, 2000) returns 25820 (1904 + 1908 + ... + 1996)", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the sum of all leap years between two given years (exclusive).\nA leap year is a year that is divisible by 4 but not by 100, unless it is also divisible by 400.\nThe function takes two integers representing the start and end years and returns the sum of all leap years in between.\nIf the start year is greater than or equal to the end year, or if there are no leap years in the range, it returns 0.\n\nExample:\nsum_leap_years(2000, 2020) returns 8040 (2004 + 2008 + 2012 + 2016)\nsum_leap_years(1900, 2000) returns 25820 (1904 + 1908 + ... + 1996)\n\n* Incomplete Code:\nsum_leap_years/2, test/0]).sum_leap_years(StartYear, EndYear) ->\nlists:sum([Year || Year <- lists:seq(StartYear + 1, EndYear - 1), is_leap_year(Year)]).\n\nis_le[MASK]Year) ->\n(Year rem 4 == 0 andalso Year rem 100 /= 0) orelse Year rem 400 == 0.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "lists:sum([Year || Year <- lists:seq(StartYear + 1, EndYear - 1), is_leap_year(Year)]).\n\nis_le[MASK]Year) ->\n(Year rem 4 == 0 andalso Year rem 100 /= 0) orelse Year rem 400 == 0."}
{"task_id": "Erlang/17-0-light-span", "prompt": "-module(list_occurrence).\n-export([find_list_in_list/2, test/0]).\n\n% Check if list A appears in list B. If yes, return the starting position of A in B (0-based).\n% If not, return -1.\n% >>> find_list_in_list([2, 3], [1, 2, 3, 4])\n% 1\n% >>> find_list_in_list([3, 4, 5], [1, 2, 3])\n% -1\nfind_list_in_list(A, B) ->", "canonical_solution": "find_list_in_list_helper(A, B, 0).\n\nfind_list_in_list_helper(_, [], _) -> -1;\nfind_list_in_list_helper(A, B, Index) ->\ncase lists:prefix(A, B) of\ntrue -> Index;\nfalse -> find_list_in_list_helper(A, tl(B), Index + 1)\nend.", "test": "test() ->\n1 = find_list_in_list([2, 3], [1, 2, 3, 4]),\n-1 = find_list_in_list([3, 4, 5], [1, 2, 3]),\n-1 = find_list_in_list([1, 2, 3], []),\n0 = find_list_in_list([], [1, 2, 3]),\n-1 = find_list_in_list([1, 2, 3], [4, 5, 6]),\nok.", "module": "list_occurrence", "entry_point": "find_list_in_list", "signature": "find_list_in_list(A, B) ->", "docstring": "Check if list A appears in list B. If yes, return the starting position of A in B (0-based).\nIf not, return -1.\n>>> find_list_in_list([2, 3], [1, 2, 3, 4])\n1\n>>> find_list_in_list([3, 4, 5], [1, 2, 3])\n-1\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nCheck if list A appears in list B. If yes, return the starting position of A in B (0-based).\nIf not, return -1.\n>>> find_list_in_list([2, 3], [1, 2, 3, 4])\n1\n>>> find_list_in_list([3, 4, 5], [1, 2, 3])\n-1\n\n\n* Incomplete Code:\nfind_list_in_list(A, B) ->\nfind_list_in_list_helper(A, B, 0).\n\nf[MASK], B) of\ntrue -> Index;\nfalse -> find_list_in_list_helper(A, tl(B), Index + 1)\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "find_list_in_list_helper(A, B, 0).\n\nf[MASK], B) of\ntrue -> Index;\nfalse -> find_list_in_list_helper(A, tl(B), Index + 1)\nend."}
{"task_id": "Erlang/18-0-light-span", "prompt": "-module(merge_lists).\n-export([merge/2, test/0]).\n\n% Merge two lists into one.\n% >>> merge([1, 2, 3], [4, 5, 6])\n% [1, 2, 3, 4, 5, 6]\n% >>> merge([\"apple\", \"banana\"], [\"cherry\", \"date\"])\n% [\"apple\", \"banana\", \"cherry\", \"date\"]\nmerge(List1, List2) ->", "canonical_solution": "List1 ++ List2.", "test": "test() ->\n[1, 2, 3, 4, 5, 6] = merge([1, 2, 3], [4, 5, 6]),\n[\"apple\", \"banana\", \"cherry\", \"date\"] = merge([\"apple\", \"banana\"], [\"cherry\", \"date\"]),\n[1, 2, 3] = merge([], [1, 2, 3]),\n[1, 2, 3] = merge([1, 2, 3], []),\n[] = merge([], []),\nok.", "module": "merge_lists", "entry_point": "merge", "signature": "merge(List1, List2) ->", "docstring": "Merge two lists into one.\n>>> merge([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]\n>>> merge([\"apple\", \"banana\"], [\"cherry\", \"date\"])\n[\"apple\", \"banana\", \"cherry\", \"date\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nMerge two lists into one.\n>>> merge([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]\n>>> merge([\"apple\", \"banana\"], [\"cherry\", \"date\"])\n[\"apple\", \"banana\", \"cherry\", \"date\"]\n\n\n* Incomplete Code:\nmerge(List1, List2) ->\nLi[MASK] List2.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Li[MASK] List2."}
{"task_id": "Erlang/19-0-light-span", "prompt": "-module(multiply_evens).\n-export([multiply_evens/1, test/0]).\n\n% Multiply all even numbers in a list.\n% Returns 1 if there are no even numbers.\n% >>> multiply_evens([1, 2, 3, 4, 5])\n% 8\n% >>> multiply_evens([10, 23, 35, 42, 55])\n% 420\nmultiply_evens(List) ->", "canonical_solution": "lists:foldl(fun(X, Acc) -> \nif X rem 2 =:= 0 -> Acc * X;\ntrue -> Acc\nend\nend, 1, List).", "test": "test() ->\n8 = multiply_evens([1, 2, 3, 4, 5]),\n420 = multiply_evens([10, 23, 35, 42, 55]),\n1 = multiply_evens([1, 3, 5, 7]),\n2 = multiply_evens([2]),\n1 = multiply_evens([]),\nok.", "module": "multiply_evens", "entry_point": "multiply_evens", "signature": "multiply_evens(List) ->", "docstring": "Multiply all even numbers in a list.\nReturns 1 if there are no even numbers.\n>>> multiply_evens([1, 2, 3, 4, 5])\n8\n>>> multiply_evens([10, 23, 35, 42, 55])\n420\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nMultiply all even numbers in a list.\nReturns 1 if there are no even numbers.\n>>> multiply_evens([1, 2, 3, 4, 5])\n8\n>>> multiply_evens([10, 23, 35, 42, 55])\n420\n\n\n* Incomplete Code:\nmultiply_evens(List) ->\nlists:foldl(fun(X, Acc) -> \nif X re[MASK]> Acc * X;\ntrue -> Acc\nend\nend, 1, List).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "lists:foldl(fun(X, Acc) -> \nif X re[MASK]> Acc * X;\ntrue -> Acc\nend\nend, 1, List)."}
{"task_id": "Erlang/20-0-light-span", "prompt": "-module(prime_numbers).\n-export([get_prime/1, test/0]).\n\nget_prime(N) ->\n% This function calculates the number of prime numbers from 1 up to a given number N( excluding N).\n% A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n% The function takes an integer N and returns the number of prime numbers from 1 to N.\n%\n% Example:\n% primes_up_to(10) returns 4\n% primes_up_to(20) returns 8", "canonical_solution": "length(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \nRec =:= null ->\nget_prime(Seq + 1, N, List);\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\nfor_prime(Seq) ->\nSqrtValue = trunc(math:sqrt(Seq)),\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\nnull;\n\nfor_prime(Seq, [], _) ->\nSeq;\n\nfor_prime(_Seq, _, 0) ->\nnull;\n\nfor_prime(Seq, [Num | List], _) ->\nfor_prime(Seq, List, Seq rem Num).\n", "test": "test() ->\n0 = get_prime(2),\n1 = get_prime(3),\n4 = get_prime(10),\n8 = get_prime(20),\nok.", "module": "prime_numbers", "entry_point": "get_prime", "signature": "get_prime/1, test/0]).get_prime(N) ->", "docstring": "This function calculates the number of prime numbers from 1 up to a given number N( excluding N).\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\nThe function takes an integer N and returns the number of prime numbers from 1 to N.\n\nExample:\nprimes_up_to(10) returns 4\nprimes_up_to(20) returns 8", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function calculates the number of prime numbers from 1 up to a given number N( excluding N).\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\nThe function takes an integer N and returns the number of prime numbers from 1 to N.\n\nExample:\nprimes_up_to(10) returns 4\nprimes_up_to(20) returns 8\n\n* Incomplete Code:\nget_prime/1, test/0]).get_prime(N) ->\nlength(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \nRec =:= null ->\nget_prime(Seq + 1, N, List);\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\nfor_prime(Seq) ->\nSqrtValue = trunc(math:sqrt(Seq)),\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\n[MASK]Num).\n\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "length(get_prime(2, N, [])).\n\n%使用erlang的尾递归编程，提高效率\nget_prime(Seq, Seq, List) ->\nList;\n\nget_prime(Seq, N, List) ->\nRec = for_prime(Seq),\nif \nRec =:= null ->\nget_prime(Seq + 1, N, List);\ntrue ->\nget_prime(Seq + 1, N, [Rec | List])\nend.\n\n%判断某一个具体的数是否为质数\nfor_prime(Seq) ->\nSqrtValue = trunc(math:sqrt(Seq)),\nfor_prime(Seq, lists:seq(2, SqrtValue), 1).\n\nfor_prime(_Seq, [], 0) ->\n[MASK]Num).\n"}
{"task_id": "Erlang/21-0-light-span", "prompt": "-module(quick_sort).\n-export([quick_sort/1, test/0]).\n\n% This function implements the Quick Sort algorithm to sort a list of integers.\n% Quick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\n% and partitions the other elements into two sub-arrays, according to whether they are less than\n% or greater than the pivot. The sub-arrays are then sorted recursively.\n% This function takes a list of integers and returns a sorted list.\n%\n% Example:\n% quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n% quick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]", "canonical_solution": "quick_sort([]) -> [];\nquick_sort([Pivot|Rest]) ->\n{Smaller, Greater} = partition(Rest, Pivot, [], []),\nquick_sort(Smaller) ++ [Pivot] ++ quick_sort(Greater).\n\npartition([], _, Smaller, Greater) -> {Smaller, Greater};\npartition([H|T], Pivot, Smaller, Greater) ->\nif\nH =< Pivot -> partition(T, Pivot, [H|Smaller], Greater);\nH > Pivot -> partition(T, Pivot, Smaller, [H|Greater])\nend.", "test": "test() ->\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] = quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]),\n[1, 2, 3, 4, 5] = quick_sort([5, 4, 3, 2, 1]),\n[] = quick_sort([]),\n[1] = quick_sort([1]),\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = quick_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]),\nok.", "module": "quick_sort", "entry_point": "quick_sort", "signature": "quick_sort() ->", "docstring": "This function implements the Quick Sort algorithm to sort a list of integers.\nQuick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\nand partitions the other elements into two sub-arrays, according to whether they are less than\nor greater than the pivot. The sub-arrays are then sorted recursively.\nThis function takes a list of integers and returns a sorted list.\n\nExample:\nquick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nquick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function implements the Quick Sort algorithm to sort a list of integers.\nQuick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array\nand partitions the other elements into two sub-arrays, according to whether they are less than\nor greater than the pivot. The sub-arrays are then sorted recursively.\nThis function takes a list of integers and returns a sorted list.\n\nExample:\nquick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) returns [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nquick_sort([5, 4, 3, 2, 1]) returns [1, 2, 3, 4, 5]\n\n* Incomplete Code:\nquick_sort() ->\nquick_sort([]) ->[MASK]ot -> partition(T, Pivot, [H|Smaller], Greater);\nH > Pivot -> partition(T, Pivot, Smaller, [H|Greater])\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "quick_sort([]) ->[MASK]ot -> partition(T, Pivot, [H|Smaller], Greater);\nH > Pivot -> partition(T, Pivot, Smaller, [H|Greater])\nend."}
{"task_id": "Erlang/22-0-light-span", "prompt": "-module(ranking_comparison).\n-export([compare_rankings/4, test/0]).\n\ncompare_rankings(A, B, C, D) ->\n% Determines if the sum of the NOI rankings of four people (A, B, C, and D)\n% is less than 51. If the sum is less than 51, the output is 'Rabbit wins',\n% indicating their combined ranking is not higher than that of \"Little Pink Rabbit\".\n% If the sum is 51 or more, the output is 'Rabbit lose', indicating their combined\n% ranking is not lower than \"Little Pink Rabbit\".\n%\n% Example:\n% compare_rankings(10, 10, 10, 10) returns 'Rabbit wins'\n% compare_rankings(5, 6, 7, 8) returns 'Rabbit wins'", "canonical_solution": "Sum = A + B + C + D,\nif\nSum < 51 -> 'Rabbit wins';\ntrue -> 'Rabbit lose'\nend.", "test": "test() ->\n'Rabbit wins' = compare_rankings(5, 6, 7, 8),\n'Rabbit wins' = compare_rankings(10, 10, 10, 10),\n'Rabbit wins' = compare_rankings(3, 3, 3, 3),\n'Rabbit lose' = compare_rankings(12, 13, 14, 15),\n'Rabbit lose' = compare_rankings(50, 1, 1, 1),\nok.", "module": "ranking_comparison", "entry_point": "compare_rankings", "signature": "compare_rankings/4, test/0]).compare_rankings(A, B, C, D) ->", "docstring": "Determines if the sum of the NOI rankings of four people (A, B, C, and D)\nis less than 51. If the sum is less than 51, the output is 'Rabbit wins',\nindicating their combined ranking is not higher than that of \"Little Pink Rabbit\".\nIf the sum is 51 or more, the output is 'Rabbit lose', indicating their combined\nranking is not lower than \"Little Pink Rabbit\".\n\nExample:\ncompare_rankings(10, 10, 10, 10) returns 'Rabbit wins'\ncompare_rankings(5, 6, 7, 8) returns 'Rabbit wins'", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nDetermines if the sum of the NOI rankings of four people (A, B, C, and D)\nis less than 51. If the sum is less than 51, the output is 'Rabbit wins',\nindicating their combined ranking is not higher than that of \"Little Pink Rabbit\".\nIf the sum is 51 or more, the output is 'Rabbit lose', indicating their combined\nranking is not lower than \"Little Pink Rabbit\".\n\nExample:\ncompare_rankings(10, 10, 10, 10) returns 'Rabbit wins'\ncompare_rankings(5, 6, 7, 8) returns 'Rabbit wins'\n\n* Incomplete Code:\ncompare_rankings/4, test/0]).compare_rankings(A, B, C, D) ->\nSum [MASK]+ C + D,\nif\nSum < 51 -> 'Rabbit wins';\ntrue -> 'Rabbit lose'\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Sum [MASK]+ C + D,\nif\nSum < 51 -> 'Rabbit wins';\ntrue -> 'Rabbit lose'\nend."}
{"task_id": "Erlang/23-0-light-span", "prompt": "-module(remove_duplicates).\n-export([remove_duplicates_list/1, remove_duplicates_tuple/1, test/0]).\n\n% Remove all duplicate elements from a list.\n% >>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n% [1,2,3, 4, 5]\n% >>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n% [\"apple\",\"banana\", \"cherry\"]\nremove_duplicates_list(List) ->", "canonical_solution": "remove_duplicates_list_helper(List, []).\n\nremove_duplicates_list_helper([], _) -> [];\nremove_duplicates_list_helper([H|T], Checked) ->\ncase lists:member(H, Checked) of\ntrue -> remove_duplicates_list_helper(T, Checked);\nfalse -> [H | remove_duplicates_list_helper(T, [H|Checked])]\nend.\n\nremove_duplicates_tuple(Tuple) ->\nlist_to_tuple(remove_duplicates_list(tuple_to_list(Tuple))).", "test": "test() ->\n[1,2,3, 4, 5] = remove_duplicates_list([1, 2, 3, 2, 4, 5, 1]),\n[\"apple\",\"banana\", \"cherry\"] = remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"]),\n[] = remove_duplicates_list([]),\n{1,2,3, 4, 5} = remove_duplicates_tuple({1, 2, 3, 2, 4, 5, 1}),\n{\"apple\",\"banana\", \"cherry\"} = remove_duplicates_tuple({\"apple\", \"banana\", \"apple\", \"cherry\"}),\n{} = remove_duplicates_tuple({}),\nok.", "module": "remove_duplicates", "entry_point": "remove_duplicates_list", "signature": "remove_duplicates_list(List) ->", "docstring": "Remove all duplicate elements from a list.\n>>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n[1,2,3, 4, 5]\n>>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n[\"apple\",\"banana\", \"cherry\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nRemove all duplicate elements from a list.\n>>> remove_duplicates_list([1, 2, 3, 2, 4, 5, 1])\n[1,2,3, 4, 5]\n>>> remove_duplicates_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n[\"apple\",\"banana\", \"cherry\"]\n\n\n* Incomplete Code:\nremove_duplicates_list(List) ->\nremove_duplicates_list_helper([MASK]le) ->\nlist_to_tuple(remove_duplicates_list(tuple_to_list(Tuple))).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "remove_duplicates_list_helper([MASK]le) ->\nlist_to_tuple(remove_duplicates_list(tuple_to_list(Tuple)))."}
{"task_id": "Erlang/24-0-light-span", "prompt": "-module(replace_element).\n-export([replace_in_list/3, test/0]).\n\n% Replace an element at a specified position in a list.\n% >>> replace_in_list([1, 2, 3, 4, 5], 3, 99)\n% [1, 2, 99, 4, 5]\n% >>> replace_in_list([\"a\", \"b\", \"c\", \"d\"], 1, \"z\")\n% [\"z\", \"b\", \"c\", \"d\"]\nreplace_in_list(List, Index, NewElement) ->", "canonical_solution": "{Left, [_ | Right]} = lists:split(Index - 1, List),\nLeft ++ [NewElement] ++ Right.", "test": "test() ->\n[1, 2, 99, 4, 5] = replace_in_list([1, 2, 3, 4, 5], 3, 99),\n[\"z\", \"b\", \"c\", \"d\"] = replace_in_list([\"a\", \"b\", \"c\", \"d\"], 1, \"z\"),\nok.", "module": "replace_element", "entry_point": "replace_in_list", "signature": "replace_in_list(List, Index, NewElement) ->", "docstring": "Replace an element at a specified position in a list.\n>>> replace_in_list([1, 2, 3, 4, 5], 3, 99)\n[1, 2, 99, 4, 5]\n>>> replace_in_list([\"a\", \"b\", \"c\", \"d\"], 1, \"z\")\n[\"z\", \"b\", \"c\", \"d\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nReplace an element at a specified position in a list.\n>>> replace_in_list([1, 2, 3, 4, 5], 3, 99)\n[1, 2, 99, 4, 5]\n>>> replace_in_list([\"a\", \"b\", \"c\", \"d\"], 1, \"z\")\n[\"z\", \"b\", \"c\", \"d\"]\n\n\n* Incomplete Code:\nreplace_in_list(List, Index, NewElement) ->\n{Left[MASK]ts:split(Index - 1, List),\nLeft ++ [NewElement] ++ Right.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "{Left[MASK]ts:split(Index - 1, List),\nLeft ++ [NewElement] ++ Right."}
{"task_id": "Erlang/25-0-light-span", "prompt": "-module(reverse_after_position).\n-export([reverse_after/2, test/0]).\n\n% Reverse elements of a list after a specified position.\n% >>> reverse_after([1, 2, 3, 4, 5], 3)\n% [1, 2, 3, 5, 4]\n% >>> reverse_after([\"a\", \"b\", \"c\", \"d\", \"e\"], 2)\n% [\"a\", \"b\", \"e\", \"d\", \"c\"]\nreverse_after(List, Position) ->", "canonical_solution": "{Front, Back} = lists:split(Position, List),\nFront ++ lists:reverse(Back).", "test": "test() ->\n[1, 2, 3, 5, 4] = reverse_after([1, 2, 3, 4, 5], 3),\n[\"a\", \"b\", \"e\", \"d\", \"c\"] = reverse_after([\"a\", \"b\", \"c\", \"d\", \"e\"], 2),\n[1, 2, 3, 4, 5] = reverse_after([1, 2, 3, 4, 5], 5),\n[1] = reverse_after([1], 1),\n[\"z\", \"y\", \"x\"] = reverse_after([\"x\", \"y\", \"z\"], 0),\nok.", "module": "reverse_after_position", "entry_point": "reverse_after", "signature": "reverse_after(List, Position) ->", "docstring": "Reverse elements of a list after a specified position.\n>>> reverse_after([1, 2, 3, 4, 5], 3)\n[1, 2, 3, 5, 4]\n>>> reverse_after([\"a\", \"b\", \"c\", \"d\", \"e\"], 2)\n[\"a\", \"b\", \"e\", \"d\", \"c\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nReverse elements of a list after a specified position.\n>>> reverse_after([1, 2, 3, 4, 5], 3)\n[1, 2, 3, 5, 4]\n>>> reverse_after([\"a\", \"b\", \"c\", \"d\", \"e\"], 2)\n[\"a\", \"b\", \"e\", \"d\", \"c\"]\n\n\n* Incomplete Code:\nreverse_after(List, Position) ->\n{Front, Back} = lists:split(Position, List),\nFront ++ lis[MASK]Back).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "{Front, Back} = lists:split(Position, List),\nFront ++ lis[MASK]Back)."}
{"task_id": "Erlang/26-0-light-span", "prompt": "-module(split_string).\n-export([split/2, test/0]).\n\n% Split a string by a specified delimiter.\n% >>> split(\"one,two,three\", \",\")\n% [\"one\", \"two\", \"three\"]\n% >>> split(\"hello world\", \" \")\n% [\"hello\", \"world\"]\nsplit(String, Delimiter) ->", "canonical_solution": "string:split(String, Delimiter, all).", "test": "test() ->\n[\"one\", \"two\", \"three\"] = split(\"one,two,three\", \",\"),\n[\"hello\", \"world\"] = split(\"hello world\", \" \"),\n[\"one\", \"two\", \"three\"] = split(\"one two three\", \" \"),\n[\"\", \"\"] = split(\",\", \",\"),\n[\"hello\"] = split(\"hello\", \",\"),\nok.", "module": "split_string", "entry_point": "split", "signature": "split(String, Delimiter) ->", "docstring": "Split a string by a specified delimiter.\n>>> split(\"one,two,three\", \",\")\n[\"one\", \"two\", \"three\"]\n>>> split(\"hello world\", \" \")\n[\"hello\", \"world\"]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nSplit a string by a specified delimiter.\n>>> split(\"one,two,three\", \",\")\n[\"one\", \"two\", \"three\"]\n>>> split(\"hello world\", \" \")\n[\"hello\", \"world\"]\n\n\n* Incomplete Code:\nsplit(String, Delimiter) ->\nstring:spl[MASK]imiter, all).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "string:spl[MASK]imiter, all)."}
{"task_id": "Erlang/27-0-light-span", "prompt": "-module(sum_odds).\n-export([sum_odds_list/1, test/0]).\n\n% Sum all odd numbers in a list.\n% >>> sum_odds_list([1, 2, 3, 4, 5])\n% 9\n% >>> sum_odds_list([10, 23, 35, 42, 55])\n% 113\nsum_odds_list(List) ->", "canonical_solution": "lists:foldl(fun(X, Acc) -> \nif X rem 2 =/= 0 -> Acc + X;\ntrue -> Acc\nend\nend, 0, List).", "test": "test() ->\n9 = sum_odds_list([1, 2, 3, 4, 5]),\n113 = sum_odds_list([10, 23, 35, 42, 55]),\n0 = sum_odds_list([2, 4, 6, 8]),\n1 = sum_odds_list([1]),\nok.", "module": "sum_odds", "entry_point": "sum_odds_list", "signature": "sum_odds_list(List) ->", "docstring": "Sum all odd numbers in a list.\n>>> sum_odds_list([1, 2, 3, 4, 5])\n9\n>>> sum_odds_list([10, 23, 35, 42, 55])\n113\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nSum all odd numbers in a list.\n>>> sum_odds_list([1, 2, 3, 4, 5])\n9\n>>> sum_odds_list([10, 23, 35, 42, 55])\n113\n\n\n* Incomplete Code:\nsum_odds_list(List) ->\nlists:foldl(fun(X, Acc) -> \nif X rem 2 =/= 0 -> Acc + X;\ntru[MASK] Acc\nend\nend, 0, List).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "lists:foldl(fun(X, Acc) -> \nif X rem 2 =/= 0 -> Acc + X;\ntru[MASK] Acc\nend\nend, 0, List)."}
{"task_id": "Erlang/28-0-light-span", "prompt": "-module(sum_values_by_key).\n-export([sum_values_and_sort_keys/1, test/0]).\n\n% Sum the values of identical keys in a list of key-value pairs and sort the keys.\n% >>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n% [{a, 4}, {b, 2}]\n% >>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n% [{bar, 20}, {baz, 40}, {foo, 40}]\nsum_values_and_sort_keys(List) ->", "canonical_solution": "SortedDict = lists:foldl(fun({K, V}, Acc) ->\ndict:update(K, fun(OldV) -> OldV + V end, V, Acc)\nend, dict:new(), List),\nSortedList = dict:to_list(SortedDict),\nlists:sort(fun({K1, _}, {K2, _}) -> K1 < K2 end, SortedList).", "test": "test() ->\n[{a, 4}, {b, 2}] = sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}]),\n[{bar, 20}, {baz, 40}, {foo, 40}] = sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}]),\n[] = sum_values_and_sort_keys([]),\n[{x, 1}] = sum_values_and_sort_keys([{x, 1}]),\nok.", "module": "sum_values_by_key", "entry_point": "sum_values_and_sort_keys", "signature": "sum_values_and_sort_keys(List) ->", "docstring": "Sum the values of identical keys in a list of key-value pairs and sort the keys.\n>>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n[{a, 4}, {b, 2}]\n>>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n[{bar, 20}, {baz, 40}, {foo, 40}]\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nSum the values of identical keys in a list of key-value pairs and sort the keys.\n>>> sum_values_and_sort_keys([{a, 1}, {b, 2}, {a, 3}])\n[{a, 4}, {b, 2}]\n>>> sum_values_and_sort_keys([{foo, 10}, {bar, 20}, {foo, 30}, {baz, 40}])\n[{bar, 20}, {baz, 40}, {foo, 40}]\n\n\n* Incomplete Code:\nsum_values_and_sort_keys(List) ->\nSortedDict = lists:foldl(fun({K, V}, Acc) ->\ndict:update(K, fun(OldV) -> OldV + V end, V, Acc)\nend, dict:new(), List),\nSortedList = dict:to[MASK]ort(fun({K1, _}, {K2, _}) -> K1 < K2 end, SortedList).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "SortedDict = lists:foldl(fun({K, V}, Acc) ->\ndict:update(K, fun(OldV) -> OldV + V end, V, Acc)\nend, dict:new(), List),\nSortedList = dict:to[MASK]ort(fun({K1, _}, {K2, _}) -> K1 < K2 end, SortedList)."}
{"task_id": "Erlang/29-0-light-span", "prompt": "-module(third_largest).\n-export([find_third_largest/1, test/0]).\n\n% Find the third largest number in a non-empty array.\n% If the third largest number does not exist, return the largest number.\n% >>> find_third_largest([2, 3, 1])\n% 1\n% >>> find_third_largest([9, 2, 3, 6])\n% 3\nfind_third_largest(Numbers) ->", "canonical_solution": "Sorted = lists:usort(Numbers),\ncase length(Sorted) of\nL when L >= 3 -> lists:nth(L - 2, Sorted);\n_ -> lists:last(Sorted)\nend.", "test": "test() ->\n1 = find_third_largest([2, 3, 1]),\n3 = find_third_largest([9, 2, 3, 6]),\n5 = find_third_largest([5]),\n7 = find_third_largest([7, 7, 7]),\nok.", "module": "third_largest", "entry_point": "find_third_largest", "signature": "find_third_largest(Numbers) ->", "docstring": "Find the third largest number in a non-empty array.\nIf the third largest number does not exist, return the largest number.\n>>> find_third_largest([2, 3, 1])\n1\n>>> find_third_largest([9, 2, 3, 6])\n3\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind the third largest number in a non-empty array.\nIf the third largest number does not exist, return the largest number.\n>>> find_third_largest([2, 3, 1])\n1\n>>> find_third_largest([9, 2, 3, 6])\n3\n\n\n* Incomplete Code:\nfind_third_largest(Numbers) ->\nSorted = lists:usort(Numbe[MASK]Sorted) of\nL when L >= 3 -> lists:nth(L - 2, Sorted);\n_ -> lists:last(Sorted)\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "Sorted = lists:usort(Numbe[MASK]Sorted) of\nL when L >= 3 -> lists:nth(L - 2, Sorted);\n_ -> lists:last(Sorted)\nend."}
{"task_id": "Erlang/30-0-light-span", "prompt": "-module(two_sum).\n-export([find_two_sum/2, test/0]).\n\n% Find two integers in the array nums that add up to the target value.\n% Returns the indices of the two numbers.\n% >>> find_two_sum([2, 7, 11, 15], 9)\n% {0, 1}\n% >>> find_two_sum([3, 2, 4], 6)\n% {1, 2}\nfind_two_sum(Nums, Target) ->", "canonical_solution": "find_two_sum_helper(Nums, Target, 0, dict:new()).\n\nfind_two_sum_helper([], _, _, _) -> not_found;\nfind_two_sum_helper([H|T], Target, Index, Dict) ->\ncase dict:find(Target - H, Dict) of\n{ok, OtherIndex} -> {OtherIndex, Index};\nerror -> find_two_sum_helper(T, Target, Index + 1, dict:store(H, Index, Dict))\nend.", "test": "test() ->\n{0, 1} = find_two_sum([2, 7, 11, 15], 9),\n{1, 2} = find_two_sum([3, 2, 4], 6),\nnot_found = find_two_sum([1, 2, 3], 7),\nok.", "module": "two_sum", "entry_point": "find_two_sum", "signature": "find_two_sum(Nums, Target) ->", "docstring": "Find two integers in the array nums that add up to the target value.\nReturns the indices of the two numbers.\n>>> find_two_sum([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_two_sum([3, 2, 4], 6)\n{1, 2}\n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nFind two integers in the array nums that add up to the target value.\nReturns the indices of the two numbers.\n>>> find_two_sum([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_two_sum([3, 2, 4], 6)\n{1, 2}\n\n\n* Incomplete Code:\nfind_two_sum(Nums, Target) ->\nfind_two_sum_helper(Nums, Target, 0, dict:new()).\n\nfind_two_sum_helper([], _, _, _) -> not_found;\nfind_two_sum_helper([H|T], Target, Index, Dict) ->\ncase dict:find(Target - H, Di[MASK])\nend.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "find_two_sum_helper(Nums, Target, 0, dict:new()).\n\nfind_two_sum_helper([], _, _, _) -> not_found;\nfind_two_sum_helper([H|T], Target, Index, Dict) ->\ncase dict:find(Target - H, Di[MASK])\nend."}
{"task_id": "Erlang/31-0-light-span", "prompt": "-module(absolute_value).\n-export([abs_value/1, test/0]).\nabs_value(N) ->\n    % Calculates absolute_value\n    % Examples\n    % abs_value(-7)\n    % 7", "canonical_solution": "    if\n        N >= 0 -> N;\n        true -> -N\n    end.", "test": "test() ->\n    7 = abs_value(-7),\n    10 = abs_value(10),\n    0 = abs_value(0),\n    10000 = abs_value(-10000),\n    12345 = abs_value(12345),\n    ok.", "entry_point": "abs_value", "signature": "abs_value/1, test/0]).abs_value(N) ->", "docstring": " Calculates absolute_value\n  Examples\n  abs_value(-7)\n  7", "module": "absolute_value", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n Calculates absolute_value\n  Examples\n  abs_value(-7)\n  7\n\n* Incomplete Code:\nabs_value/1, test/0]).abs_value(N) ->\n    if\n   [MASK]= 0 -> N;\n        true -> -N\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    if\n   [MASK]= 0 -> N;\n        true -> -N\n    end."}
{"task_id": "Erlang/32-0-light-span", "prompt": "-module(arithmetic_sum).\n-export([sum_of_n_terms/3, test/0]).\n\nsum_of_n_terms(A1, A2, N) ->\n% This function calculates the sum of the first n terms of an arithmetic sequence.\n% An arithmetic sequence is characterized by a constant difference between consecutive terms.\n% Given the first term (A1), the second term (A2), and the number of terms (N),\n% the function computes the sum of the sequence's first N terms.\n%\n% The formula used is: S_n = n/2 * (2*A1 + (N-1)*D), where D is the common difference.\n%\n% Examples:\n% sum_of_n_terms(1, 3, 5) returns 25 (The sequence is 1, 3, 5, 7, 9)\n% sum_of_n_terms(5, 7, 3) returns 21 (The sequence is 5, 7, 9)\n% sum_of_n_terms(-2, 1, 4) returns 4 (The sequence is -2, 1, 4, 7)\n% sum_of_n_terms(10, 20, 2) returns 30 (The sequence is 10, 20)", "canonical_solution": "    D = A2 - A1,\n    N * (2*A1 + (N - 1) * D) div 2.", "test": "test() ->\n    25 = sum_of_n_terms(1, 3, 5),\n    21 = sum_of_n_terms(5, 7, 3),\n    10 = sum_of_n_terms(-2, 1, 4),\n    30 = sum_of_n_terms(10, 20, 2),\n    5050 = sum_of_n_terms(1, 2, 100), % Sum of the first 100 natural numbers\n    ok.", "entry_point": "sum_of_n_terms", "signature": "sum_of_n_terms/3, test/0]).sum_of_n_terms(A1, A2, N) ->", "docstring": " This function calculates the sum of the first n terms of an arithmetic sequence.\n An arithmetic sequence is characterized by a constant difference between consecutive terms.\n Given the first term (A1), the second term (A2), and the number of terms (N),\n the function computes the sum of the sequence's first N terms.\n\n The formula used is: S_n = n/2 * (2*A1 + (N-1)*D), where D is the common difference.\n\n Examples:\n sum_of_n_terms(1, 3, 5) returns 25 (The sequence is 1, 3, 5, 7, 9)\n sum_of_n_terms(5, 7, 3) returns 21 (The sequence is 5, 7, 9)\n sum_of_n_terms(-2, 1, 4) returns 4 (The sequence is -2, 1, 4, 7)\n sum_of_n_terms(10, 20, 2) returns 30 (The sequence is 10, 20)", "module": "arithmetic_sum", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the sum of the first n terms of an arithmetic sequence.\n An arithmetic sequence is characterized by a constant difference between consecutive terms.\n Given the first term (A1), the second term (A2), and the number of terms (N),\n the function computes the sum of the sequence's first N terms.\n\n The formula used is: S_n = n/2 * (2*A1 + (N-1)*D), where D is the common difference.\n\n Examples:\n sum_of_n_terms(1, 3, 5) returns 25 (The sequence is 1, 3, 5, 7, 9)\n sum_of_n_terms(5, 7, 3) returns 21 (The sequence is 5, 7, 9)\n sum_of_n_terms(-2, 1, 4) returns 4 (The sequence is -2, 1, 4, 7)\n sum_of_n_terms(10, 20, 2) returns 30 (The sequence is 10, 20)\n\n* Incomplete Code:\nsum_of_n_terms/3, test/0]).sum_of_n_terms(A1, A2, N) ->\n [MASK] A2 - A1,\n    N * (2*A1 + (N - 1) * D) div 2.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK] A2 - A1,\n    N * (2*A1 + (N - 1) * D) div 2."}
{"task_id": "Erlang/33-0-light-span", "prompt": "-module(ascii_to_char).\n-export([convert_to_char/1, test/0]).\n\nconvert_to_char(AsciiCode) ->\n% This function converts an ASCII code to its corresponding character.\n% It takes an integer representing the ASCII code and returns the character as a string.\n% The function is designed to handle ASCII codes for visible characters, which are in the range from 1 to 127.\n%\n% Examples:\n% convert_to_char(65) returns \"A\"\n% convert_to_char(97) returns \"a\"\n% convert_to_char(48) returns \"0\"\n% convert_to_char(36) returns \"$\"\n% convert_to_char(32) returns \" \" (space character)", "canonical_solution": "    [AsciiCode].", "test": "test() ->\n    \"A\" = convert_to_char(65),\n    \"a\" = convert_to_char(97),\n    \"0\" = convert_to_char(48),\n    \"$\" = convert_to_char(36),\n    \" \" = convert_to_char(32),\n    ok.", "entry_point": "convert_to_char", "signature": "convert_to_char/1, test/0]).convert_to_char(AsciiCode) ->", "docstring": " This function converts an ASCII code to its corresponding character.\n It takes an integer representing the ASCII code and returns the character as a string.\n The function is designed to handle ASCII codes for visible characters, which are in the range from 1 to 127.\n\n Examples:\n convert_to_char(65) returns \"A\"\n convert_to_char(97) returns \"a\"\n convert_to_char(48) returns \"0\"\n convert_to_char(36) returns \"$\"\n convert_to_char(32) returns \" \" (space character)", "module": "ascii_to_char", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function converts an ASCII code to its corresponding character.\n It takes an integer representing the ASCII code and returns the character as a string.\n The function is designed to handle ASCII codes for visible characters, which are in the range from 1 to 127.\n\n Examples:\n convert_to_char(65) returns \"A\"\n convert_to_char(97) returns \"a\"\n convert_to_char(48) returns \"0\"\n convert_to_char(36) returns \"$\"\n convert_to_char(32) returns \" \" (space character)\n\n* Incomplete Code:\nconvert_to_char/1, test/0]).convert_to_char(AsciiCode) ->\n    [As[MASK]e].\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    [As[MASK]e]."}
{"task_id": "Erlang/34-0-light-span", "prompt": "-module(binary_search).\n-export([search/2, test/0]).\n\nsearch(List, Target) ->\n% This function performs a binary search to find a target element within a sorted list.\n% The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n% until it finds the target or concludes the target is not in the list.\n%\n% Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n% Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n% or 'not_found' if the target is not in the list.\n%\n% Examples:\n% search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n% search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n% search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)", "canonical_solution": "    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n    not_found;\nsearch(List, Target, Start, End) ->\n    Mid = Start + ((End - Start) div 2),\n    MidValue = lists:nth(Mid, List),\n    case Target of\n        MidValue -> {found, Mid};\n        _ when Target < MidValue -> search(List, Target, Start, Mid - 1);\n        _ when Target > MidValue -> search(List, Target, Mid + 1, End)\n    end.", "test": "test() ->\n    {found, 3} = search([1, 2, 3, 4, 5], 3),\n    not_found = search([1, 2, 4, 5, 6], 3),\n    {found, 4} = search([10, 20, 30, 40, 50], 40),\n    {found, 1} = search([100], 100),\n    not_found = search([], 1),\n    ok.", "entry_point": "search", "signature": "search).-export([search/2, test/0]).search(List, Target) ->", "docstring": " This function performs a binary search to find a target element within a sorted list.\n The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n until it finds the target or concludes the target is not in the list.\n\n Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n or 'not_found' if the target is not in the list.\n\n Examples:\n search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)", "module": "binary_search", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function performs a binary search to find a target element within a sorted list.\n The binary search algorithm divides the list in half to systematically eliminate halves where the target cannot lie,\n until it finds the target or concludes the target is not in the list.\n\n Input: A sorted list of integers 'List' and an integer 'Target' to find within the list.\n Output: A tuple {found, Index} if the target is found, where 'Index' is the position of the target in the list (1-based indexing),\n or 'not_found' if the target is not in the list.\n\n Examples:\n search([1, 2, 3, 4, 5], 3) returns {found, 3} (3 is found at index 3)\n search([1, 2, 4, 5, 6], 3) returns not_found (3 is not in the list)\n search([10, 20, 30, 40, 50], 40) returns {found, 4} (40 is found at index 4)\n\n* Incomplete Code:\nsearch).-export([search/2, test/0]).search(List, Target) ->\n    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n  [MASK] = lists:nth(Mid, List),\n    case Target of\n        MidValue -> {found, Mid};\n        _ when Target < MidValue -> search(List, Target, Start, Mid - 1);\n        _ when Target > MidValue -> search(List, Target, Mid + 1, End)\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    search(List, Target, 1, length(List)).\n\nsearch(_List, _Target, Start, End) when Start > End ->\n  [MASK] = lists:nth(Mid, List),\n    case Target of\n        MidValue -> {found, Mid};\n        _ when Target < MidValue -> search(List, Target, Start, Mid - 1);\n        _ when Target > MidValue -> search(List, Target, Mid + 1, End)\n    end."}
{"task_id": "Erlang/35-0-light-span", "prompt": "-module(char_to_ascii).\n-export([convert_to_ascii/1, test/0]).\n\nconvert_to_ascii(Char) ->\n% This function converts a visible character (excluding space) to its corresponding ASCII code.\n% It takes a character as input and returns the ASCII code as an integer.\n% The function ensures that the input character is within the range of visible ASCII characters (excluding space).\n%\n% Examples:\n% convert_to_ascii('A') returns 65\n% convert_to_ascii('a') returns 97\n% convert_to_ascii('0') returns 48\n% convert_to_ascii('$') returns 36\n% convert_to_ascii('!') returns 33", "canonical_solution": "    Char.", "test": "test() ->\n    65 = convert_to_ascii($A),\n    97 = convert_to_ascii($a),\n    48 = convert_to_ascii($0),\n    36 = convert_to_ascii($$),\n    33 = convert_to_ascii($!),\n    ok.", "entry_point": "convert_to_ascii", "signature": "convert_to_ascii/1, test/0]).convert_to_ascii(Char) ->", "docstring": " This function converts a visible character (excluding space) to its corresponding ASCII code.\n It takes a character as input and returns the ASCII code as an integer.\n The function ensures that the input character is within the range of visible ASCII characters (excluding space).\n\n Examples:\n convert_to_ascii('A') returns 65\n convert_to_ascii('a') returns 97\n convert_to_ascii('0') returns 48\n convert_to_ascii('$') returns 36\n convert_to_ascii('!') returns 33", "module": "char_to_ascii", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function converts a visible character (excluding space) to its corresponding ASCII code.\n It takes a character as input and returns the ASCII code as an integer.\n The function ensures that the input character is within the range of visible ASCII characters (excluding space).\n\n Examples:\n convert_to_ascii('A') returns 65\n convert_to_ascii('a') returns 97\n convert_to_ascii('0') returns 48\n convert_to_ascii('$') returns 36\n convert_to_ascii('!') returns 33\n\n* Incomplete Code:\nconvert_to_ascii/1, test/0]).convert_to_ascii(Char) ->\n [MASK]Char.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK]Char."}
{"task_id": "Erlang/36-0-light-span", "prompt": "-module(expression_calc).\n-export([calc/3, test/0]).\n\ncalc(A, B, C) ->\n% This function calculates the value of the expression (a+b) * c for given integers a, b, and c.\n% It demonstrates basic arithmetic operations and the use of parentheses to control the order of evaluation.\n% The function can handle integers within the range specified in the prompt, ensuring accurate calculations\n% even with negative numbers or zero.\n%\n% Examples:\n% calc(2, 3, 5) returns 25 (since (2+3)*5 = 25)\n% calc(-1, -2, 3) returns -9 (since (-1-2)*3 = -9)\n% calc(0, 0, 10) returns 0 (since (0+0)*10 = 0)\n% calc(100, 200, -2) returns -600 (since (100+200)*-2 = -600)\n% calc(5, 5, 0) returns 0 (since (5+5)*0 = 0)", "canonical_solution": "    (A + B) * C.", "test": "test() ->\n    25 = calc(2, 3, 5),\n    -9 = calc(-1, -2, 3),\n    0 = calc(0, 0, 10),\n    -600 = calc(100, 200, -2),\n    0 = calc(5, 5, 0),\n    ok.", "entry_point": "calc", "signature": "calc).-export([calc/3, test/0]).calc(A, B, C) ->", "docstring": " This function calculates the value of the expression (a+b) * c for given integers a, b, and c.\n It demonstrates basic arithmetic operations and the use of parentheses to control the order of evaluation.\n The function can handle integers within the range specified in the prompt, ensuring accurate calculations\n even with negative numbers or zero.\n\n Examples:\n calc(2, 3, 5) returns 25 (since (2+3)*5 = 25)\n calc(-1, -2, 3) returns -9 (since (-1-2)*3 = -9)\n calc(0, 0, 10) returns 0 (since (0+0)*10 = 0)\n calc(100, 200, -2) returns -600 (since (100+200)*-2 = -600)\n calc(5, 5, 0) returns 0 (since (5+5)*0 = 0)", "module": "expression_calc", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the value of the expression (a+b) * c for given integers a, b, and c.\n It demonstrates basic arithmetic operations and the use of parentheses to control the order of evaluation.\n The function can handle integers within the range specified in the prompt, ensuring accurate calculations\n even with negative numbers or zero.\n\n Examples:\n calc(2, 3, 5) returns 25 (since (2+3)*5 = 25)\n calc(-1, -2, 3) returns -9 (since (-1-2)*3 = -9)\n calc(0, 0, 10) returns 0 (since (0+0)*10 = 0)\n calc(100, 200, -2) returns -600 (since (100+200)*-2 = -600)\n calc(5, 5, 0) returns 0 (since (5+5)*0 = 0)\n\n* Incomplete Code:\ncalc).-export([calc/3, test/0]).calc(A, B, C) ->\n  [MASK] B) * C.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "  [MASK] B) * C."}
{"task_id": "Erlang/37-0-light-span", "prompt": "-module(fish_danger).\n-export([is_danger/2, test/0]).\n\nis_danger(S, X) ->\n% This function determines whether a fish swimming with an initial speed of 7 meters per second,\n% with its speed decreasing to 98% of its speed in the previous second, will be in danger.\n% The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n% to both sides) and not being able to exit that range within the next second.\n%\n% Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n% extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n%\n% Examples:\n% is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n% is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)", "canonical_solution": "    Danger_Start = S - X,\n    Danger_End = S + X,\n    check_danger(7, 0, Danger_Start, Danger_End).\n\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position >= Danger_Start, Position + Speed < Danger_End ->\n    'y';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) when Position > Danger_End ->\n    'n';\ncheck_danger(Speed, Position, Danger_Start, Danger_End) ->\n    NewSpeed = Speed * 0.98,\n    NewPosition = Position + Speed,\n    check_danger(NewSpeed, NewPosition, Danger_Start, Danger_End).", "test": "test() ->\n    'n' = is_danger(14, 1),\n    'n' = is_danger(20, 2),\n    'n' = is_danger(10, 1),\n    'n' = is_danger(14, 0.5),\n    'n' = is_danger(30, 3),\n    ok.", "entry_point": "is_danger", "signature": "is_danger/2, test/0]).is_danger(S, X) ->", "docstring": " This function determines whether a fish swimming with an initial speed of 7 meters per second,\n with its speed decreasing to 98 of its speed in the previous second, will be in danger.\n The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n to both sides) and not being able to exit that range within the next second.\n\n Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n\n Examples:\n is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)", "module": "fish_danger", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function determines whether a fish swimming with an initial speed of 7 meters per second,\n with its speed decreasing to 98 of its speed in the previous second, will be in danger.\n The danger is defined by entering a detection range (S meters from the starting point, extending X meters\n to both sides) and not being able to exit that range within the next second.\n\n Inputs are two real numbers S (the distance from the starting point to the detector) and X (the detection range\n extending to both sides of the detector). The output is 'y' if the fish will be in danger or 'n' if not.\n\n Examples:\n is_danger(14, 1) returns 'n' (The fish can swim through the detection range without staying in it for more than a second)\n is_danger(10, 1) returns 'n' (The fish can safely swim past the detector's range)\n\n* Incomplete Code:\nis_danger/2, test/0]).is_danger(S, X) ->\n    Danger_Start = S - X,\n    Dang[MASK]sition, Danger_Start, Danger_End).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    Danger_Start = S - X,\n    Dang[MASK]sition, Danger_Start, Danger_End)."}
{"task_id": "Erlang/38-0-light-span", "prompt": "-module(fish_numbers_game).\n-export([reverse_sequence/1, test/0]).\n\nreverse_sequence(Sequence) ->\n% This function takes a list of integers ending with 0 and reverses the sequence.\n% The sequence is input as a list of integers, where 0 marks the end of the input and is not included in the output.\n% The function returns a list of integers in reverse order, excluding the terminal 0.\n%\n% Examples:\n% reverse_sequence([3, 65, 23, 5, 34, 1, 30, 0]) returns [30, 1, 34, 5, 23, 65, 3]\n% reverse_sequence([10, 0]) returns [10]\n% reverse_sequence([1, 2, 3, 0]) returns [3, 2, 1]\n% reverse_sequence([0]) returns []", "canonical_solution": "    lists:reverse(lists:droplast(Sequence)).", "test": "test() ->\n    [30, 1, 34, 5, 23, 65, 3] = reverse_sequence([3, 65, 23, 5, 34, 1, 30, 0]),\n    [10] = reverse_sequence([10, 0]),\n    [3, 2, 1] = reverse_sequence([1, 2, 3, 0]),\n    [] = reverse_sequence([0]),\n    [2, 1] = reverse_sequence([1, 2, 0]),\n    ok.", "entry_point": "reverse_sequence", "signature": "reverse_sequence/1, test/0]).reverse_sequence(Sequence) ->", "docstring": " This function takes a list of integers ending with 0 and reverses the sequence.\n The sequence is input as a list of integers, where 0 marks the end of the input and is not included in the output.\n The function returns a list of integers in reverse order, excluding the terminal 0.\n\n Examples:\n reverse_sequence([3, 65, 23, 5, 34, 1, 30, 0]) returns [30, 1, 34, 5, 23, 65, 3]\n reverse_sequence([10, 0]) returns [10]\n reverse_sequence([1, 2, 3, 0]) returns [3, 2, 1]\n reverse_sequence([0]) returns []", "module": "fish_numbers_game", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function takes a list of integers ending with 0 and reverses the sequence.\n The sequence is input as a list of integers, where 0 marks the end of the input and is not included in the output.\n The function returns a list of integers in reverse order, excluding the terminal 0.\n\n Examples:\n reverse_sequence([3, 65, 23, 5, 34, 1, 30, 0]) returns [30, 1, 34, 5, 23, 65, 3]\n reverse_sequence([10, 0]) returns [10]\n reverse_sequence([1, 2, 3, 0]) returns [3, 2, 1]\n reverse_sequence([0]) returns []\n\n* Incomplete Code:\nreverse_sequence/1, test/0]).reverse_sequence(Sequence) ->\n   [MASK]sts:droplast(Sequence)).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK]sts:droplast(Sequence))."}
{"task_id": "Erlang/39-0-light-span", "prompt": "-module(int_bool_conversion).\n-export([convert/1, test/0]).\n\nconvert(Int) ->\n% This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n% In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n% Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n% and converting 0 will result in 0 (for false).\n%\n% Examples:\n% convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n% convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n% convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n% convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)", "canonical_solution": "    Bool = Int /= 0, % Convert integer to boolean\n    case Bool of\n        true -> 1;\n        false -> 0\n    end.", "test": "test() ->\n    1 = convert(3),\n    0 = convert(0),\n    1 = convert(-5),\n    1 = convert(100),\n    1 = convert(2),\n    ok.", "entry_point": "convert", "signature": "convert/1, test/0]).convert(Int) ->", "docstring": " This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n and converting 0 will result in 0 (for false).\n\n Examples:\n convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)", "module": "int_bool_conversion", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function takes an integer and converts it to a boolean value, then converts this boolean back to an integer.\n In Erlang, any non-zero value is considered true (equivalent to the boolean 'true'), and 0 is considered false (equivalent to 'false').\n Thus, converting any non-zero integer to boolean and back will result in 1 (for true),\n and converting 0 will result in 0 (for false).\n\n Examples:\n convert(3) returns 1 (since 3 is non-zero, it is considered true, and true is converted back to 1)\n convert(0) returns 0 (since 0 is equivalent to false, and false is converted back to 0)\n convert(-5) returns 1 (since -5 is non-zero, it is considered true, and true is converted back to 1)\n convert(100) returns 1 (since 100 is non-zero, it is considered true, and true is converted back to 1)\n\n* Incomplete Code:\nconvert/1, test/0]).convert(Int) ->\n    Bool = Int /= 0, % [MASK]ol of\n        true -> 1;\n        false -> 0\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    Bool = Int /= 0, % [MASK]ol of\n        true -> 1;\n        false -> 0\n    end."}
{"task_id": "Erlang/40-0-light-span", "prompt": "-module(median_without_extremes).\n-export([median/1, test/0]).\n\nmedian(List) ->\n% This function calculates the median of a list after removing the maximum and minimum values.\n% It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n% If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n% If the list has an odd number of elements, the median is the middle element.\n%\n% Examples:\n% median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n% median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n% median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)", "canonical_solution": "    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(Sorted)),\n    Length = length(Trimmed),\n    case Length rem 2 of\n        0 -> % Even number of elements\n            Middle1 = lists:nth(Length div 2, Trimmed),\n            Middle2 = lists:nth((Length div 2) + 1, Trimmed),\n            (Middle1 + Middle2) / 2;\n        1 -> % Odd number of elements\n            lists:nth((Length div 2) + 1, Trimmed)\n    end.", "test": "test() ->\n    6 = median([10, 5, 1, 8, 7, 6, 2]),\n    3 = median([1, 2, 3, 4, 5]),\n    3.5 = median([10, 10, 5, 2, 2, 1]),\n    2 = median([1, 2, 3]),\n    4.5 = median([1, 2, 3, 4, 5, 6, 7, 8]),\n    ok.", "entry_point": "median", "signature": "median_without_extremes).-export([median/1, test/0]).median(List) ->", "docstring": " This function calculates the median of a list after removing the maximum and minimum values.\n It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n If the list has an odd number of elements, the median is the middle element.\n\n Examples:\n median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)", "module": "median_without_extremes", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the median of a list after removing the maximum and minimum values.\n It sorts the list, removes the first (minimum) and last (maximum) elements, and then calculates the median of the remaining list.\n If the list has an even number of elements (after removal), the median is the average of the two middle numbers.\n If the list has an odd number of elements, the median is the middle element.\n\n Examples:\n median([10, 5, 1, 8, 7, 6, 2]) returns 6 (After removing 1 and 10, the median of [2, 5, 6, 7, 8] is 6)\n median([1, 2, 3, 4, 5]) returns 3 (After removing 1 and 5, the median of [2, 3, 4] is 3)\n median([10, 10, 5, 2, 2, 1]) returns 5 (After removing 1 and 10, the median of [2, 2, 5, 10] is 5)\n\n* Incomplete Code:\nmedian_without_extremes).-export([median/1, test/0]).median(List) ->\n    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(S[MASK]mber of elements\n            Middle1 = lists:nth(Length div 2, Trimmed),\n            Middle2 = lists:nth((Length div 2) + 1, Trimmed),\n            (Middle1 + Middle2) / 2;\n        1 -> % Odd number of elements\n            lists:nth((Length div 2) + 1, Trimmed)\n    end.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "    Sorted = lists:sort(List),\n    Trimmed = tl(lists:droplast(S[MASK]mber of elements\n            Middle1 = lists:nth(Length div 2, Trimmed),\n            Middle2 = lists:nth((Length div 2) + 1, Trimmed),\n            (Middle1 + Middle2) / 2;\n        1 -> % Odd number of elements\n            lists:nth((Length div 2) + 1, Trimmed)\n    end."}
{"task_id": "Erlang/41-0-light-span", "prompt": "-module(minimum_n).\n-export([find_min_n/1, test/0]).\n\nfind_min_n(K) ->\n% This function calculates the minimum value of n for which the sum\n% S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n% It iteratively adds terms of the harmonic series until the sum exceeds k.\n%\n% The input is a positive integer k, and the output is the minimum n\n% such that the sum of the harmonic series up to 1/n is greater than k.\n%\n% Examples:\n% find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n% find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n% find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n% find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)", "canonical_solution": "    find_min_n(1, 0, K).\n\nfind_min_n(N, Sum, K) when Sum > K ->\n    N-1;\nfind_min_n(N, Sum, K) ->\n    find_min_n(N + 1, Sum + 1/N, K).", "test": "test() ->\n    2 = find_min_n(1),\n    4 = find_min_n(2),\n    11 = find_min_n(3),\n    31 = find_min_n(4),\n    83 = find_min_n(5),\n    ok.", "entry_point": "find_min_n", "signature": "find_min_n/1, test/0]).find_min_n(K) ->", "docstring": " This function calculates the minimum value of n for which the sum\n S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n It iteratively adds terms of the harmonic series until the sum exceeds k.\n\n The input is a positive integer k, and the output is the minimum n\n such that the sum of the harmonic series up to 1/n is greater than k.\n\n Examples:\n find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)", "module": "minimum_n", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the minimum value of n for which the sum\n S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n It iteratively adds terms of the harmonic series until the sum exceeds k.\n\n The input is a positive integer k, and the output is the minimum n\n such that the sum of the harmonic series up to 1/n is greater than k.\n\n Examples:\n find_min_n(1) returns 2 (since 1 + 1/2 > 1)\n find_min_n(2) returns 4 (since 1 + 1/2 + 1/3 + 1/4 > 2)\n find_min_n(3) returns 11 (since the sum up to 1/11 exceeds 3)\n find_min_n(4) returns 31 (since the sum up to 1/31 exceeds 4)\n\n* Incomplete Code:\nfind_min_n/1, test/0]).find_min_n(K) ->\n    find_min_n(1, 0, K).\n\nfind_min_n(N, Sum, K) when Sum > K[MASK] + 1, Sum + 1/N, K).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    find_min_n(1, 0, K).\n\nfind_min_n(N, Sum, K) when Sum > K[MASK] + 1, Sum + 1/N, K)."}
{"task_id": "Erlang/42-0-light-span", "prompt": "-module(monotonic_list).\n-export([is_monotonic/1, test/0]).\n\n% This function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n% The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n%\n% Input: A list of integers.\n% Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n%\n% Examples:\n% is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n% is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n% is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n% is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)", "canonical_solution": "is_monotonic([]) -> true;\nis_monotonic([_]) -> true;\nis_monotonic([First, Second | Tail]) ->\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\ncheck_non_decreasing([_]) -> true;\ncheck_non_decreasing([First, Second | Tail]) ->\n    First =< Second andalso check_non_decreasing([Second | Tail]).\n\ncheck_non_increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\ncheck_non_increasing([First, Second | Tail]) ->\n    First >= Second andalso check_non_increasing([Second | Tail]).", "test": "test() ->\n    true = is_monotonic([1, 2, 2, 3]),\n    true = is_monotonic([3, 2, 1]),\n    false = is_monotonic([1, 3, 2]),\n    true = is_monotonic([10, 10, 10]),\n    true = is_monotonic([5]),\n    true = is_monotonic([]),\n    false = is_monotonic([1, 2, 3, 2, 4]),\n    ok.", "entry_point": "is_monotonic", "signature": "is_monotonic() ->", "docstring": "This function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n\n Input: A list of integers.\n Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n\n Examples:\n is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)", "module": "monotonic_list", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \nThis function checks if a given list is monotonic. A list is considered monotonic if it is either entirely non-increasing or non-decreasing.\n The function takes a list of integers and returns 'true' if the list is monotonic, otherwise it returns 'false'.\n\n Input: A list of integers.\n Output: 'true' if the list is monotonic (either non-increasing or non-decreasing), 'false' otherwise.\n\n Examples:\n is_monotonic([1, 2, 2, 3]) returns true (The list is non-decreasing)\n is_monotonic([3, 2, 1]) returns true (The list is non-increasing)\n is_monotonic([1, 3, 2]) returns false (The list is not monotonic)\n is_monotonic([10, 10, 10]) returns true (The list is both non-increasing and non-decreasing)\n\n* Incomplete Code:\nis_monotonic() ->\nis_monotonic([]) -> true;\nis_monotonic([_]) -> true;\nis_monotonic([First, Second | Tail]) ->\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\ncheck_non_decreasing([_]) -> true;\ncheck_non_decreasing([Fi[MASK]increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\ncheck_non_increasing([First, Second | Tail]) ->\n    First >= Second andalso check_non_increasing([Second | Tail]).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "hard", "mask_code": "is_monotonic([]) -> true;\nis_monotonic([_]) -> true;\nis_monotonic([First, Second | Tail]) ->\n    case Second >= First of\n        true -> check_non_decreasing([Second | Tail]);\n        false -> check_non_increasing([Second | Tail])\n    end.\n\ncheck_non_decreasing([]) -> true;\ncheck_non_decreasing([_]) -> true;\ncheck_non_decreasing([Fi[MASK]increasing([]) -> true;\ncheck_non_increasing([_]) -> true;\ncheck_non_increasing([First, Second | Tail]) ->\n    First >= Second andalso check_non_increasing([Second | Tail])."}
{"task_id": "Erlang/43-0-light-span", "prompt": "-module(multiply).\n-export([product/2, test/0]).\n\nproduct(A, B) ->\n% This function multiplies two positive integers, A and B, and returns their product.\n% The function is designed to handle integers within the range of 1 to 50,000, ensuring\n% the result falls within the capacity of Erlang's integer data type without overflow.\n%\n% Examples:\n% product(3, 4) returns 12\n% product(1, 50000) returns 50000\n% product(123, 456) returns 56088\n% product(50000, 2) returns 100000\n% product(111, 111) returns 12321", "canonical_solution": "    A * B.", "test": "test() ->\n    12 = product(3, 4),\n    50000 = product(1, 50000),\n    56088 = product(123, 456),\n    100000 = product(50000, 2),\n    12321 = product(111, 111),\n    ok.", "entry_point": "product", "signature": "product/2, test/0]).product(A, B) ->", "docstring": " This function multiplies two positive integers, A and B, and returns their product.\n The function is designed to handle integers within the range of 1 to 50,000, ensuring\n the result falls within the capacity of Erlang's integer data type without overflow.\n\n Examples:\n product(3, 4) returns 12\n product(1, 50000) returns 50000\n product(123, 456) returns 56088\n product(50000, 2) returns 100000\n product(111, 111) returns 12321", "module": "multiply", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function multiplies two positive integers, A and B, and returns their product.\n The function is designed to handle integers within the range of 1 to 50,000, ensuring\n the result falls within the capacity of Erlang's integer data type without overflow.\n\n Examples:\n product(3, 4) returns 12\n product(1, 50000) returns 50000\n product(123, 456) returns 56088\n product(50000, 2) returns 100000\n product(111, 111) returns 12321\n\n* Incomplete Code:\nproduct/2, test/0]).product(A, B) ->\n [MASK] * B.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK] * B."}
{"task_id": "Erlang/44-0-light-span", "prompt": "-module(number_sign).\n-export([determine_sign/1, test/0]).\n\n% This function determines the sign of a given integer N.\n% It returns 'positive' if N is greater than 0, 'zero' if N is 0,\n% and 'negative' if N is less than 0.\n% Examples:\n% determine_sign(10) returns 'positive'\n% determine_sign(0) returns 'zero'\n% determine_sign(-5) returns 'negative'\n% determine_sign(123456789) returns 'positive'\n% determine_sign(-987654321) returns 'negative'", "canonical_solution": "    determine_sign(N) when N > 0 -> positive;\n    determine_sign(0) -> zero;\n    determine_sign(N) when N < 0 -> negative.", "test": "test() ->\n    positive = determine_sign(10),\n    zero = determine_sign(0),\n    negative = determine_sign(-5),\n    positive = determine_sign(123456789),\n    negative = determine_sign(-987654321),\n    ok.", "entry_point": "determine_sign", "signature": "determine_sign(N)", "docstring": "\nThis function determines the sign of a given integer N.\nIt returns 'positive' if N is greater than 0, 'zero' if N is 0,\n% and 'negative' if N is less than 0.\nExamples:\ndetermine_sign(10) returns 'positive'\ndetermine_sign(0) returns 'zero'\ndetermine_sign(-5) returns 'negative'\ndetermine_sign(123456789) returns 'positive'\ndetermine_sign(-987654321) returns 'negative'", "module": "number_sign", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n\nThis function determines the sign of a given integer N.\nIt returns 'positive' if N is greater than 0, 'zero' if N is 0,\n% and 'negative' if N is less than 0.\nExamples:\ndetermine_sign(10) returns 'positive'\ndetermine_sign(0) returns 'zero'\ndetermine_sign(-5) returns 'negative'\ndetermine_sign(123456789) returns 'positive'\ndetermine_sign(-987654321) returns 'negative'\n\n* Incomplete Code:\ndetermine_sign(N)\n [MASK]N) when N > 0 -> positive;\n    determine_sign(0) -> zero;\n    determine_sign(N) when N < 0 -> negative.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": " [MASK]N) when N > 0 -> positive;\n    determine_sign(0) -> zero;\n    determine_sign(N) when N < 0 -> negative."}
{"task_id": "Erlang/45-0-light-span", "prompt": "-module(pen_purchase).\n-export([max_pens/2, test/0]).\n\nmax_pens(A, B) ->\n% This function calculates the maximum number of pens that can be bought\n% given the amount of money in yuan (A) and jiao (B). Each pen costs 1 yuan and 9 jiao (1.9 yuan).\n% The input is the amount of money given to Xiao Yu by the class teacher to buy pens,\n% represented by two integers A (yuan) and B (jiao).\n%\n% Examples:\n% max_pens(10, 3) returns 5 (With 10 yuan and 3 jiao, Xiao Yu can buy 5 pens)\n% max_pens(20, 5) returns 10 (With 20 yuan and 5 jiao, Xiao Yu can buy 10 pens)\n% max_pens(0, 19) returns 1 (With 0 yuan and 19 jiao, Xiao Yu can buy 1 pen)\n% max_pens(5, 0) returns 2 (With 5 yuan, Xiao Yu can buy 2 pens and have 0.2 yuan left)", "canonical_solution": "    TotalMoney = A * 10 + B, % Convert the total amount to jiao\n    PenCost = 19, % Cost of one pen in jiao\n    TotalMoney div PenCost.", "test": "test() ->\n    5 = max_pens(10, 3),\n    10 = max_pens(20, 5),\n    1 = max_pens(0, 19),\n    2 = max_pens(5, 0),\n    52 = max_pens(100, 0),\n    ok.", "entry_point": "max_pens", "signature": "max_pens/2, test/0]).max_pens(A, B) ->", "docstring": " This function calculates the maximum number of pens that can be bought\n given the amount of money in yuan (A) and jiao (B). Each pen costs 1 yuan and 9 jiao (1.9 yuan).\n The input is the amount of money given to Xiao Yu by the class teacher to buy pens,\n represented by two integers A (yuan) and B (jiao).\n\n Examples:\n max_pens(10, 3) returns 5 (With 10 yuan and 3 jiao, Xiao Yu can buy 5 pens)\n max_pens(20, 5) returns 10 (With 20 yuan and 5 jiao, Xiao Yu can buy 10 pens)\n max_pens(0, 19) returns 1 (With 0 yuan and 19 jiao, Xiao Yu can buy 1 pen)\n max_pens(5, 0) returns 2 (With 5 yuan, Xiao Yu can buy 2 pens and have 0.2 yuan left)", "module": "pen_purchase", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the maximum number of pens that can be bought\n given the amount of money in yuan (A) and jiao (B). Each pen costs 1 yuan and 9 jiao (1.9 yuan).\n The input is the amount of money given to Xiao Yu by the class teacher to buy pens,\n represented by two integers A (yuan) and B (jiao).\n\n Examples:\n max_pens(10, 3) returns 5 (With 10 yuan and 3 jiao, Xiao Yu can buy 5 pens)\n max_pens(20, 5) returns 10 (With 20 yuan and 5 jiao, Xiao Yu can buy 10 pens)\n max_pens(0, 19) returns 1 (With 0 yuan and 19 jiao, Xiao Yu can buy 1 pen)\n max_pens(5, 0) returns 2 (With 5 yuan, Xiao Yu can buy 2 pens and have 0.2 yuan left)\n\n* Incomplete Code:\nmax_pens/2, test/0]).max_pens(A, B) ->\n    TotalMoney = A * 10 + B, % Convert the total amount to jiao\n    PenCost = 19[MASK]en in jiao\n    TotalMoney div PenCost.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    TotalMoney = A * 10 + B, % Convert the total amount to jiao\n    PenCost = 19[MASK]en in jiao\n    TotalMoney div PenCost."}
{"task_id": "Erlang/46-0-light-span", "prompt": "-module(power_of_two).\n-export([calculate/1, test/0]).\n\ncalculate(N) ->\n% This function calculates the power of 2 given a non-negative integer N.\n% It returns the result of 2 raised to the power of N.\n%\n% The value of N must satisfy 0 <= N < 31 to ensure the result is within the range of an Erlang integer.\n%\n% Examples:\n% calculate(5) returns 32 (2^5 = 32)\n% calculate(0) returns 1 (2^0 = 1)\n% calculate(10) returns 1024 (2^10 = 1024)\n% calculate(15) returns 32768 (2^15 = 32768)", "canonical_solution": "    2 bsl (N-1).", "test": "test() ->\n    32 = calculate(5),\n    1 = calculate(0),\n    1024 = calculate(10),\n    32768 = calculate(15),\n    16384 = calculate(14),\n    ok.", "entry_point": "calculate", "signature": "calculate/1, test/0]).calculate(N) ->", "docstring": " This function calculates the power of 2 given a non-negative integer N.\n It returns the result of 2 raised to the power of N.\n\n The value of N must satisfy 0 <= N < 31 to ensure the result is within the range of an Erlang integer.\n\n Examples:\n calculate(5) returns 32 (2^5 = 32)\n calculate(0) returns 1 (2^0 = 1)\n calculate(10) returns 1024 (2^10 = 1024)\n calculate(15) returns 32768 (2^15 = 32768)", "module": "power_of_two", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the power of 2 given a non-negative integer N.\n It returns the result of 2 raised to the power of N.\n\n The value of N must satisfy 0 <= N < 31 to ensure the result is within the range of an Erlang integer.\n\n Examples:\n calculate(5) returns 32 (2^5 = 32)\n calculate(0) returns 1 (2^0 = 1)\n calculate(10) returns 1024 (2^10 = 1024)\n calculate(15) returns 32768 (2^15 = 32768)\n\n* Incomplete Code:\ncalculate/1, test/0]).calculate(N) ->\n   [MASK] (N-1).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "   [MASK] (N-1)."}
{"task_id": "Erlang/47-0-light-span", "prompt": "-module(reverse_number).\n-export([reverse/1, test/0]).\n\nreverse(N) ->\n% This function reverses a three-digit number.\n% It takes a three-digit number N as input and returns its reverse.\n% The function handles numbers with leading zeros by ensuring the output is properly formatted\n% as a three-digit number, including those zeros.\n%\n% Examples:\n% reverse(123) returns 321\n% reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n% reverse(205) returns 502\n% reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n% reverse(050) returns 5 (as 050 -> 5 in integer format)", "canonical_solution": "    Hundreds = N div 100,\n    Tens = (N div 10) rem 10,\n    Ones = N rem 10,\n    Ones * 100 + Tens * 10 + Hundreds.", "test": "test() ->\n    321 = reverse(123),\n    1 = reverse(100), % Note: Erlang integers do not preserve leading zeros\n    502 = reverse(205),\n    98 = reverse(890), % Note: Erlang integers do not preserve leading zeros\n    50 = reverse(050), % Note: Erlang integers do not preserve leading zeros, 050 is equivalent to 50 in Erlang\n    ok.", "entry_point": "reverse", "signature": "reverse_number).-export([reverse/1, test/0]).reverse(N) ->", "docstring": " This function reverses a three-digit number.\n It takes a three-digit number N as input and returns its reverse.\n The function handles numbers with leading zeros by ensuring the output is properly formatted\n as a three-digit number, including those zeros.\n\n Examples:\n reverse(123) returns 321\n reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(205) returns 502\n reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(050) returns 5 (as 050 -> 5 in integer format)", "module": "reverse_number", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function reverses a three-digit number.\n It takes a three-digit number N as input and returns its reverse.\n The function handles numbers with leading zeros by ensuring the output is properly formatted\n as a three-digit number, including those zeros.\n\n Examples:\n reverse(123) returns 321\n reverse(100) returns 1 (as 001 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(205) returns 502\n reverse(890) returns 98 (as 098 in integer format, but Erlang does not preserve leading zeros in integers)\n reverse(050) returns 5 (as 050 -> 5 in integer format)\n\n* Incomplete Code:\nreverse_number).-export([reverse/1, test/0]).reverse(N) ->\n    Hundreds = N div 100,\n    Te[MASK]+ Tens * 10 + Hundreds.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "easy", "mask_code": "    Hundreds = N div 100,\n    Te[MASK]+ Tens * 10 + Hundreds."}
{"task_id": "Erlang/48-0-light-span", "prompt": "-module(swimming_distance).\n-export([total_swim_distance/2, test/0]).\n\ntotal_swim_distance(X, N) ->\n% This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n% Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n% it returns the cumulative distance swum by the fish.\n%\n% The fish does not swim on weekends (Saturday and Sunday).\n%\n% Examples:\n% total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n% total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n% total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n% total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)", "canonical_solution": "    DaysSwum = lists:foldl(fun(Day, Acc) ->\n                               case (Day rem 7) of\n                                   6 -> Acc; % Saturday\n                                   0 -> Acc; % Sunday\n                                   _ -> Acc + 1\n                               end\n                           end, 0, lists:seq(X, X + N - 1)),\n    DaysSwum * 250.", "test": "test() ->\n    2000 = total_swim_distance(3, 10),\n    1250 = total_swim_distance(6, 7),\n    2500 = total_swim_distance(1, 14),\n    500 = total_swim_distance(7, 3),\n    1000 = total_swim_distance(5, 5),\n    ok.", "entry_point": "total_swim_distance", "signature": "total_swim_distance/2, test/0]).total_swim_distance(X, N) ->", "docstring": " This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n it returns the cumulative distance swum by the fish.\n\n The fish does not swim on weekends (Saturday and Sunday).\n\n Examples:\n total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)", "module": "swimming_distance", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the total swimming distance of a fish that swims 250 km every day except on weekends.\n Given a starting day of the week 'X' (1 for Monday through 7 for Sunday) and a total number of days 'N',\n it returns the cumulative distance swum by the fish.\n\n The fish does not swim on weekends (Saturday and Sunday).\n\n Examples:\n total_swim_distance(3, 10) returns 2000 (Starting on Wednesday, over 10 days, the fish swims 2000 km)\n total_swim_distance(6, 7) returns 1250 (Starting on Saturday, over 7 days, the fish swims 1250 km)\n total_swim_distance(1, 14) returns 2500 (Starting on Monday, over 14 days, the fish swims 2500 km)\n total_swim_distance(7, 3) returns 500 (Starting on Sunday, over 3 days, the fish swims 500 km)\n\n* Incomplete Code:\ntotal_swim_distance/2, test/0]).total_swim_distance(X, N) ->\n    DaysSwum = lists:foldl(fun(Day, Acc) ->\n   [MASK]    DaysSwum * 250.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    DaysSwum = lists:foldl(fun(Day, Acc) ->\n   [MASK]    DaysSwum * 250."}
{"task_id": "Erlang/49-0-light-span", "prompt": "-module(swimming_steps).\n-export([calculate_steps/1, test/0]).\n\ncalculate_steps(S) ->\n% This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n% Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98% of the distance of the previous step.\n% The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n% and returns the number of steps required.\n%\n% Examples:\n% calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n% calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).", "canonical_solution": "calculate_steps(Distance, Target, Steps, Speed) when Distance >= Target ->\n    Steps;\ncalculate_steps(Distance, Target, Steps, Speed) ->\n    NextDistance = Speed * 0.98,\n    calculate_steps(Distance + NextDistance, Target, Steps + 1,NextDistance).", "test": "test() ->\n    3 = calculate_steps(4.3),\n    1 = calculate_steps(2.0),\n    4 = calculate_steps(6),\n    ok.", "entry_point": "calculate_steps", "signature": "calculate_steps/1, test/0]).calculate_steps(S) ->", "docstring": " This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98 of the distance of the previous step.\n The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n and returns the number of steps required.\n\n Examples:\n calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).", "module": "swimming_steps", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the number of steps required for Xiao Yu to swim to a given distance S meters.\n Xiao Yu starts with an initial step of 2 meters, and each subsequent step is 98 of the distance of the previous step.\n The function iterates through each step, cumulatively adding the distance swum until it reaches or exceeds the target distance S,\n and returns the number of steps required.\n\n Examples:\n calculate_steps(4.3) returns 3 (Xiao Yu can reach 4.3 meters in 3 steps)\n calculate_steps(2.0) returns 1 (Xiao Yu reaches 2 meters in the first step)\n    calculate_steps(2, S, 1, 2).\n\n* Incomplete Code:\ncalculate_steps/1, test/0]).calculate_steps(S) ->\ncalculate_steps(Distance, Target, Steps, Speed) when Distance >= Target ->\n    [MASK]culate_steps(Distance, Target, Steps, Speed) ->\n    NextDistance = Speed * 0.98,\n    calculate_steps(Distance + NextDistance, Target, Steps + 1,NextDistance).\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "calculate_steps(Distance, Target, Steps, Speed) when Distance >= Target ->\n    [MASK]culate_steps(Distance, Target, Steps, Speed) ->\n    NextDistance = Speed * 0.98,\n    calculate_steps(Distance + NextDistance, Target, Steps + 1,NextDistance)."}
{"task_id": "Erlang/50-0-light-span", "prompt": "-module(swimming_time).\n-export([calculate_time/4, test/0]).\n\ncalculate_time(A, B, C, D) ->\n% This function calculates the total swimming time for a fish, given the start and end times.\n% The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n% The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n%\n% Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n% The output is the total time spent swimming, formatted as hours and minutes.\n%\n% Examples:\n% calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n% calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n% calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)", "canonical_solution": "    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n    TotalMinutes = EndMinutes - StartMinutes,\n    Hours = TotalMinutes div 60,\n    Minutes = TotalMinutes rem 60,\n    {Hours, Minutes}.", "test": "test() ->\n    {6, 20} = calculate_time(12, 50, 19, 10),\n    {1, 15} = calculate_time(9, 30, 10, 45),\n    {8, 20} = calculate_time(14, 55, 23, 15),\n    {0, 45} = calculate_time(0, 15, 1, 0),\n    {23, 45} = calculate_time(0, 0, 23, 45),\n    ok.", "entry_point": "calculate_time", "signature": "calculate_time/4, test/0]).calculate_time(A, B, C, D) ->", "docstring": " This function calculates the total swimming time for a fish, given the start and end times.\n The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n\n Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n The output is the total time spent swimming, formatted as hours and minutes.\n\n Examples:\n calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)", "module": "swimming_time", "instruction": "Below is a explanation of Erlang code and incomplete code implementation.\n\n* Docstring: \n This function calculates the total swimming time for a fish, given the start and end times.\n The start time is given by the hours and minutes 'A' and 'B', and the end time by 'C' and 'D'.\n The function returns the total swimming time in hours and minutes, where the minutes are less than 60.\n\n Inputs are four integers, representing the start and end times of the swimming session in 24-hour format.\n The output is the total time spent swimming, formatted as hours and minutes.\n\n Examples:\n calculate_time(12, 50, 19, 10) returns (6, 20) (From 12:50 to 19:10 is 6 hours and 20 minutes)\n calculate_time(9, 30, 10, 45) returns (1, 15) (From 9:30 to 10:45 is 1 hour and 15 minutes)\n calculate_time(14, 55, 23, 15) returns (8, 20) (From 14:55 to 23:15 is 8 hours and 20 minutes)\n\n* Incomplete Code:\ncalculate_time/4, test/0]).calculate_time(A, B, C, D) ->\n    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n    TotalMinutes = EndMinutes - StartMinutes,\n    Hours = TotalMinutes di[MASK]nutes = TotalMinutes rem 60,\n    {Hours, Minutes}.\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "level": "middle", "mask_code": "    StartMinutes = A * 60 + B,\n    EndMinutes = C * 60 + D,\n    TotalMinutes = EndMinutes - StartMinutes,\n    Hours = TotalMinutes di[MASK]nutes = TotalMinutes rem 60,\n    {Hours, Minutes}."}
